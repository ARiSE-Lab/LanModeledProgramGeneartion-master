public static void show ( AppCompatActivity activity , ObaArrivalInfo arrival ) { show ( activity , arrival , null ) ; }
public static void show ( AppCompatActivity activity , ObaArrivalInfo arrival , Integer containerViewId ) { FragmentManager fm = activity . getSupportFragmentManager ( ) ; Bundle args = new Bundle ( ) ; args . putString ( TRIP_ID , arrival . getTripId ( ) ) ; args . putString ( STOP_ID , arrival . getStopId ( ) ) ; args . putString ( TRIP_HEADSIGN , arrival . getHeadsign ( ) ) ; args . putLong ( TRIP_SERVICE_DATE , arrival . getServiceDate ( ) ) ; args . putString ( TRIP_VEHICLE_ID , arrival . getVehicleId ( ) ) ; ReportTripProblemFragment content = new ReportTripProblemFragment ( ) ; content . setArguments ( args ) ; FragmentTransaction ft = fm . beginTransaction ( ) ; if ( containerViewId == null ) { ft . replace ( android . R . id . content , content , TAG ) ; } else { ft . replace ( containerViewId , content , TAG ) ; } ft . addToBackStack ( null ) ; try { ft . commit ( ) ; } catch ( IllegalStateException e ) { Log . e ( TAG , "Cannot show ReportTripProblemFragment after onSaveInstanceState has been called" ) ; } }
@ Override protected int getLayoutId ( ) { return R . layout . report_trip_problem ; }
@ Override public void onViewCreated ( View view , Bundle savedInstanceState ) { Bundle args = getArguments ( ) ; final TextView tripHeadsign = ( TextView ) view . findViewById ( R . id . report_problem_headsign ) ; tripHeadsign . setText ( UIUtils . formatDisplayText ( args . getString ( TRIP_HEADSIGN ) ) ) ; final int tripArray = R . array . report_trip_problem_code_bus ; mCodeView = ( Spinner ) view . findViewById ( R . id . report_problem_code ) ; ArrayAdapter < ? > adapter = ArrayAdapter . createFromResource ( getActivity ( ) , tripArray , android . R . layout . simple_spinner_item ) ; adapter . setDropDownViewResource ( android . R . layout . simple_spinner_dropdown_item ) ; mCodeView . setAdapter ( adapter ) ; mUserComment = ( TextView ) view . findViewById ( R . id . report_problem_comment ) ; mUserOnVehicle = ( CheckBox ) view . findViewById ( R . id . report_problem_onvehicle ) ; mUserVehicle = ( EditText ) view . findViewById ( R . id . report_problem_uservehicle ) ; mUserVehicle . setEnabled ( false ) ; mUserOnVehicle . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { boolean checked = mUserOnVehicle . isChecked ( ) ; mUserVehicle . setEnabled ( checked ) ; } } ) ; if ( savedInstanceState != null ) { int position = savedInstanceState . getInt ( CODE ) ; mCodeView . setSelection ( position ) ; CharSequence comment = savedInstanceState . getCharSequence ( USER_COMMENT ) ; mUserComment . setText ( comment ) ; boolean onVehicle = savedInstanceState . getBoolean ( USER_ON_VEHICLE ) ; mUserOnVehicle . setChecked ( onVehicle ) ; CharSequence num = savedInstanceState . getCharSequence ( USER_VEHICLE_NUM ) ; mUserVehicle . setText ( num ) ; mUserVehicle . setEnabled ( onVehicle ) ; } SPINNER_TO_CODE = new String [] { null , ObaReportProblemWithTripRequest . VEHICLE_NEVER_CAME , ObaReportProblemWithTripRequest . VEHICLE_CAME_EARLY , ObaReportProblemWithTripRequest . VEHICLE_CAME_LATE , ObaReportProblemWithTripRequest . WRONG_HEADSIGN , ObaReportProblemWithTripRequest . VEHICLE_DOES_NOT_STOP_HERE , ObaReportProblemWithTripRequest . OTHER } ; setupIconColors ( ) ; }
@ Override public void onClick ( View v ) { boolean checked = mUserOnVehicle . isChecked ( ) ; mUserVehicle . setEnabled ( checked ) ; }
private void setupIconColors ( ) { ( ( ImageView ) getActivity ( ) . findViewById ( R . id . ic_category ) ) . setColorFilter ( getResources ( ) . getColor ( R . color . material_gray ) ) ; ( ( ImageView ) getActivity ( ) . findViewById ( R . id . ic_trip_info ) ) . setColorFilter ( getResources ( ) . getColor ( R . color . material_gray ) ) ; ( ( ImageView ) getActivity ( ) . findViewById ( R . id . ic_headsign_info ) ) . setColorFilter ( getResources ( ) . getColor ( R . color . material_gray ) ) ; }
@ Override public void onSaveInstanceState ( Bundle outState ) { super. onSaveInstanceState ( outState ) ; outState . putInt ( CODE , mCodeView . getSelectedItemPosition ( ) ) ; outState . putCharSequence ( USER_COMMENT , mUserComment . getText ( ) ) ; outState . putBoolean ( USER_ON_VEHICLE , mUserOnVehicle . isChecked ( ) ) ; outState . putCharSequence ( USER_VEHICLE_NUM , mUserVehicle . getText ( ) ) ; }
@ Override protected void sendReport ( ) { InputMethodManager imm = ( InputMethodManager ) getActivity ( ) . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; imm . hideSoftInputFromWindow ( mUserComment . getWindowToken ( ) , 0 ) ; if ( isReportArgumentsValid ( ) ) { ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . SUBMIT . toString ( ) , getString ( R . string . analytics_action_problem ) , getString ( R . string . analytics_label_report_trip_problem ) ) ; super. sendReport ( ) ; } else { Toast . makeText ( getActivity ( ) , getString ( R . string . report_problem_invalid_argument ) , Toast . LENGTH_LONG ) . show ( ) ; } }
@ Override protected ReportLoader createLoader ( Bundle args ) { String tripId = args . getString ( TRIP_ID ) ; ObaReportProblemWithTripRequest . Builder builder = new ObaReportProblemWithTripRequest . Builder ( getActivity ( ) , tripId ) ; builder . setStopId ( args . getString ( STOP_ID ) ) ; builder . setVehicleId ( args . getString ( TRIP_VEHICLE_ID ) ) ; builder . setServiceDate ( args . getLong ( TRIP_SERVICE_DATE ) ) ; String code = SPINNER_TO_CODE [ mCodeView . getSelectedItemPosition ( ) ] ; if ( code != null ) { builder . setCode ( code ) ; } CharSequence comment = mUserComment . getText ( ) ; if ( ! TextUtils . isEmpty ( comment ) ) { builder . setUserComment ( comment . toString ( ) ) ; } Location location = Application . getLastKnownLocation ( getActivity ( ) , mGoogleApiClient ) ; if ( location != null ) { builder . setUserLocation ( location . getLatitude ( ) , location . getLongitude ( ) ) ; if ( location . hasAccuracy ( ) ) { builder . setUserLocationAccuracy ( ( int ) location . getAccuracy ( ) ) ; } } builder . setUserOnVehicle ( mUserOnVehicle . isChecked ( ) ) ; CharSequence vehicleNum = mUserVehicle . getText ( ) ; if ( ! TextUtils . isEmpty ( vehicleNum ) ) { builder . setUserVehicleNumber ( vehicleNum . toString ( ) ) ; } return new ReportLoader ( getActivity ( ) , builder . build ( ) ) ; }
public GPUImageRenderer ( final GPUImageFilter filter ) { mFilter = filter ; mRunOnDraw = new LinkedList < Runnable > ( ) ; mRunOnDrawEnd = new LinkedList < Runnable > ( ) ; mGLCubeBuffer = ByteBuffer . allocateDirect ( CUBE . length * 4 ) . order ( ByteOrder . nativeOrder ( ) ) . asFloatBuffer ( ) ; mGLCubeBuffer . put ( CUBE ) . position ( 0 ) ; mGLTextureBuffer = ByteBuffer . allocateDirect ( TEXTURE_NO_ROTATION . length * 4 ) . order ( ByteOrder . nativeOrder ( ) ) . asFloatBuffer ( ) ; setRotation ( Rotation . NORMAL , false , false ) ; }
@ Override public void onSurfaceCreated ( final GL10 unused , final EGLConfig config ) { GLES20 . glClearColor ( mBackgroundRed , mBackgroundGreen , mBackgroundBlue , 1 ) ; GLES20 . glDisable ( GLES20 . GL_DEPTH_TEST ) ; mFilter . init ( ) ; }
@ Override public void onSurfaceChanged ( final GL10 gl , final int width , final int height ) { mOutputWidth = width ; mOutputHeight = height ; GLES20 . glViewport ( 0 , 0 , width , height ) ; GLES20 . glUseProgram ( mFilter . getProgram ( ) ) ; mFilter . onOutputSizeChanged ( width , height ) ; adjustImageScaling ( ) ; synchronized ( mSurfaceChangedWaiter ) { mSurfaceChangedWaiter . notifyAll ( ) ; } }
@ Override public void onDrawFrame ( final GL10 gl ) { GLES20 . glClear ( GLES20 . GL_COLOR_BUFFER_BIT | GLES20 . GL_DEPTH_BUFFER_BIT ) ; runAll ( mRunOnDraw ) ; mFilter . onDraw ( mGLTextureId , mGLCubeBuffer , mGLTextureBuffer ) ; runAll ( mRunOnDrawEnd ) ; if ( mSurfaceTexture != null ) { mSurfaceTexture . updateTexImage ( ) ; } }
public void setBackgroundColor ( float red , float green , float blue ) { mBackgroundRed = red ; mBackgroundGreen = green ; mBackgroundBlue = blue ; }
private void runAll ( Queue < Runnable > queue ) { synchronized ( queue ) { while ( ! queue . isEmpty ( ) ) { queue . poll ( ) . run ( ) ; } } }
@ Override public void onPreviewFrame ( final byte [] data , final Camera camera ) { final Size previewSize = camera . getParameters ( ) . getPreviewSize ( ) ; if ( mGLRgbBuffer == null ) { mGLRgbBuffer = IntBuffer . allocate ( previewSize . width * previewSize . height ) ; } if ( mRunOnDraw . isEmpty ( ) ) { runOnDraw ( new Runnable ( ) { @ Override public void run ( ) { GPUImageNativeLibrary . YUVtoRBGA ( data , previewSize . width , previewSize . height , mGLRgbBuffer . array ( ) ) ; mGLTextureId = OpenGlUtils . loadTexture ( mGLRgbBuffer , previewSize , mGLTextureId ) ; camera . addCallbackBuffer ( data ) ; if ( mImageWidth != previewSize . width ) { mImageWidth = previewSize . width ; mImageHeight = previewSize . height ; adjustImageScaling ( ) ; } } } ) ; } }
@ Override public void run ( ) { GPUImageNativeLibrary . YUVtoRBGA ( data , previewSize . width , previewSize . height , mGLRgbBuffer . array ( ) ) ; mGLTextureId = OpenGlUtils . loadTexture ( mGLRgbBuffer , previewSize , mGLTextureId ) ; camera . addCallbackBuffer ( data ) ; if ( mImageWidth != previewSize . width ) { mImageWidth = previewSize . width ; mImageHeight = previewSize . height ; adjustImageScaling ( ) ; } }
public void setUpSurfaceTexture ( final Camera camera ) { runOnDraw ( new Runnable ( ) { @ Override public void run ( ) { int [] textures = new int [ 1 ] ; GLES20 . glGenTextures ( 1 , textures , 0 ) ; mSurfaceTexture = new SurfaceTexture ( textures [ 0 ] ) ; try { camera . setPreviewTexture ( mSurfaceTexture ) ; camera . setPreviewCallback ( GPUImageRenderer .this ) ; camera . startPreview ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } ) ; }
@ Override public void run ( ) { int [] textures = new int [ 1 ] ; GLES20 . glGenTextures ( 1 , textures , 0 ) ; mSurfaceTexture = new SurfaceTexture ( textures [ 0 ] ) ; try { camera . setPreviewTexture ( mSurfaceTexture ) ; camera . setPreviewCallback ( GPUImageRenderer .this ) ; camera . startPreview ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
public void setFilter ( final GPUImageFilter filter ) { runOnDraw ( new Runnable ( ) { @ Override public void run ( ) { final GPUImageFilter oldFilter = mFilter ; mFilter = filter ; if ( oldFilter != null ) { oldFilter . destroy ( ) ; } mFilter . init ( ) ; GLES20 . glUseProgram ( mFilter . getProgram ( ) ) ; mFilter . onOutputSizeChanged ( mOutputWidth , mOutputHeight ) ; } } ) ; }
@ Override public void run ( ) { final GPUImageFilter oldFilter = mFilter ; mFilter = filter ; if ( oldFilter != null ) { oldFilter . destroy ( ) ; } mFilter . init ( ) ; GLES20 . glUseProgram ( mFilter . getProgram ( ) ) ; mFilter . onOutputSizeChanged ( mOutputWidth , mOutputHeight ) ; }
public void deleteImage ( ) { runOnDraw ( new Runnable ( ) { @ Override public void run ( ) { GLES20 . glDeleteTextures ( 1 , new int [] { mGLTextureId } , 0 ) ; mGLTextureId = NO_IMAGE ; } } ) ; }
@ Override public void run ( ) { GLES20 . glDeleteTextures ( 1 , new int [] { mGLTextureId } , 0 ) ; mGLTextureId = NO_IMAGE ; }
public void setImageBitmap ( final Bitmap bitmap ) { setImageBitmap ( bitmap , true ) ; }
public void setImageBitmap ( final Bitmap bitmap , final boolean recycle ) { if ( bitmap == null ) { return; } runOnDraw ( new Runnable ( ) { @ Override public void run ( ) { Bitmap resizedBitmap = null ; if ( bitmap . getWidth ( ) % 2 == 1 ) { resizedBitmap = Bitmap . createBitmap ( bitmap . getWidth ( ) + 1 , bitmap . getHeight ( ) , Bitmap . Config . ARGB_8888 ) ; Canvas can = new Canvas ( resizedBitmap ) ; can . drawARGB ( 0x00 , 0x00 , 0x00 , 0x00 ) ; can . drawBitmap ( bitmap , 0 , 0 , null ) ; mAddedPadding = 1 ; } else { mAddedPadding = 0 ; } mGLTextureId = OpenGlUtils . loadTexture ( resizedBitmap != null ? resizedBitmap : bitmap , mGLTextureId , recycle ) ; if ( resizedBitmap != null ) { resizedBitmap . recycle ( ) ; } mImageWidth = bitmap . getWidth ( ) ; mImageHeight = bitmap . getHeight ( ) ; adjustImageScaling ( ) ; } } ) ; }
@ Override public void run ( ) { Bitmap resizedBitmap = null ; if ( bitmap . getWidth ( ) % 2 == 1 ) { resizedBitmap = Bitmap . createBitmap ( bitmap . getWidth ( ) + 1 , bitmap . getHeight ( ) , Bitmap . Config . ARGB_8888 ) ; Canvas can = new Canvas ( resizedBitmap ) ; can . drawARGB ( 0x00 , 0x00 , 0x00 , 0x00 ) ; can . drawBitmap ( bitmap , 0 , 0 , null ) ; mAddedPadding = 1 ; } else { mAddedPadding = 0 ; } mGLTextureId = OpenGlUtils . loadTexture ( resizedBitmap != null ? resizedBitmap : bitmap , mGLTextureId , recycle ) ; if ( resizedBitmap != null ) { resizedBitmap . recycle ( ) ; } mImageWidth = bitmap . getWidth ( ) ; mImageHeight = bitmap . getHeight ( ) ; adjustImageScaling ( ) ; }
public void setScaleType ( GPUImage . ScaleType scaleType ) { mScaleType = scaleType ; }
protected int getFrameWidth ( ) { return mOutputWidth ; }
protected int getFrameHeight ( ) { return mOutputHeight ; }
private void adjustImageScaling ( ) { float outputWidth = mOutputWidth ; float outputHeight = mOutputHeight ; if ( mRotation == Rotation . ROTATION_270 || mRotation == Rotation . ROTATION_90 ) { outputWidth = mOutputHeight ; outputHeight = mOutputWidth ; } float ratio1 = outputWidth / mImageWidth ; float ratio2 = outputHeight / mImageHeight ; float ratioMax = Math . max ( ratio1 , ratio2 ) ; int imageWidthNew = Math . round ( mImageWidth * ratioMax ) ; int imageHeightNew = Math . round ( mImageHeight * ratioMax ) ; float ratioWidth = imageWidthNew / outputWidth ; float ratioHeight = imageHeightNew / outputHeight ; float [] cube = CUBE ; float [] textureCords = TextureRotationUtil . getRotation ( mRotation , mFlipHorizontal , mFlipVertical ) ; if ( mScaleType == GPUImage . ScaleType . CENTER_CROP ) { float distHorizontal = ( 1 - 1 / ratioWidth ) / 2 ; float distVertical = ( 1 - 1 / ratioHeight ) / 2 ; textureCords = new float [] { addDistance ( textureCords [ 0 ] , distHorizontal ) , addDistance ( textureCords [ 1 ] , distVertical ) , addDistance ( textureCords [ 2 ] , distHorizontal ) , addDistance ( textureCords [ 3 ] , distVertical ) , addDistance ( textureCords [ 4 ] , distHorizontal ) , addDistance ( textureCords [ 5 ] , distVertical ) , addDistance ( textureCords [ 6 ] , distHorizontal ) , addDistance ( textureCords [ 7 ] , distVertical ) ,            } ; } else { cube = new float [] { CUBE [ 0 ] / ratioHeight , CUBE [ 1 ] / ratioWidth , CUBE [ 2 ] / ratioHeight , CUBE [ 3 ] / ratioWidth , CUBE [ 4 ] / ratioHeight , CUBE [ 5 ] / ratioWidth , CUBE [ 6 ] / ratioHeight , CUBE [ 7 ] / ratioWidth ,            } ; } mGLCubeBuffer . clear ( ) ; mGLCubeBuffer . put ( cube ) . position ( 0 ) ; mGLTextureBuffer . clear ( ) ; mGLTextureBuffer . put ( textureCords ) . position ( 0 ) ; }
private float addDistance ( float coordinate , float distance ) { return coordinate == 0.0f ? distance : 1 - distance ; }
public void setRotationCamera ( final Rotation rotation , final boolean flipHorizontal , final boolean flipVertical ) { setRotation ( rotation , flipVertical , flipHorizontal ) ; }
public void setRotation ( final Rotation rotation ) { mRotation = rotation ; adjustImageScaling ( ) ; }
public void setRotation ( final Rotation rotation , final boolean flipHorizontal , final boolean flipVertical ) { mFlipHorizontal = flipHorizontal ; mFlipVertical = flipVertical ; setRotation ( rotation ) ; }
public Rotation getRotation ( ) { return mRotation ; }
public boolean isFlippedHorizontally ( ) { return mFlipHorizontal ; }
public boolean isFlippedVertically ( ) { return mFlipVertical ; }
protected void runOnDraw ( final Runnable runnable ) { synchronized ( mRunOnDraw ) { mRunOnDraw . add ( runnable ) ; } }
protected void runOnDrawEnd ( final Runnable runnable ) { synchronized ( mRunOnDrawEnd ) { mRunOnDrawEnd . add ( runnable ) ; } }
void setPanelHeightPixels ( int heightInPixels );
int getPanelHeightPixels ( )
public static void start ( Context context , String focusId , double lat , double lon ) { context . startActivity ( makeIntent ( context , focusId , lat , lon ) ) ; }
public static void start ( Context context , ObaStop stop ) { context . startActivity ( makeIntent ( context , stop ) ) ; }
public static void start ( Context context , String routeId ) { context . startActivity ( makeIntent ( context , routeId ) ) ; }
public static Intent makeIntent ( Context context , String focusId , double lat , double lon ) { Intent myIntent = new Intent ( context , HomeActivity .class ) ; myIntent . putExtra ( MapParams . STOP_ID , focusId ) ; myIntent . putExtra ( MapParams . CENTER_LAT , lat ) ; myIntent . putExtra ( MapParams . CENTER_LON , lon ) ; return myIntent ; }
public static Intent makeIntent ( Context context , ObaStop stop ) { Intent myIntent = new Intent ( context , HomeActivity .class ) ; myIntent . putExtra ( MapParams . STOP_ID , stop . getId ( ) ) ; myIntent . putExtra ( MapParams . STOP_NAME , stop . getName ( ) ) ; myIntent . putExtra ( MapParams . STOP_CODE , stop . getStopCode ( ) ) ; myIntent . putExtra ( MapParams . CENTER_LAT , stop . getLatitude ( ) ) ; myIntent . putExtra ( MapParams . CENTER_LON , stop . getLongitude ( ) ) ; return myIntent ; }
public static Intent makeIntent ( Context context , String routeId ) { Intent myIntent = new Intent ( context , HomeActivity .class ) ; myIntent . putExtra ( MapParams . MODE , MapParams . MODE_ROUTE ) ; myIntent . putExtra ( MapParams . ZOOM_TO_ROUTE , true ) ; myIntent . putExtra ( MapParams . ROUTE_ID , routeId ) ; return myIntent ; }
@ Override public void onCreate ( Bundle savedInstanceState ) { requestWindowFeature ( Window . FEATURE_INDETERMINATE_PROGRESS ) ; super. onCreate ( savedInstanceState ) ; setContentView ( R . layout . main ) ; mContext = this ; setupNavigationDrawer ( ) ; setupSlidingPanel ( ) ; setupMapState ( savedInstanceState ) ; setupMyLocationButton ( ) ; setupGooglePlayServices ( ) ; UIUtils . setupActionBar ( this ) ; checkRegionStatus ( ) ; Bundle b = getIntent ( ) . getExtras ( ) ; if ( b != null ) { if ( b . getBoolean ( ShowcaseViewUtils . TUTORIAL_WELCOME ) ) { ShowcaseViewUtils . showTutorial ( ShowcaseViewUtils . TUTORIAL_WELCOME , this , null ) ; } } }
@ Override public void onStart ( ) { super. onStart ( ) ; if ( mGoogleApiClient != null && ! mGoogleApiClient . isConnected ( ) ) { mGoogleApiClient . connect ( ) ; } ObaAnalytics . reportActivityStart ( this ) ; if ( Build . VERSION . SDK_INT >= 14 ) { AccessibilityManager am = ( AccessibilityManager ) getSystemService ( ACCESSIBILITY_SERVICE ) ; Boolean isTalkBackEnabled = am . isTouchExplorationEnabled ( ) ; if ( isTalkBackEnabled ) { ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . ACCESSIBILITY . toString ( ) , getString ( R . string . analytics_action_touch_exploration ) , getString ( R . string . analytics_label_talkback ) + getClass ( ) . getSimpleName ( ) + " using TalkBack" ) ; } } }
@ Override public void onResume ( ) { super. onResume ( ) ; if ( mArrivalsListHeader != null && mSlidingPanel != null ) { mArrivalsListHeader . setSlidingPanelCollapsed ( isSlidingPanelCollapsed ( ) ) ; } checkLeftHandMode ( ) ; mFabMyLocation . requestLayout ( ) ; }
@ Override protected void onPause ( ) { ShowcaseViewUtils . hideShowcaseView ( ) ; super. onPause ( ) ; }
@ Override public void onStop ( ) { if ( mGoogleApiClient != null && mGoogleApiClient . isConnected ( ) ) { mGoogleApiClient . disconnect ( ) ; } super. onStop ( ) ; }
@ Override protected void onSaveInstanceState ( Bundle outState ) { super. onSaveInstanceState ( outState ) ; if ( mFocusedStopId != null ) { outState . putString ( MapParams . STOP_ID , mFocusedStopId ) ; if ( mFocusedStop != null ) { outState . putString ( MapParams . STOP_CODE , mFocusedStop . getStopCode ( ) ) ; outState . putString ( MapParams . STOP_NAME , mFocusedStop . getName ( ) ) ; } } }
@ Override public void onNavigationDrawerItemSelected ( int position ) { goToNavDrawerItem ( position ) ; }
private void goToNavDrawerItem ( int item ) { switch ( item ) { case NAVDRAWER_ITEM_STARRED_STOPS : if ( mCurrentNavDrawerPosition != NAVDRAWER_ITEM_STARRED_STOPS ) { showStarredStopsFragment ( ) ; mCurrentNavDrawerPosition = item ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getString ( R . string . analytics_action_button_press ) , getString ( R . string . analytics_label_button_press_star ) ) ; } break; case NAVDRAWER_ITEM_NEARBY : if ( mCurrentNavDrawerPosition != NAVDRAWER_ITEM_NEARBY ) { showMapFragment ( ) ; mCurrentNavDrawerPosition = item ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getString ( R . string . analytics_action_button_press ) , getString ( R . string . analytics_label_button_press_nearby ) ) ; } break; case NAVDRAWER_ITEM_MY_REMINDERS : if ( mCurrentNavDrawerPosition != NAVDRAWER_ITEM_MY_REMINDERS ) { showMyRemindersFragment ( ) ; mCurrentNavDrawerPosition = item ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getString ( R . string . analytics_action_button_press ) , getString ( R . string . analytics_label_button_press_reminders ) ) ; } break; case NAVDRAWER_ITEM_PLAN_TRIP : Intent planTrip = new Intent ( HomeActivity .this , TripPlanActivity .class ) ; startActivity ( planTrip ) ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getString ( R . string . analytics_action_button_press ) , getString ( R . string . analytics_label_button_press_trip_plan ) ) ; break; case NAVDRAWER_ITEM_SETTINGS : Intent preferences = new Intent ( HomeActivity .this , PreferencesActivity .class ) ; startActivity ( preferences ) ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getString ( R . string . analytics_action_button_press ) , getString ( R . string . analytics_label_button_press_settings ) ) ; break; case NAVDRAWER_ITEM_HELP : showDialog ( HELP_DIALOG ) ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getString ( R . string . analytics_action_button_press ) , getString ( R . string . analytics_label_button_press_help ) ) ; break; case NAVDRAWER_ITEM_SEND_FEEDBACK : ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getString ( R . string . analytics_action_button_press ) , getString ( R . string . analytics_label_button_press_feedback ) ) ; goToSendFeedBack ( ) ; break; } invalidateOptionsMenu ( ) ; }
private void showMapFragment ( ) { FragmentManager fm = getSupportFragmentManager ( ) ; hideStarredStopsFragment ( ) ; hideReminderFragment ( ) ; mShowStarredStopsMenu = false ; if ( mMapFragment == null ) { mMapFragment = ( BaseMapFragment ) fm . findFragmentByTag ( BaseMapFragment . TAG ) ; if ( mMapFragment == null ) { Log . d ( TAG , "Creating new BaseMapFragment" ) ; mMapFragment = BaseMapFragment . newInstance ( ) ; fm . beginTransaction ( ) . add ( R . id . main_fragment_container , mMapFragment , BaseMapFragment . TAG ) . commit ( ) ; } } mMapFragment . setOnFocusChangeListener ( this ) ; mMapFragment . setOnProgressBarChangedListener ( this ) ; getSupportFragmentManager ( ) . beginTransaction ( ) . show ( mMapFragment ) . commit ( ) ; showMyLocationButton ( ) ; if ( mLastMapProgressBarState ) { showMapProgressBar ( ) ; } mShowArrivalsMenu = true ; if ( mFocusedStopId != null && mSlidingPanel != null ) { mSlidingPanel . setPanelState ( SlidingUpPanelLayout . PanelState . COLLAPSED ) ; } setTitle ( getResources ( ) . getString ( R . string . navdrawer_item_nearby ) ) ; }
private void showStarredStopsFragment ( ) { FragmentManager fm = getSupportFragmentManager ( ) ; hideMyLocationButton ( ) ; hideMapProgressBar ( ) ; hideMapFragment ( ) ; hideReminderFragment ( ) ; hideSlidingPanel ( ) ; mShowArrivalsMenu = false ; mShowStarredStopsMenu = true ; if ( mMyStarredStopsFragment == null ) { mMyStarredStopsFragment = ( MyStarredStopsFragment ) fm . findFragmentByTag ( MyStarredStopsFragment . TAG ) ; if ( mMyStarredStopsFragment == null ) { Log . d ( TAG , "Creating new MyStarredStopsFragment" ) ; mMyStarredStopsFragment = new MyStarredStopsFragment ( ) ; fm . beginTransaction ( ) . add ( R . id . main_fragment_container , mMyStarredStopsFragment , MyStarredStopsFragment . TAG ) . commit ( ) ; } } fm . beginTransaction ( ) . show ( mMyStarredStopsFragment ) . commit ( ) ; setTitle ( getResources ( ) . getString ( R . string . navdrawer_item_starred_stops ) ) ; }
private void showMyRemindersFragment ( ) { FragmentManager fm = getSupportFragmentManager ( ) ; hideMyLocationButton ( ) ; hideMapProgressBar ( ) ; hideStarredStopsFragment ( ) ; hideMapFragment ( ) ; hideSlidingPanel ( ) ; mShowArrivalsMenu = false ; mShowStarredStopsMenu = false ; if ( mMyRemindersFragment == null ) { mMyRemindersFragment = ( MyRemindersFragment ) fm . findFragmentByTag ( MyRemindersFragment . TAG ) ; if ( mMyRemindersFragment == null ) { Log . d ( TAG , "Creating new MyRemindersFragment" ) ; mMyRemindersFragment = new MyRemindersFragment ( ) ; fm . beginTransaction ( ) . add ( R . id . main_fragment_container , mMyRemindersFragment , MyRemindersFragment . TAG ) . commit ( ) ; } } fm . beginTransaction ( ) . show ( mMyRemindersFragment ) . commit ( ) ; setTitle ( getResources ( ) . getString ( R . string . navdrawer_item_my_reminders ) ) ; }
private void hideMapFragment ( ) { FragmentManager fm = getSupportFragmentManager ( ) ; mMapFragment = ( BaseMapFragment ) fm . findFragmentByTag ( BaseMapFragment . TAG ) ; if ( mMapFragment != null && ! mMapFragment . isHidden ( ) ) { fm . beginTransaction ( ) . hide ( mMapFragment ) . commit ( ) ; } }
private void hideStarredStopsFragment ( ) { FragmentManager fm = getSupportFragmentManager ( ) ; mMyStarredStopsFragment = ( MyStarredStopsFragment ) fm . findFragmentByTag ( MyStarredStopsFragment . TAG ) ; if ( mMyStarredStopsFragment != null && ! mMyStarredStopsFragment . isHidden ( ) ) { fm . beginTransaction ( ) . hide ( mMyStarredStopsFragment ) . commit ( ) ; } }
private void hideReminderFragment ( ) { FragmentManager fm = getSupportFragmentManager ( ) ; mMyRemindersFragment = ( MyRemindersFragment ) fm . findFragmentByTag ( MyRemindersFragment . TAG ) ; if ( mMyRemindersFragment != null && ! mMyRemindersFragment . isHidden ( ) ) { fm . beginTransaction ( ) . hide ( mMyRemindersFragment ) . commit ( ) ; } }
private void hideSlidingPanel ( ) { if ( mSlidingPanel != null ) { mSlidingPanel . setPanelState ( SlidingUpPanelLayout . PanelState . HIDDEN ) ; } }
@ Override public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . main_options , menu ) ; UIUtils . setupSearch ( this , menu ) ; setupOptionsMenu ( menu ) ; return super. onCreateOptionsMenu ( menu ) ; }
@ Override public boolean onPrepareOptionsMenu ( Menu menu ) { super. onPrepareOptionsMenu ( menu ) ; setupOptionsMenu ( menu ) ; return true ; }
private void setupOptionsMenu ( Menu menu ) { menu . setGroupVisible ( R . id . main_options_menu_group , true ) ; menu . setGroupVisible ( R . id . arrival_list_menu_group , mShowArrivalsMenu ) ; menu . setGroupVisible ( R . id . starred_stop_menu_group , mShowStarredStopsMenu ) ; }
@ Override @ SuppressWarnings ( "deprecation" ) public boolean onOptionsItemSelected ( MenuItem item ) { Log . d ( TAG , "onOptionsItemSelected" ) ; final int id = item . getItemId ( ) ; if ( id == R . id . search ) { onSearchRequested ( ) ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getString ( R . string . analytics_action_button_press ) , getString ( R . string . analytics_label_button_press_search_box ) ) ; return true ; } else if ( id == R . id . recent_stops_routes ) { ShowcaseViewUtils . doNotShowTutorial ( ShowcaseViewUtils . TUTORIAL_RECENT_STOPS_ROUTES ) ; Intent myIntent = new Intent ( this , MyRecentStopsAndRoutesActivity .class ) ; startActivity ( myIntent ) ; return true ; } return super. onOptionsItemSelected ( item ) ; }
@ Override protected Dialog onCreateDialog ( int id ) { switch ( id ) { case HELP_DIALOG : return createHelpDialog ( ) ; case WHATSNEW_DIALOG : return createWhatsNewDialog ( ) ; case LEGEND_DIALOG : return createLegendDialog ( ) ; } return super. onCreateDialog ( id ) ; }
@ SuppressWarnings ( "deprecation" ) private Dialog createHelpDialog ( ) { AlertDialog . Builder builder = new AlertDialog . Builder ( this ) ; builder . setTitle ( R . string . main_help_title ) ; int options ; if ( TextUtils . isEmpty ( Application . get ( ) . getCustomApiUrl ( ) ) ) { options = R . array . main_help_options ; } else { options = R . array . main_help_options_no_contact_us ; } builder . setItems ( options , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int which ) { switch ( which ) { case 0 : ShowcaseViewUtils . resetAllTutorials ( HomeActivity .this ) ; NavHelp . goHome ( HomeActivity .this , true ) ; break; case 1 : showDialog ( LEGEND_DIALOG ) ; break; case 2 : showDialog ( WHATSNEW_DIALOG ) ; break; case 3 : AgenciesActivity . start ( HomeActivity .this ) ; break; case 4 : String twitterUrl = TWITTER_URL ; if ( Application . get ( ) . getCurrentRegion ( ) != null && ! TextUtils . isEmpty ( Application . get ( ) . getCurrentRegion ( ) . getTwitterUrl ( ) ) ) { twitterUrl = Application . get ( ) . getCurrentRegion ( ) . getTwitterUrl ( ) ; } UIUtils . goToUrl ( HomeActivity .this , twitterUrl ) ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getString ( R . string . analytics_action_switch ) , getString ( R . string . analytics_label_app_switch ) ) ; break; case 5 : goToSendFeedBack ( ) ; break; } } } ) ; return builder . create ( ) ; }
public void onClick ( DialogInterface dialog , int which ) { switch ( which ) { case 0 : ShowcaseViewUtils . resetAllTutorials ( HomeActivity .this ) ; NavHelp . goHome ( HomeActivity .this , true ) ; break; case 1 : showDialog ( LEGEND_DIALOG ) ; break; case 2 : showDialog ( WHATSNEW_DIALOG ) ; break; case 3 : AgenciesActivity . start ( HomeActivity .this ) ; break; case 4 : String twitterUrl = TWITTER_URL ; if ( Application . get ( ) . getCurrentRegion ( ) != null && ! TextUtils . isEmpty ( Application . get ( ) . getCurrentRegion ( ) . getTwitterUrl ( ) ) ) { twitterUrl = Application . get ( ) . getCurrentRegion ( ) . getTwitterUrl ( ) ; } UIUtils . goToUrl ( HomeActivity .this , twitterUrl ) ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getString ( R . string . analytics_action_switch ) , getString ( R . string . analytics_label_app_switch ) ) ; break; case 5 : goToSendFeedBack ( ) ; break; } }
@ SuppressWarnings ( "deprecation" ) private Dialog createWhatsNewDialog ( ) { TextView textView = ( TextView ) getLayoutInflater ( ) . inflate ( R . layout . whats_new_dialog , null ) ; textView . setText ( R . string . main_help_whatsnew ) ; AlertDialog . Builder builder = new AlertDialog . Builder ( this ) ; builder . setTitle ( R . string . main_help_whatsnew_title ) ; builder . setIcon ( R . mipmap . ic_launcher ) ; builder . setView ( textView ) ; builder . setNeutralButton ( R . string . main_help_close , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int which ) { dismissDialog ( WHATSNEW_DIALOG ) ; } } ) ; builder . setOnDismissListener ( new DialogInterface . OnDismissListener ( ) { @ Override public void onDismiss ( DialogInterface dialog ) { boolean showOptOut = Application . getPrefs ( ) . getBoolean ( ShowcaseViewUtils . TUTORIAL_OPT_OUT_DIALOG , true ) ; if ( showOptOut ) { ShowcaseViewUtils . showOptOutDialog ( HomeActivity .this ) ; } } } ) ; return builder . create ( ) ; }
public void onClick ( DialogInterface dialog , int which ) { dismissDialog ( WHATSNEW_DIALOG ) ; }
@ Override public void onDismiss ( DialogInterface dialog ) { boolean showOptOut = Application . getPrefs ( ) . getBoolean ( ShowcaseViewUtils . TUTORIAL_OPT_OUT_DIALOG , true ) ; if ( showOptOut ) { ShowcaseViewUtils . showOptOutDialog ( HomeActivity .this ) ; } }
@ SuppressWarnings ( "deprecation" ) private Dialog createLegendDialog ( ) { AlertDialog . Builder builder = new AlertDialog . Builder ( this ) ; builder . setTitle ( R . string . main_help_legend_title ) ; Resources resources = getResources ( ) ; LayoutInflater inflater = LayoutInflater . from ( getApplicationContext ( ) ) ; View legendDialogView = inflater . inflate ( R . layout . legend_dialog , null ) ; final float etaTextFontSize = 30 ; View etaAndMin = legendDialogView . findViewById ( R . id . eta_view_ontime ) ; GradientDrawable d1 = ( GradientDrawable ) etaAndMin . getBackground ( ) ; d1 . setColor ( resources . getColor ( R . color . stop_info_ontime ) ) ; etaAndMin . findViewById ( R . id . eta_realtime_indicator ) . setVisibility ( View . VISIBLE ) ; TextView etaTextView = ( ( TextView ) etaAndMin . findViewById ( R . id . eta ) ) ; etaTextView . setTextSize ( etaTextFontSize ) ; etaTextView . setText ( "5" ) ; etaAndMin = legendDialogView . findViewById ( R . id . eta_view_early ) ; d1 = ( GradientDrawable ) etaAndMin . getBackground ( ) ; d1 . setColor ( resources . getColor ( R . color . stop_info_early ) ) ; etaAndMin . findViewById ( R . id . eta_realtime_indicator ) . setVisibility ( View . VISIBLE ) ; etaTextView = ( ( TextView ) etaAndMin . findViewById ( R . id . eta ) ) ; etaTextView . setTextSize ( etaTextFontSize ) ; etaTextView . setText ( "5" ) ; etaAndMin = legendDialogView . findViewById ( R . id . eta_view_delayed ) ; d1 = ( GradientDrawable ) etaAndMin . getBackground ( ) ; d1 . setColor ( resources . getColor ( R . color . stop_info_delayed ) ) ; etaAndMin . findViewById ( R . id . eta_realtime_indicator ) . setVisibility ( View . VISIBLE ) ; etaTextView = ( ( TextView ) etaAndMin . findViewById ( R . id . eta ) ) ; etaTextView . setTextSize ( etaTextFontSize ) ; etaTextView . setText ( "5" ) ; etaAndMin = legendDialogView . findViewById ( R . id . eta_view_scheduled ) ; d1 = ( GradientDrawable ) etaAndMin . getBackground ( ) ; d1 . setColor ( resources . getColor ( R . color . stop_info_scheduled_time ) ) ; etaAndMin . findViewById ( R . id . eta_realtime_indicator ) . setVisibility ( View . INVISIBLE ) ; etaTextView = ( ( TextView ) etaAndMin . findViewById ( R . id . eta ) ) ; etaTextView . setTextSize ( etaTextFontSize ) ; etaTextView . setText ( "5" ) ; builder . setView ( legendDialogView ) ; builder . setNeutralButton ( R . string . main_help_close , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int which ) { dismissDialog ( LEGEND_DIALOG ) ; } } ) ; return builder . create ( ) ; }
public void onClick ( DialogInterface dialog , int which ) { dismissDialog ( LEGEND_DIALOG ) ; }
@ SuppressWarnings ( "deprecation" ) private boolean autoShowWhatsNew ( ) { SharedPreferences settings = Application . getPrefs ( ) ; PackageManager pm = getPackageManager ( ) ; PackageInfo appInfo = null ; try { appInfo = pm . getPackageInfo ( getPackageName ( ) , PackageManager . GET_META_DATA ) ; } catch ( NameNotFoundException e ) { return false ; } final int oldVer = settings . getInt ( WHATS_NEW_VER , 0 ) ; final int newVer = appInfo . versionCode ; if ( oldVer < newVer ) { showDialog ( WHATSNEW_DIALOG ) ; TripService . scheduleAll ( this ) ; PreferenceUtils . saveInt ( WHATS_NEW_VER , appInfo . versionCode ) ; return true ; } return false ; }
@ Override public void onFocusChanged ( ObaStop stop , HashMap < String , ObaRoute > routes , Location location ) { if ( mFocusedStopId != null && stop != null && mFocusedStopId . equalsIgnoreCase ( stop . getId ( ) ) ) { return; } mFocusedStop = stop ; if ( stop != null ) { mFocusedStopId = stop . getId ( ) ; updateArrivalListFragment ( stop . getId ( ) , stop . getName ( ) , stop . getStopCode ( ) , stop , routes ) ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getString ( R . string . analytics_action_button_press ) , getString ( R . string . analytics_label_button_press_map_icon ) ) ; } else { mFocusedStopId = null ; moveMyLocationButton ( ) ; mSlidingPanel . setPanelState ( SlidingUpPanelLayout . PanelState . HIDDEN ) ; if ( mArrivalsListFragment != null ) { FragmentManager fm = getSupportFragmentManager ( ) ; fm . beginTransaction ( ) . remove ( mArrivalsListFragment ) . commit ( ) ; } mShowArrivalsMenu = false ; } }
@ Override public void onProgressBarChanged ( boolean showProgressBar ) { mLastMapProgressBarState = showProgressBar ; if ( showProgressBar ) { showMapProgressBar ( ) ; } else { hideMapProgressBar ( ) ; } }
@ Override public void onListViewCreated ( ListView listView ) { mSlidingPanel . setScrollableView ( listView ) ; }
@ Override public void onArrivalTimesUpdated ( ObaArrivalInfoResponse response ) { if ( response == null || response . getStop ( ) == null ) { return; } if ( mFocusedStopId == null ) { mFocusedStopId = response . getStop ( ) . getId ( ) ; } if ( mFocusedStop == null ) { mFocusedStop = response . getStop ( ) ; if ( mMapFragment != null && mSlidingPanel != null ) { mMapFragment . setMapCenter ( mFocusedStop . getLocation ( ) , false , mSlidingPanel . getPanelState ( ) == SlidingUpPanelLayout . PanelState . ANCHORED ) ; } if ( mMapFragment != null ) { mMapFragment . setFocusStop ( mFocusedStop , response . getRoutes ( ) ) ; } } moveMyLocationButton ( ) ; showArrivalInfoTutorials ( response ) ; }
private void showArrivalInfoTutorials ( ObaArrivalInfoResponse response ) { if ( ShowcaseViewUtils . isShowcaseViewShowing ( ) ) { return; } if ( mMapFragment . isHidden ( ) || ! mMapFragment . isVisible ( ) || mSlidingPanel . getPanelState ( ) == SlidingUpPanelLayout . PanelState . HIDDEN ) { return; } ShowcaseViewUtils . showTutorial ( ShowcaseViewUtils . TUTORIAL_ARRIVAL_HEADER_ARRIVAL_INFO , this , response ) ; if ( mSlidingPanel != null && ( isSlidingPanelCollapsed ( ) || mSlidingPanel . getPanelState ( ) == SlidingUpPanelLayout . PanelState . ANCHORED || mSlidingPanel . getPanelState ( ) == SlidingUpPanelLayout . PanelState . EXPANDED ) ) { ShowcaseViewUtils . showTutorial ( ShowcaseViewUtils . TUTORIAL_ARRIVAL_HEADER_STAR_ROUTE , this , response ) ; } ShowcaseViewUtils . showTutorial ( ShowcaseViewUtils . TUTORIAL_RECENT_STOPS_ROUTES , this , null ) ; }
@ Override public boolean onShowRouteOnMapSelected ( ArrivalInfo arrivalInfo ) { if ( mSlidingPanel != null ) { mSlidingPanel . setPanelState ( SlidingUpPanelLayout . PanelState . COLLAPSED ) ; } Bundle bundle = new Bundle ( ) ; bundle . putBoolean ( MapParams . ZOOM_TO_ROUTE , false ) ; bundle . putBoolean ( MapParams . ZOOM_INCLUDE_CLOSEST_VEHICLE , true ) ; bundle . putString ( MapParams . ROUTE_ID , arrivalInfo . getInfo ( ) . getRouteId ( ) ) ; mMapFragment . setMapMode ( MapParams . MODE_ROUTE , bundle ) ; return true ; }
@ Override public void onSortBySelected ( ) { if ( mSlidingPanel != null ) { if ( isSlidingPanelCollapsed ( ) ) { mSlidingPanel . setPanelState ( SlidingUpPanelLayout . PanelState . ANCHORED ) ; } } }
@ Override public void onBackPressed ( ) { if ( mSlidingPanel != null ) { if ( mSlidingPanel . getPanelState ( ) == SlidingUpPanelLayout . PanelState . EXPANDED || mSlidingPanel . getPanelState ( ) == SlidingUpPanelLayout . PanelState . ANCHORED ) { mSlidingPanel . setPanelState ( SlidingUpPanelLayout . PanelState . COLLAPSED ) ; return; } if ( mSlidingPanel . getPanelState ( ) == SlidingUpPanelLayout . PanelState . COLLAPSED ) { mMapFragment . setFocusStop ( null , null ) ; return; } } super. onBackPressed ( ) ; }
private void redrawNavigationDrawerFragment ( ) { if ( mNavigationDrawerFragment != null ) { mNavigationDrawerFragment . populateNavDrawer ( ) ; } }
private void updateArrivalListFragment ( @ NonNull String stopId , @ NonNull String stopName , @ NonNull String stopCode , ObaStop stop , HashMap < String , ObaRoute > routes ) { FragmentManager fm = getSupportFragmentManager ( ) ; Intent intent ; mArrivalsListFragment = new ArrivalsListFragment ( ) ; mArrivalsListFragment . setListener ( this ) ; mArrivalsListHeader = new ArrivalsListHeader ( this , mArrivalsListFragment , getSupportFragmentManager ( ) ) ; mArrivalsListFragment . setHeader ( mArrivalsListHeader , mArrivalsListHeaderView ) ; mArrivalsListHeader . setSlidingPanelController ( mSlidingPanelController ) ; mArrivalsListHeader . setSlidingPanelCollapsed ( isSlidingPanelCollapsed ( ) ) ; mShowArrivalsMenu = true ; mExpandCollapse = ( ImageView ) mArrivalsListHeaderView . findViewById ( R . id . expand_collapse ) ; if ( stop != null && routes != null ) { intent = new ArrivalsListFragment . IntentBuilder ( this , stop , routes ) . build ( ) ; } else { intent = new ArrivalsListFragment . IntentBuilder ( this , stopId ) . setStopName ( stopName ) . setStopCode ( stopCode ) . build ( ) ; } mArrivalsListFragment . setArguments ( FragmentUtils . getIntentArgs ( intent ) ) ; fm . beginTransaction ( ) . replace ( R . id . slidingFragment , mArrivalsListFragment ) . commit ( ) ; if ( mSlidingPanel . getPanelState ( ) == SlidingUpPanelLayout . PanelState . HIDDEN ) { mSlidingPanel . setPanelState ( SlidingUpPanelLayout . PanelState . COLLAPSED ) ; } moveMyLocationButton ( ) ; }
private void goToSendFeedBack ( ) { if ( mFocusedStop != null ) { ReportActivity . start ( this , mFocusedStopId , mFocusedStop . getName ( ) , mFocusedStop . getStopCode ( ) , mFocusedStop . getLatitude ( ) , mFocusedStop . getLongitude ( ) , mGoogleApiClient ) ; } else { Location loc = Application . getLastKnownLocation ( this , mGoogleApiClient ) ; if ( loc != null ) { ReportActivity . start ( this , loc . getLatitude ( ) , loc . getLongitude ( ) , mGoogleApiClient ) ; } else { ReportActivity . start ( this , mGoogleApiClient ) ; } } }
private void checkRegionStatus ( ) { if ( ! TextUtils . isEmpty ( Application . get ( ) . getCustomApiUrl ( ) ) ) { return; } if ( BuildConfig . USE_FIXED_REGION ) { ObaRegion r = RegionUtils . getRegionFromBuildFlavor ( ) ; RegionUtils . saveToProvider ( this , Collections . singletonList ( r ) ) ; Application . get ( ) . setCurrentRegion ( r ) ; PreferenceUtils . saveBoolean ( getString ( R . string . preference_key_auto_select_region ) , false ) ; return; } boolean forceReload = false ; boolean showProgressDialog = true ; if ( Application . get ( ) . getCurrentRegion ( ) == null || new Date ( ) . getTime ( ) - Application . get ( ) . getLastRegionUpdateDate ( ) > REGION_UPDATE_THRESHOLD ) { forceReload = true ; Log . d ( TAG , "Region info has expired (or does not exist), forcing a reload from the server..." ) ; } if ( Application . get ( ) . getCurrentRegion ( ) != null ) { showProgressDialog = false ; } try { PackageInfo appInfo = getPackageManager ( ) . getPackageInfo ( getPackageName ( ) , PackageManager . GET_META_DATA ) ; SharedPreferences settings = Application . getPrefs ( ) ; final int oldVer = settings . getInt ( CHECK_REGION_VER , 0 ) ; final int newVer = appInfo . versionCode ; if ( oldVer < newVer ) { forceReload = true ; } PreferenceUtils . saveInt ( CHECK_REGION_VER , appInfo . versionCode ) ; } catch ( NameNotFoundException e ) { } List < ObaRegionsTask . Callback > callbacks = new ArrayList <> ( ) ; callbacks . add ( mMapFragment ) ; callbacks . add ( this ) ; ObaRegionsTask task = new ObaRegionsTask ( this , callbacks , forceReload , showProgressDialog ) ; task . execute ( ) ; }
@ Override public void onRegionTaskFinished ( boolean currentRegionChanged ) { boolean update = autoShowWhatsNew ( ) ; if ( currentRegionChanged || update ) { redrawNavigationDrawerFragment ( ) ; } if ( currentRegionChanged && Application . getPrefs ( ) . getBoolean ( getString ( R . string . preference_key_auto_select_region ) , true ) && Application . get ( ) . getCurrentRegion ( ) != null && UIUtils . canManageDialog ( this ) ) { Toast . makeText ( getApplicationContext ( ) , getString ( R . string . region_region_found , Application . get ( ) . getCurrentRegion ( ) . getName ( ) ) , Toast . LENGTH_LONG ) . show ( ) ; } }
private void setupMyLocationButton ( ) { mFabMyLocation = ( FloatingActionButton ) findViewById ( R . id . btnMyLocation ) ; mFabMyLocation . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View arg0 ) { if ( mMapFragment != null ) { PreferenceUtils . saveBoolean ( getString ( R . string . preference_key_never_show_location_dialog ) , false ) ; mMapFragment . setMyLocation ( true , true ) ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getString ( R . string . analytics_action_button_press ) , getString ( R . string . analytics_label_button_press_location ) ) ; } } } ) ; ViewGroup . MarginLayoutParams p = ( ViewGroup . MarginLayoutParams ) mFabMyLocation . getLayoutParams ( ) ; MY_LOC_DEFAULT_BOTTOM_MARGIN = p . bottomMargin ; checkLeftHandMode ( ) ; if ( mCurrentNavDrawerPosition == NAVDRAWER_ITEM_NEARBY ) { showMyLocationButton ( ) ; showMapProgressBar ( ) ; } else { hideMyLocationButton ( ) ; hideMapProgressBar ( ) ; } }
@ Override public void onClick ( View arg0 ) { if ( mMapFragment != null ) { PreferenceUtils . saveBoolean ( getString ( R . string . preference_key_never_show_location_dialog ) , false ) ; mMapFragment . setMyLocation ( true , true ) ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getString ( R . string . analytics_action_button_press ) , getString ( R . string . analytics_label_button_press_location ) ) ; } }
private void checkLeftHandMode ( ) { if ( mFabMyLocation == null ) { return; } RelativeLayout . LayoutParams layoutParams = ( RelativeLayout . LayoutParams ) mFabMyLocation . getLayoutParams ( ) ; boolean leftHandMode = Application . getPrefs ( ) . getBoolean ( getString ( R . string . preference_key_left_hand_mode ) , false ) ; if ( leftHandMode ) { layoutParams . addRule ( RelativeLayout . ALIGN_PARENT_LEFT ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . JELLY_BEAN_MR1 ) { layoutParams . removeRule ( RelativeLayout . ALIGN_PARENT_RIGHT ) ; } } else { layoutParams . addRule ( RelativeLayout . ALIGN_PARENT_RIGHT ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . JELLY_BEAN_MR1 ) { layoutParams . removeRule ( RelativeLayout . ALIGN_PARENT_LEFT ) ; } } }
synchronized private void moveMyLocationButton ( ) { if ( mFabMyLocation == null ) { return; } if ( mMyLocationAnimation != null && ( mMyLocationAnimation . hasStarted ( ) && ! mMyLocationAnimation . hasEnded ( ) ) ) { return; } if ( mMyLocationAnimation != null ) { mMyLocationAnimation . reset ( ) ; } final Handler h = new Handler ( ) ; h . postDelayed ( new Runnable ( ) { @ Override public void run ( ) { final ViewGroup . MarginLayoutParams p = ( ViewGroup . MarginLayoutParams ) mFabMyLocation . getLayoutParams ( ) ; int tempMargin = MY_LOC_DEFAULT_BOTTOM_MARGIN ; if ( mSlidingPanel . getPanelState ( ) == SlidingUpPanelLayout . PanelState . COLLAPSED ) { tempMargin += mSlidingPanel . getPanelHeight ( ) ; if ( p . bottomMargin == tempMargin ) { return; } } else { if ( mSlidingPanel . getPanelState ( ) == SlidingUpPanelLayout . PanelState . HIDDEN ) { if ( p . bottomMargin == tempMargin ) { return; } } } final int goalMargin = tempMargin ; final int currentMargin = p . bottomMargin ; mMyLocationAnimation = new Animation ( ) { @ Override protected void applyTransformation ( float interpolatedTime , Transformation t ) { int bottom ; if ( goalMargin > currentMargin ) { bottom = currentMargin + ( int ) ( Math . abs ( currentMargin - goalMargin ) * interpolatedTime ) ; } else { bottom = currentMargin - ( int ) ( Math . abs ( currentMargin - goalMargin ) * interpolatedTime ) ; } UIUtils . setMargins ( mFabMyLocation , p . leftMargin , p . topMargin , p . rightMargin , bottom ) ; } } ; mMyLocationAnimation . setDuration ( MY_LOC_BTN_ANIM_DURATION ) ; mFabMyLocation . startAnimation ( mMyLocationAnimation ) ; } } , 100 ) ; }
@ Override public void run ( ) { final ViewGroup . MarginLayoutParams p = ( ViewGroup . MarginLayoutParams ) mFabMyLocation . getLayoutParams ( ) ; int tempMargin = MY_LOC_DEFAULT_BOTTOM_MARGIN ; if ( mSlidingPanel . getPanelState ( ) == SlidingUpPanelLayout . PanelState . COLLAPSED ) { tempMargin += mSlidingPanel . getPanelHeight ( ) ; if ( p . bottomMargin == tempMargin ) { return; } } else { if ( mSlidingPanel . getPanelState ( ) == SlidingUpPanelLayout . PanelState . HIDDEN ) { if ( p . bottomMargin == tempMargin ) { return; } } } final int goalMargin = tempMargin ; final int currentMargin = p . bottomMargin ; mMyLocationAnimation = new Animation ( ) { @ Override protected void applyTransformation ( float interpolatedTime , Transformation t ) { int bottom ; if ( goalMargin > currentMargin ) { bottom = currentMargin + ( int ) ( Math . abs ( currentMargin - goalMargin ) * interpolatedTime ) ; } else { bottom = currentMargin - ( int ) ( Math . abs ( currentMargin - goalMargin ) * interpolatedTime ) ; } UIUtils . setMargins ( mFabMyLocation , p . leftMargin , p . topMargin , p . rightMargin , bottom ) ; } } ; mMyLocationAnimation . setDuration ( MY_LOC_BTN_ANIM_DURATION ) ; mFabMyLocation . startAnimation ( mMyLocationAnimation ) ; }
@ Override protected void applyTransformation ( float interpolatedTime , Transformation t ) { int bottom ; if ( goalMargin > currentMargin ) { bottom = currentMargin + ( int ) ( Math . abs ( currentMargin - goalMargin ) * interpolatedTime ) ; } else { bottom = currentMargin - ( int ) ( Math . abs ( currentMargin - goalMargin ) * interpolatedTime ) ; } UIUtils . setMargins ( mFabMyLocation , p . leftMargin , p . topMargin , p . rightMargin , bottom ) ; }
private void showMyLocationButton ( ) { if ( mFabMyLocation == null ) { return; } if ( mFabMyLocation . getVisibility ( ) != View . VISIBLE ) { mFabMyLocation . setVisibility ( View . VISIBLE ) ; } }
private void hideMyLocationButton ( ) { if ( mFabMyLocation == null ) { return; } if ( mFabMyLocation . getVisibility ( ) != View . GONE ) { mFabMyLocation . setVisibility ( View . GONE ) ; } }
private void showMapProgressBar ( ) { if ( mMapProgressBar == null ) { return; } if ( mMapProgressBar . getVisibility ( ) != View . VISIBLE ) { mMapProgressBar . setVisibility ( View . VISIBLE ) ; } }
private void hideMapProgressBar ( ) { if ( mMapProgressBar == null ) { return; } if ( mMapProgressBar . getVisibility ( ) != View . GONE ) { mMapProgressBar . setVisibility ( View . GONE ) ; } }
private void setupNavigationDrawer ( ) { mNavigationDrawerFragment = ( NavigationDrawerFragment ) getSupportFragmentManager ( ) . findFragmentById ( R . id . navigation_drawer ) ; mNavigationDrawerFragment . setUp ( R . id . navigation_drawer , ( DrawerLayout ) findViewById ( R . id . nav_drawer_left_pane ) ) ; Bundle bundle = getIntent ( ) . getExtras ( ) ; if ( bundle != null ) { String routeId = bundle . getString ( MapParams . ROUTE_ID ) ; String stopId = bundle . getString ( MapParams . STOP_ID ) ; if ( routeId != null || stopId != null ) { mNavigationDrawerFragment . selectItem ( NAVDRAWER_ITEM_NEARBY ) ; } } }
private void setupGooglePlayServices ( ) { GoogleApiAvailability api = GoogleApiAvailability . getInstance ( ) ; if ( api . isGooglePlayServicesAvailable ( this ) == ConnectionResult . SUCCESS ) { mGoogleApiClient = LocationUtils . getGoogleApiClientWithCallbacks ( this ) ; mGoogleApiClient . connect ( ) ; } }
private void setupSlidingPanel ( ) { mSlidingPanel = ( SlidingUpPanelLayout ) findViewById ( R . id . bottom_sliding_layout ) ; mArrivalsListHeaderView = findViewById ( R . id . arrivals_list_header ) ; mArrivalsListHeaderSubView = mArrivalsListHeaderView . findViewById ( R . id . main_header_content ) ; mSlidingPanel . setPanelState ( SlidingUpPanelLayout . PanelState . HIDDEN ) ; mSlidingPanel . setOverlayed ( true ) ; mSlidingPanel . setAnchorPoint ( MapModeController . OVERLAY_PERCENTAGE ) ; mSlidingPanel . addPanelSlideListener ( new SlidingUpPanelLayout . PanelSlideListener ( ) { @ Override public void onPanelStateChanged ( View panel , SlidingUpPanelLayout . PanelState previousState , SlidingUpPanelLayout . PanelState newState ) { if ( previousState == SlidingUpPanelLayout . PanelState . HIDDEN ) { return; } switch( newState ) { case EXPANDED : onPanelExpanded ( panel ) ; break; case COLLAPSED : onPanelCollapsed ( panel ) ; break; case ANCHORED : onPanelAnchored ( panel ) ; break; case HIDDEN : onPanelHidden ( panel ) ; break; } } @ Override public void onPanelSlide ( View panel , float slideOffset ) { Log . d ( TAG , "onPanelSlide, offset " + slideOffset ) ; if ( mArrivalsListHeader != null ) { mArrivalsListHeader . closeStatusPopups ( ) ; } } public void onPanelExpanded ( View panel ) { Log . d ( TAG , "onPanelExpanded" ) ; if ( mArrivalsListHeader != null ) { mArrivalsListHeader . setSlidingPanelCollapsed ( false ) ; mArrivalsListHeader . refresh ( ) ; } if ( mExpandCollapse != null ) { mExpandCollapse . setContentDescription ( mContext . getResources ( ) . getString ( R . string . stop_header_sliding_panel_open ) ) ; } } public void onPanelCollapsed ( View panel ) { Log . d ( TAG , "onPanelCollapsed" ) ; if ( mMapFragment != null ) { mMapFragment . getMapView ( ) . setPadding ( null , null , null , mSlidingPanel . getPanelHeight ( ) ) ; } if ( mArrivalsListHeader != null ) { mArrivalsListHeader . setSlidingPanelCollapsed ( true ) ; mArrivalsListHeader . refresh ( ) ; } moveMyLocationButton ( ) ; if ( mExpandCollapse != null ) { mExpandCollapse . setContentDescription ( mContext . getResources ( ) . getString ( R . string . stop_header_sliding_panel_collapsed ) ) ; } } public void onPanelAnchored ( View panel ) { Log . d ( TAG , "onPanelAnchored" ) ; if ( mMapFragment != null ) { mMapFragment . getMapView ( ) . setPadding ( null , null , null , mSlidingPanel . getPanelHeight ( ) ) ; } if ( mFocusedStop != null && mMapFragment != null ) { mMapFragment . setMapCenter ( mFocusedStop . getLocation ( ) , true , true ) ; } if ( mArrivalsListHeader != null ) { mArrivalsListHeader . setSlidingPanelCollapsed ( false ) ; mArrivalsListHeader . refresh ( ) ; } if ( mExpandCollapse != null ) { mExpandCollapse . setContentDescription ( mContext . getResources ( ) . getString ( R . string . stop_header_sliding_panel_open ) ) ; } } public void onPanelHidden ( View panel ) { Log . d ( TAG , "onPanelHidden" ) ; if ( mMapFragment != null ) { mMapFragment . getMapView ( ) . setPadding ( null , null , null , 0 ) ; } if ( mExpandCollapse != null ) { mExpandCollapse . setContentDescription ( mContext . getResources ( ) . getString ( R . string . stop_header_sliding_panel_collapsed ) ) ; } } } ) ; mSlidingPanelController = new SlidingPanelController ( ) { @ Override public void setPanelHeightPixels ( int heightInPixels ) { if ( mSlidingPanel != null ) { if ( mSlidingPanel . getPanelState ( ) == SlidingUpPanelLayout . PanelState . DRAGGING || mSlidingPanel . getPanelState ( ) == SlidingUpPanelLayout . PanelState . HIDDEN ) { return; } if ( mSlidingPanel . getPanelHeight ( ) != heightInPixels ) { mSlidingPanel . setPanelHeight ( heightInPixels ) ; mArrivalsListHeaderView . getLayoutParams ( ) . height = heightInPixels ; mArrivalsListHeaderSubView . getLayoutParams ( ) . height = heightInPixels ; } } } @ Override public int getPanelHeightPixels ( ) { if ( mSlidingPanel != null ) { return mSlidingPanel . getPanelHeight ( ) ; } return - 1 ; } } ; }
@ Override public void onPanelStateChanged ( View panel , SlidingUpPanelLayout . PanelState previousState , SlidingUpPanelLayout . PanelState newState ) { if ( previousState == SlidingUpPanelLayout . PanelState . HIDDEN ) { return; } switch( newState ) { case EXPANDED : onPanelExpanded ( panel ) ; break; case COLLAPSED : onPanelCollapsed ( panel ) ; break; case ANCHORED : onPanelAnchored ( panel ) ; break; case HIDDEN : onPanelHidden ( panel ) ; break; } }
@ Override public void onPanelSlide ( View panel , float slideOffset ) { Log . d ( TAG , "onPanelSlide, offset " + slideOffset ) ; if ( mArrivalsListHeader != null ) { mArrivalsListHeader . closeStatusPopups ( ) ; } }
public void onPanelExpanded ( View panel ) { Log . d ( TAG , "onPanelExpanded" ) ; if ( mArrivalsListHeader != null ) { mArrivalsListHeader . setSlidingPanelCollapsed ( false ) ; mArrivalsListHeader . refresh ( ) ; } if ( mExpandCollapse != null ) { mExpandCollapse . setContentDescription ( mContext . getResources ( ) . getString ( R . string . stop_header_sliding_panel_open ) ) ; } }
public void onPanelCollapsed ( View panel ) { Log . d ( TAG , "onPanelCollapsed" ) ; if ( mMapFragment != null ) { mMapFragment . getMapView ( ) . setPadding ( null , null , null , mSlidingPanel . getPanelHeight ( ) ) ; } if ( mArrivalsListHeader != null ) { mArrivalsListHeader . setSlidingPanelCollapsed ( true ) ; mArrivalsListHeader . refresh ( ) ; } moveMyLocationButton ( ) ; if ( mExpandCollapse != null ) { mExpandCollapse . setContentDescription ( mContext . getResources ( ) . getString ( R . string . stop_header_sliding_panel_collapsed ) ) ; } }
public void onPanelAnchored ( View panel ) { Log . d ( TAG , "onPanelAnchored" ) ; if ( mMapFragment != null ) { mMapFragment . getMapView ( ) . setPadding ( null , null , null , mSlidingPanel . getPanelHeight ( ) ) ; } if ( mFocusedStop != null && mMapFragment != null ) { mMapFragment . setMapCenter ( mFocusedStop . getLocation ( ) , true , true ) ; } if ( mArrivalsListHeader != null ) { mArrivalsListHeader . setSlidingPanelCollapsed ( false ) ; mArrivalsListHeader . refresh ( ) ; } if ( mExpandCollapse != null ) { mExpandCollapse . setContentDescription ( mContext . getResources ( ) . getString ( R . string . stop_header_sliding_panel_open ) ) ; } }
public void onPanelHidden ( View panel ) { Log . d ( TAG , "onPanelHidden" ) ; if ( mMapFragment != null ) { mMapFragment . getMapView ( ) . setPadding ( null , null , null , 0 ) ; } if ( mExpandCollapse != null ) { mExpandCollapse . setContentDescription ( mContext . getResources ( ) . getString ( R . string . stop_header_sliding_panel_collapsed ) ) ; } }
@ Override public void setPanelHeightPixels ( int heightInPixels ) { if ( mSlidingPanel != null ) { if ( mSlidingPanel . getPanelState ( ) == SlidingUpPanelLayout . PanelState . DRAGGING || mSlidingPanel . getPanelState ( ) == SlidingUpPanelLayout . PanelState . HIDDEN ) { return; } if ( mSlidingPanel . getPanelHeight ( ) != heightInPixels ) { mSlidingPanel . setPanelHeight ( heightInPixels ) ; mArrivalsListHeaderView . getLayoutParams ( ) . height = heightInPixels ; mArrivalsListHeaderSubView . getLayoutParams ( ) . height = heightInPixels ; } } }
@ Override public int getPanelHeightPixels ( ) { if ( mSlidingPanel != null ) { return mSlidingPanel . getPanelHeight ( ) ; } return - 1 ; }
private void setupMapState ( Bundle savedInstanceState ) { String stopId ; String stopName ; String stopCode ; if ( savedInstanceState != null ) { stopId = savedInstanceState . getString ( MapParams . STOP_ID ) ; stopName = savedInstanceState . getString ( MapParams . STOP_NAME ) ; stopCode = savedInstanceState . getString ( MapParams . STOP_CODE ) ; if ( stopId != null ) { mFocusedStopId = stopId ; updateArrivalListFragment ( stopId , stopName , stopCode , null , null ) ; } } else { Bundle bundle = getIntent ( ) . getExtras ( ) ; if ( bundle != null ) { stopId = bundle . getString ( MapParams . STOP_ID ) ; stopName = bundle . getString ( MapParams . STOP_NAME ) ; stopCode = bundle . getString ( MapParams . STOP_CODE ) ; double lat = bundle . getDouble ( MapParams . CENTER_LAT ) ; double lon = bundle . getDouble ( MapParams . CENTER_LON ) ; if ( stopId != null && lat != 0.0 && lon != 0.0 ) { mFocusedStopId = stopId ; updateArrivalListFragment ( stopId , stopName , stopCode , null , null ) ; } } } mMapProgressBar = ( ProgressBar ) findViewById ( R . id . progress_horizontal ) ; }
private boolean isSlidingPanelCollapsed ( ) { return ! ( mSlidingPanel . getPanelState ( ) == SlidingUpPanelLayout . PanelState . EXPANDED || mSlidingPanel . getPanelState ( ) == SlidingUpPanelLayout . PanelState . ANCHORED ) ; }
public ArrivalsListFragment getArrivalsListFragment ( ) { return mArrivalsListFragment ; }
public SampleHelper ( Context context ) { super( context , "MyDatabase" , null , 1 ); }
@ Override public void onCreate ( SQLiteDatabase database , ConnectionSource connectionSource ) { try { TableUtils . createTableIfNotExists ( connectionSource , Account .class ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
@ Override public void onUpgrade ( SQLiteDatabase database , ConnectionSource connectionSource , int oldVersion , int newVersion ) { try { TableUtils . dropTable ( connectionSource , Account .class , true ) ; TableUtils . createTable ( connectionSource , Account .class ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
public NavigationDrawerFragment ( ) {    }
@ Override public void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; SharedPreferences sp = PreferenceManager . getDefaultSharedPreferences ( getActivity ( ) ) ; if ( savedInstanceState != null ) { mCurrentSelectedPosition = savedInstanceState . getInt ( STATE_SELECTED_POSITION ) ; Log . d ( TAG , "Using position from savedInstanceState = " + mCurrentSelectedPosition ) ; } else { mCurrentSelectedPosition = sp . getInt ( STATE_SELECTED_POSITION , NAVDRAWER_ITEM_NEARBY ) ; Log . d ( TAG , "Using position from preferences = " + mCurrentSelectedPosition ) ; } selectItem ( mCurrentSelectedPosition ) ; }
@ Override public void onActivityCreated ( Bundle savedInstanceState ) { super. onActivityCreated ( savedInstanceState ) ; setHasOptionsMenu ( true ) ; }
@ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { mDrawerItemsListContainer = inflater . inflate ( R . layout . navdrawer_list , container , false ) ; return mDrawerItemsListContainer ; }
public void setUp ( int fragmentId , DrawerLayout drawerLayout ) { int selfItem = mCurrentSelectedPosition ; mFragmentContainerView = getActivity ( ) . findViewById ( fragmentId ) ; mDrawerLayout = drawerLayout ; if ( mDrawerLayout == null ) { return; } mDrawerLayout . setDrawerShadow ( R . drawable . drawer_shadow , GravityCompat . START ) ; ScrimInsetsScrollView navDrawer = ( ScrimInsetsScrollView ) mDrawerLayout . findViewById ( R . id . navdrawer ) ; if ( selfItem == NAVDRAWER_ITEM_INVALID ) { if ( navDrawer != null ) { ( ( ViewGroup ) navDrawer . getParent ( ) ) . removeView ( navDrawer ) ; } mDrawerLayout = null ; return; } populateNavDrawer ( ) ; ActionBar actionBar = getActionBar ( ) ; actionBar . setDisplayHomeAsUpEnabled ( true ) ; actionBar . setHomeButtonEnabled ( true ) ; mDrawerToggle = new android . support . v7 . app . ActionBarDrawerToggle ( getActivity ( ) , mDrawerLayout , R . string . navigation_drawer_open , R . string . navigation_drawer_close ) { @ Override public void onDrawerClosed ( View drawerView ) { super. onDrawerClosed ( drawerView ) ; if ( ! isAdded ( ) ) { return; } getActivity ( ) . supportInvalidateOptionsMenu ( ) ; } @ Override public void onDrawerOpened ( View drawerView ) { super. onDrawerOpened ( drawerView ) ; if ( ! isAdded ( ) ) { return; } getActivity ( ) . supportInvalidateOptionsMenu ( ) ; } } ; mDrawerLayout . post ( new Runnable ( ) { @ Override public void run ( ) { mDrawerToggle . syncState ( ) ; } } ) ; mDrawerLayout . setDrawerListener ( mDrawerToggle ) ; }
@ Override public void onDrawerClosed ( View drawerView ) { super. onDrawerClosed ( drawerView ) ; if ( ! isAdded ( ) ) { return; } getActivity ( ) . supportInvalidateOptionsMenu ( ) ; }
@ Override public void onDrawerOpened ( View drawerView ) { super. onDrawerOpened ( drawerView ) ; if ( ! isAdded ( ) ) { return; } getActivity ( ) . supportInvalidateOptionsMenu ( ) ; }
@ Override public void run ( ) { mDrawerToggle . syncState ( ) ; }
public void selectItem ( int position ) { setSelectedNavDrawerItem ( position ) ; if ( mDrawerLayout != null ) { mDrawerLayout . closeDrawer ( mFragmentContainerView ) ; } if ( mCallbacks != null ) { mCallbacks . onNavigationDrawerItemSelected ( position ) ; } }
private void setSelectedNavDrawerItem ( int itemId ) { if ( ! isNewActivityItem ( itemId ) ) { mCurrentSelectedPosition = itemId ; SharedPreferences sp = PreferenceManager . getDefaultSharedPreferences ( getActivity ( ) ) ; sp . edit ( ) . putInt ( STATE_SELECTED_POSITION , mCurrentSelectedPosition ) . apply ( ) ; } if ( mNavDrawerItemViews != null ) { for ( int i = 0 ; i < mNavDrawerItemViews . length ; i ++ ) { if ( i < mNavDrawerItems . size ( ) ) { int thisItemId = mNavDrawerItems . get ( i ) ; formatNavDrawerItem ( mNavDrawerItemViews [ i ] , thisItemId , itemId == thisItemId ) ; } } } }
@ Override public void onAttach ( Context context ) { super. onAttach ( context ) ; try { mCallbacks = ( NavigationDrawerCallbacks ) context ; } catch ( ClassCastException e ) { throw new ClassCastException ( "Activity must implement NavigationDrawerCallbacks." ) ; } }
@ Override public void onDetach ( ) { super. onDetach ( ) ; mCallbacks = null ; }
@ Override public void onSaveInstanceState ( Bundle outState ) { super. onSaveInstanceState ( outState ) ; Log . d ( TAG , "Saving position = " + mCurrentSelectedPosition ) ; outState . putInt ( STATE_SELECTED_POSITION , mCurrentSelectedPosition ) ; }
@ Override public void onConfigurationChanged ( Configuration newConfig ) { super. onConfigurationChanged ( newConfig ) ; mDrawerToggle . onConfigurationChanged ( newConfig ) ; }
@ Override public boolean onOptionsItemSelected ( MenuItem item ) { if ( mDrawerToggle . onOptionsItemSelected ( item ) ) { return true ; } return super. onOptionsItemSelected ( item ) ; }
private ActionBar getActionBar ( ) { return ( ( AppCompatActivity ) getActivity ( ) ) . getSupportActionBar ( ) ; }
void onNavigationDrawerItemSelected ( int position );
public void populateNavDrawer ( ) { mNavDrawerItems . clear ( ) ; mNavDrawerItems . add ( NAVDRAWER_ITEM_NEARBY ) ; mNavDrawerItems . add ( NAVDRAWER_ITEM_STARRED_STOPS ) ; mNavDrawerItems . add ( NAVDRAWER_ITEM_MY_REMINDERS ) ; if ( ( Application . get ( ) . getCurrentRegion ( ) != null && ! TextUtils . isEmpty ( Application . get ( ) . getCurrentRegion ( ) . getOtpBaseUrl ( ) ) ) || ! TextUtils . isEmpty ( Application . get ( ) . getCustomOtpApiUrl ( ) ) ) { mNavDrawerItems . add ( NAVDRAWER_ITEM_PLAN_TRIP ) ; } mNavDrawerItems . add ( NAVDRAWER_ITEM_SEPARATOR ) ; mNavDrawerItems . add ( NAVDRAWER_ITEM_SETTINGS ) ; mNavDrawerItems . add ( NAVDRAWER_ITEM_HELP ) ; mNavDrawerItems . add ( NAVDRAWER_ITEM_SEND_FEEDBACK ) ; createNavDrawerItems ( ) ; }
private void createNavDrawerItems ( ) { if ( mDrawerItemsListContainer == null || getActivity ( ) == null ) { return; } mNavDrawerItemViews = new View [ mNavDrawerItems . size ( ) ] ; int i = 0 ; LinearLayout containerLayout = ( LinearLayout ) mDrawerItemsListContainer . findViewById ( R . id . navdrawer_items_list ) ; containerLayout . removeAllViews ( ) ; for ( int itemId : mNavDrawerItems ) { mNavDrawerItemViews [ i ] = makeNavDrawerItem ( itemId , containerLayout ) ; containerLayout . addView ( mNavDrawerItemViews [ i ] ) ; ++ i ; } }
private View makeNavDrawerItem ( final int itemId , ViewGroup container ) { boolean selected = mCurrentSelectedPosition == itemId ; int layoutToInflate ; if ( itemId == NAVDRAWER_ITEM_SEPARATOR ) { layoutToInflate = R . layout . navdrawer_separator ; } else if ( itemId == NAVDRAWER_ITEM_SEPARATOR_SPECIAL ) { layoutToInflate = R . layout . navdrawer_separator ; } else { layoutToInflate = R . layout . navdrawer_item ; } View view = getActivity ( ) . getLayoutInflater ( ) . inflate ( layoutToInflate , container , false ) ; if ( isSeparator ( itemId ) ) { UIUtils . setAccessibilityIgnore ( view ) ; return view ; } ImageView iconView = ( ImageView ) view . findViewById ( R . id . icon ) ; TextView titleView = ( TextView ) view . findViewById ( R . id . title ) ; int iconId = itemId >= 0 && itemId < NAVDRAWER_ICON_RES_ID . length ? NAVDRAWER_ICON_RES_ID [ itemId ] : 0 ; int titleId = itemId >= 0 && itemId < NAVDRAWER_TITLE_RES_ID . length ? NAVDRAWER_TITLE_RES_ID [ itemId ] : 0 ; iconView . setVisibility ( iconId > 0 ? View . VISIBLE : View . GONE ) ; if ( iconId > 0 ) { iconView . setImageResource ( iconId ) ; } titleView . setText ( getString ( titleId ) ) ; formatNavDrawerItem ( view , itemId , selected ) ; view . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { selectItem ( itemId ) ; } } ) ; return view ; }
@ Override public void onClick ( View v ) { selectItem ( itemId ) ; }
private void formatNavDrawerItem ( View view , int itemId , boolean selected ) { if ( isSeparator ( itemId ) ) { return; } ImageView iconView = ( ImageView ) view . findViewById ( R . id . icon ) ; TextView titleView = ( TextView ) view . findViewById ( R . id . title ) ; if ( selected ) { if ( isNewActivityItem ( itemId ) ) { return; } else { view . setSelected ( true ) ; titleView . setTextColor ( getResources ( ) . getColor ( R . color . navdrawer_text_color_selected ) ) ; iconView . setColorFilter ( getResources ( ) . getColor ( R . color . navdrawer_icon_tint_selected ) ) ; } } else { if ( itemId != mCurrentSelectedPosition ) { view . setSelected ( false ) ; titleView . setTextColor ( getResources ( ) . getColor ( R . color . navdrawer_text_color ) ) ; iconView . setColorFilter ( getResources ( ) . getColor ( R . color . navdrawer_icon_tint ) ) ; } } }
private boolean isSeparator ( int itemId ) { return itemId == NAVDRAWER_ITEM_SEPARATOR || itemId == NAVDRAWER_ITEM_SEPARATOR_SPECIAL ; }
private boolean isNewActivityItem ( int itemId ) { return itemId == NAVDRAWER_ITEM_SETTINGS || itemId == NAVDRAWER_ITEM_HELP || itemId == NAVDRAWER_ITEM_SEND_FEEDBACK || itemId == NAVDRAWER_ITEM_PLAN_TRIP ; }
public SimpleCursorAdapterAssert ( SimpleCursorAdapter actual ) { super( actual , SimpleCursorAdapterAssert .class ); }
public SimpleCursorAdapterAssert hasCursorToStringConverter ( CursorToStringConverter converter ) { isNotNull ( ) ; CursorToStringConverter actualConverter = actual . getCursorToStringConverter ( ) ; assertThat ( actualConverter ) . overridingErrorMessage ( "Expected cursor 'toString' converter <%s> but was <%s>." , converter , actualConverter ) . isSameAs ( converter ) ; return this ; }
public SimpleCursorAdapterAssert hasStringConversionColumn ( int column ) { isNotNull ( ) ; int actualColumn = actual . getStringConversionColumn ( ) ; assertThat ( actualColumn ) . overridingErrorMessage ( "Expected string conversion column <%s> but was <%s>." , column , actualColumn ) . isEqualTo ( column ) ; return this ; }
public SimpleCursorAdapterAssert hasViewBinder ( SimpleCursorAdapter . ViewBinder binder ) { isNotNull ( ) ; SimpleCursorAdapter . ViewBinder actualBinder = actual . getViewBinder ( ) ; assertThat ( actualBinder ) . overridingErrorMessage ( "Expected view binder <%s> but was <%s>." , binder , actualBinder ) . isSameAs ( binder ) ; return this ; }
public Builder ( Context context , String stopId ) { mContext = context ; mIntent = new Intent ( context , ArrivalsListActivity .class ) ; mIntent . setData ( Uri . withAppendedPath ( ObaContract . Stops . CONTENT_URI , stopId ) ) ; }
public Builder ( Context context , ObaStop stop , HashMap < String , ObaRoute > routes ) { mContext = context ; mIntent = new Intent ( context , ArrivalsListActivity .class ) ; mIntent . setData ( Uri . withAppendedPath ( ObaContract . Stops . CONTENT_URI , stop . getId ( ) ) ) ; setStopName ( stop . getName ( ) ) ; setStopDirection ( stop . getDirection ( ) ) ; setStopRoutes ( UIUtils . serializeRouteDisplayNames ( stop , routes ) ) ; }
public Builder setStopName ( String stopName ) { mIntent . putExtra ( ArrivalsListFragment . STOP_NAME , stopName ) ; return this ; }
public Builder setStopDirection ( String stopDir ) { mIntent . putExtra ( ArrivalsListFragment . STOP_DIRECTION , stopDir ) ; return this ; }
public Builder setStopRoutes ( String routes ) { mIntent . putExtra ( ArrivalsListFragment . STOP_ROUTES , routes ) ; return this ; }
public Builder setUpMode ( String mode ) { mIntent . putExtra ( NavHelp . UP_MODE , mode ) ; return this ; }
public Intent getIntent ( ) { return mIntent ; }
public void start ( ) { mContext . startActivity ( mIntent ) ; }
public static void start ( Context context , String stopId ) { new Builder ( context , stopId ) . start ( ) ; }
public static void start ( Context context , ObaStop stop , HashMap < String , ObaRoute > routes ) { new Builder ( context , stop , routes ) . start ( ) ; }
@ Override protected void onCreate ( Bundle savedInstanceState ) { requestWindowFeature ( Window . FEATURE_INDETERMINATE_PROGRESS ) ; super. onCreate ( savedInstanceState ) ; UIUtils . setupActionBar ( this ) ; FragmentManager fm = getSupportFragmentManager ( ) ; if ( fm . findFragmentById ( android . R . id . content ) == null ) { ArrivalsListFragment list = new ArrivalsListFragment ( ) ; list . setArguments ( FragmentUtils . getIntentArgs ( getIntent ( ) ) ) ; fm . beginTransaction ( ) . add ( android . R . id . content , list ) . commit ( ) ; } }
@ Override protected void onNewIntent ( Intent intent ) { super. onNewIntent ( intent ) ; setIntent ( intent ) ; mNewFragment = true ; }
@ Override protected void onResume ( ) { super. onResume ( ) ; boolean newFrag = mNewFragment ; mNewFragment = false ; if ( newFrag ) { FragmentManager fm = getSupportFragmentManager ( ) ; ArrivalsListFragment list = new ArrivalsListFragment ( ) ; list . setArguments ( FragmentUtils . getIntentArgs ( getIntent ( ) ) ) ; FragmentTransaction ft = fm . beginTransaction ( ) ; ft . replace ( android . R . id . content , list ) ; if ( fm . getBackStackEntryCount ( ) > 0 ) { ft . addToBackStack ( null ) ; } ft . commit ( ) ; } }
@ Override protected void onPause ( ) { ShowcaseViewUtils . hideShowcaseView ( ) ; super. onPause ( ) ; }
@ Override protected void onStart ( ) { ObaAnalytics . reportActivityStart ( this ) ; super. onStart ( ) ; }
@ Override public boolean onOptionsItemSelected ( MenuItem item ) { if ( item . getItemId ( ) == android . R . id . home ) { NavHelp . goUp ( this ) ; return true ; } return false ; }
public ArrivalsListFragment getArrivalsListFragment ( ) { FragmentManager fm = getSupportFragmentManager ( ) ; return ( ArrivalsListFragment ) fm . findFragmentById ( android . R . id . content ) ; }
@ Override protected void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; final String url = new URLRewriteController ( tracker ) . getUrlByUri ( getIntent ( ) . getData ( ) ) ; if ( url == null ) { new AlertDialog . Builder ( this ) . setTitle ( "Workaround failed" ) . setMessage ( "The URL PassAndroid tried to work around failed :-( some companies just send PassBooks to Apple Devices - this was an attempt to workaround this." + "Unfortunately it failed - perhaps there where changes on the serverside - you can open the site with your browser now - to see it in PassAndroid in future again it would help if you can send me the pass" ) . setPositiveButton ( "Browser" , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { tracker . trackException ( "URLRewrite with invalid activity" , false ) ; final Intent intent = new Intent ( URLRewriteActivity .this , OpenIphoneWebView .class ) ; intent . setData ( getIntent ( ) . getData ( ) ) ; startActivity ( intent ) ; } } ) . setNeutralButton ( "send" , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { Intent intent = new Intent ( Intent . ACTION_SEND ) ; intent . putExtra ( Intent . EXTRA_SUBJECT , "PassAndroid: URLRewrite Problem" ) ; intent . putExtra ( Intent . EXTRA_EMAIL , new String [] { "ligi@ligi.de" } ) ; intent . putExtra ( Intent . EXTRA_TEXT , getIntent ( ) . getData ( ) . toString ( ) ) ; intent . setType ( "text/plain" ) ; startActivity ( Intent . createChooser ( intent , "How to send Link?" ) ) ; finish ( ) ; } } ) . setNegativeButton ( "cancel" , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { URLRewriteActivity .this . finish ( ) ; } } ) . show ( ) ; return; } final Intent intent = new Intent ( this , PassImportActivity .class ) ; intent . setData ( Uri . parse ( url ) ) ; startActivity ( intent ) ; finish ( ) ; }
@ Override public void onClick ( DialogInterface dialog , int which ) { tracker . trackException ( "URLRewrite with invalid activity" , false ) ; final Intent intent = new Intent ( URLRewriteActivity .this , OpenIphoneWebView .class ) ; intent . setData ( getIntent ( ) . getData ( ) ) ; startActivity ( intent ) ; }
@ Override public void onClick ( DialogInterface dialog , int which ) { Intent intent = new Intent ( Intent . ACTION_SEND ) ; intent . putExtra ( Intent . EXTRA_SUBJECT , "PassAndroid: URLRewrite Problem" ) ; intent . putExtra ( Intent . EXTRA_EMAIL , new String [] { "ligi@ligi.de" } ) ; intent . putExtra ( Intent . EXTRA_TEXT , getIntent ( ) . getData ( ) . toString ( ) ) ; intent . setType ( "text/plain" ) ; startActivity ( Intent . createChooser ( intent , "How to send Link?" ) ) ; finish ( ) ; }
@ Override public void onClick ( DialogInterface dialog , int which ) { URLRewriteActivity .this . finish ( ) ; }
public ArrayAdapter ( Context context , int layout ) { super( context , layout ); mLayoutId = layout ; mInflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; }
@ TargetApi ( 11 ) public void setData ( List < T > data ) { setNotifyOnChange ( false ) ; clear ( ) ; if ( data != null ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . HONEYCOMB ) { addAll ( data ) ; } else { for ( T info : data ) { add ( info ) ; } } } notifyDataSetChanged ( ) ; }
@ Override public View getView ( int position , View convertView , ViewGroup parent ) { View view ; if ( convertView == null ) { view = mInflater . inflate ( mLayoutId , parent , false ) ; } else { view = convertView ; } T item = getItem ( position ) ; initView ( view , item ) ; return view ; }
protected LayoutInflater getLayoutInflater ( ) { return mInflater ; }
abstract protected void initView ( View view , T t );
@ Override protected void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_actionbarcontrolscrollview ) ; ObservableScrollView scrollView = ( ObservableScrollView ) findViewById ( R . id . scroll ) ; scrollView . setScrollViewCallbacks ( this ) ; }
@ Override public void onScrollChanged ( int scrollY , boolean firstScroll , boolean dragging ) {    }
@ Override public void onDownMotionEvent ( ) {    }
@ Override public void onUpOrCancelMotionEvent ( ScrollState scrollState ) { ActionBar ab = getSupportActionBar ( ) ; if ( ab == null ) { return; } if ( scrollState == ScrollState . UP ) { if ( ab . isShowing ( ) ) { ab . hide ( ) ; } } else if ( scrollState == ScrollState . DOWN ) { if ( ! ab . isShowing ( ) ) { ab . show ( ) ; } } }
public Account ( ) { }
public Account ( String name ) { this . id = 0 ; this . name = name ; }
public int getId ( ) { return id ; }
public String getName ( ) { return name ; }
public static Test suite ( ) { return new TestSuiteBuilder ( AllTests .class ) . includeAllPackagesUnderHere ( ) . build ( ) ; }
public BluetoothGattCharacteristicAssert ( BluetoothGattCharacteristic actual ) { super( actual , BluetoothGattCharacteristicAssert .class ); }
public BluetoothGattCharacteristicAssert hasInstanceId ( int id ) { isNotNull ( ) ; int actualId = actual . getInstanceId ( ) ; assertThat ( actualId ) . overridingErrorMessage ( "Expected instance ID <%s> but was <%s>" , id , actualId ) . isEqualTo ( id ) ; return this ; }
public BluetoothGattCharacteristicAssert hasPermissions ( @ BluetoothGattCharacteristicPermissions int permissions ) { isNotNull ( ) ; int actualPermissions = actual . getPermissions ( ) ; assertThat ( actualPermissions ) . overridingErrorMessage ( "Expected permissions <%s> but was <%s>." , permissionsToString ( permissions ) , permissionsToString ( actualPermissions ) ) . isEqualTo ( permissions ) ; return this ; }
public BluetoothGattCharacteristicAssert hasProperties ( @ BluetoothGattCharacteristicProperties int properties ) { isNotNull ( ) ; int actualProperties = actual . getProperties ( ) ; assertThat ( actualProperties ) . overridingErrorMessage ( "Expected properties <%s> but was <%s>." , propertiesToString ( properties ) , propertiesToString ( actualProperties ) ) . isEqualTo ( properties ) ; return this ; }
public BluetoothGattCharacteristicAssert hasUuid ( UUID uuid ) { isNotNull ( ) ; UUID actualUuid = actual . getUuid ( ) ; assertThat ( actualUuid ) . overridingErrorMessage ( "Expected UUID <%s> but was <%s>." , uuid , actualUuid ) . isEqualTo ( uuid ) ; return this ; }
public BluetoothGattCharacteristicAssert hasValue ( byte [] value ) { isNotNull ( ) ; byte [] actualValue = actual . getValue ( ) ; assertThat ( actualValue ) . overridingErrorMessage ( "Expected value <%s> but was <%s>." , Arrays . toString ( value ) , Arrays . toString ( actualValue ) ) . isEqualTo ( value ) ; return this ; }
public BluetoothGattCharacteristicAssert hasWriteType ( @ BluetoothGattCharacteristicWriteType int writeType ) { isNotNull ( ) ; int actualWriteType = actual . getWriteType ( ) ; assertThat ( actualWriteType ) . overridingErrorMessage ( "Expected write type <%s> but was <%s>." , writeTypeToString ( writeType ) , writeTypeToString ( actualWriteType ) ) . isEqualTo ( writeType ) ; return this ; }
public static String writeTypeToString ( @ BluetoothGattCharacteristicWriteType int writeType ) { return buildNamedValueString ( writeType ) . value ( WRITE_TYPE_DEFAULT , "default" ) . value ( WRITE_TYPE_NO_RESPONSE , "no_response" ) . value ( WRITE_TYPE_SIGNED , "signed" ) . get ( ) ; }
public static String permissionsToString ( @ BluetoothGattCharacteristicPermissions int permissions ) { return buildBitMaskString ( permissions ) . flag ( PERMISSION_READ , "read" ) . flag ( PERMISSION_READ_ENCRYPTED , "read_encrypted" ) . flag ( PERMISSION_READ_ENCRYPTED_MITM , "read_encrypted_mitm" ) . flag ( PERMISSION_WRITE , "write" ) . flag ( PERMISSION_WRITE_ENCRYPTED , "write_encrypted" ) . flag ( PERMISSION_WRITE_ENCRYPTED_MITM , "write_encrypted_mitm" ) . flag ( PERMISSION_WRITE_SIGNED , "write_signed" ) . flag ( PERMISSION_WRITE_SIGNED_MITM , "write_signed_mitm" ) . get ( ) ; }
public static String propertiesToString ( @ BluetoothGattCharacteristicProperties int properties ) { return buildBitMaskString ( properties ) . flag ( PROPERTY_BROADCAST , "broadcast" ) . flag ( PROPERTY_EXTENDED_PROPS , "extended_props" ) . flag ( PROPERTY_INDICATE , "indicate" ) . flag ( PROPERTY_NOTIFY , "notify" ) . flag ( PROPERTY_READ , "read" ) . flag ( PROPERTY_SIGNED_WRITE , "signed_write" ) . flag ( PROPERTY_WRITE , "write" ) . flag ( PROPERTY_WRITE_NO_RESPONSE , "write_no_response" ) . get ( ) ; }
private JacksonSerializer ( ) { }
public static ObaApi . SerializationHandler getInstance ( ) { return SingletonHolder . INSTANCE ; }
private static JsonParser getJsonParser ( Reader reader )            throws IOException { TreeTraversingParser parser = new TreeTraversingParser ( mMapper . readTree ( reader ) ) ; parser . setCodec ( mMapper ) ; return parser ; }
public String toJson ( String input ) { TextNode node = JsonNodeFactory . instance . textNode ( input ) ; return node . toString ( ) ; }
@ Override public < T > T createFromError ( Class < T > cls , int code , String error ) { final String jsonErr = toJson ( error ) ; final String json = getErrorJson ( code , jsonErr ) ; try { return mMapper . readValue ( json , cls ) ; } catch ( JsonParseException e ) { Log . e ( TAG , e . toString ( ) ) ; } catch ( JsonMappingException e ) { Log . e ( TAG , e . toString ( ) ) ; } catch ( IOException e ) { Log . e ( TAG , e . toString ( ) ) ; } return null ; }
private String getErrorJson ( int code , final String jsonErr ) { return String . format ( "{\"code\": %d,\"version\":\"2\",\"text\":%s}" , code , jsonErr ) ; }
public < T > T deserialize ( Reader reader , Class < T > cls ) { try { T t = getJsonParser ( reader ) . readValueAs ( cls ) ; if ( t == null ) { t = createFromError ( cls , ObaApi . OBA_INTERNAL_ERROR , "Json error" ) ; } return t ; } catch ( FileNotFoundException e ) { return createFromError ( cls , ObaApi . OBA_NOT_FOUND , e . toString ( ) ) ; } catch ( JsonProcessingException e ) { return createFromError ( cls , ObaApi . OBA_INTERNAL_ERROR , e . toString ( ) ) ; } catch ( IOException e ) { return createFromError ( cls , ObaApi . OBA_IO_EXCEPTION , e . toString ( ) ) ; } }
public < T > T deserializeFromResponse ( String response , Class < T > cls ) { try { return mMapper . readValue ( response , cls ) ; } catch ( JsonParseException e ) { Log . e ( TAG , e . toString ( ) ) ; } catch ( JsonMappingException e ) { Log . e ( TAG , e . toString ( ) ) ; } catch ( IOException e ) { Log . e ( TAG , e . toString ( ) ) ; } return null ; }
public String serialize ( Object obj ) { StringWriter writer = new StringWriter ( ) ; JsonGenerator jsonGenerator ; try { jsonGenerator = new MappingJsonFactory ( ) . createJsonGenerator ( writer ) ; mMapper . writeValue ( jsonGenerator , obj ) ; return writer . toString ( ) ; } catch ( JsonGenerationException e ) { Log . e ( TAG , e . toString ( ) ) ; return getErrorJson ( ObaApi . OBA_INTERNAL_ERROR , e . toString ( ) ) ; } catch ( JsonMappingException e ) { Log . e ( TAG , e . toString ( ) ) ; return getErrorJson ( ObaApi . OBA_INTERNAL_ERROR , e . toString ( ) ) ; } catch ( IOException e ) { Log . e ( TAG , e . toString ( ) ) ; return getErrorJson ( ObaApi . OBA_IO_EXCEPTION , e . toString ( ) ) ; } }
public static void assertOK ( ObaResponse response ) { assertNotNull ( response ) ; assertEquals ( ObaApi . OBA_OK , response . getCode ( ) ) ; }
@ Override protected void setUp ( ) { mContext . setTheme ( R . style . Theme_OneBusAway ) ; mMock = new ObaMock ( getContext ( ) ) ; Application . get ( ) . setCustomApiUrl ( "api.pugetsound.onebusaway.org" ) ; }
@ Override protected void tearDown ( ) { mMock . finish ( ) ; }
void onScrollChanged ( int scrollY , boolean firstScroll , boolean dragging );
void onDownMotionEvent ( )
void onUpOrCancelMotionEvent ( ScrollState scrollState );
@ Test public void checkParent ( ) { Context context = InstrumentationRegistry . getTargetContext ( ) ; ParentStoryTeller teller = new ParentStoryTeller ( context ) ; teller . tellStory ( ) ; }
public GPUImageEmbossFilter ( ) { this( 1.0f ); }
public GPUImageEmbossFilter ( final float intensity ) { super(); mIntensity = intensity ; }
@ Override public void onInit ( ) { super. onInit ( ) ; setIntensity ( mIntensity ) ; }
public void setIntensity ( final float intensity ) { mIntensity = intensity ; setConvolutionKernel ( new float [] { intensity * ( - 2.0f ) , - intensity , 0.0f , - intensity , 1.0f , intensity , 0.0f , intensity , intensity * 2.0f ,        } ) ; }
public float getIntensity ( ) { return mIntensity ; }
HandlerScheduler ( Handler handler ) { this . handler = handler ; }
@ Override public Disposable scheduleDirect ( Runnable run , long delay , TimeUnit unit ) { if ( run == null ) throw new NullPointerException ( "run == null" ) ; if ( unit == null ) throw new NullPointerException ( "unit == null" ) ; run = RxJavaPlugins . onSchedule ( run ) ; ScheduledRunnable scheduled = new ScheduledRunnable ( handler , run ) ; handler . postDelayed ( scheduled , Math . max ( 0L , unit . toMillis ( delay ) ) ) ; return scheduled ; }
@ Override public Worker createWorker ( ) { return new HandlerWorker ( handler ) ; }
HandlerWorker ( Handler handler ) { this . handler = handler ; }
@ Override public Disposable schedule ( Runnable run , long delay , TimeUnit unit ) { if ( run == null ) throw new NullPointerException ( "run == null" ) ; if ( unit == null ) throw new NullPointerException ( "unit == null" ) ; if ( disposed ) { return Disposables . disposed ( ) ; } run = RxJavaPlugins . onSchedule ( run ) ; ScheduledRunnable scheduled = new ScheduledRunnable ( handler , run ) ; Message message = Message . obtain ( handler , scheduled ) ; message . obj = this ; handler . sendMessageDelayed ( message , Math . max ( 0L , unit . toMillis ( delay ) ) ) ; if ( disposed ) { handler . removeCallbacks ( scheduled ) ; return Disposables . disposed ( ) ; } return scheduled ; }
@ Override public void dispose ( ) { disposed = true ; handler . removeCallbacksAndMessages ( this ) ; }
@ Override public boolean isDisposed ( ) { return disposed ; }
ScheduledRunnable ( Handler handler , Runnable delegate ) { this . handler = handler ; this . delegate = delegate ; }
@ Override public void run ( ) { try { delegate . run ( ) ; } catch ( Throwable t ) { IllegalStateException ie = new IllegalStateException ( "Fatal Exception thrown on Scheduler." , t ) ; RxJavaPlugins . onError ( ie ) ; Thread thread = Thread . currentThread ( ) ; thread . getUncaughtExceptionHandler ( ) . uncaughtException ( thread , ie ) ; } }
@ Override public void dispose ( ) { disposed = true ; handler . removeCallbacks ( this ) ; }
@ Override public boolean isDisposed ( ) { return disposed ; }
public GPUImage ( final Context context ) { if ( ! supportsOpenGLES2 ( context ) ) { throw new IllegalStateException ( "OpenGL ES 2.0 is not supported on this phone." ) ; } mContext = context ; mFilter = new GPUImageFilter ( ) ; mRenderer = new GPUImageRenderer ( mFilter ) ; }
private boolean supportsOpenGLES2 ( final Context context ) { final ActivityManager activityManager = ( ActivityManager ) context . getSystemService ( Context . ACTIVITY_SERVICE ) ; final ConfigurationInfo configurationInfo = activityManager . getDeviceConfigurationInfo ( ) ; return configurationInfo . reqGlEsVersion >= 0x20000 ; }
public void setGLSurfaceView ( final GLSurfaceView view ) { mGlSurfaceView = view ; mGlSurfaceView . setEGLContextClientVersion ( 2 ) ; mGlSurfaceView . setEGLConfigChooser ( 8 , 8 , 8 , 8 , 16 , 0 ) ; mGlSurfaceView . getHolder ( ) . setFormat ( PixelFormat . RGBA_8888 ) ; mGlSurfaceView . setRenderer ( mRenderer ) ; mGlSurfaceView . setRenderMode ( GLSurfaceView . RENDERMODE_WHEN_DIRTY ) ; mGlSurfaceView . requestRender ( ) ; }
public void setBackgroundColor ( float red , float green , float blue ) { mRenderer . setBackgroundColor ( red , green , blue ) ; }
public void requestRender ( ) { if ( mGlSurfaceView != null ) { mGlSurfaceView . requestRender ( ) ; } }
public void setUpCamera ( final Camera camera ) { setUpCamera ( camera , 0 , false , false ) ; }
public void setUpCamera ( final Camera camera , final int degrees , final boolean flipHorizontal , final boolean flipVertical ) { mGlSurfaceView . setRenderMode ( GLSurfaceView . RENDERMODE_CONTINUOUSLY ) ; if ( Build . VERSION . SDK_INT > Build . VERSION_CODES . GINGERBREAD_MR1 ) { setUpCameraGingerbread ( camera ) ; } else { camera . setPreviewCallback ( mRenderer ) ; camera . startPreview ( ) ; } Rotation rotation = Rotation . NORMAL ; switch ( degrees ) { case 90 : rotation = Rotation . ROTATION_90 ; break; case 180 : rotation = Rotation . ROTATION_180 ; break; case 270 : rotation = Rotation . ROTATION_270 ; break; } mRenderer . setRotationCamera ( rotation , flipHorizontal , flipVertical ) ; }
@ TargetApi ( 11 ) private void setUpCameraGingerbread ( final Camera camera ) { mRenderer . setUpSurfaceTexture ( camera ) ; }
public void setFilter ( final GPUImageFilter filter ) { mFilter = filter ; mRenderer . setFilter ( mFilter ) ; requestRender ( ) ; }
public void setImage ( final Bitmap bitmap ) { mCurrentBitmap = bitmap ; mRenderer . setImageBitmap ( bitmap , false ) ; requestRender ( ) ; }
public void setScaleType ( ScaleType scaleType ) { mScaleType = scaleType ; mRenderer . setScaleType ( scaleType ) ; mRenderer . deleteImage ( ) ; mCurrentBitmap = null ; requestRender ( ) ; }
public void setRotation ( Rotation rotation ) { mRenderer . setRotation ( rotation ) ; }
public void setRotation ( Rotation rotation , boolean flipHorizontal , boolean flipVertical ) { mRenderer . setRotation ( rotation , flipHorizontal , flipVertical ) ; }
public void deleteImage ( ) { mRenderer . deleteImage ( ) ; mCurrentBitmap = null ; requestRender ( ) ; }
public void setImage ( final Uri uri ) { new LoadImageUriTask ( this , uri ) . execute ( ) ; }
public void setImage ( final File file ) { new LoadImageFileTask ( this , file ) . execute ( ) ; }
private String getPath ( final Uri uri ) { String [] projection = { MediaStore . Images . Media . DATA ,        } ; Cursor cursor = mContext . getContentResolver ( ) . query ( uri , projection , null , null , null ) ; int pathIndex = cursor . getColumnIndexOrThrow ( MediaStore . Images . Media . DATA ) ; String path = null ; if ( cursor . moveToFirst ( ) ) { path = cursor . getString ( pathIndex ) ; } cursor . close ( ) ; return path ; }
public Bitmap getBitmapWithFilterApplied ( ) { return getBitmapWithFilterApplied ( mCurrentBitmap ) ; }
public Bitmap getBitmapWithFilterApplied ( final Bitmap bitmap ) { if ( mGlSurfaceView != null ) { mRenderer . deleteImage ( ) ; mRenderer . runOnDraw ( new Runnable ( ) { @ Override public void run ( ) { synchronized( mFilter ) { mFilter . destroy ( ) ; mFilter . notify ( ) ; } } } ) ; synchronized( mFilter ) { requestRender ( ) ; try { mFilter . wait ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } GPUImageRenderer renderer = new GPUImageRenderer ( mFilter ) ; renderer . setRotation ( Rotation . NORMAL , mRenderer . isFlippedHorizontally ( ) , mRenderer . isFlippedVertically ( ) ) ; renderer . setScaleType ( mScaleType ) ; PixelBuffer buffer = new PixelBuffer ( bitmap . getWidth ( ) , bitmap . getHeight ( ) ) ; buffer . setRenderer ( renderer ) ; renderer . setImageBitmap ( bitmap , false ) ; Bitmap result = buffer . getBitmap ( ) ; mFilter . destroy ( ) ; renderer . deleteImage ( ) ; buffer . destroy ( ) ; mRenderer . setFilter ( mFilter ) ; if ( mCurrentBitmap != null ) { mRenderer . setImageBitmap ( mCurrentBitmap , false ) ; } requestRender ( ) ; return result ; }
@ Override public void run ( ) { synchronized( mFilter ) { mFilter . destroy ( ) ; mFilter . notify ( ) ; } }
public static void getBitmapForMultipleFilters ( final Bitmap bitmap , final List < GPUImageFilter > filters , final ResponseListener < Bitmap > listener ) { if ( filters . isEmpty ( ) ) { return; } GPUImageRenderer renderer = new GPUImageRenderer ( filters . get ( 0 ) ) ; renderer . setImageBitmap ( bitmap , false ) ; PixelBuffer buffer = new PixelBuffer ( bitmap . getWidth ( ) , bitmap . getHeight ( ) ) ; buffer . setRenderer ( renderer ) ; for ( GPUImageFilter filter : filters ) { renderer . setFilter ( filter ) ; listener . response ( buffer . getBitmap ( ) ) ; filter . destroy ( ) ; } renderer . deleteImage ( ) ; buffer . destroy ( ) ; }
@ Deprecated public void saveToPictures ( final String folderName , final String fileName , final OnPictureSavedListener listener ) { saveToPictures ( mCurrentBitmap , folderName , fileName , listener ) ; }
@ Deprecated public void saveToPictures ( final Bitmap bitmap , final String folderName , final String fileName , final OnPictureSavedListener listener ) { new SaveTask ( bitmap , folderName , fileName , listener ) . execute ( ) ; }
void runOnGLThread ( Runnable runnable ) { mRenderer . runOnDrawEnd ( runnable ) ; }
private int getOutputWidth ( ) { if ( mRenderer != null && mRenderer . getFrameWidth ( ) != 0 ) { return mRenderer . getFrameWidth ( ) ; } else if ( mCurrentBitmap != null ) { return mCurrentBitmap . getWidth ( ) ; } else { WindowManager windowManager = ( WindowManager ) mContext . getSystemService ( Context . WINDOW_SERVICE ) ; Display display = windowManager . getDefaultDisplay ( ) ; return display . getWidth ( ) ; } }
private int getOutputHeight ( ) { if ( mRenderer != null && mRenderer . getFrameHeight ( ) != 0 ) { return mRenderer . getFrameHeight ( ) ; } else if ( mCurrentBitmap != null ) { return mCurrentBitmap . getHeight ( ) ; } else { WindowManager windowManager = ( WindowManager ) mContext . getSystemService ( Context . WINDOW_SERVICE ) ; Display display = windowManager . getDefaultDisplay ( ) ; return display . getHeight ( ) ; } }
public SaveTask ( final Bitmap bitmap , final String folderName , final String fileName , final OnPictureSavedListener listener ) { mBitmap = bitmap ; mFolderName = folderName ; mFileName = fileName ; mListener = listener ; mHandler = new Handler ( ) ; }
@ Override protected Void doInBackground ( final Void ... params ) { Bitmap result = getBitmapWithFilterApplied ( mBitmap ) ; saveImage ( mFolderName , mFileName , result ) ; return null ; }
private void saveImage ( final String folderName , final String fileName , final Bitmap image ) { File path = Environment . getExternalStoragePublicDirectory ( Environment . DIRECTORY_PICTURES ) ; File file = new File ( path , folderName + "/" + fileName ) ; try { file . getParentFile ( ) . mkdirs ( ) ; image . compress ( CompressFormat . JPEG , 80 , new FileOutputStream ( file ) ) ; MediaScannerConnection . scanFile ( mContext , new String [] { file . toString ( ) } , null , new MediaScannerConnection . OnScanCompletedListener ( ) { @ Override public void onScanCompleted ( final String path , final Uri uri ) { if ( mListener != null ) { mHandler . post ( new Runnable ( ) { @ Override public void run ( ) { mListener . onPictureSaved ( uri ) ; } } ) ; } } } ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } }
@ Override public void onScanCompleted ( final String path , final Uri uri ) { if ( mListener != null ) { mHandler . post ( new Runnable ( ) { @ Override public void run ( ) { mListener . onPictureSaved ( uri ) ; } } ) ; } }
@ Override public void run ( ) { mListener . onPictureSaved ( uri ) ; }
void onPictureSaved ( Uri uri );
public LoadImageUriTask ( GPUImage gpuImage , Uri uri ) { super( gpuImage ); mUri = uri ; }
@ Override protected Bitmap decode ( BitmapFactory . Options options ) { try { InputStream inputStream ; if ( mUri . getScheme ( ) . startsWith ( "http" ) || mUri . getScheme ( ) . startsWith ( "https" ) ) { inputStream = new URL ( mUri . toString ( ) ) . openStream ( ) ; } else { inputStream = mContext . getContentResolver ( ) . openInputStream ( mUri ) ; } return BitmapFactory . decodeStream ( inputStream , null , options ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; }
@ Override protected int getImageOrientation ( ) IOException { Cursor cursor = mContext . getContentResolver ( ) . query ( mUri , new String [] { MediaStore . Images . ImageColumns . ORIENTATION } , null , null , null ) ; if ( cursor == null || cursor . getCount ( ) != 1 ) { return 0 ; } cursor . moveToFirst ( ) ; int orientation = cursor . getInt ( 0 ) ; cursor . close ( ) ; return orientation ; }
public LoadImageFileTask ( GPUImage gpuImage , File file ) { super( gpuImage ); mImageFile = file ; }
@ Override protected Bitmap decode ( BitmapFactory . Options options ) { return BitmapFactory . decodeFile ( mImageFile . getAbsolutePath ( ) , options ) ; }
@ Override protected int getImageOrientation ( ) IOException { ExifInterface exif = new ExifInterface ( mImageFile . getAbsolutePath ( ) ) ; int orientation = exif . getAttributeInt ( ExifInterface . TAG_ORIENTATION , 1 ) ; switch ( orientation ) { case ExifInterface . ORIENTATION_NORMAL : return 0 ; case ExifInterface . ORIENTATION_ROTATE_90 : return 90 ; case ExifInterface . ORIENTATION_ROTATE_180 : return 180 ; case ExifInterface . ORIENTATION_ROTATE_270 : return 270 ; default: return 0 ; } }
@ SuppressWarnings ( "deprecation" ) public LoadImageTask ( final GPUImage gpuImage ) { mGPUImage = gpuImage ; }
@ Override protected Bitmap doInBackground ( Void ... params ) { if ( mRenderer != null && mRenderer . getFrameWidth ( ) == 0 ) { try { synchronized ( mRenderer . mSurfaceChangedWaiter ) { mRenderer . mSurfaceChangedWaiter . wait ( 3000 ) ; } } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } mOutputWidth = getOutputWidth ( ) ; mOutputHeight = getOutputHeight ( ) ; return loadResizedImage ( ) ; }
@ Override protected void onPostExecute ( Bitmap bitmap ) { super. onPostExecute ( bitmap ) ; mGPUImage . deleteImage ( ) ; mGPUImage . setImage ( bitmap ) ; }
protected abstract Bitmap decode ( BitmapFactory . Options options );
private Bitmap loadResizedImage ( ) { BitmapFactory . Options options = new BitmapFactory . Options ( ) ; options . inJustDecodeBounds = true ; decode ( options ) ; int scale = 1 ; while ( checkSize ( options . outWidth / scale > mOutputWidth , options . outHeight / scale > mOutputHeight ) ) { scale ++ ; } scale -- ; if ( scale < 1 ) { scale = 1 ; } options = new BitmapFactory . Options ( ) ; options . inSampleSize = scale ; options . inPreferredConfig = Bitmap . Config . RGB_565 ; options . inPurgeable = true ; options . inTempStorage = new byte [ 32 * 1024 ] ; Bitmap bitmap = decode ( options ) ; if ( bitmap == null ) { return null ; } bitmap = rotateImage ( bitmap ) ; bitmap = scaleBitmap ( bitmap ) ; return bitmap ; }
private Bitmap scaleBitmap ( Bitmap bitmap ) { int width = bitmap . getWidth ( ) ; int height = bitmap . getHeight ( ) ; int [] newSize = getScaleSize ( width , height ) ; Bitmap workBitmap = Bitmap . createScaledBitmap ( bitmap , newSize [ 0 ] , newSize [ 1 ] , true ) ; if ( workBitmap != bitmap ) { bitmap . recycle ( ) ; bitmap = workBitmap ; System . gc ( ) ; } if ( mScaleType == ScaleType . CENTER_CROP ) { int diffWidth = newSize [ 0 ] - mOutputWidth ; int diffHeight = newSize [ 1 ] - mOutputHeight ; workBitmap = Bitmap . createBitmap ( bitmap , diffWidth / 2 , diffHeight / 2 , newSize [ 0 ] - diffWidth , newSize [ 1 ] - diffHeight ) ; if ( workBitmap != bitmap ) { bitmap . recycle ( ) ; bitmap = workBitmap ; } } return bitmap ; }
private int [] getScaleSize ( int width , int height ) { float newWidth ; float newHeight ; float withRatio = ( float ) width / mOutputWidth ; float heightRatio = ( float ) height / mOutputHeight ; boolean adjustWidth = mScaleType == ScaleType . CENTER_CROP ? withRatio > heightRatio : withRatio < heightRatio ; if ( adjustWidth ) { newHeight = mOutputHeight ; newWidth = ( newHeight / height ) * width ; } else { newWidth = mOutputWidth ; newHeight = ( newWidth / width ) * height ; } return new int [] { Math . round ( newWidth ) , Math . round ( newHeight ) } ; }
private boolean checkSize ( boolean widthBigger , boolean heightBigger ) { if ( mScaleType == ScaleType . CENTER_CROP ) { return widthBigger && heightBigger ; } else { return widthBigger || heightBigger ; } }
private Bitmap rotateImage ( final Bitmap bitmap ) { if ( bitmap == null ) { return null ; } Bitmap rotatedBitmap = bitmap ; try { int orientation = getImageOrientation ( ) ; if ( orientation != 0 ) { Matrix matrix = new Matrix ( ) ; matrix . postRotate ( orientation ) ; rotatedBitmap = Bitmap . createBitmap ( bitmap , 0 , 0 , bitmap . getWidth ( ) , bitmap . getHeight ( ) , matrix , true ) ; bitmap . recycle ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } return rotatedBitmap ; }
protected abstract int getImageOrientation ( ) IOException ;
void response ( T item );
@ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View view = inflater . inflate ( R . layout . fragment_recyclerview , container , false ) ; Activity parentActivity = getActivity ( ) ; final ObservableRecyclerView recyclerView = ( ObservableRecyclerView ) view . findViewById ( R . id . scroll ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( parentActivity ) ) ; recyclerView . setHasFixedSize ( false ) ; setDummyData ( recyclerView ) ; recyclerView . setTouchInterceptionViewGroup ( ( ViewGroup ) parentActivity . findViewById ( R . id . container ) ) ; if ( parentActivity instanceof ObservableScrollViewCallbacks ) { recyclerView . setScrollViewCallbacks ( ( ObservableScrollViewCallbacks ) parentActivity ) ; } return view ; }
public RecyclerViewLayoutManagerAssert ( RecyclerView . LayoutManager actual ) { super( actual , RecyclerViewLayoutManagerAssert .class ); }
public RecyclerViewLayoutManagerAssert supportsPredictiveItemAnimations ( ) { isNotNull ( ) ; assertThat ( actual . supportsPredictiveItemAnimations ( ) ) . overridingErrorMessage ( "Expected to support predictive item animations but did not." ) . isTrue ( ) ; return this ; }
public RecyclerViewLayoutManagerAssert doesNotSupportPredictiveItemAnimations ( ) { isNotNull ( ) ; assertThat ( actual . supportsPredictiveItemAnimations ( ) ) . overridingErrorMessage ( "Expected to not support predictive item animations but did." ) . isFalse ( ) ; return this ; }
public RecyclerViewLayoutManagerAssert canScrollHorizontally ( ) { isNotNull ( ) ; assertThat ( actual . canScrollHorizontally ( ) ) . overridingErrorMessage ( "Expected to be able to scroll horizontally but can not." ) . isTrue ( ) ; return this ; }
public RecyclerViewLayoutManagerAssert canNotScrollHorizontally ( ) { isNotNull ( ) ; assertThat ( actual . canScrollHorizontally ( ) ) . overridingErrorMessage ( "Expected to not be able to scroll horizontally but can." ) . isFalse ( ) ; return this ; }
public RecyclerViewLayoutManagerAssert canScrollVertically ( ) { isNotNull ( ) ; assertThat ( actual . canScrollVertically ( ) ) . overridingErrorMessage ( "Expected to be able to scroll vertically but can not." ) . isTrue ( ) ; return this ; }
public RecyclerViewLayoutManagerAssert canNotScrollVertically ( ) { isNotNull ( ) ; assertThat ( actual . canScrollVertically ( ) ) . overridingErrorMessage ( "Expected to not be able to scroll horizontally but can." ) . isFalse ( ) ; return this ; }
public RecyclerViewLayoutManagerAssert isSmoothScrolling ( ) { isNotNull ( ) ; assertThat ( actual . isSmoothScrolling ( ) ) . overridingErrorMessage ( "Expected to be smooth scrolling but was not." ) . isTrue ( ) ; return this ; }
public RecyclerViewLayoutManagerAssert isNotSmoothScrolling ( ) { isNotNull ( ) ; assertThat ( actual . isSmoothScrolling ( ) ) . overridingErrorMessage ( "Expected to not be smooth scrolling but was." ) . isFalse ( ) ; return this ; }
public RecyclerViewLayoutManagerAssert hasLayoutDirection ( int direction ) { isNotNull ( ) ; int actualDirection = actual . getLayoutDirection ( ) ; assertThat ( actualDirection ) . overridingErrorMessage ( "Expected layout direction <%s> but was <%s>." , layoutDirectionToString ( direction ) , layoutDirectionToString ( actualDirection ) ) . isEqualTo ( direction ) ; return this ; }
public RecyclerViewLayoutManagerAssert hasChildCount ( int count ) { isNotNull ( ) ; int actualCount = actual . getChildCount ( ) ; assertThat ( actualCount ) . overridingErrorMessage ( "Expected child count <%s> but was <%s>." , count , actualCount ) . isEqualTo ( count ) ; return this ; }
public RecyclerViewLayoutManagerAssert hasWidth ( int width ) { isNotNull ( ) ; int actualWidth = actual . getWidth ( ) ; assertThat ( actualWidth ) . overridingErrorMessage ( "Expected width <%s> but was <%s>." , width , actualWidth ) . isEqualTo ( width ) ; return this ; }
public RecyclerViewLayoutManagerAssert hasHeight ( int height ) { isNotNull ( ) ; int actualHeight = actual . getHeight ( ) ; assertThat ( actualHeight ) . overridingErrorMessage ( "Expected height <%s> but was <%s>." , height , actualHeight ) . isEqualTo ( height ) ; return this ; }
public RecyclerViewLayoutManagerAssert hasPaddingLeft ( int padding ) { isNotNull ( ) ; int actualPadding = actual . getPaddingLeft ( ) ; assertThat ( actualPadding ) . overridingErrorMessage ( "Expected padding left <%s> but was <%s>." , padding , actualPadding ) . isEqualTo ( padding ) ; return this ; }
public RecyclerViewLayoutManagerAssert hasPaddingTop ( int padding ) { isNotNull ( ) ; int actualPadding = actual . getPaddingTop ( ) ; assertThat ( actualPadding ) . overridingErrorMessage ( "Expected padding top <%s> but was <%s>." , padding , actualPadding ) . isEqualTo ( padding ) ; return this ; }
public RecyclerViewLayoutManagerAssert hasPaddingRight ( int padding ) { isNotNull ( ) ; int actualPadding = actual . getPaddingRight ( ) ; assertThat ( actualPadding ) . overridingErrorMessage ( "Expected padding right <%s> but was <%s>." , padding , actualPadding ) . isEqualTo ( padding ) ; return this ; }
public RecyclerViewLayoutManagerAssert hasPaddingBottom ( int padding ) { isNotNull ( ) ; int actualPadding = actual . getPaddingBottom ( ) ; assertThat ( actualPadding ) . overridingErrorMessage ( "Expected padding bottom <%s> but was <%s>." , padding , actualPadding ) . isEqualTo ( padding ) ; return this ; }
public RecyclerViewLayoutManagerAssert hasPaddingStart ( int padding ) { isNotNull ( ) ; int actualPadding = actual . getPaddingStart ( ) ; assertThat ( actualPadding ) . overridingErrorMessage ( "Expected padding start <%s> but was <%s>." , padding , actualPadding ) . isEqualTo ( padding ) ; return this ; }
public RecyclerViewLayoutManagerAssert hasPaddingEnd ( int padding ) { isNotNull ( ) ; int actualPadding = actual . getPaddingEnd ( ) ; assertThat ( actualPadding ) . overridingErrorMessage ( "Expected padding end <%s> but was <%s>." , padding , actualPadding ) . isEqualTo ( padding ) ; return this ; }
public RecyclerViewLayoutManagerAssert isFocused ( ) { isNotNull ( ) ; assertThat ( actual . isFocused ( ) ) . overridingErrorMessage ( "Expected to be focused but was not." ) . isTrue ( ) ; return this ; }
public RecyclerViewLayoutManagerAssert isNotFocused ( ) { isNotNull ( ) ; assertThat ( actual . isFocused ( ) ) . overridingErrorMessage ( "Expected to not be focused but was." ) . isFalse ( ) ; return this ; }
public RecyclerViewLayoutManagerAssert hasFocus ( ) { isNotNull ( ) ; assertThat ( actual . hasFocus ( ) ) . overridingErrorMessage ( "Expected to have focus but did not." ) . isTrue ( ) ; return this ; }
public RecyclerViewLayoutManagerAssert doesNotHaveFocus ( ) { isNotNull ( ) ; assertThat ( actual . hasFocus ( ) ) . overridingErrorMessage ( "Expected to not have focus but did." ) . isFalse ( ) ; return this ; }
public RecyclerViewLayoutManagerAssert hasItemCount ( int count ) { isNotNull ( ) ; int actualCount = actual . getItemCount ( ) ; assertThat ( actualCount ) . overridingErrorMessage ( "Expected item count <%s> but was <%s>." , count , actualCount ) . isEqualTo ( count ) ; return this ; }
public RecyclerViewLayoutManagerAssert hasMinimumWidth ( int width ) { isNotNull ( ) ; int actualWidth = actual . getMinimumWidth ( ) ; assertThat ( actualWidth ) . overridingErrorMessage ( "Expected minimum width <%s> but was <%s>." , width , actualWidth ) . isEqualTo ( width ) ; return this ; }
public RecyclerViewLayoutManagerAssert hasMinimumHeight ( int height ) { isNotNull ( ) ; int actualHeight = actual . getMinimumWidth ( ) ; assertThat ( actualHeight ) . overridingErrorMessage ( "Expected minimum height <%s> but was <%s>." , height , actualHeight ) . isEqualTo ( height ) ; return this ; }
@ Override public void execute ( ) MojoExecutionException , MojoFailureException { ConfigHandler configHandler = new ConfigHandler ( this , this . session , this . execution ) ; configHandler . parseConfiguration ( ) ; if ( isEnableIntegrationTest ( ) ) { playTests ( ) ; } }
protected boolean isEnableIntegrationTest ( ) { return ! parsedSkip && ! mavenTestSkip && ! mavenSkipTests ; }
protected boolean isIgnoreTestFailures ( ) { return mavenIgnoreTestFailure || mavenTestFailureIgnore ; }
protected void playTests ( ) MojoExecutionException , MojoFailureException { getLog ( ) . debug ( "Parsed values for Android UI UIAutomator invocation: " ) ; getLog ( ) . debug ( "jarFile:" + parsedJarFile ) ; String testClassOrMethodString = buildSpaceSeparatedString ( parsedTestClassOrMethods ) ; getLog ( ) . debug ( "testClassOrMethod:" + testClassOrMethodString ) ; getLog ( ) . debug ( "createReport:" + parsedCreateReport ) ; DeviceCallback instrumentationTestExecutor = new DeviceCallback ( ) { @ Override public void doWithDevice ( final IDevice device ) throws MojoExecutionException , MojoFailureException { String deviceLogLinePrefix = DeviceHelper . getDeviceLogLinePrefix ( device ) ; UIAutomatorRemoteAndroidTestRunner automatorRemoteAndroidTestRunner = new UIAutomatorRemoteAndroidTestRunner ( parsedJarFile , device ) ; automatorRemoteAndroidTestRunner . setRunName ( "ui uiautomator tests" ) ; automatorRemoteAndroidTestRunner . setDebug ( uiautomatorDebug ) ; automatorRemoteAndroidTestRunner . setTestClassOrMethods ( parsedTestClassOrMethods ) ; automatorRemoteAndroidTestRunner . setNoHup ( parsedNoHup ) ; automatorRemoteAndroidTestRunner . setUserProperties ( session . getUserProperties ( ) , parsedPropertiesKeyPrefix ) ; if ( parsedUseDump ) { automatorRemoteAndroidTestRunner . setDumpFilePath ( parsedDumpFilePath ) ; } getLog ( ) . info ( deviceLogLinePrefix + "Running ui uiautomator tests in" + parsedJarFile ) ; try { AndroidTestRunListener testRunListener = new AndroidTestRunListener ( device , getLog ( ) , parsedCreateReport , parsedTakeScreenshotOnFailure , parsedScreenshotsPathOnDevice , parsedReportSuffix , targetDirectory ) ; automatorRemoteAndroidTestRunner . run ( testRunListener ) ; if ( testRunListener . hasFailuresOrErrors ( ) && ! isIgnoreTestFailures ( ) ) { throw new MojoFailureException ( deviceLogLinePrefix + "Tests failed on device." ) ; } if ( testRunListener . testRunFailed ( ) ) { throw new MojoFailureException ( deviceLogLinePrefix + "Test run failed to complete: " + testRunListener . getTestRunFailureCause ( ) ) ; } if ( testRunListener . threwException ( ) && ! isIgnoreTestFailures ( ) ) { throw new MojoFailureException ( deviceLogLinePrefix + testRunListener . getExceptionMessages ( ) ) ; } } catch ( TimeoutException e ) { throw new MojoExecutionException ( deviceLogLinePrefix + "timeout" , e ) ; } catch ( AdbCommandRejectedException e ) { throw new MojoExecutionException ( deviceLogLinePrefix + "adb command rejected" , e ) ; } catch ( ShellCommandUnresponsiveException e ) { throw new MojoExecutionException ( deviceLogLinePrefix + "shell command " + "unresponsive" , e ) ; } catch ( IOException e ) { throw new MojoExecutionException ( deviceLogLinePrefix + "IO problem" , e ) ; } } } ; instrumentationTestExecutor = new ScreenshotServiceWrapper ( instrumentationTestExecutor , project , getLog ( ) ) ; doWithDevices ( instrumentationTestExecutor ) ; }
@ Override public void doWithDevice ( final IDevice device ) throws MojoExecutionException , MojoFailureException { String deviceLogLinePrefix = DeviceHelper . getDeviceLogLinePrefix ( device ) ; UIAutomatorRemoteAndroidTestRunner automatorRemoteAndroidTestRunner = new UIAutomatorRemoteAndroidTestRunner ( parsedJarFile , device ) ; automatorRemoteAndroidTestRunner . setRunName ( "ui uiautomator tests" ) ; automatorRemoteAndroidTestRunner . setDebug ( uiautomatorDebug ) ; automatorRemoteAndroidTestRunner . setTestClassOrMethods ( parsedTestClassOrMethods ) ; automatorRemoteAndroidTestRunner . setNoHup ( parsedNoHup ) ; automatorRemoteAndroidTestRunner . setUserProperties ( session . getUserProperties ( ) , parsedPropertiesKeyPrefix ) ; if ( parsedUseDump ) { automatorRemoteAndroidTestRunner . setDumpFilePath ( parsedDumpFilePath ) ; } getLog ( ) . info ( deviceLogLinePrefix + "Running ui uiautomator tests in" + parsedJarFile ) ; try { AndroidTestRunListener testRunListener = new AndroidTestRunListener ( device , getLog ( ) , parsedCreateReport , parsedTakeScreenshotOnFailure , parsedScreenshotsPathOnDevice , parsedReportSuffix , targetDirectory ) ; automatorRemoteAndroidTestRunner . run ( testRunListener ) ; if ( testRunListener . hasFailuresOrErrors ( ) && ! isIgnoreTestFailures ( ) ) { throw new MojoFailureException ( deviceLogLinePrefix + "Tests failed on device." ) ; } if ( testRunListener . testRunFailed ( ) ) { throw new MojoFailureException ( deviceLogLinePrefix + "Test run failed to complete: " + testRunListener . getTestRunFailureCause ( ) ) ; } if ( testRunListener . threwException ( ) && ! isIgnoreTestFailures ( ) ) { throw new MojoFailureException ( deviceLogLinePrefix + testRunListener . getExceptionMessages ( ) ) ; } } catch ( TimeoutException e ) { throw new MojoExecutionException ( deviceLogLinePrefix + "timeout" , e ) ; } catch ( AdbCommandRejectedException e ) { throw new MojoExecutionException ( deviceLogLinePrefix + "adb command rejected" , e ) ; } catch ( ShellCommandUnresponsiveException e ) { throw new MojoExecutionException ( deviceLogLinePrefix + "shell command " + "unresponsive" , e ) ; } catch ( IOException e ) { throw new MojoExecutionException ( deviceLogLinePrefix + "IO problem" , e ) ; } }
private String getJarFile ( ) { if ( parsedJarFile == null ) { File jarFilePath = new File ( targetDirectory + File . separator + finalName + ".jar" ) ; return jarFilePath . getName ( ) ; } return parsedJarFile ; }
private String [] getTestClassOrMethods ( ) { return parsedTestClassOrMethods ; }
private String getReportSuffix ( ) { return parsedReportSuffix ; }
private String getPropertiesKeyPrefix ( ) { return parsedPropertiesKeyPrefix ; }
protected static String buildSpaceSeparatedString ( String [] lines ) { if ( lines == null || lines . length == 0 ) { return null ; } return StringUtils . join ( lines , " " ) ; }
public static String join ( List < String > parts ) { StringBuilder builder = new StringBuilder ( ) ; for ( String part : parts ) { if ( builder . length ( ) > 0 ) { builder . append ( "," ) ; } builder . append ( part ) ; } return builder . toString ( ) ; }
private Utils ( ) { }
@ Override public void execute ( ) MojoExecutionException , MojoFailureException { ConfigHandler configHandler = new ConfigHandler ( this , this . session , this . execution ) ; configHandler . parseConfiguration ( ) ; if ( isEnableIntegrationTest ( ) ) { exerciseApp ( ) ; } }
protected boolean isEnableIntegrationTest ( ) { return ! parsedSkip && ! mavenTestSkip && ! mavenSkipTests ; }
protected boolean isIgnoreTestFailures ( ) { return mavenIgnoreTestFailure || mavenTestFailureIgnore ; }
protected void exerciseApp ( ) MojoExecutionException , MojoFailureException { getLog ( ) . debug ( "Parsed values for Android Monkey invocation: " ) ; getLog ( ) . debug ( "seed:" + parsedSeed ) ; DeviceCallback instrumentationTestExecutor = new DeviceCallback ( ) { @ Override public void doWithDevice ( final IDevice device ) throws MojoExecutionException , MojoFailureException { String deviceLogLinePrefix = DeviceHelper . getDeviceLogLinePrefix ( device ) ; MonkeyTestRunner monkeyTestRunner = new MonkeyTestRunner ( parsedEventCount , device ) ; monkeyTestRunner . setRunName ( "ui monkey tests" ) ; if ( parsedSeed != null ) { monkeyTestRunner . setSeed ( parsedSeed ) ; } if ( parsedPercentTouch != null ) { monkeyTestRunner . setPercentTouch ( parsedPercentTouch ) ; } if ( parsedPercentMotion != null ) { monkeyTestRunner . setPercentTouch ( parsedPercentMotion ) ; } if ( parsedPercentTrackball != null ) { monkeyTestRunner . setPercentTrackball ( parsedPercentTrackball ) ; } if ( parsedPercentNav != null ) { monkeyTestRunner . setPercentNav ( parsedPercentNav ) ; } if ( parsedPercentMajorNav != null ) { monkeyTestRunner . setPercentMajorNav ( parsedPercentMajorNav ) ; } if ( parsedPercentSyskeys != null ) { monkeyTestRunner . setPercentSyskeys ( parsedPercentSyskeys ) ; } if ( parsedPercentAppswitch != null ) { monkeyTestRunner . setPercentAppswitch ( parsedPercentAppswitch ) ; } if ( parsedPercentAnyevent != null ) { monkeyTestRunner . setPercentAnyEvent ( parsedPercentAnyevent ) ; } if ( parsedPackages != null ) { monkeyTestRunner . setPackages ( parsedPackages ) ; } if ( parsedCategories != null ) { monkeyTestRunner . setCategories ( parsedCategories ) ; } monkeyTestRunner . setDebugNoEvents ( parsedDebugNoEvents ) ; monkeyTestRunner . setHprof ( parsedHprof ) ; monkeyTestRunner . setIgnoreCrashes ( parsedIgnoreCrashes ) ; monkeyTestRunner . setIgnoreTimeouts ( parsedIgnoreTimeouts ) ; monkeyTestRunner . setIgnoreSecurityExceptions ( parsedIgnoreSecurityExceptions ) ; monkeyTestRunner . setKillProcessAfterError ( parsedKillProcessAfterError ) ; monkeyTestRunner . setMonitorNativeCrash ( parsedMonitorNativeCrashes ) ; getLog ( ) . info ( deviceLogLinePrefix + "Running ui monkey tests" ) ; try { AndroidTestRunListener testRunListener = new AndroidTestRunListener ( device , getLog ( ) , parsedCreateReport , false , "" , "" , targetDirectory ) ; monkeyTestRunner . run ( testRunListener ) ; if ( testRunListener . hasFailuresOrErrors ( ) && ! isIgnoreTestFailures ( ) ) { throw new MojoFailureException ( deviceLogLinePrefix + "Tests failed on device." ) ; } if ( testRunListener . testRunFailed ( ) ) { throw new MojoFailureException ( deviceLogLinePrefix + "Test run failed to complete: " + testRunListener . getTestRunFailureCause ( ) ) ; } if ( testRunListener . threwException ( ) && ! isIgnoreTestFailures ( ) ) { throw new MojoFailureException ( deviceLogLinePrefix + testRunListener . getExceptionMessages ( ) ) ; } } catch ( TimeoutException e ) { throw new MojoExecutionException ( deviceLogLinePrefix + "timeout" , e ) ; } catch ( AdbCommandRejectedException e ) { throw new MojoExecutionException ( deviceLogLinePrefix + "adb command rejected" , e ) ; } catch ( ShellCommandUnresponsiveException e ) { throw new MojoExecutionException ( deviceLogLinePrefix + "shell command " + "unresponsive" , e ) ; } catch ( IOException e ) { throw new MojoExecutionException ( deviceLogLinePrefix + "IO problem" , e ) ; } } } ; doWithDevices ( instrumentationTestExecutor ) ; }
@ Override public void doWithDevice ( final IDevice device ) throws MojoExecutionException , MojoFailureException { String deviceLogLinePrefix = DeviceHelper . getDeviceLogLinePrefix ( device ) ; MonkeyTestRunner monkeyTestRunner = new MonkeyTestRunner ( parsedEventCount , device ) ; monkeyTestRunner . setRunName ( "ui monkey tests" ) ; if ( parsedSeed != null ) { monkeyTestRunner . setSeed ( parsedSeed ) ; } if ( parsedPercentTouch != null ) { monkeyTestRunner . setPercentTouch ( parsedPercentTouch ) ; } if ( parsedPercentMotion != null ) { monkeyTestRunner . setPercentTouch ( parsedPercentMotion ) ; } if ( parsedPercentTrackball != null ) { monkeyTestRunner . setPercentTrackball ( parsedPercentTrackball ) ; } if ( parsedPercentNav != null ) { monkeyTestRunner . setPercentNav ( parsedPercentNav ) ; } if ( parsedPercentMajorNav != null ) { monkeyTestRunner . setPercentMajorNav ( parsedPercentMajorNav ) ; } if ( parsedPercentSyskeys != null ) { monkeyTestRunner . setPercentSyskeys ( parsedPercentSyskeys ) ; } if ( parsedPercentAppswitch != null ) { monkeyTestRunner . setPercentAppswitch ( parsedPercentAppswitch ) ; } if ( parsedPercentAnyevent != null ) { monkeyTestRunner . setPercentAnyEvent ( parsedPercentAnyevent ) ; } if ( parsedPackages != null ) { monkeyTestRunner . setPackages ( parsedPackages ) ; } if ( parsedCategories != null ) { monkeyTestRunner . setCategories ( parsedCategories ) ; } monkeyTestRunner . setDebugNoEvents ( parsedDebugNoEvents ) ; monkeyTestRunner . setHprof ( parsedHprof ) ; monkeyTestRunner . setIgnoreCrashes ( parsedIgnoreCrashes ) ; monkeyTestRunner . setIgnoreTimeouts ( parsedIgnoreTimeouts ) ; monkeyTestRunner . setIgnoreSecurityExceptions ( parsedIgnoreSecurityExceptions ) ; monkeyTestRunner . setKillProcessAfterError ( parsedKillProcessAfterError ) ; monkeyTestRunner . setMonitorNativeCrash ( parsedMonitorNativeCrashes ) ; getLog ( ) . info ( deviceLogLinePrefix + "Running ui monkey tests" ) ; try { AndroidTestRunListener testRunListener = new AndroidTestRunListener ( device , getLog ( ) , parsedCreateReport , false , "" , "" , targetDirectory ) ; monkeyTestRunner . run ( testRunListener ) ; if ( testRunListener . hasFailuresOrErrors ( ) && ! isIgnoreTestFailures ( ) ) { throw new MojoFailureException ( deviceLogLinePrefix + "Tests failed on device." ) ; } if ( testRunListener . testRunFailed ( ) ) { throw new MojoFailureException ( deviceLogLinePrefix + "Test run failed to complete: " + testRunListener . getTestRunFailureCause ( ) ) ; } if ( testRunListener . threwException ( ) && ! isIgnoreTestFailures ( ) ) { throw new MojoFailureException ( deviceLogLinePrefix + testRunListener . getExceptionMessages ( ) ) ; } } catch ( TimeoutException e ) { throw new MojoExecutionException ( deviceLogLinePrefix + "timeout" , e ) ; } catch ( AdbCommandRejectedException e ) { throw new MojoExecutionException ( deviceLogLinePrefix + "adb command rejected" , e ) ; } catch ( ShellCommandUnresponsiveException e ) { throw new MojoExecutionException ( deviceLogLinePrefix + "shell command " + "unresponsive" , e ) ; } catch ( IOException e ) { throw new MojoExecutionException ( deviceLogLinePrefix + "IO problem" , e ) ; } }
private Long getSeed ( ) { return parsedSeed ; }
private Long getThrottle ( ) { return parsedThrottle ; }
private Integer getPercentTouch ( ) { return parsedPercentTouch ; }
private Integer getPercentMotion ( ) { return parsedPercentMotion ; }
private Integer getPercentTrackball ( ) { return parsedPercentTrackball ; }
private Integer getPercentNav ( ) { return parsedPercentNav ; }
private Integer getPercentMajorNav ( ) { return parsedPercentMajorNav ; }
private Integer getPercentSyskeys ( ) { return parsedPercentSyskeys ; }
private Integer getPercentAppswitch ( ) { return parsedPercentAppswitch ; }
private Integer getPercentAnyevent ( ) { return parsedPercentAnyevent ; }
public String [] getPackages ( ) { return parsedPackages ; }
public String [] getCategories ( ) { return parsedCategories ; }
public AndroidSdk ( File sdkPath , String apiLevel ) { this( sdkPath , apiLevel , null ); }
public AndroidSdk ( File sdkPath , String apiLevel , @ Nullable String buildToolsVersion ) { this . sdkPath = sdkPath ; this . buildToolsVersion = buildToolsVersion ; this . progressIndicator = new ProgressIndicatorImpl ( ) ; if ( sdkPath != null ) { sdkManager = AndroidSdkHandler . getInstance ( sdkPath ) ; platformToolsPath = new File ( sdkPath , SdkConstants . FD_PLATFORM_TOOLS ) ; toolsPath = new File ( sdkPath , SdkConstants . FD_TOOLS ) ; if ( sdkManager == null ) { throw invalidSdkException ( sdkPath , apiLevel ) ; } } loadSDKToolsMajorVersion ( ) ; if ( apiLevel == null ) { apiLevel = DEFAULT_ANDROID_API_LEVEL ; } androidTarget = findPlatformByApiLevel ( apiLevel ) ; if ( androidTarget == null ) { throw invalidSdkException ( sdkPath , apiLevel ) ; } }
private InvalidSdkException invalidSdkException ( File sdkPath , String platformOrApiLevel ) { throw new InvalidSdkException ( "Invalid SDK: Platform/API level " + platformOrApiLevel + " not available. This command should give you all you need:\n" + sdkPath . getAbsolutePath ( ) + File . separator + "tools" + File . separator + "android update sdk --no-ui --obsolete --force" ) ; }
private IAndroidTarget findPlatformByApiLevel ( String apiLevel ) { AndroidVersion version = null ; try { version = new AndroidVersion ( apiLevel ) ; String hashString = AndroidTargetHash . getPlatformHashString ( version ) ; IAndroidTarget target = sdkManager . getAndroidTargetManager ( progressIndicator ) . getTargetFromHashString ( hashString , progressIndicator ) ; if ( target != null && target . getLocation ( ) != null ) { return target ; } } catch ( AndroidVersion . AndroidVersionException ignore ) { throw new InvalidSdkException ( "Error AndroidVersion: " + ignore . getMessage ( ) ) ; } for ( IAndroidTarget t : sdkManager . getAndroidTargetManager ( null ) . getTargets ( null ) ) { if ( t . isPlatform ( ) && t . getVersionName ( ) . equals ( apiLevel ) ) { return t ; } } return null ; }
private void assertPathIsDirectory ( final File path ) { if ( path == null ) { throw new InvalidSdkException ( PARAMETER_MESSAGE ) ; } if ( ! path . isDirectory ( ) ) { throw new InvalidSdkException ( "Path \"" + path + "\" is not a directory. " + PARAMETER_MESSAGE ) ; } }
public String getAaptPath ( ) { return getPathForBuildTool ( BuildToolInfo . PathId . AAPT ) ; }
public String getAidlPath ( ) { return getPathForBuildTool ( BuildToolInfo . PathId . AIDL ) ; }
public String getDxJarPath ( ) { return getPathForBuildTool ( BuildToolInfo . PathId . DX_JAR ) ; }
public String getAdbPath ( ) { return getPathForPlatformTool ( SdkConstants . FN_ADB ) ; }
public String getZipalignPath ( ) { return getPathForBuildTool ( BuildToolInfo . PathId . ZIP_ALIGN ) ; }
public String getLintPath ( ) { return getPathForTool ( "lint" + ext ( ".bat" , "" ) ) ; }
public String getMonkeyRunnerPath ( ) { return getPathForTool ( "monkeyrunner" + ext ( ".bat" , "" ) ) ; }
public String getApkBuilderPath ( ) { return getPathForTool ( "apkbuilder" + ext ( ".bat" , "" ) ) ; }
public String getAndroidPath ( ) { String cmd = "android" ; String ext = SdkConstants . currentPlatform ( ) == 2 ? ".bat" : "" ; return getPathForTool ( cmd + ext ) ; }
public File getToolsPath ( ) { return toolsPath ; }
private String getPathForBuildTool ( BuildToolInfo . PathId pathId ) { return getBuildToolInfo ( ) . getPath ( pathId ) ; }
private BuildToolInfo getBuildToolInfo ( ) { if ( buildToolsVersion != null && ! buildToolsVersion . equals ( "" ) ) { BuildToolInfo buildToolInfo = sdkManager . getBuildToolInfo ( Revision . parseRevision ( buildToolsVersion ) , progressIndicator ) ; if ( buildToolInfo != null ) { return buildToolInfo ; } throw new InvalidSdkException ( "Invalid SDK: Build-tools " + buildToolsVersion + " not found." + " Check your Android SDK to install the build tools " + buildToolsVersion ) ; } if ( androidTarget != null ) { BuildToolInfo buildToolInfo = androidTarget . getBuildToolInfo ( ) ; if ( buildToolInfo != null ) { return buildToolInfo ; } } BuildToolInfo latestBuildToolInfo = sdkManager . getLatestBuildTool ( progressIndicator , true ) ; if ( latestBuildToolInfo == null ) { throw new InvalidSdkException ( "Invalid SDK: Build-tools not found. Check the content of '" + sdkPath . getAbsolutePath ( ) + File . separator + "build-tools', or run '" + sdkPath . getAbsolutePath ( ) + File . separator + "tools" + File . separator + "android sdk' to install them" ) ; } return latestBuildToolInfo ; }
private String getPathForPlatformTool ( String tool ) { return new File ( platformToolsPath , tool ) . getAbsolutePath ( ) ; }
private String getPathForTool ( String tool ) { return new File ( toolsPath , tool ) . getAbsolutePath ( ) ; }
private static String ext ( String windowsExtension , String nonWindowsExtension ) { if ( SdkConstants . currentPlatform ( ) == SdkConstants . PLATFORM_WINDOWS ) { return windowsExtension ; } else { return nonWindowsExtension ; } }
public String getPathForFrameworkAidl ( ) { return androidTarget . getPath ( IAndroidTarget . ANDROID_AIDL ) ; }
public File getMainDexClasses ( ) MojoExecutionException { final File location = getBuildToolInfo ( ) . getLocation ( ) ; String mainDexClassesScript = "mainDexClasses" ; if ( Os . isFamily ( Os . FAMILY_WINDOWS ) ) { mainDexClassesScript += ".bat" ; } File mainDexClasses = new File ( location , mainDexClassesScript ) ; if ( ! mainDexClasses . exists ( ) ) { throw new MojoExecutionException ( "No " + mainDexClassesScript + " found in " + location ) ; } return mainDexClasses ; }
public File getAndroidJar ( ) MojoExecutionException { final String androidJarPath = androidTarget . getPath ( IAndroidTarget . ANDROID_JAR ) ; if ( androidJarPath == null ) { throw new MojoExecutionException ( "No AndroidJar found for " + androidTarget . getLocation ( ) ) ; } return new File ( androidJarPath ) ; }
public File getSdkPath ( ) MojoExecutionException { if ( sdkPath . exists ( ) ) { return sdkPath ; } throw new MojoExecutionException ( "Can't find the SDK directory : " + sdkPath . getAbsolutePath ( ) ) ; }
public File getPlatform ( ) { assertPathIsDirectory ( sdkPath ) ; final File platformsDirectory = new File ( sdkPath , PLATFORMS_FOLDER_NAME ) ; assertPathIsDirectory ( platformsDirectory ) ; final File platformDirectory ; if ( androidTarget == null ) { IAndroidTarget latestTarget = null ; AndroidTargetManager targetManager = sdkManager . getAndroidTargetManager ( progressIndicator ) ; for ( IAndroidTarget target : targetManager . getTargets ( progressIndicator ) ) { if ( target . isPlatform ( ) ) { if ( latestTarget == null || target . getVersion ( ) . getApiLevel ( ) > latestTarget . getVersion ( ) . getApiLevel ( ) ) { latestTarget = target ; } } } platformDirectory = new File ( latestTarget . getLocation ( ) ) ; } else { platformDirectory = new File ( androidTarget . getLocation ( ) ) ; } assertPathIsDirectory ( platformDirectory ) ; return platformDirectory ; }
private void loadSDKToolsMajorVersion ( ) { File propFile = new File ( sdkPath , "tools/" + SOURCE_PROPERTIES_FILENAME ) ; Properties properties = new Properties ( ) ; try { properties . load ( new FileInputStream ( propFile ) ) ; } catch ( IOException e ) { throw new InvalidSdkException ( "Error reading " + propFile . getAbsoluteFile ( ) ) ; } if ( properties . containsKey ( SDK_TOOLS_REVISION_PROPERTY ) ) { try { String versionString = properties . getProperty ( SDK_TOOLS_REVISION_PROPERTY ) ; String majorVersion ; if ( versionString . matches ( ".*[\\.| ].*" ) ) { String [] versions = versionString . split ( "[\\.| ]" ) ; majorVersion = versions [ 0 ] ; } else { majorVersion = versionString ; } sdkMajorVersion = Integer . parseInt ( majorVersion ) ; } catch ( NumberFormatException e ) { throw new InvalidSdkException ( "Error - The property '" + SDK_TOOLS_REVISION_PROPERTY + "' in the SDK source.properties file  number is not an Integer: " + properties . getProperty ( SDK_TOOLS_REVISION_PROPERTY ) ) ; } } }
public int getSdkMajorVersion ( ) { return sdkMajorVersion ; }
@ Override public void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; UIUtils . setupActionBar ( this ) ; Intent myIntent = getIntent ( ) ; if ( Intent . ACTION_CREATE_SHORTCUT . equals ( myIntent . getAction ( ) ) ) { setResult ( RESULT_OK , getShortcutIntent ( ) ) ; } finish ( ) ; }
private Intent getShortcutIntent ( ) { final Uri uri = MyTabActivityBase . getDefaultTabUri ( MyStarredStopsFragment . TAB_NAME ) ; return UIUtils . makeShortcut ( this , getString ( R . string . starred_stops_shortcut ) , new Intent ( this , MyStopsActivity .class ) . setData ( uri ) ) ; }
public TableInfo ( Class < ? > tableClassType ) { this . classType = tableClassType ; this . name = OrmLiteAnnotationAccessor . getAnnotationTableName ( tableClassType ) ; this . defaultContentUriInfo = new ContentUriInfo ( tableClassType ) ; this . defaultContentMimeTypeVndInfo = new ContentMimeTypeVndInfo ( tableClassType ) ; this . columns = new HashMap < String , ColumnInfo > ( ) ; this . projectionMap = new HashMap < String , String > ( ) ; SortedMap < Integer , String > defaultSortOrderMap = new TreeMap < Integer , String > ( ) ; this . idColumnInfo = null ; for ( Field classfield : tableClassType . getDeclaredFields ( ) ) { if ( classfield . isAnnotationPresent ( DatabaseField .class ) ) { classfield . setAccessible ( true ) ; ColumnInfo columnInfo = new ColumnInfo ( classfield ) ; this . columns . put ( columnInfo . getColumnName ( ) , columnInfo ) ; if ( columnInfo . getColumnName ( ) . equals ( BaseColumns . _ID ) ) { boolean generatedId = classfield . getAnnotation ( DatabaseField .class ) . generatedId ( ) ; boolean id = classfield . getAnnotation ( DatabaseField .class ) . id ( ) ; if ( generatedId || id ) { this . idColumnInfo = columnInfo ; } } SortOrderInfo defaultSortOrderInfo = columnInfo . getDefaultSortOrderInfo ( ) ; if ( defaultSortOrderInfo . isValid ( ) ) { defaultSortOrderMap . put ( defaultSortOrderInfo . getWeight ( ) , defaultSortOrderInfo . makeSqlOrderString ( columnInfo . getColumnName ( ) ) ) ; } this . projectionMap . put ( columnInfo . getProjectionColumnName ( ) , columnInfo . getColumnName ( ) ) ; } } if ( this . idColumnInfo == null ) { throw new IllegalArgumentException ( "Proper ID is not defined for field." ) ; } if ( defaultSortOrderMap . size ( ) >= 1 ) { StringBuilder result = new StringBuilder ( ) ; String comma = "" ; for ( Map . Entry < Integer , String > entry : defaultSortOrderMap . entrySet ( ) ) { result . append ( comma ) ; result . append ( entry . getValue ( ) ) ; comma = ", " ; } this . defaultSortOrder = result . toString ( ) ; } else { this . defaultSortOrder = "" ; } }
@ Override public boolean isValid ( ) { return isValid ( false ) ; }
@ Override public boolean isValid ( boolean throwException ) { boolean result = true ; if ( this . classType == null ) { result = false ; if ( throwException && ! result ) { throw new IllegalStateException ( "classType is null." ) ; } } else if ( TextUtils . isEmpty ( name ) ) { result = false ; if ( throwException && ! result ) { throw new IllegalStateException ( "name is zero string." ) ; } } else if ( this . columns . isEmpty ( ) ) { result = false ; if ( throwException && ! result ) { throw new IllegalStateException ( "columns is zero size." ) ; } } else if ( this . columns . size ( ) != this . projectionMap . size ( ) ) { result = false ; if ( throwException && ! result ) { throw new IllegalStateException ( "Number of columns and projectionMap do not match." ) ; } } return result ; }
public Class < ? > getClassType ( ) { return this . classType ; }
public String getName ( ) { return this . name ; }
public ContentUriInfo getDefaultContentUriInfo ( ) { return this . defaultContentUriInfo ; }
public void setDefaultContentUriInfo ( ContentUriInfo defaultContentUriInfo ) { this . defaultContentUriInfo = defaultContentUriInfo ; }
public ContentMimeTypeVndInfo getDefaultContentMimeTypeVndInfo ( ) { return this . defaultContentMimeTypeVndInfo ; }
public void setDefaultContentMimeTypeVndInfo ( ContentMimeTypeVndInfo defaultContentMimeTypeVndInfo ) { this . defaultContentMimeTypeVndInfo = defaultContentMimeTypeVndInfo ; }
public String getDefaultSortOrderString ( ) { return this . defaultSortOrder ; }
public ColumnInfo getIdColumnInfo ( ) { return this . idColumnInfo ; }
public Map < String , String > getProjectionMap ( ) { return this . projectionMap ; }
boolean onQueryTextSubmit ( String query );
boolean onQueryTextChange ( String newText );
public SearchView ( Context context ) { this( context , null ); }
public SearchView ( Context context , AttributeSet attrs ) { super( context , attrs ); LayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; inflater . inflate ( R . layout . search_box , this , true ) ; mSearchButton = findViewById ( R . id . search_button ) ; mQueryTextView = ( EditText ) findViewById ( R . id . search_text ) ; mSearchButton . setOnClickListener ( mOnClickListener ) ; mQueryTextView . setOnClickListener ( mOnClickListener ) ; mQueryTextView . addTextChangedListener ( mTextWatcher ) ; mQueryTextView . setOnEditorActionListener ( mOnEditorActionListener ) ; mQueryTextView . setOnFocusChangeListener ( new OnFocusChangeListener ( ) { public void onFocusChange ( View v , boolean hasFocus ) { if ( mOnQueryTextFocusChangeListener != null ) { mOnQueryTextFocusChangeListener . onFocusChange ( SearchView .this , hasFocus ) ; } } } ) ; }
public void onFocusChange ( View v , boolean hasFocus ) { if ( mOnQueryTextFocusChangeListener != null ) { mOnQueryTextFocusChangeListener . onFocusChange ( SearchView .this , hasFocus ) ; } }
public void setOnQueryTextListener ( OnQueryTextListener listener ) { mOnQueryChangeListener = listener ; }
public void setOnQueryTextFocusChangeListener ( OnFocusChangeListener listener ) { mOnQueryTextFocusChangeListener = listener ; }
public CharSequence getQuery ( ) { return mQueryTextView . getText ( ) ; }
public void setQuery ( CharSequence query , boolean submit ) { mQueryTextView . setText ( query ) ; if ( query != null ) { mQueryTextView . setSelection ( query . length ( ) ) ; } if ( submit && ! TextUtils . isEmpty ( query ) ) { onSubmitQuery ( ) ; } }
public void setQueryHint ( CharSequence hint ) { mQueryHint = hint ; updateQueryHint ( ) ; }
public void beforeTextChanged ( CharSequence s , int start , int before , int after ) {        }
public void onTextChanged ( CharSequence s , int start , int before , int after ) { SearchView .this . onTextChanged ( s ) ; }
public void afterTextChanged ( Editable s ) {        }
public boolean onEditorAction ( TextView v , int actionId , KeyEvent event ) { onSubmitQuery ( ) ; return true ; }
private void onTextChanged ( CharSequence newText ) { if ( mOnQueryChangeListener != null && ! TextUtils . equals ( newText , mOldQueryText ) ) { mOnQueryChangeListener . onQueryTextChange ( newText . toString ( ) ) ; } mOldQueryText = newText . toString ( ) ; }
private void onSubmitQuery ( ) { CharSequence query = mQueryTextView . getText ( ) ; if ( query != null && TextUtils . getTrimmedLength ( query ) > 0 ) { if ( mOnQueryChangeListener == null || ! mOnQueryChangeListener . onQueryTextSubmit ( query . toString ( ) ) ) { } } }
public void onClick ( View v ) { }
private CharSequence getDecoratedHint ( CharSequence hintText ) { return hintText ; }
private void updateQueryHint ( ) { if ( mQueryHint != null ) { mQueryTextView . setHint ( getDecoratedHint ( mQueryHint ) ) ; } else { mQueryTextView . setHint ( getDecoratedHint ( "" ) ) ; } }
@ Override protected void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; setContentView ( R . layout . main_activity ) ; findViewById ( R . id . button_run_scheduler ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { onRunSchedulerExampleButtonClicked ( ) ; } } ) ; }
@ Override public void onClick ( View v ) { onRunSchedulerExampleButtonClicked ( ) ; }
@ Override protected void onDestroy ( ) { super. onDestroy ( ) ; disposables . clear ( ) ; }
void onRunSchedulerExampleButtonClicked ( ) { disposables . add ( sampleObservable ( ) . subscribeOn ( Schedulers . io ( ) ) . observeOn ( AndroidSchedulers . mainThread ( ) ) . subscribeWith ( new DisposableObserver < String > ( ) { @ Override public void onComplete ( ) { Log . d ( TAG , "onComplete()" ) ; } @ Override public void onError ( Throwable e ) { Log . e ( TAG , "onError()" , e ) ; } @ Override public void onNext ( String string ) { Log . d ( TAG , "onNext(" + string + ")" ) ; } } ) ) ; }
@ Override public void onComplete ( ) { Log . d ( TAG , "onComplete()" ) ; }
@ Override public void onError ( Throwable e ) { Log . e ( TAG , "onError()" , e ) ; }
@ Override public void onNext ( String string ) { Log . d ( TAG , "onNext(" + string + ")" ) ; }
static Observable < String > sampleObservable ( ) { return Observable . defer ( new Callable < ObservableSource < ? extends String > > ( ) { @ Override public ObservableSource < ? extends String > call ( ) Exception { SystemClock . sleep ( 5000 ) ; return Observable . just ( "one" , "two" , "three" , "four" , "five" ) ; } } ) ; }
@ Override public ObservableSource < ? extends String > call ( ) Exception { SystemClock . sleep ( 5000 ) ; return Observable . just ( "one" , "two" , "three" , "four" , "five" ) ; }
void onFocusChanged ( ObaStop stop , HashMap < String , ObaRoute > routes , Location location );
public StopOverlay ( Activity activity , GoogleMap map ) { mActivity = activity ; mMap = map ; loadIcons ( ) ; mMap . setOnMarkerClickListener ( this ) ; mMap . setOnMapClickListener ( this ) ; }
public void setOnFocusChangeListener ( OnFocusChangedListener onFocusChangedListener ) { mOnFocusChangedListener = onFocusChangedListener ; }
public synchronized void populateStops ( List < ObaStop > stops , ObaReferences refs ) { populate ( stops , refs . getRoutes ( ) ) ; }
public synchronized void populateStops ( List < ObaStop > stops , List < ObaRoute > routes ) { populate ( stops , routes ) ; }
private void populate ( List < ObaStop > stops , List < ObaRoute > routes ) { setupMarkerData ( ) ; mMarkerData . populate ( stops , routes ) ; }
public synchronized int size ( ) { if ( mMarkerData != null ) { return mMarkerData . size ( ) ; } else { return 0 ; } }
public synchronized void clear ( boolean clearFocusedStop ) { if ( mMarkerData != null ) { mMarkerData . clear ( clearFocusedStop ) ; } }
private static final void loadIcons ( ) { Resources r = Application . get ( ) . getResources ( ) ; mPx = r . getDimensionPixelSize ( R . dimen . map_stop_shadow_size_6 ) ; mArrowWidthPx = mPx / 2f ; mArrowHeightPx = mPx / 3f ; float arrowSpacingReductionPx = mPx / 10f ; mBuffer = mArrowHeightPx - arrowSpacingReductionPx ; mPercentOffset = ( mBuffer / ( mPx + mBuffer ) ) * 0.5f ; mArrowPaintStroke = new Paint ( ) ; mArrowPaintStroke . setColor ( Color . WHITE ) ; mArrowPaintStroke . setStyle ( Paint . Style . STROKE ) ; mArrowPaintStroke . setStrokeWidth ( 1.0f ) ; mArrowPaintStroke . setAntiAlias ( true ) ; bus_stop_icons [ 0 ] = createBusStopIcon ( NORTH ) ; bus_stop_icons [ 1 ] = createBusStopIcon ( NORTH_WEST ) ; bus_stop_icons [ 2 ] = createBusStopIcon ( WEST ) ; bus_stop_icons [ 3 ] = createBusStopIcon ( SOUTH_WEST ) ; bus_stop_icons [ 4 ] = createBusStopIcon ( SOUTH ) ; bus_stop_icons [ 5 ] = createBusStopIcon ( SOUTH_EAST ) ; bus_stop_icons [ 6 ] = createBusStopIcon ( EAST ) ; bus_stop_icons [ 7 ] = createBusStopIcon ( NORTH_EAST ) ; bus_stop_icons [ 8 ] = createBusStopIcon ( NO_DIRECTION ) ; }
private static Bitmap createBusStopIcon ( String direction ) throws NullPointerException { if ( direction == null ) { throw new IllegalArgumentException ( direction ) ; } Resources r = Application . get ( ) . getResources ( ) ; Context context = Application . get ( ) ; Float directionAngle = null ; Bitmap bm ; Canvas c ; Drawable shape ; Float rotationX = null , rotationY = null ; Paint arrowPaintFill = new Paint ( ) ; arrowPaintFill . setStyle ( Paint . Style . FILL ) ; arrowPaintFill . setAntiAlias ( true ) ; if ( direction . equals ( NO_DIRECTION ) ) { bm = Bitmap . createBitmap ( mPx , mPx , Bitmap . Config . ARGB_8888 ) ; c = new Canvas ( bm ) ; shape = ContextCompat . getDrawable ( context , R . drawable . map_stop_icon ) ; shape . setBounds ( 0 , 0 , bm . getWidth ( ) , bm . getHeight ( ) ) ; } else if ( direction . equals ( NORTH ) ) { directionAngle = 0f ; bm = Bitmap . createBitmap ( mPx , ( int ) ( mPx + mBuffer ) , Bitmap . Config . ARGB_8888 ) ; c = new Canvas ( bm ) ; shape = ContextCompat . getDrawable ( context , R . drawable . map_stop_icon ) ; shape . setBounds ( 0 , ( int ) mBuffer , mPx , bm . getHeight ( ) ) ; arrowPaintFill . setShader ( new LinearGradient ( bm . getWidth ( ) / 2 , 0 , bm . getWidth ( ) / 2 , mArrowHeightPx , r . getColor ( R . color . theme_primary ) , r . getColor ( R . color . theme_accent ) , Shader . TileMode . MIRROR ) ) ; rotationX = bm . getWidth ( ) / 2f ; rotationY = bm . getHeight ( ) / 2f ; } else if ( direction . equals ( NORTH_WEST ) ) { directionAngle = 315f ; bm = Bitmap . createBitmap ( ( int ) ( mPx + mBuffer ) , ( int ) ( mPx + mBuffer ) , Bitmap . Config . ARGB_8888 ) ; c = new Canvas ( bm ) ; shape = ContextCompat . getDrawable ( context , R . drawable . map_stop_icon ) ; shape . setBounds ( ( int ) mBuffer , ( int ) mBuffer , bm . getWidth ( ) , bm . getHeight ( ) ) ; arrowPaintFill . setShader ( new LinearGradient ( 0 , 0 , mBuffer , mBuffer , r . getColor ( R . color . theme_primary ) , r . getColor ( R . color . theme_accent ) , Shader . TileMode . MIRROR ) ) ; rotationX = mPx / 2f + mBuffer / 2f ; rotationY = bm . getHeight ( ) / 2f - mBuffer / 2f ; } else if ( direction . equals ( WEST ) ) { directionAngle = 0f ; bm = Bitmap . createBitmap ( ( int ) ( mPx + mBuffer ) , mPx , Bitmap . Config . ARGB_8888 ) ; c = new Canvas ( bm ) ; shape = ContextCompat . getDrawable ( context , R . drawable . map_stop_icon ) ; shape . setBounds ( ( int ) mBuffer , 0 , bm . getWidth ( ) , bm . getHeight ( ) ) ; arrowPaintFill . setShader ( new LinearGradient ( 0 , bm . getHeight ( ) / 2 , mArrowHeightPx , bm . getHeight ( ) / 2 , r . getColor ( R . color . theme_primary ) , r . getColor ( R . color . theme_accent ) , Shader . TileMode . MIRROR ) ) ; rotationX = bm . getHeight ( ) / 2f ; rotationY = bm . getHeight ( ) / 2f ; } else if ( direction . equals ( SOUTH_WEST ) ) { directionAngle = 225f ; bm = Bitmap . createBitmap ( ( int ) ( mPx + mBuffer ) , ( int ) ( mPx + mBuffer ) , Bitmap . Config . ARGB_8888 ) ; c = new Canvas ( bm ) ; shape = ContextCompat . getDrawable ( context , R . drawable . map_stop_icon ) ; shape . setBounds ( ( int ) mBuffer , 0 , bm . getWidth ( ) , mPx ) ; arrowPaintFill . setShader ( new LinearGradient ( 0 , bm . getHeight ( ) , mBuffer , bm . getHeight ( ) - mBuffer , r . getColor ( R . color . theme_primary ) , r . getColor ( R . color . theme_accent ) , Shader . TileMode . MIRROR ) ) ; rotationX = bm . getWidth ( ) / 2f - mBuffer / 4f ; rotationY = mPx / 2f + mBuffer / 4f ; } else if ( direction . equals ( SOUTH ) ) { directionAngle = 180f ; bm = Bitmap . createBitmap ( mPx , ( int ) ( mPx + mBuffer ) , Bitmap . Config . ARGB_8888 ) ; c = new Canvas ( bm ) ; shape = ContextCompat . getDrawable ( context , R . drawable . map_stop_icon ) ; shape . setBounds ( 0 , 0 , bm . getWidth ( ) , ( int ) ( bm . getHeight ( ) - mBuffer ) ) ; arrowPaintFill . setShader ( new LinearGradient ( bm . getWidth ( ) / 2 , bm . getHeight ( ) , bm . getWidth ( ) / 2 , bm . getHeight ( ) - mArrowHeightPx , r . getColor ( R . color . theme_primary ) , r . getColor ( R . color . theme_accent ) , Shader . TileMode . MIRROR ) ) ; rotationX = bm . getWidth ( ) / 2f ; rotationY = bm . getHeight ( ) / 2f ; } else if ( direction . equals ( SOUTH_EAST ) ) { directionAngle = 135f ; bm = Bitmap . createBitmap ( ( int ) ( mPx + mBuffer ) , ( int ) ( mPx + mBuffer ) , Bitmap . Config . ARGB_8888 ) ; c = new Canvas ( bm ) ; shape = ContextCompat . getDrawable ( context , R . drawable . map_stop_icon ) ; shape . setBounds ( 0 , 0 , mPx , mPx ) ; arrowPaintFill . setShader ( new LinearGradient ( bm . getWidth ( ) , bm . getHeight ( ) , bm . getWidth ( ) - mBuffer , bm . getHeight ( ) - mBuffer , r . getColor ( R . color . theme_primary ) , r . getColor ( R . color . theme_accent ) , Shader . TileMode . MIRROR ) ) ; rotationX = ( mPx + mBuffer / 2 ) / 2f ; rotationY = bm . getHeight ( ) / 2f ; } else if ( direction . equals ( EAST ) ) { directionAngle = 180f ; bm = Bitmap . createBitmap ( ( int ) ( mPx + mBuffer ) , mPx , Bitmap . Config . ARGB_8888 ) ; c = new Canvas ( bm ) ; shape = ContextCompat . getDrawable ( context , R . drawable . map_stop_icon ) ; shape . setBounds ( 0 , 0 , mPx , bm . getHeight ( ) ) ; arrowPaintFill . setShader ( new LinearGradient ( bm . getWidth ( ) , bm . getHeight ( ) / 2 , bm . getWidth ( ) - mArrowHeightPx , bm . getHeight ( ) / 2 , r . getColor ( R . color . theme_primary ) , r . getColor ( R . color . theme_accent ) , Shader . TileMode . MIRROR ) ) ; rotationX = bm . getWidth ( ) / 2f ; rotationY = bm . getHeight ( ) / 2f ; } else if ( direction . equals ( NORTH_EAST ) ) { directionAngle = 45f ; bm = Bitmap . createBitmap ( ( int ) ( mPx + mBuffer ) , ( int ) ( mPx + mBuffer ) , Bitmap . Config . ARGB_8888 ) ; c = new Canvas ( bm ) ; shape = ContextCompat . getDrawable ( context , R . drawable . map_stop_icon ) ; shape . setBounds ( 0 , ( int ) mBuffer , mPx , bm . getHeight ( ) ) ; arrowPaintFill . setShader ( new LinearGradient ( bm . getWidth ( ) , 0 , bm . getWidth ( ) - mBuffer , mBuffer , r . getColor ( R . color . theme_primary ) , r . getColor ( R . color . theme_accent ) , Shader . TileMode . MIRROR ) ) ; rotationX = ( float ) mPx / 2 ; rotationY = bm . getHeight ( ) - ( float ) mPx / 2 ; } else { throw new IllegalArgumentException ( direction ) ; } shape . draw ( c ) ; if ( direction . equals ( NO_DIRECTION ) ) { return bm ; } final float CUTOUT_HEIGHT = mPx / 12 ; Path path = new Path ( ) ; float x1 = 0 , y1 = 0 ; float x2 = 0 , y2 = 0 ; float x3 = 0 , y3 = 0 ; float x4 = 0 , y4 = 0 ; if ( direction . equals ( NORTH ) || direction . equals ( SOUTH ) || direction . equals ( NORTH_EAST ) || direction . equals ( SOUTH_EAST ) || direction . equals ( NORTH_WEST ) || direction . equals ( SOUTH_WEST ) ) { x1 = mPx / 2 ; y1 = 0 ; x2 = ( mPx / 2 ) - ( mArrowWidthPx / 2 ) ; y2 = mArrowHeightPx ; x3 = mPx / 2 ; y3 = mArrowHeightPx - CUTOUT_HEIGHT ; x4 = ( mPx / 2 ) + ( mArrowWidthPx / 2 ) ; y4 = mArrowHeightPx ; } else if ( direction . equals ( EAST ) || direction . equals ( WEST ) ) { x1 = 0 ; y1 = mPx / 2 ; x2 = mArrowHeightPx ; y2 = ( mPx / 2 ) - ( mArrowWidthPx / 2 ) ; x3 = mArrowHeightPx - CUTOUT_HEIGHT ; y3 = mPx / 2 ; x4 = mArrowHeightPx ; y4 = ( mPx / 2 ) + ( mArrowWidthPx / 2 ) ; } path . setFillType ( Path . FillType . EVEN_ODD ) ; path . moveTo ( x1 , y1 ) ; path . lineTo ( x2 , y2 ) ; path . lineTo ( x3 , y3 ) ; path . lineTo ( x4 , y4 ) ; path . lineTo ( x1 , y1 ) ; path . close ( ) ; Matrix matrix = new Matrix ( ) ; matrix . postRotate ( directionAngle , rotationX , rotationY ) ; path . transform ( matrix ) ; c . drawPath ( path , arrowPaintFill ) ; c . drawPath ( path , mArrowPaintStroke ) ; return bm ; }
private static float getXPercentOffsetForDirection ( String direction ) { if ( direction . equals ( NORTH ) ) { return 0.5f ; } else if ( direction . equals ( NORTH_WEST ) ) { return 0.5f + mPercentOffset ; } else if ( direction . equals ( WEST ) ) { return 0.5f + mPercentOffset ; } else if ( direction . equals ( SOUTH_WEST ) ) { return 0.5f + mPercentOffset ; } else if ( direction . equals ( SOUTH ) ) { return 0.5f ; } else if ( direction . equals ( SOUTH_EAST ) ) { return 0.5f - mPercentOffset ; } else if ( direction . equals ( EAST ) ) { return 0.5f - mPercentOffset ; } else if ( direction . equals ( NORTH_EAST ) ) { return 0.5f - mPercentOffset ; } else if ( direction . equals ( NO_DIRECTION ) ) { return 0.5f ; } else { return 0.5f ; } }
private static float getYPercentOffsetForDirection ( String direction ) { if ( direction . equals ( NORTH ) ) { return 0.5f + mPercentOffset ; } else if ( direction . equals ( NORTH_WEST ) ) { return 0.5f + mPercentOffset ; } else if ( direction . equals ( WEST ) ) { return 0.5f ; } else if ( direction . equals ( SOUTH_WEST ) ) { return 0.5f - mPercentOffset ; } else if ( direction . equals ( SOUTH ) ) { return 0.5f - mPercentOffset ; } else if ( direction . equals ( SOUTH_EAST ) ) { return 0.5f - mPercentOffset ; } else if ( direction . equals ( EAST ) ) { return 0.5f ; } else if ( direction . equals ( NORTH_EAST ) ) { return 0.5f + mPercentOffset ; } else if ( direction . equals ( NO_DIRECTION ) ) { return 0.5f ; } else { return 0.5f ; } }
private static BitmapDescriptor getBitmapDescriptorForBusStopDirection ( String direction ) { if ( direction . equals ( NORTH ) ) { return BitmapDescriptorFactory . fromBitmap ( bus_stop_icons [ 0 ] ) ; } else if ( direction . equals ( NORTH_WEST ) ) { return BitmapDescriptorFactory . fromBitmap ( bus_stop_icons [ 1 ] ) ; } else if ( direction . equals ( WEST ) ) { return BitmapDescriptorFactory . fromBitmap ( bus_stop_icons [ 2 ] ) ; } else if ( direction . equals ( SOUTH_WEST ) ) { return BitmapDescriptorFactory . fromBitmap ( bus_stop_icons [ 3 ] ) ; } else if ( direction . equals ( SOUTH ) ) { return BitmapDescriptorFactory . fromBitmap ( bus_stop_icons [ 4 ] ) ; } else if ( direction . equals ( SOUTH_EAST ) ) { return BitmapDescriptorFactory . fromBitmap ( bus_stop_icons [ 5 ] ) ; } else if ( direction . equals ( EAST ) ) { return BitmapDescriptorFactory . fromBitmap ( bus_stop_icons [ 6 ] ) ; } else if ( direction . equals ( NORTH_EAST ) ) { return BitmapDescriptorFactory . fromBitmap ( bus_stop_icons [ 7 ] ) ; } else if ( direction . equals ( NO_DIRECTION ) ) { return BitmapDescriptorFactory . fromBitmap ( bus_stop_icons [ 8 ] ) ; } else { return BitmapDescriptorFactory . fromBitmap ( bus_stop_icons [ 8 ] ) ; } }
public ObaStop getFocus ( ) { if ( mMarkerData != null ) { return mMarkerData . getFocus ( ) ; } return null ; }
public void setFocus ( ObaStop stop , List < ObaRoute > routes ) { setupMarkerData ( ) ; if ( stop == null ) { removeFocus ( null ) ; return; } if ( ! mMarkerData . containsStop ( stop ) ) { ArrayList < ObaStop > l = new ArrayList < ObaStop > ( ) ; l . add ( stop ) ; populateStops ( l , routes ) ; } doFocusChange ( stop ) ; }
@ Override public boolean onMarkerClick ( Marker marker ) { long startTime = Long . MAX_VALUE , endTime = Long . MAX_VALUE ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . JELLY_BEAN_MR1 ) { startTime = SystemClock . elapsedRealtimeNanos ( ) ; } ObaStop stop = mMarkerData . getStopFromMarker ( marker ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . JELLY_BEAN_MR1 ) { endTime = SystemClock . elapsedRealtimeNanos ( ) ; Log . d ( TAG , "Stop HashMap read time: " + TimeUnit . MILLISECONDS . convert ( endTime - startTime , TimeUnit . NANOSECONDS ) + "ms" ) ; } if ( stop == null ) { return false ; } if ( BuildConfig . DEBUG ) { Toast . makeText ( mActivity , stop . getId ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } doFocusChange ( stop ) ; Location stopLocation = stop . getLocation ( ) ; Location myLocation = Application . getLastKnownLocation ( mActivity , null ) ; ObaAnalytics . trackBusStopDistance ( stop . getId ( ) , myLocation , stopLocation ) ; return true ; }
private void doFocusChange ( ObaStop stop ) { mMarkerData . setFocus ( stop ) ; HashMap < String , ObaRoute > routes = mMarkerData . getCachedRoutes ( ) ; mOnFocusChangedListener . onFocusChanged ( stop , routes , stop . getLocation ( ) ) ; }
@ Override public void onMapClick ( LatLng latLng ) { Log . d ( TAG , "Map clicked" ) ; removeFocus ( latLng ) ; }
private void removeFocus ( LatLng latLng ) { if ( mMarkerData . getFocus ( ) != null ) { mMarkerData . removeFocus ( ) ; } Location location = null ; if ( latLng != null ) { location = MapHelpV2 . makeLocation ( latLng ) ; } mOnFocusChangedListener . onFocusChanged ( null , null , location ) ; }
private void setupMarkerData ( ) { if ( mMarkerData == null ) { mMarkerData = new MarkerData ( ) ; } }
MarkerData ( ) { mStopMarkers = new HashMap < String , Marker > ( ) ; mStops = new HashMap < Marker , ObaStop > ( ) ; mStopRoutes = new HashMap < String , ObaRoute > ( ) ; mFocusedRoutes = new LinkedList < ObaRoute > ( ) ; }
synchronized void populate ( List < ObaStop > stops , List < ObaRoute > routes ) { int count = 0 ; if ( mStopMarkers . size ( ) >= FUZZY_MAX_MARKER_COUNT ) { Log . d ( TAG , "Exceed max marker cache of " + FUZZY_MAX_MARKER_COUNT + ", clearing cache" ) ; removeMarkersFromMap ( ) ; mStopMarkers . clear ( ) ; mStops . clear ( ) ; if ( mCurrentFocusStop != null && mFocusedRoutes != null ) { addMarkerToMap ( mCurrentFocusStop , mFocusedRoutes ) ; count ++ ; } } for ( ObaStop stop : stops ) { if ( ! mStopMarkers . containsKey ( stop . getId ( ) ) ) { addMarkerToMap ( stop , routes ) ; count ++ ; } } Log . d ( TAG , "Added " + count + " markers, total markers = " + mStopMarkers . size ( ) ) ; }
private void addMarkerToMap ( ObaStop stop , List < ObaRoute > routes ) { Marker m = mMap . addMarker ( new MarkerOptions ( ) . position ( MapHelpV2 . makeLatLng ( stop . getLocation ( ) ) ) . icon ( getBitmapDescriptorForBusStopDirection ( stop . getDirection ( ) ) ) . flat ( true ) . anchor ( getXPercentOffsetForDirection ( stop . getDirection ( ) ) , getYPercentOffsetForDirection ( stop . getDirection ( ) ) ) ) ; mStopMarkers . put ( stop . getId ( ) , m ) ; mStops . put ( m , stop ) ; for ( ObaRoute route : routes ) { if ( ! mStopRoutes . containsKey ( route . getId ( ) ) ) { mStopRoutes . put ( route . getId ( ) , route ) ; } } }
synchronized ObaStop getStopFromMarker ( Marker marker ) { return mStops . get ( marker ) ; }
synchronized boolean containsStop ( ObaStop stop ) { if ( stop != null ) { return containsStop ( stop . getId ( ) ) ; } else { return false ; } }
synchronized boolean containsStop ( String stopId ) { if ( mStopMarkers != null ) { return mStopMarkers . containsKey ( stopId ) ; } else { return false ; } }
synchronized HashMap < String , ObaRoute > getCachedRoutes ( ) { return new HashMap < String , ObaRoute > ( mStopRoutes ) ; }
void setFocus ( ObaStop stop ) { if ( mCurrentFocusMarker != null ) { mCurrentFocusMarker . remove ( ) ; } mCurrentFocusStop = stop ; mFocusedRoutes . clear ( ) ; String [] routeIds = stop . getRouteIds ( ) ; for ( int i = 0 ; i < routeIds . length ; i ++ ) { ObaRoute route = mStopRoutes . get ( routeIds [ i ] ) ; if ( route != null ) { mFocusedRoutes . add ( route ) ; } } LatLng latLng = new LatLng ( stop . getLatitude ( ) - 0.000001 , stop . getLongitude ( ) ) ; mCurrentFocusMarker = mMap . addMarker ( new MarkerOptions ( ) . position ( latLng ) ) ; }
private void animateMarker ( final Marker marker ) { final Handler handler = new Handler ( ) ; final long startTime = SystemClock . uptimeMillis ( ) ; final long duration = 300 ; Projection proj = mMap . getProjection ( ) ; final LatLng markerLatLng = marker . getPosition ( ) ; Point startPoint = proj . toScreenLocation ( markerLatLng ) ; startPoint . offset ( 0 , - 10 ) ; final LatLng startLatLng = proj . fromScreenLocation ( startPoint ) ; final Interpolator interpolator = new BounceInterpolator ( ) ; handler . post ( new Runnable ( ) { @ Override public void run ( ) { long elapsed = SystemClock . uptimeMillis ( ) - startTime ; float t = interpolator . getInterpolation ( ( float ) elapsed / duration ) ; double lng = t * markerLatLng . longitude + ( 1 - t ) * startLatLng . longitude ; double lat = t * markerLatLng . latitude + ( 1 - t ) * startLatLng . latitude ; marker . setPosition ( new LatLng ( lat , lng ) ) ; if ( t < 1.0 ) { handler . postDelayed ( this , 16 ) ; } } } ) ; }
@ Override public void run ( ) { long elapsed = SystemClock . uptimeMillis ( ) - startTime ; float t = interpolator . getInterpolation ( ( float ) elapsed / duration ) ; double lng = t * markerLatLng . longitude + ( 1 - t ) * startLatLng . longitude ; double lat = t * markerLatLng . latitude + ( 1 - t ) * startLatLng . latitude ; marker . setPosition ( new LatLng ( lat , lng ) ) ; if ( t < 1.0 ) { handler . postDelayed ( this , 16 ) ; } }
ObaStop getFocus ( ) { return mCurrentFocusStop ; }
void removeFocus ( ) { if ( mCurrentFocusMarker != null ) { mCurrentFocusMarker . remove ( ) ; mCurrentFocusMarker = null ; } mFocusedRoutes . clear ( ) ; mCurrentFocusStop = null ; }
private void removeMarkersFromMap ( ) { for ( Map . Entry < String , Marker > entry : mStopMarkers . entrySet ( ) ) { entry . getValue ( ) . remove ( ) ; } }
synchronized void clear ( boolean clearFocusedStop ) { if ( mStopMarkers != null ) { removeMarkersFromMap ( ) ; mStopMarkers . clear ( ) ; } if ( mStops != null ) { mStops . clear ( ) ; } if ( mStopRoutes != null ) { mStopRoutes . clear ( ) ; } if ( clearFocusedStop ) { removeFocus ( ) ; } else { if ( mCurrentFocusStop != null && mFocusedRoutes != null ) { addMarkerToMap ( mCurrentFocusStop , mFocusedRoutes ) ; } } }
synchronized int size ( ) { return mStopMarkers . size ( ) ; }
@ Override protected void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; App . component ( ) . inject ( this ) ; if ( getIntent ( ) . getData ( ) == null || getIntent ( ) . getData ( ) . getScheme ( ) == null ) { tracker . trackException ( "invalid_import_uri" , false ) ; finish ( ) ; } else { new ImportAndShowAsyncTask ( this , getIntent ( ) . getData ( ) ) . execute ( ) ; } }
private AccountContract ( ) { }
@ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View view = inflater . inflate ( R . layout . fragment_scrollview , container , false ) ; final ObservableScrollView scrollView = ( ObservableScrollView ) view . findViewById ( R . id . scroll ) ; Activity parentActivity = getActivity ( ) ; if ( parentActivity instanceof ObservableScrollViewCallbacks ) { Bundle args = getArguments ( ) ; if ( args != null && args . containsKey ( ARG_SCROLL_Y ) ) { final int scrollY = args . getInt ( ARG_SCROLL_Y , 0 ) ; ScrollUtils . addOnGlobalLayoutListener ( scrollView , new Runnable ( ) { @ Override public void run ( ) { scrollView . scrollTo ( 0 , scrollY ) ; } } ) ; } scrollView . setTouchInterceptionViewGroup ( ( ViewGroup ) parentActivity . findViewById ( R . id . root ) ) ; scrollView . setScrollViewCallbacks ( ( ObservableScrollViewCallbacks ) parentActivity ) ; } return view ; }
@ Override public void run ( ) { scrollView . scrollTo ( 0 , scrollY ) ; }
public WrapperListAdapterImpl ( ListAdapter wrapped ) { this . wrapped = wrapped ; }
@ Override public ListAdapter getWrappedAdapter ( ) { return wrapped ; }
@ Override public boolean areAllItemsEnabled ( ) { return wrapped . areAllItemsEnabled ( ) ; }
@ Override public boolean isEnabled ( int i ) { return wrapped . isEnabled ( i ) ; }
@ Override public void registerDataSetObserver ( DataSetObserver dataSetObserver ) { wrapped . registerDataSetObserver ( dataSetObserver ) ; }
@ Override public void unregisterDataSetObserver ( DataSetObserver dataSetObserver ) { wrapped . unregisterDataSetObserver ( dataSetObserver ) ; }
@ Override public int getCount ( ) { return wrapped . getCount ( ) ; }
@ Override public Object getItem ( int i ) { return wrapped . getItem ( i ) ; }
@ Override public long getItemId ( int i ) { return wrapped . getItemId ( i ) ; }
@ Override public boolean hasStableIds ( ) { return wrapped . hasStableIds ( ) ; }
@ Override public View getView ( int position , View view , ViewGroup viewGroup ) { return wrapped . getView ( position , view , viewGroup ) ; }
@ Override public int getItemViewType ( int i ) { return wrapped . getItemViewType ( i ) ; }
@ Override public int getViewTypeCount ( ) { return wrapped . getViewTypeCount ( ) ; }
@ Override public boolean isEmpty ( ) { return wrapped . isEmpty ( ) ; }
public AarActionbarsherlockExampleSampleIT ( MavenRuntimeBuilder builder ) throws Exception { this . mavenRuntime = builder . build ( ) ; }
@ Test public void buildDeployAndRun ( ) Exception { File basedir = resources . getBasedir ( "aar-actionbarsherlock-example" ) ; MavenExecutionResult result = mavenRuntime . forProject ( basedir ) . execute ( "clean" , PluginInfo . getQualifiedGoal ( "undeploy" ) , "install" , PluginInfo . getQualifiedGoal ( "deploy" ) , PluginInfo . getQualifiedGoal ( "run" ) ) ; result . assertErrorFreeLog ( ) ; }
@ Override public void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; final UserPreference callingActivity = ( UserPreference ) getActivity ( ) ; final SharedPreferences sharedPreferences = getPreferenceManager ( ) . getSharedPreferences ( ) ; addPreferencesFromResource ( R . xml . preference ) ; findPreference ( "openpgp_key_id_pref" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( Preference preference ) { Intent intent = new Intent ( callingActivity , PgpHandler .class ) ; intent . putExtra ( "Operation" , "GET_KEY_ID" ) ; startActivityForResult ( intent , IMPORT_PGP_KEY ) ; return true ; } } ) ; findPreference ( "ssh_key" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( Preference preference ) { callingActivity . getSshKeyWithPermissions ( ) ; return true ; } } ) ; findPreference ( "ssh_keygen" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( Preference preference ) { callingActivity . makeSshKey ( true ) ; return true ; } } ) ; findPreference ( "ssh_see_key" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( Preference preference ) { DialogFragment df = new SshKeyGen . ShowSshKeyFragment ( ) ; df . show ( getFragmentManager ( ) , "public_key" ) ; return true ; } } ) ; findPreference ( "git_server_info" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( Preference preference ) { Intent intent = new Intent ( callingActivity , GitActivity .class ) ; intent . putExtra ( "Operation" , GitActivity . EDIT_SERVER ) ; startActivityForResult ( intent , EDIT_GIT_INFO ) ; return true ; } } ) ; findPreference ( "git_delete_repo" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( Preference preference ) { new AlertDialog . Builder ( callingActivity ) . setTitle ( R . string . pref_dialog_delete_title ) . setMessage ( getResources ( ) . getString ( R . string . dialog_delete_msg ) + " \n" + PasswordRepository . getRepositoryDirectory ( callingActivity . getApplicationContext ( ) ) . toString ( ) ) . setCancelable ( false ) . setPositiveButton ( R . string . dialog_delete , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialogInterface , int i ) { try { FileUtils . cleanDirectory ( PasswordRepository . getRepositoryDirectory ( callingActivity . getApplicationContext ( ) ) ) ; PasswordRepository . closeRepository ( ) ; } catch ( Exception e ) { } sharedPreferences . edit ( ) . putBoolean ( "repository_initialized" , false ) . apply ( ) ; dialogInterface . cancel ( ) ; callingActivity . finish ( ) ; } } ) . setNegativeButton ( R . string . dialog_do_not_delete , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialogInterface , int i ) { { dialogInterface . cancel ( ) ; } } } ) . show ( ) ; return true ; } } ) ; final Preference externalRepo = findPreference ( "pref_select_external" ) ; externalRepo . setSummary ( getPreferenceManager ( ) . getSharedPreferences ( ) . getString ( "git_external_repo" , callingActivity . getString ( R . string . no_repo_selected ) ) ) ; externalRepo . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( Preference preference ) { callingActivity . selectExternalGitRepository ( ) ; return true ; } } ) ; Preference . OnPreferenceChangeListener resetRepo = new Preference . OnPreferenceChangeListener ( ) { @ Override public boolean onPreferenceChange ( Preference preference , Object o ) { findPreference ( "git_delete_repo" ) . setEnabled ( ! ( Boolean ) o ) ; PasswordRepository . closeRepository ( ) ; getPreferenceManager ( ) . getSharedPreferences ( ) . edit ( ) . putBoolean ( "repo_changed" , true ) . apply ( ) ; return true ; } } ; findPreference ( "pref_select_external" ) . setOnPreferenceChangeListener ( resetRepo ) ; findPreference ( "git_external" ) . setOnPreferenceChangeListener ( resetRepo ) ; findPreference ( "autofill_apps" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( Preference preference ) { Intent intent = new Intent ( callingActivity , AutofillPreferenceActivity .class ) ; startActivity ( intent ) ; return true ; } } ) ; findPreference ( "autofill_enable" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( Preference preference ) { new AlertDialog . Builder ( callingActivity ) . setTitle ( R . string . pref_autofill_enable_title ) . setView ( R . layout . autofill_instructions ) . setPositiveButton ( R . string . dialog_ok , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { Intent intent = new Intent ( Settings . ACTION_ACCESSIBILITY_SETTINGS ) ; startActivity ( intent ) ; } } ) . setNegativeButton ( R . string . dialog_cancel , null ) . setOnDismissListener ( new DialogInterface . OnDismissListener ( ) { @ Override public void onDismiss ( DialogInterface dialog ) { ( ( CheckBoxPreference ) findPreference ( "autofill_enable" ) ) . setChecked ( ( ( UserPreference ) getActivity ( ) ) . isServiceEnabled ( ) ) ; } } ) . show ( ) ; return true ; } } ) ; findPreference ( "export_passwords" ) . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) { @ Override public boolean onPreferenceClick ( Preference preference ) { callingActivity . exportPasswordsWithPermissions ( ) ; return true ; } } ) ; }
@ Override public boolean onPreferenceClick ( Preference preference ) { Intent intent = new Intent ( callingActivity , PgpHandler .class ) ; intent . putExtra ( "Operation" , "GET_KEY_ID" ) ; startActivityForResult ( intent , IMPORT_PGP_KEY ) ; return true ; }
@ Override public boolean onPreferenceClick ( Preference preference ) { callingActivity . getSshKeyWithPermissions ( ) ; return true ; }
@ Override public boolean onPreferenceClick ( Preference preference ) { callingActivity . makeSshKey ( true ) ; return true ; }
@ Override public boolean onPreferenceClick ( Preference preference ) { DialogFragment df = new SshKeyGen . ShowSshKeyFragment ( ) ; df . show ( getFragmentManager ( ) , "public_key" ) ; return true ; }
@ Override public boolean onPreferenceClick ( Preference preference ) { Intent intent = new Intent ( callingActivity , GitActivity .class ) ; intent . putExtra ( "Operation" , GitActivity . EDIT_SERVER ) ; startActivityForResult ( intent , EDIT_GIT_INFO ) ; return true ; }
@ Override public boolean onPreferenceClick ( Preference preference ) { new AlertDialog . Builder ( callingActivity ) . setTitle ( R . string . pref_dialog_delete_title ) . setMessage ( getResources ( ) . getString ( R . string . dialog_delete_msg ) + " \n" + PasswordRepository . getRepositoryDirectory ( callingActivity . getApplicationContext ( ) ) . toString ( ) ) . setCancelable ( false ) . setPositiveButton ( R . string . dialog_delete , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialogInterface , int i ) { try { FileUtils . cleanDirectory ( PasswordRepository . getRepositoryDirectory ( callingActivity . getApplicationContext ( ) ) ) ; PasswordRepository . closeRepository ( ) ; } catch ( Exception e ) { } sharedPreferences . edit ( ) . putBoolean ( "repository_initialized" , false ) . apply ( ) ; dialogInterface . cancel ( ) ; callingActivity . finish ( ) ; } } ) . setNegativeButton ( R . string . dialog_do_not_delete , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialogInterface , int i ) { { dialogInterface . cancel ( ) ; } } } ) . show ( ) ; return true ; }
@ Override public void onClick ( DialogInterface dialogInterface , int i ) { try { FileUtils . cleanDirectory ( PasswordRepository . getRepositoryDirectory ( callingActivity . getApplicationContext ( ) ) ) ; PasswordRepository . closeRepository ( ) ; } catch ( Exception e ) { } sharedPreferences . edit ( ) . putBoolean ( "repository_initialized" , false ) . apply ( ) ; dialogInterface . cancel ( ) ; callingActivity . finish ( ) ; }
@ Override public void onClick ( DialogInterface dialogInterface , int i ) { { dialogInterface . cancel ( ) ; } }
@ Override public boolean onPreferenceClick ( Preference preference ) { callingActivity . selectExternalGitRepository ( ) ; return true ; }
@ Override public boolean onPreferenceChange ( Preference preference , Object o ) { findPreference ( "git_delete_repo" ) . setEnabled ( ! ( Boolean ) o ) ; PasswordRepository . closeRepository ( ) ; getPreferenceManager ( ) . getSharedPreferences ( ) . edit ( ) . putBoolean ( "repo_changed" , true ) . apply ( ) ; return true ; }
@ Override public boolean onPreferenceClick ( Preference preference ) { Intent intent = new Intent ( callingActivity , AutofillPreferenceActivity .class ) ; startActivity ( intent ) ; return true ; }
@ Override public boolean onPreferenceClick ( Preference preference ) { new AlertDialog . Builder ( callingActivity ) . setTitle ( R . string . pref_autofill_enable_title ) . setView ( R . layout . autofill_instructions ) . setPositiveButton ( R . string . dialog_ok , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { Intent intent = new Intent ( Settings . ACTION_ACCESSIBILITY_SETTINGS ) ; startActivity ( intent ) ; } } ) . setNegativeButton ( R . string . dialog_cancel , null ) . setOnDismissListener ( new DialogInterface . OnDismissListener ( ) { @ Override public void onDismiss ( DialogInterface dialog ) { ( ( CheckBoxPreference ) findPreference ( "autofill_enable" ) ) . setChecked ( ( ( UserPreference ) getActivity ( ) ) . isServiceEnabled ( ) ) ; } } ) . show ( ) ; return true ; }
@ Override public void onClick ( DialogInterface dialog , int which ) { Intent intent = new Intent ( Settings . ACTION_ACCESSIBILITY_SETTINGS ) ; startActivity ( intent ) ; }
@ Override public void onDismiss ( DialogInterface dialog ) { ( ( CheckBoxPreference ) findPreference ( "autofill_enable" ) ) . setChecked ( ( ( UserPreference ) getActivity ( ) ) . isServiceEnabled ( ) ) ; }
@ Override public boolean onPreferenceClick ( Preference preference ) { callingActivity . exportPasswordsWithPermissions ( ) ; return true ; }
@ Override public void onStart ( ) { super. onStart ( ) ; final SharedPreferences sharedPreferences = getPreferenceManager ( ) . getSharedPreferences ( ) ; findPreference ( "pref_select_external" ) . setSummary ( getPreferenceManager ( ) . getSharedPreferences ( ) . getString ( "git_external_repo" , getString ( R . string . no_repo_selected ) ) ) ; findPreference ( "ssh_see_key" ) . setEnabled ( sharedPreferences . getBoolean ( "use_generated_key" , false ) ) ; findPreference ( "git_delete_repo" ) . setEnabled ( ! sharedPreferences . getBoolean ( "git_external" , false ) ) ; Preference keyPref = findPreference ( "openpgp_key_id_pref" ) ; Set < String > selectedKeys = sharedPreferences . getStringSet ( "openpgp_key_ids_set" , new HashSet < String > ( ) ) ; if ( selectedKeys . isEmpty ( ) ) { keyPref . setSummary ( "No key selected" ) ; } else { keyPref . setSummary ( Joiner . on ( ',' ) . join ( Iterables . transform ( selectedKeys , new Function < String , Object > ( ) { @ Override public Object apply ( String input ) { return OpenPgpUtils . convertKeyIdToHex ( Long . valueOf ( input ) ) ; } } ) ) ) ; } ( ( CheckBoxPreference ) findPreference ( "autofill_enable" ) ) . setChecked ( ( ( UserPreference ) getActivity ( ) ) . isServiceEnabled ( ) ) ; }
@ Override public Object apply ( String input ) { return OpenPgpUtils . convertKeyIdToHex ( Long . valueOf ( input ) ) ; }
@ Override public void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; if ( getIntent ( ) != null ) { if ( getIntent ( ) . getStringExtra ( "operation" ) != null ) { switch ( getIntent ( ) . getStringExtra ( "operation" ) ) { case "get_ssh_key" : getSshKeyWithPermissions ( ) ; break; case "make_ssh_key" : makeSshKey ( false ) ; break; case "git_external" : selectExternalGitRepository ( ) ; break; } } } prefsFragment = new PrefsFragment ( ) ; getFragmentManager ( ) . beginTransaction ( ) . replace ( android . R . id . content , prefsFragment ) . commit ( ) ; getSupportActionBar ( ) . setDisplayHomeAsUpEnabled ( true ) ; }
public void selectExternalGitRepository ( ) { final Activity activity = this ; new AlertDialog . Builder ( this ) . setTitle ( "Choose where to store the passwords" ) . setMessage ( "You must select a directory where to store your passwords. If you want " + "to store your passwords within the hidden storage of the application, " + "cancel this dialog and disable the \"External Repository\" option." ) . setPositiveButton ( R . string . dialog_ok , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { Intent i = new Intent ( activity . getApplicationContext ( ) , FilePickerActivity .class ) ; i . putExtra ( FilePickerActivity . EXTRA_ALLOW_MULTIPLE , false ) ; i . putExtra ( FilePickerActivity . EXTRA_ALLOW_CREATE_DIR , true ) ; i . putExtra ( FilePickerActivity . EXTRA_MODE , FilePickerActivity . MODE_DIR ) ; i . putExtra ( FilePickerActivity . EXTRA_START_PATH , Environment . getExternalStorageDirectory ( ) . getPath ( ) ) ; startActivityForResult ( i , SELECT_GIT_DIRECTORY ) ; } } ) . setNegativeButton ( R . string . dialog_cancel , null ) . show ( ) ; }
@ Override public void onClick ( DialogInterface dialog , int which ) { Intent i = new Intent ( activity . getApplicationContext ( ) , FilePickerActivity .class ) ; i . putExtra ( FilePickerActivity . EXTRA_ALLOW_MULTIPLE , false ) ; i . putExtra ( FilePickerActivity . EXTRA_ALLOW_CREATE_DIR , true ) ; i . putExtra ( FilePickerActivity . EXTRA_MODE , FilePickerActivity . MODE_DIR ) ; i . putExtra ( FilePickerActivity . EXTRA_START_PATH , Environment . getExternalStorageDirectory ( ) . getPath ( ) ) ; startActivityForResult ( i , SELECT_GIT_DIRECTORY ) ; }
@ Override public boolean onOptionsItemSelected ( MenuItem item ) { int id = item . getItemId ( ) ; switch ( id ) { case android . R . id . home : setResult ( RESULT_OK ) ; finish ( ) ; return true ; } return super. onOptionsItemSelected ( item ) ; }
public void getSshKeyWithPermissions ( ) { final Activity activity = this ; if ( ContextCompat . checkSelfPermission ( activity , Manifest . permission . READ_EXTERNAL_STORAGE ) != PackageManager . PERMISSION_GRANTED ) { if ( ActivityCompat . shouldShowRequestPermissionRationale ( activity , Manifest . permission . READ_EXTERNAL_STORAGE ) ) { Snackbar snack = Snackbar . make ( prefsFragment . getView ( ) , "We need access to the sd-card to import the ssh-key" , Snackbar . LENGTH_INDEFINITE ) . setAction ( R . string . dialog_ok , new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { ActivityCompat . requestPermissions ( activity , new String [] { Manifest . permission . READ_EXTERNAL_STORAGE } , REQUEST_EXTERNAL_STORAGE ) ; } } ) ; snack . show ( ) ; View view = snack . getView ( ) ; TextView tv = ( TextView ) view . findViewById ( android . support . design . R . id . snackbar_text ) ; tv . setTextColor ( Color . WHITE ) ; tv . setMaxLines ( 10 ) ; } else { ActivityCompat . requestPermissions ( activity , new String [] { Manifest . permission . READ_EXTERNAL_STORAGE } , REQUEST_EXTERNAL_STORAGE ) ; } } else { getSshKey ( ) ; } }
@ Override public void onClick ( View view ) { ActivityCompat . requestPermissions ( activity , new String [] { Manifest . permission . READ_EXTERNAL_STORAGE } , REQUEST_EXTERNAL_STORAGE ) ; }
public void getSshKey ( ) { Intent i = new Intent ( getApplicationContext ( ) , FilePickerActivity .class ) ; i . putExtra ( FilePickerActivity . EXTRA_ALLOW_MULTIPLE , false ) ; i . putExtra ( FilePickerActivity . EXTRA_ALLOW_CREATE_DIR , false ) ; i . putExtra ( FilePickerActivity . EXTRA_MODE , FilePickerActivity . MODE_FILE ) ; i . putExtra ( FilePickerActivity . EXTRA_START_PATH , Environment . getExternalStorageDirectory ( ) . getPath ( ) ) ; startActivityForResult ( i , IMPORT_SSH_KEY ) ; }
public void exportPasswordsWithPermissions ( ) { final Activity activity = this ; if ( ContextCompat . checkSelfPermission ( activity , Manifest . permission . WRITE_EXTERNAL_STORAGE ) != PackageManager . PERMISSION_GRANTED ) { if ( ActivityCompat . shouldShowRequestPermissionRationale ( activity , Manifest . permission . WRITE_EXTERNAL_STORAGE ) ) { Snackbar snack = Snackbar . make ( prefsFragment . getView ( ) , "We need access to the sd-card to export the passwords" , Snackbar . LENGTH_INDEFINITE ) . setAction ( R . string . dialog_ok , new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { ActivityCompat . requestPermissions ( activity , new String [] { Manifest . permission . WRITE_EXTERNAL_STORAGE } , REQUEST_EXTERNAL_STORAGE ) ; } } ) ; snack . show ( ) ; View view = snack . getView ( ) ; TextView tv = ( TextView ) view . findViewById ( android . support . design . R . id . snackbar_text ) ; tv . setTextColor ( Color . WHITE ) ; tv . setMaxLines ( 10 ) ; } else { ActivityCompat . requestPermissions ( activity , new String [] { Manifest . permission . WRITE_EXTERNAL_STORAGE } , REQUEST_EXTERNAL_STORAGE ) ; } } else { Intent i = new Intent ( getApplicationContext ( ) , FilePickerActivity .class ) ; i . putExtra ( FilePickerActivity . EXTRA_ALLOW_MULTIPLE , false ) ; i . putExtra ( FilePickerActivity . EXTRA_ALLOW_CREATE_DIR , true ) ; i . putExtra ( FilePickerActivity . EXTRA_MODE , FilePickerActivity . MODE_DIR ) ; i . putExtra ( FilePickerActivity . EXTRA_START_PATH , Environment . getExternalStorageDirectory ( ) . getPath ( ) ) ; startActivityForResult ( i , EXPORT_PASSWORDS ) ; } }
@ Override public void onClick ( View view ) { ActivityCompat . requestPermissions ( activity , new String [] { Manifest . permission . WRITE_EXTERNAL_STORAGE } , REQUEST_EXTERNAL_STORAGE ) ; }
public void makeSshKey ( boolean fromPreferences ) { Intent intent = new Intent ( getApplicationContext ( ) , SshKeyGen .class ) ; startActivity ( intent ) ; if ( ! fromPreferences ) { setResult ( RESULT_OK ) ; finish ( ) ; } }
private void copySshKey ( Uri uri ) throws IOException { InputStream sshKey = this . getContentResolver ( ) . openInputStream ( uri ) ; byte [] privateKey = IOUtils . toByteArray ( sshKey ) ; FileUtils . writeByteArrayToFile ( new File ( getFilesDir ( ) + "/.ssh_key" ) , privateKey ) ; sshKey . close ( ) ; }
private boolean isServiceEnabled ( ) { AccessibilityManager am = ( AccessibilityManager ) this . getSystemService ( Context . ACCESSIBILITY_SERVICE ) ; List < AccessibilityServiceInfo > runningServices = am . getEnabledAccessibilityServiceList ( AccessibilityServiceInfo . FEEDBACK_GENERIC ) ; for ( AccessibilityServiceInfo service : runningServices ) { if ( "com.zeapo.pwdstore/.autofill.AutofillService" . equals ( service . getId ( ) ) ) { return true ; } } return false ; }
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { if ( resultCode == RESULT_OK ) { switch ( requestCode ) { case IMPORT_SSH_KEY : { try { final Uri uri = data . getData ( ) ; if ( uri == null ) { throw new IOException ( "Unable to open file" ) ; } copySshKey ( uri ) ; Toast . makeText ( this , this . getResources ( ) . getString ( R . string . ssh_key_success_dialog_title ) , Toast . LENGTH_LONG ) . show ( ) ; SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ; SharedPreferences . Editor editor = prefs . edit ( ) ; editor . putBoolean ( "use_generated_key" , false ) ; editor . apply ( ) ; File file = new File ( getFilesDir ( ) + "/.ssh_key.pub" ) ; file . delete ( ) ; setResult ( RESULT_OK ) ; finish ( ) ; } catch ( IOException e ) { new AlertDialog . Builder ( this ) . setTitle ( this . getResources ( ) . getString ( R . string . ssh_key_error_dialog_title ) ) . setMessage ( this . getResources ( ) . getString ( R . string . ssh_key_error_dialog_text ) + e . getMessage ( ) ) . setPositiveButton ( this . getResources ( ) . getString ( R . string . dialog_ok ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialogInterface , int i ) { } } ) . show ( ) ; } } break; case EDIT_GIT_INFO : {                } break; case SELECT_GIT_DIRECTORY : { final Uri uri = data . getData ( ) ; if ( uri . getPath ( ) . equals ( Environment . getExternalStorageDirectory ( ) . getPath ( ) ) ) { new AlertDialog . Builder ( this ) . setTitle ( "SD-Card root selected" ) . setMessage ( "You have selected the root of your sdcard for the store. " + "This is extremely dangerous and you will lose your data " + "as its content will, eventually, be deleted" ) . setPositiveButton ( "Remove everything" , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) . edit ( ) . putString ( "git_external_repo" , uri . getPath ( ) ) . apply ( ) ; } } ) . setNegativeButton ( R . string . dialog_cancel , null ) . show ( ) ; } else { PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) . edit ( ) . putString ( "git_external_repo" , uri . getPath ( ) ) . apply ( ) ; } } break; case EXPORT_PASSWORDS : { final Uri uri = data . getData ( ) ; final File repositoryDirectory = PasswordRepository . getRepositoryDirectory ( getApplicationContext ( ) ) ; SimpleDateFormat fmtOut = new SimpleDateFormat ( "yyyy_MM_dd_HH_mm_ss" , Locale . US ) ; Date date = new Date ( ) ; String password_now = "/password_store_" + fmtOut . format ( date ) ; final File targetDirectory = new File ( uri . getPath ( ) + password_now ) ; if ( repositoryDirectory != null ) { try { FileUtils . copyDirectory ( repositoryDirectory , targetDirectory , true ) ; } catch ( IOException e ) { Log . d ( "PWD_EXPORT" , "Exception happened : " + e . getMessage ( ) ) ; } } } break; default: break; } } }
@ Override public void onClick ( DialogInterface dialogInterface , int i ) { }
@ Override public void onClick ( DialogInterface dialog , int which ) { PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) . edit ( ) . putString ( "git_external_repo" , uri . getPath ( ) ) . apply ( ) ; }
@ Override public void onRequestPermissionsResult ( int requestCode , String permissions [] , int [] grantResults ) { switch ( requestCode ) { case REQUEST_EXTERNAL_STORAGE : { if ( grantResults . length > 0 && grantResults [ 0 ] == PackageManager . PERMISSION_GRANTED ) { getSshKey ( ) ; } } } }
protected ObaShapeRequest ( Uri uri ) { super( uri ); }
public Builder ( Context context , String shapeId ) { super( context , getPathWithId ( "/shape/" , shapeId ) ); }
public ObaShapeRequest build ( ) { return new ObaShapeRequest ( buildUri ( ) ) ; }
public static ObaShapeRequest newRequest ( Context context , String shapeId ) { return new Builder ( context , shapeId ) . build ( ) ; }
@ Override public ObaShapeResponse call ( ) { return call ( ObaShapeResponse .class ) ; }
@ Override public String toString ( ) { return "ObaShapeRequest [mUri=" + mUri + "]" ; }
protected AbstractAccessibilityRecordAssert ( A actual , Class < S > selfType ) { super( actual , selfType ); }
public AbstractAccessibilityRecordAssert hasAddedCount ( int count ) { isNotNull ( ) ; int actualCount = actual . getAddedCount ( ) ; assertThat ( actualCount ) . overridingErrorMessage ( "Expected added count <%s> but was <%s>." , count , actualCount ) . isEqualTo ( count ) ; return this ; }
public AbstractAccessibilityRecordAssert hasBeforeText ( CharSequence text ) { isNotNull ( ) ; CharSequence actualText = actual . getBeforeText ( ) ; assertThat ( actualText ) . overridingErrorMessage ( "Expected before text <%s> but was <%s>." , text , actualText ) . isEqualTo ( text ) ; return this ; }
public AbstractAccessibilityRecordAssert hasClassName ( CharSequence name ) { isNotNull ( ) ; CharSequence actualName = actual . getClassName ( ) ; assertThat ( actualName ) . overridingErrorMessage ( "Expected class name <%s> but was <%s>." , name , actualName ) . isEqualTo ( name ) ; return this ; }
public AbstractAccessibilityRecordAssert hasContentDescription ( CharSequence description ) { isNotNull ( ) ; CharSequence actualDescription = actual . getContentDescription ( ) ; assertThat ( actualDescription ) . overridingErrorMessage ( "Expected content description <%s> but was <%s>." , description , actualDescription ) . isEqualTo ( description ) ; return this ; }
public AbstractAccessibilityRecordAssert hasCurrentItemIndex ( int index ) { isNotNull ( ) ; int actualIndex = actual . getCurrentItemIndex ( ) ; assertThat ( actualIndex ) . overridingErrorMessage ( "Expected current item index <%s> but was <%s>." , index , actualIndex ) . isEqualTo ( index ) ; return this ; }
public AbstractAccessibilityRecordAssert hasFromIndex ( int index ) { isNotNull ( ) ; int actualIndex = actual . getFromIndex ( ) ; assertThat ( actualIndex ) . overridingErrorMessage ( "Expected from index <%s> but was <%s>." , index , actualIndex ) . isEqualTo ( index ) ; return this ; }
public AbstractAccessibilityRecordAssert hasItemCount ( int count ) { isNotNull ( ) ; int actualCount = actual . getItemCount ( ) ; assertThat ( actualCount ) . overridingErrorMessage ( "Expected item count <%s> but was <%s>." , count , actualCount ) . isEqualTo ( count ) ; return this ; }
@ TargetApi ( ICE_CREAM_SANDWICH_MR1 ) public AbstractAccessibilityRecordAssert hasMaximumScrollX ( int scroll ) { isNotNull ( ) ; int actualScroll = actual . getMaxScrollX ( ) ; assertThat ( actualScroll ) . overridingErrorMessage ( "Expected maximum X scroll <%s> but was <%s>." , scroll , actualScroll ) . isEqualTo ( scroll ) ; return this ; }
@ TargetApi ( ICE_CREAM_SANDWICH_MR1 ) public AbstractAccessibilityRecordAssert hasMaximumScrollY ( int scroll ) { isNotNull ( ) ; int actualScroll = actual . getMaxScrollY ( ) ; assertThat ( actualScroll ) . overridingErrorMessage ( "Expected maximum Y scroll <%s> but was <%s>." , scroll , actualScroll ) . isEqualTo ( scroll ) ; return this ; }
public AbstractAccessibilityRecordAssert hasRemovedCount ( int count ) { isNotNull ( ) ; int actualCount = actual . getRemovedCount ( ) ; assertThat ( actualCount ) . overridingErrorMessage ( "Expected remove count <%s> but was <%s>." , count , actualCount ) . isEqualTo ( count ) ; return this ; }
public AbstractAccessibilityRecordAssert hasScrollX ( int scroll ) { isNotNull ( ) ; int actualScroll = actual . getScrollX ( ) ; assertThat ( actualScroll ) . overridingErrorMessage ( "Expected X scroll <%s> but was <%s>." , scroll , actualScroll ) . isEqualTo ( scroll ) ; return this ; }
public AbstractAccessibilityRecordAssert hasScrollY ( int scroll ) { isNotNull ( ) ; int actualScroll = actual . getScrollY ( ) ; assertThat ( actualScroll ) . overridingErrorMessage ( "Expected Y scroll <%s> but was <%s>." , scroll , actualScroll ) . isEqualTo ( scroll ) ; return this ; }
public AbstractAccessibilityRecordAssert hasSource ( AccessibilityNodeInfo info ) { isNotNull ( ) ; AccessibilityNodeInfo actualInfo = actual . getSource ( ) ; assertThat ( actualInfo ) . overridingErrorMessage ( "Expected source <%s> but was <%s>." , info , actualInfo ) . isSameAs ( info ) ; return this ; }
public AbstractAccessibilityRecordAssert hasText ( List < CharSequence > text ) { isNotNull ( ) ; List < CharSequence > actualText = actual . getText ( ) ; assertThat ( actualText ) . overridingErrorMessage ( "Expected text <%s> but was <%s>." , text , actualText ) . isEqualTo ( text ) ; return this ; }
public AbstractAccessibilityRecordAssert hasToIndex ( int index ) { isNotNull ( ) ; int actualIndex = actual . getToIndex ( ) ; assertThat ( actualIndex ) . overridingErrorMessage ( "Expected to index <%s> but was <%s>." , index , actualIndex ) . isEqualTo ( index ) ; return this ; }
public AbstractAccessibilityRecordAssert hasWindowId ( int id ) { isNotNull ( ) ; int actualId = actual . getWindowId ( ) ; assertThat ( actualId ) . overridingErrorMessage ( "Expected window ID <%s> but was <%s>." , id , actualId ) . isEqualTo ( id ) ; return this ; }
public AbstractAccessibilityRecordAssert isChecked ( ) { isNotNull ( ) ; assertThat ( actual . isChecked ( ) ) . overridingErrorMessage ( "Expected to be checked but was not." ) . isTrue ( ) ; return this ; }
public AbstractAccessibilityRecordAssert isNotChecked ( ) { isNotNull ( ) ; assertThat ( actual . isChecked ( ) ) . overridingErrorMessage ( "Expected to not be checked but was." ) . isFalse ( ) ; return this ; }
public AbstractAccessibilityRecordAssert isEnabled ( ) { isNotNull ( ) ; assertThat ( actual . isEnabled ( ) ) . overridingErrorMessage ( "Expected to be enabled but was not." ) . isTrue ( ) ; return this ; }
public AbstractAccessibilityRecordAssert isNotEnabled ( ) { isNotNull ( ) ; assertThat ( actual . isEnabled ( ) ) . overridingErrorMessage ( "Expected to not be enabled but was." ) . isFalse ( ) ; return this ; }
public AbstractAccessibilityRecordAssert isFullScreen ( ) { isNotNull ( ) ; assertThat ( actual . isFullScreen ( ) ) . overridingErrorMessage ( "Expected to be full screen but was not." ) . isTrue ( ) ; return this ; }
public AbstractAccessibilityRecordAssert isNotFullScreen ( ) { isNotNull ( ) ; assertThat ( actual . isFullScreen ( ) ) . overridingErrorMessage ( "Expected to not be full screen but was." ) . isFalse ( ) ; return this ; }
public AbstractAccessibilityRecordAssert isPassword ( ) { isNotNull ( ) ; assertThat ( actual . isPassword ( ) ) . overridingErrorMessage ( "Expected to be password but was not." ) . isTrue ( ) ; return this ; }
public AbstractAccessibilityRecordAssert isNotPassword ( ) { isNotNull ( ) ; assertThat ( actual . isPassword ( ) ) . overridingErrorMessage ( "Expected to not be password but was." ) . isFalse ( ) ; return this ; }
public AbstractAccessibilityRecordAssert isScrollable ( ) { isNotNull ( ) ; assertThat ( actual . isScrollable ( ) ) . overridingErrorMessage ( "Expected to be scrollable but was not." ) . isTrue ( ) ; return this ; }
public AbstractAccessibilityRecordAssert isNotScrollable ( ) { isNotNull ( ) ; assertThat ( actual . isScrollable ( ) ) . overridingErrorMessage ( "Expected to not be scrollable but was." ) . isFalse ( ) ; return this ; }
public String translate ( String key ) { if ( containsKey ( key ) ) { return get ( key ) ; } return key ; }
public void loadFromFile ( final File file ) { final String content = readFileAsStringGuessEncoding ( file ) ; loadFromString ( content ) ; }
@ VisibleForTesting public void loadFromString ( final String inputString ) { if ( inputString == null ) { return; } for ( String pair : inputString . split ( "\";" ) ) { final String [] kv = pair . split ( "\" ?= ?\"" ) ; if ( kv . length == 2 ) { put ( removeLeadingClutter ( kv [ 0 ] ) , kv [ 1 ] ) ; } } }
private static String removeLeadingClutter ( String s ) { if ( s . startsWith ( "\"" ) || s . startsWith ( "\n" ) || s . startsWith ( "\r" ) || s . startsWith ( " " ) ) { return removeLeadingClutter ( s . substring ( 1 ) ) ; } else { return s ; } }
@ Nullable public static String readFileAsStringGuessEncoding ( final @ NonNull File file ) { try { final byte [] fileData = new byte [ ( int ) file . length ( ) ] ; final DataInputStream dataInputStream = new DataInputStream ( new FileInputStream ( file ) ) ; dataInputStream . readFully ( fileData ) ; dataInputStream . close ( ) ; final CharsetMatch match = new CharsetDetector ( ) . setText ( fileData ) . detect ( ) ; if ( match != null ) try { return new String ( fileData , match . getName ( ) ) ; } catch ( UnsupportedEncodingException ignored ) {            } return new String ( fileData ) ; } catch ( Throwable e ) { App . component ( ) . tracker ( ) . trackException ( "problem_reading_translation" , e , false ) ; e . printStackTrace ( ) ; return null ; } }
public AtomicFileAssert ( AtomicFile actual ) { super( actual , AtomicFileAssert .class ); }
public AtomicFileAssert hasBaseFile ( File file ) { isNotNull ( ) ; File actualFile = actual . getBaseFile ( ) ; assertThat ( actualFile ) . overridingErrorMessage ( "Expected base file <%s> but was <%s>." , file , actualFile ) . isEqualTo ( file ) ; return this ; }
public GPUImageContrastFilter ( ) { this( 1.2f ); }
public GPUImageContrastFilter ( float contrast ) { super( NO_FILTER_VERTEX_SHADER , CONTRAST_FRAGMENT_SHADER ); mContrast = contrast ; }
@ Override public void onInit ( ) { super. onInit ( ) ; mContrastLocation = GLES20 . glGetUniformLocation ( getProgram ( ) , "contrast" ) ; }
@ Override public void onInitialized ( ) { super. onInitialized ( ) ; setContrast ( mContrast ) ; }
public void setContrast ( final float contrast ) { mContrast = contrast ; setFloat ( mContrastLocation , mContrast ) ; }
@ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View view = inflater . inflate ( R . layout . fragment_listview , container , false ) ; Activity parentActivity = getActivity ( ) ; final ObservableListView listView = ( ObservableListView ) view . findViewById ( R . id . scroll ) ; setDummyDataWithHeader ( listView , inflater . inflate ( R . layout . padding , listView , false ) ) ; if ( parentActivity instanceof ObservableScrollViewCallbacks ) { Bundle args = getArguments ( ) ; if ( args != null && args . containsKey ( ARG_INITIAL_POSITION ) ) { final int initialPosition = args . getInt ( ARG_INITIAL_POSITION , 0 ) ; ScrollUtils . addOnGlobalLayoutListener ( listView , new Runnable ( ) { @ Override public void run ( ) { listView . setSelection ( initialPosition ) ; } } ) ; } listView . setTouchInterceptionViewGroup ( ( ViewGroup ) parentActivity . findViewById ( R . id . root ) ) ; listView . setScrollViewCallbacks ( ( ObservableScrollViewCallbacks ) parentActivity ) ; } return view ; }
@ Override public void run ( ) { listView . setSelection ( initialPosition ) ; }
public Cube ( GLWorld world , float left , float bottom , float back , float right , float top , float front ) { super( world ); GLVertex leftBottomBack = addVertex ( left , bottom , back ) ; GLVertex rightBottomBack = addVertex ( right , bottom , back ) ; GLVertex leftTopBack = addVertex ( left , top , back ) ; GLVertex rightTopBack = addVertex ( right , top , back ) ; GLVertex leftBottomFront = addVertex ( left , bottom , front ) ; GLVertex rightBottomFront = addVertex ( right , bottom , front ) ; GLVertex leftTopFront = addVertex ( left , top , front ) ; GLVertex rightTopFront = addVertex ( right , top , front ) ; addFace ( new GLFace ( leftBottomBack , leftBottomFront , rightBottomFront , rightBottomBack ) ) ; addFace ( new GLFace ( leftBottomFront , leftTopFront , rightTopFront , rightBottomFront ) ) ; addFace ( new GLFace ( leftBottomBack , leftTopBack , leftTopFront , leftBottomFront ) ) ; addFace ( new GLFace ( rightBottomBack , rightBottomFront , rightTopFront , rightTopBack ) ) ; addFace ( new GLFace ( leftBottomBack , rightBottomBack , rightTopBack , leftTopBack ) ) ; addFace ( new GLFace ( leftTopBack , rightTopBack , rightTopFront , leftTopFront ) ) ; }
private static File getDB ( Context context ) { return ObaProvider . getDatabasePath ( context ) ; }
private static File getBackup ( Context context ) { File backupDir = Environment . getExternalStoragePublicDirectory ( BACKUP_TYPE ) ; return new File ( backupDir , BACKUP_NAME ) ; }
public static String backup ( Context context ) throws IOException { File backupPath = getBackup ( context ) ; FileUtils . copyFile ( getDB ( context ) , backupPath ) ; return backupPath . getAbsolutePath ( ) ; }
public static void restore ( Context context ) throws IOException { File dbPath = getDB ( context ) ; File backupPath = getBackup ( context ) ; ContentProviderClient client = null ; try { client = context . getContentResolver ( ) . acquireContentProviderClient ( ObaContract . AUTHORITY ) ; ObaProvider provider = ( ObaProvider ) client . getLocalContentProvider ( ) ; provider . closeDB ( ) ; FileUtils . copyFile ( backupPath , dbPath ) ; } finally { if ( client != null ) { client . release ( ) ; } } }
public static boolean isRestoreAvailable ( Context context ) { return getBackup ( context ) . exists ( ) ; }
public void onRegionTaskFinished ( boolean currentRegionChanged );
public ObaRegionsTask ( Context context , List < ObaRegionsTask . Callback > callbacks ) { mContext = context ; mCallbacks = callbacks ; mForceReload = false ; mShowProgressDialog = true ; }
public ObaRegionsTask ( Context context , List < ObaRegionsTask . Callback > callbacks , boolean force , boolean showProgressDialog ) { mContext = context ; mCallbacks = callbacks ; mForceReload = force ; mShowProgressDialog = showProgressDialog ; GoogleApiAvailability api = GoogleApiAvailability . getInstance ( ) ; if ( api . isGooglePlayServicesAvailable ( context ) == ConnectionResult . SUCCESS ) { mGoogleApiClient = LocationUtils . getGoogleApiClientWithCallbacks ( context ) ; mGoogleApiClient . connect ( ) ; } }
@ Override protected void onPreExecute ( ) { if ( mShowProgressDialog && UIUtils . canManageDialog ( mContext ) ) { if ( mProgressDialogMessage == null ) { mProgressDialogMessage = mContext . getString ( R . string . region_detecting_server ) ; } mProgressDialog = ProgressDialog . show ( mContext , "" , mProgressDialogMessage , true ) ; mProgressDialog . setIndeterminate ( true ) ; mProgressDialog . setCancelable ( false ) ; mProgressDialog . show ( ) ; } super. onPreExecute ( ) ; }
@ Override protected ArrayList < ObaRegion > doInBackground ( Void ... params ) { return RegionUtils . getRegions ( mContext , mForceReload ) ; }
@ Override protected void onPostExecute ( ArrayList < ObaRegion > results ) { if ( results == null ) { return; } if ( mShowProgressDialog && UIUtils . canManageDialog ( mContext ) && mProgressDialog . isShowing ( ) ) { mProgressDialog . dismiss ( ) ; } SharedPreferences settings = Application . getPrefs ( ) ; if ( settings . getBoolean ( mContext . getString ( R . string . preference_key_auto_select_region ) , true ) ) { Location myLocation = Application . getLastKnownLocation ( mContext , mGoogleApiClient ) ; ObaRegion closestRegion = RegionUtils . getClosestRegion ( results , myLocation , true ) ; if ( Application . get ( ) . getCurrentRegion ( ) == null ) { if ( closestRegion != null ) { Application . get ( ) . setCurrentRegion ( closestRegion ) ; Log . d ( TAG , "Detected closest region '" + closestRegion . getName ( ) + "'" ) ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . APP_SETTINGS . toString ( ) , mContext . getString ( R . string . analytics_action_configured_region_auto ) , mContext . getString ( R . string . analytics_label_region_auto ) + closestRegion . getName ( ) + "; Old Region: null" ) ; doCallback ( true ) ; } else { haveUserChooseRegion ( results ) ; } } else if ( Application . get ( ) . getCurrentRegion ( ) != null && closestRegion != null && ! Application . get ( ) . getCurrentRegion ( ) . equals ( closestRegion ) ) { String oldRegionName = Application . get ( ) . getCurrentRegion ( ) . getName ( ) ; Application . get ( ) . setCurrentRegion ( closestRegion ) ; Log . d ( TAG , "Detected closer region '" + closestRegion . getName ( ) + "', changed to this region." ) ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . APP_SETTINGS . toString ( ) , mContext . getString ( R . string . analytics_action_configured_region_auto ) , mContext . getString ( R . string . analytics_label_region_auto ) + closestRegion . getName ( ) + "; Old Region: " + oldRegionName ) ; doCallback ( true ) ; } else if ( Application . get ( ) . getCurrentRegion ( ) != null && closestRegion != null && Application . get ( ) . getCurrentRegion ( ) . equals ( closestRegion ) ) { Application . get ( ) . setCurrentRegion ( closestRegion , false ) ; doCallback ( false ) ; } else { doCallback ( false ) ; } } else { if ( Application . get ( ) . getCurrentRegion ( ) == null ) { haveUserChooseRegion ( results ) ; } else { doCallback ( false ) ; } } if ( mGoogleApiClient != null ) { mGoogleApiClient . disconnect ( ) ; } super. onPostExecute ( results ) ; }
private void haveUserChooseRegion ( final ArrayList < ObaRegion > result ) { if ( ! UIUtils . canManageDialog ( mContext ) ) { return; } List < String > serverNames = new ArrayList < String > ( ) ; for ( ObaRegion region : result ) { if ( RegionUtils . isRegionUsable ( region ) ) { serverNames . add ( region . getName ( ) ) ; } } Collections . sort ( serverNames ) ; final CharSequence [] items = serverNames . toArray ( new CharSequence [ serverNames . size ( ) ] ) ; AlertDialog . Builder builder = new AlertDialog . Builder ( mContext ) ; builder . setTitle ( mContext . getString ( R . string . region_choose_region ) ) ; builder . setCancelable ( false ) ; builder . setItems ( items , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int item ) { for ( ObaRegion region : result ) { if ( region . getName ( ) . equals ( items [ item ] ) ) { Application . get ( ) . setCurrentRegion ( region ) ; Log . d ( TAG , "User chose region '" + items [ item ] + "'." ) ; doCallback ( true ) ; break; } } } } ) ; AlertDialog alert = builder . create ( ) ; alert . show ( ) ; }
public void onClick ( DialogInterface dialog , int item ) { for ( ObaRegion region : result ) { if ( region . getName ( ) . equals ( items [ item ] ) ) { Application . get ( ) . setCurrentRegion ( region ) ; Log . d ( TAG , "User chose region '" + items [ item ] + "'." ) ; doCallback ( true ) ; break; } } }
private void doCallback ( final boolean currentRegionChanged ) { final Handler mPauseForCallbackHandler = new Handler ( ) ; final Runnable mPauseForCallback = new Runnable ( ) { public void run ( ) { if ( mCallbacks != null ) { for ( Callback callback : mCallbacks ) { if ( callback != null ) { callback . onRegionTaskFinished ( currentRegionChanged ) ; } } } } } ; mPauseForCallbackHandler . postDelayed ( mPauseForCallback , CALLBACK_DELAY ) ; }
public void run ( ) { if ( mCallbacks != null ) { for ( Callback callback : mCallbacks ) { if ( callback != null ) { callback . onRegionTaskFinished ( currentRegionChanged ) ; } } } }
public void setProgressDialogMessage ( String progressDialogMessage ) { mProgressDialogMessage = progressDialogMessage ; }
public ObservableWebView ( final Context context ) { super( context ); }
public ObservableWebView ( final Context context , final AttributeSet attrs ) { super( context , attrs ); }
public ObservableWebView ( final Context context , final AttributeSet attrs , final int defStyle ) { super( context , attrs , defStyle ); }
@ Override protected void onScrollChanged ( final int l , final int t , final int oldl , final int oldt ) { super. onScrollChanged ( l , t , oldl , oldt ) ; if( mOnScrollChangedCallback != null ) mOnScrollChangedCallback . onScroll ( l , t , oldl , oldt ) ; }
public OnScrollChangedCallback getOnScrollChangedCallback ( ) { return mOnScrollChangedCallback ; }
public void setOnScrollChangedCallback ( final OnScrollChangedCallback onScrollChangedCallback ) { mOnScrollChangedCallback = onScrollChangedCallback ; }
public void onScroll ( int l , int t , int oldL , int oldT );
@ Override public void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; Log . i ( TAG , "onCreate" ) ; setContentView ( R . layout . main ) ; button = ( Button ) findViewById ( R . id . button_main ) ; textView = ( TextView ) findViewById ( R . id . textview_hello ) ; button . setOnClickListener ( new ButtonClickListener ( ) ) ; computer = new DummyComputer ( ) ; }
public void setComputer ( Computer computer ) { this . computer = computer ; }
@ Override public void onClick ( View v ) { if ( computer != null ) { textView . setText ( String . valueOf ( computer . getResult ( ) ) ) ; } else { textView . setText ( R . string . text_no_computer ) ; } DateTime dt = new DateTime ( ) ; DateTimeFormatter fmt = DateTimeFormat . forPattern ( "MMMM, yyyy" ) ; String dateString = fmt . print ( dt ) ; Toast . makeText ( HelloAndroidActivity .this , dateString , Toast . LENGTH_LONG ) . show ( ) ; }
public SimpleHeaderRecyclerAdapter ( Context context , ArrayList < String > items , View headerView ) { mInflater = LayoutInflater . from ( context ) ; mItems = items ; mHeaderView = headerView ; }
@ Override public int getItemCount ( ) { if ( mHeaderView == null ) { return mItems . size ( ) ; } else { return mItems . size ( ) + 1 ; } }
@ Override public int getItemViewType ( int position ) { return ( position == 0 ) ? VIEW_TYPE_HEADER : VIEW_TYPE_ITEM ; }
@ Override public RecyclerView . ViewHolder onCreateViewHolder ( ViewGroup parent , int viewType ) { if ( viewType == VIEW_TYPE_HEADER ) { return new HeaderViewHolder ( mHeaderView ) ; } else { return new ItemViewHolder ( mInflater . inflate ( android . R . layout . simple_list_item_1 , parent , false ) ) ; } }
@ Override public void onBindViewHolder ( RecyclerView . ViewHolder viewHolder , int position ) { if ( viewHolder instanceof ItemViewHolder ) { ( ( ItemViewHolder ) viewHolder ) . textView . setText ( mItems . get ( position - 1 ) ) ; } }
public HeaderViewHolder ( View view ) { super( view ); }
public ItemViewHolder ( View view ) { super( view ); textView = ( TextView ) view . findViewById ( android . R . id . text1 ) ; }
@ Override protected void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; final Resources res = getResources ( ) ; final ActionBar bar = getSupportActionBar ( ) ; bar . setNavigationMode ( ActionBar . NAVIGATION_MODE_TABS ) ; bar . setDisplayOptions ( 0 , ActionBar . DISPLAY_SHOW_TITLE ) ; bar . addTab ( bar . newTab ( ) . setTag ( MyRecentStopsFragment . TAB_NAME ) . setText ( res . getString ( R . string . my_recent_title ) ) . setIcon ( res . getDrawable ( R . drawable . ic_tab_recent ) ) . setTabListener ( new TabListener < MyRecentStopsFragment > ( this , MyRecentStopsFragment . TAB_NAME , MyRecentStopsFragment .class ) ) ) ; bar . addTab ( bar . newTab ( ) . setTag ( MyStarredStopsFragment . TAB_NAME ) . setText ( res . getString ( R . string . my_starred_title ) ) . setIcon ( res . getDrawable ( R . drawable . ic_tab_starred ) ) . setTabListener ( new TabListener < MyStarredStopsFragment > ( this , MyStarredStopsFragment . TAB_NAME , MyStarredStopsFragment .class ) ) ) ; bar . addTab ( bar . newTab ( ) . setTag ( MySearchStopsFragment . TAB_NAME ) . setText ( res . getString ( R . string . my_search_title ) ) . setIcon ( res . getDrawable ( R . drawable . ic_tab_search ) ) . setTabListener ( new TabListener < MySearchStopsFragment > ( this , MySearchStopsFragment . TAB_NAME , MySearchStopsFragment .class ) ) ) ; restoreDefaultTab ( ) ; UIUtils . setupActionBar ( this ) ; }
@ Override protected void onStart ( ) { super. onStart ( ) ; ObaAnalytics . reportActivityStart ( this ) ; }
@ Override protected String getLastTabPref ( ) { return "MyStopsActivity.LastTab" ; }
public static ObaRegion getTampa ( Context context ) { ArrayList < ObaRegion > regions = RegionUtils . getRegionsFromResources ( context ) ; for ( ObaRegion r : regions ) { if ( r . getId ( ) == TAMPA_REGION_ID ) { return r ; } } return null ; }
public static ObaRegion getPugetSound ( Context context ) { ArrayList < ObaRegion > regions = RegionUtils . getRegionsFromResources ( context ) ; for ( ObaRegion r : regions ) { if ( r . getId ( ) == PUGET_SOUND_REGION_ID ) { return r ; } } return null ; }
public static ObaRegion getAtlanta ( Context context ) { ArrayList < ObaRegion > regions = RegionUtils . getRegionsFromResources ( context ) ; for ( ObaRegion r : regions ) { if ( r . getId ( ) == ATLANTA_REGION_ID ) { return r ; } } return null ; }
public static ObaRegion getRegionWithPathNoSeparator ( Context context ) { ObaRegionElement . Bounds bound = new ObaRegionElement . Bounds ( 27.976910500000002 , - 82.445851 , 0.5424609999999994 , 0.576357999999999 ) ; ObaRegionElement . Bounds [] bounds = new ObaRegionElement . Bounds [ 1 ] ; bounds [ 0 ] = bound ; return new ObaRegionElement ( 0 , "Test-RegionWithPathNoSeparator" , true , "http: , null , bounds , new ObaRegionElement . Open311Server [ 0 ] , "en_US" , "test@test.org" , true , true , false , null , false , null , null , null ) ; }
public static ObaRegion getRegionNoSeparator ( Context context ) { ObaRegionElement . Bounds bound = new ObaRegionElement . Bounds ( 47.221315 , - 122.4051325 , 0.33704 , 0.440483 ) ; ObaRegionElement . Bounds [] bounds = new ObaRegionElement . Bounds [ 1 ] ; bounds [ 0 ] = bound ; return new ObaRegionElement ( 0 , "Test-RegionWithPathNoSeparator" , true , "http: , null , bounds , new ObaRegionElement . Open311Server [ 0 ] , "en_US" , "test@test.org" , true , true , false , null , false , "http: , null , null ) ; }
public static ObaRegion getRegionWithPort ( Context context ) { ObaRegionElement . Bounds bound = new ObaRegionElement . Bounds ( 27.976910500000002 , - 82.445851 , 0.5424609999999994 , 0.576357999999999 ) ; ObaRegionElement . Bounds [] bounds = new ObaRegionElement . Bounds [ 1 ] ; bounds [ 0 ] = bound ; return new ObaRegionElement ( 0 , "Test-RegionWithPort" , true , "http: , null , bounds , new ObaRegionElement . Open311Server [ 0 ] , "en_US" , "test@test.org" , true , true , false , null , false , null , null , null ) ; }
public static ObaRegion getRegionNoScheme ( Context context ) { ObaRegionElement . Bounds bound = new ObaRegionElement . Bounds ( 27.976910500000002 , - 82.445851 , 0.5424609999999994 , 0.576357999999999 ) ; ObaRegionElement . Bounds [] bounds = new ObaRegionElement . Bounds [ 1 ] ; bounds [ 0 ] = bound ; return new ObaRegionElement ( 0 , "Test-RegionNoScheme" , true , "api.tampa.onebusaway.org/api/" , null , bounds , new ObaRegionElement . Open311Server [ 0 ] , "en_US" , "test@test.org" , true , true , false , null , false , null , null , null ) ; }
public static ObaRegion getRegionWithHttps ( ) { ObaRegionElement . Bounds bound = new ObaRegionElement . Bounds ( 27.976910500000002 , - 82.445851 , 0.5424609999999994 , 0.576357999999999 ) ; ObaRegionElement . Bounds [] bounds = new ObaRegionElement . Bounds [ 1 ] ; bounds [ 0 ] = bound ; return new ObaRegionElement ( 0 , "Test-RegionWithHttps" , true , "https: , null , bounds , new ObaRegionElement . Open311Server [ 0 ] , "en_US" , "test@test.org" , true , true , false , null , false , null , null , null ) ; }
public static ObaRegion getRegionWithHttpsAndPort ( ) { ObaRegionElement . Bounds bound = new ObaRegionElement . Bounds ( 27.976910500000002 , - 82.445851 , 0.5424609999999994 , 0.576357999999999 ) ; ObaRegionElement . Bounds [] bounds = new ObaRegionElement . Bounds [ 1 ] ; bounds [ 0 ] = bound ; return new ObaRegionElement ( 0 , "Test-RegionWithHttpsAndPort" , true , "https: , null , bounds , new ObaRegionElement . Open311Server [ 0 ] , "en_US" , "test@test.org" , true , true , false , null , false , null , null , null ) ; }
public static ObaRegion getRegionWithoutObaApis ( Context context ) { ObaRegionElement . Bounds bound = new ObaRegionElement . Bounds ( 27.976910500000002 , - 82.445851 , 0.5424609999999994 , 0.576357999999999 ) ; ObaRegionElement . Bounds [] bounds = new ObaRegionElement . Bounds [ 1 ] ; bounds [ 0 ] = bound ; return new ObaRegionElement ( 0 , "Test-RegionWithoutOBAApis" , true , "http: , null , bounds , null , "en_US" , "test@test.org" , false , false , false , null , false , null , null , null ) ; }
public static ObaRegion getInactiveRegion ( Context context ) { ObaRegionElement . Bounds bound = new ObaRegionElement . Bounds ( 27.976910500000002 , - 82.445851 , 0.5424609999999994 , 0.576357999999999 ) ; ObaRegionElement . Bounds [] bounds = new ObaRegionElement . Bounds [ 1 ] ; bounds [ 0 ] = bound ; return new ObaRegionElement ( 0 , "Test-RegionWithoutOBAApis" , true , "http: , null , bounds , null , "en_US" , "test@test.org" , false , false , false , null , false , null , null , null ) ; }
public NotifierTask ( Context context , TaskContext taskContext , Uri uri , String notifyText ) { mContext = context ; mTaskContext = taskContext ; mCR = mContext . getContentResolver ( ) ; mUri = uri ; mNotifyText = notifyText ; }
@ Override public void run ( ) { Cursor c = mCR . query ( mUri , ALERT_PROJECTION , null , null , null ) ; try { if ( c != null ) { while ( c . moveToNext ( ) ) { notify ( c ) ; } } } finally { if ( c != null ) { c . close ( ) ; } mTaskContext . taskComplete ( ) ; } }
private void notify ( Cursor c ) { final int id = c . getInt ( COL_ID ) ; final String stopId = c . getString ( COL_STOP_ID ) ; final int state = c . getInt ( COL_STATE ) ; if ( state == ObaContract . TripAlerts . STATE_CANCELLED ) { return; } Intent deleteIntent = new Intent ( mContext , TripService .class ) ; deleteIntent . setAction ( TripService . ACTION_CANCEL ) ; deleteIntent . setData ( mUri ) ; PendingIntent pendingDeleteIntent = PendingIntent . getService ( mContext , 0 , deleteIntent , PendingIntent . FLAG_UPDATE_CURRENT ) ; final PendingIntent pendingContentIntent = PendingIntent . getActivity ( mContext , 0 , new ArrivalsListActivity . Builder ( mContext , stopId ) . getIntent ( ) , PendingIntent . FLAG_UPDATE_CURRENT ) ; Notification notification = createNotification ( mNotifyText , pendingContentIntent , pendingDeleteIntent ) ; mTaskContext . setNotification ( id , notification ) ; }
private Notification createNotification ( String notifyText , PendingIntent contentIntent , PendingIntent deleteIntent ) { final String title = mContext . getString ( R . string . app_name ) ; return new NotificationCompat . Builder ( mContext ) . setSmallIcon ( R . drawable . ic_stat_notification ) . setDefaults ( Notification . DEFAULT_ALL ) . setOnlyAlertOnce ( true ) . setContentIntent ( contentIntent ) . setDeleteIntent ( deleteIntent ) . setContentTitle ( title ) . setContentText ( notifyText ) . build ( ) ; }
@ Override protected void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; context = getApplicationContext ( ) ; activity = this ; settings = PreferenceManager . getDefaultSharedPreferences ( this . context ) ; protocol = settings . getString ( "git_remote_protocol" , "ssh: ) ; connectionMode = settings . getString ( "git_remote_auth" , "ssh-key" ) ; int operationCode = getIntent ( ) . getExtras ( ) . getInt ( "Operation" ) ; getSupportActionBar ( ) . setDisplayHomeAsUpEnabled ( true ) ; switch ( operationCode ) { case REQUEST_CLONE : case EDIT_SERVER : setContentView ( R . layout . activity_git_clone ) ; setTitle ( R . string . title_activity_git_clone ) ; final Spinner protcol_spinner = ( Spinner ) findViewById ( R . id . clone_protocol ) ; final Spinner connection_mode_spinner = ( Spinner ) findViewById ( R . id . connection_mode ) ; final ArrayAdapter < CharSequence > connection_mode_adapter = ArrayAdapter . createFromResource ( this , R . array . connection_modes , android . R . layout . simple_spinner_item ) ; connection_mode_adapter . setDropDownViewResource ( android . R . layout . simple_spinner_dropdown_item ) ; connection_mode_spinner . setAdapter ( connection_mode_adapter ) ; connection_mode_spinner . setOnItemSelectedListener ( new AdapterView . OnItemSelectedListener ( ) { @ Override public void onItemSelected ( AdapterView < ? > adapterView , View view , int i , long l ) { String selection = ( ( Spinner ) findViewById ( R . id . connection_mode ) ) . getSelectedItem ( ) . toString ( ) ; connectionMode = selection ; settings . edit ( ) . putString ( "git_remote_auth" , selection ) . apply ( ) ; } @ Override public void onNothingSelected ( AdapterView < ? > adapterView ) {                    } } ) ; ArrayAdapter < CharSequence > protocol_adapter = ArrayAdapter . createFromResource ( this , R . array . clone_protocols , android . R . layout . simple_spinner_item ) ; protocol_adapter . setDropDownViewResource ( android . R . layout . simple_spinner_dropdown_item ) ; protcol_spinner . setAdapter ( protocol_adapter ) ; protcol_spinner . setOnItemSelectedListener ( new AdapterView . OnItemSelectedListener ( ) { @ Override public void onItemSelected ( AdapterView < ? > adapterView , View view , int i , long l ) { protocol = ( ( Spinner ) findViewById ( R . id . clone_protocol ) ) . getSelectedItem ( ) . toString ( ) ; if ( protocol . equals ( "ssh: ) ) { ( ( EditText ) findViewById ( R . id . clone_uri ) ) . setHint ( "user@hostname:path" ) ; ( ( EditText ) findViewById ( R . id . server_port ) ) . setHint ( R . string . default_ssh_port ) ; connection_mode_spinner . setSelection ( 0 ) ; connection_mode_spinner . setEnabled ( true ) ; if ( connectionMode . equals ( "ssh-key" ) ) { connection_mode_spinner . setSelection ( 0 ) ; } else { connection_mode_spinner . setSelection ( 1 ) ; } } else { ( ( EditText ) findViewById ( R . id . clone_uri ) ) . setHint ( "hostname/path" ) ; ( ( EditText ) findViewById ( R . id . server_port ) ) . setHint ( R . string . default_https_port ) ; connection_mode_spinner . setSelection ( 1 ) ; connection_mode_spinner . setEnabled ( false ) ; } } @ Override public void onNothingSelected ( AdapterView < ? > adapterView ) {                            } } ) ; if ( protocol . equals ( "ssh: ) ) { protcol_spinner . setSelection ( 0 ) ; } else { protcol_spinner . setSelection ( 1 ) ; } final EditText server_url = ( ( EditText ) findViewById ( R . id . server_url ) ) ; final EditText server_port = ( ( EditText ) findViewById ( R . id . server_port ) ) ; final EditText server_path = ( ( EditText ) findViewById ( R . id . server_path ) ) ; final EditText server_user = ( ( EditText ) findViewById ( R . id . server_user ) ) ; final EditText server_uri = ( ( EditText ) findViewById ( R . id . clone_uri ) ) ; View . OnFocusChangeListener updateListener = new View . OnFocusChangeListener ( ) { @ Override public void onFocusChange ( View view , boolean b ) { updateURI ( ) ; } } ; server_url . setText ( settings . getString ( "git_remote_server" , "" ) ) ; server_port . setText ( settings . getString ( "git_remote_port" , "" ) ) ; server_user . setText ( settings . getString ( "git_remote_username" , "" ) ) ; server_path . setText ( settings . getString ( "git_remote_location" , "" ) ) ; server_url . addTextChangedListener ( new TextWatcher ( ) { @ Override public void beforeTextChanged ( CharSequence charSequence , int i , int i2 , int i3 ) {                    } @ Override public void onTextChanged ( CharSequence charSequence , int i , int i2 , int i3 ) { if ( server_url . isFocused ( ) ) updateURI ( ) ; } @ Override public void afterTextChanged ( Editable editable ) {                    } } ) ; server_port . addTextChangedListener ( new TextWatcher ( ) { @ Override public void beforeTextChanged ( CharSequence charSequence , int i , int i2 , int i3 ) {                    } @ Override public void onTextChanged ( CharSequence charSequence , int i , int i2 , int i3 ) { if ( server_port . isFocused ( ) ) updateURI ( ) ; } @ Override public void afterTextChanged ( Editable editable ) {                    } } ) ; server_user . addTextChangedListener ( new TextWatcher ( ) { @ Override public void beforeTextChanged ( CharSequence charSequence , int i , int i2 , int i3 ) {                    } @ Override public void onTextChanged ( CharSequence charSequence , int i , int i2 , int i3 ) { if ( server_user . isFocused ( ) ) updateURI ( ) ; } @ Override public void afterTextChanged ( Editable editable ) {                    } } ) ; server_path . addTextChangedListener ( new TextWatcher ( ) { @ Override public void beforeTextChanged ( CharSequence charSequence , int i , int i2 , int i3 ) {                    } @ Override public void onTextChanged ( CharSequence charSequence , int i , int i2 , int i3 ) { if ( server_path . isFocused ( ) ) updateURI ( ) ; } @ Override public void afterTextChanged ( Editable editable ) {                    } } ) ; server_uri . addTextChangedListener ( new TextWatcher ( ) { @ Override public void beforeTextChanged ( CharSequence charSequence , int i , int i2 , int i3 ) {                    } @ Override public void onTextChanged ( CharSequence charSequence , int i , int i2 , int i3 ) { if ( server_uri . isFocused ( ) ) splitURI ( ) ; } @ Override public void afterTextChanged ( Editable editable ) {                    } } ) ; if ( operationCode == EDIT_SERVER ) { findViewById ( R . id . clone_button ) . setVisibility ( View . INVISIBLE ) ; findViewById ( R . id . save_button ) . setVisibility ( View . VISIBLE ) ; } else { findViewById ( R . id . clone_button ) . setVisibility ( View . VISIBLE ) ; findViewById ( R . id . save_button ) . setVisibility ( View . INVISIBLE ) ; } updateURI ( ) ; break; case REQUEST_PULL : syncRepository ( REQUEST_PULL ) ; break; case REQUEST_PUSH : syncRepository ( REQUEST_PUSH ) ; break; case REQUEST_SYNC : syncRepository ( REQUEST_SYNC ) ; break; } }
@ Override public void onItemSelected ( AdapterView < ? > adapterView , View view , int i , long l ) { String selection = ( ( Spinner ) findViewById ( R . id . connection_mode ) ) . getSelectedItem ( ) . toString ( ) ; connectionMode = selection ; settings . edit ( ) . putString ( "git_remote_auth" , selection ) . apply ( ) ; }
@ Override public void onNothingSelected ( AdapterView < ? > adapterView ) {                    }
@ Override public void onItemSelected ( AdapterView < ? > adapterView , View view , int i , long l ) { protocol = ( ( Spinner ) findViewById ( R . id . clone_protocol ) ) . getSelectedItem ( ) . toString ( ) ; if ( protocol . equals ( "ssh: ) ) { ( ( EditText ) findViewById ( R . id . clone_uri ) ) . setHint ( "user@hostname:path" ) ; ( ( EditText ) findViewById ( R . id . server_port ) ) . setHint ( R . string . default_ssh_port ) ; connection_mode_spinner . setSelection ( 0 ) ; connection_mode_spinner . setEnabled ( true ) ; if ( connectionMode . equals ( "ssh-key" ) ) { connection_mode_spinner . setSelection ( 0 ) ; } else { connection_mode_spinner . setSelection ( 1 ) ; } } else { ( ( EditText ) findViewById ( R . id . clone_uri ) ) . setHint ( "hostname/path" ) ; ( ( EditText ) findViewById ( R . id . server_port ) ) . setHint ( R . string . default_https_port ) ; connection_mode_spinner . setSelection ( 1 ) ; connection_mode_spinner . setEnabled ( false ) ; } }
@ Override public void onNothingSelected ( AdapterView < ? > adapterView ) {                            }
@ Override public void onFocusChange ( View view , boolean b ) { updateURI ( ) ; }
@ Override public void beforeTextChanged ( CharSequence charSequence , int i , int i2 , int i3 ) {                    }
@ Override public void onTextChanged ( CharSequence charSequence , int i , int i2 , int i3 ) { if ( server_url . isFocused ( ) ) updateURI ( ) ; }
@ Override public void afterTextChanged ( Editable editable ) {                    }
@ Override public void beforeTextChanged ( CharSequence charSequence , int i , int i2 , int i3 ) {                    }
@ Override public void onTextChanged ( CharSequence charSequence , int i , int i2 , int i3 ) { if ( server_port . isFocused ( ) ) updateURI ( ) ; }
@ Override public void afterTextChanged ( Editable editable ) {                    }
@ Override public void beforeTextChanged ( CharSequence charSequence , int i , int i2 , int i3 ) {                    }
@ Override public void onTextChanged ( CharSequence charSequence , int i , int i2 , int i3 ) { if ( server_user . isFocused ( ) ) updateURI ( ) ; }
@ Override public void afterTextChanged ( Editable editable ) {                    }
@ Override public void beforeTextChanged ( CharSequence charSequence , int i , int i2 , int i3 ) {                    }
@ Override public void onTextChanged ( CharSequence charSequence , int i , int i2 , int i3 ) { if ( server_path . isFocused ( ) ) updateURI ( ) ; }
@ Override public void afterTextChanged ( Editable editable ) {                    }
@ Override public void beforeTextChanged ( CharSequence charSequence , int i , int i2 , int i3 ) {                    }
@ Override public void onTextChanged ( CharSequence charSequence , int i , int i2 , int i3 ) { if ( server_uri . isFocused ( ) ) splitURI ( ) ; }
@ Override public void afterTextChanged ( Editable editable ) {                    }
private void updateURI ( ) { EditText uri = ( EditText ) findViewById ( R . id . clone_uri ) ; EditText server_url = ( ( EditText ) findViewById ( R . id . server_url ) ) ; EditText server_port = ( ( EditText ) findViewById ( R . id . server_port ) ) ; EditText server_path = ( ( EditText ) findViewById ( R . id . server_path ) ) ; EditText server_user = ( ( EditText ) findViewById ( R . id . server_user ) ) ; if ( uri != null ) { switch ( protocol ) { case "ssh: : { String hostname = server_user . getText ( ) + "@" + server_url . getText ( ) . toString ( ) . trim ( ) + ":" ; if ( server_port . getText ( ) . toString ( ) . equals ( "22" ) ) { hostname += server_path . getText ( ) . toString ( ) ; ( ( TextView ) findViewById ( R . id . warn_url ) ) . setVisibility ( View . GONE ) ; } else { TextView warn_url = ( TextView ) findViewById ( R . id . warn_url ) ; if ( ! server_path . getText ( ) . toString ( ) . matches ( "/.*" ) && ! server_port . getText ( ) . toString ( ) . isEmpty ( ) ) { warn_url . setText ( R . string . warn_malformed_url_port ) ; warn_url . setVisibility ( View . VISIBLE ) ; } else { warn_url . setVisibility ( View . GONE ) ; } hostname += server_port . getText ( ) . toString ( ) + server_path . getText ( ) . toString ( ) ; } if ( ! hostname . equals ( "@:" ) ) uri . setText ( hostname ) ; } break; case "https: : { StringBuilder hostname = new StringBuilder ( ) ; hostname . append ( server_url . getText ( ) . toString ( ) . trim ( ) ) ; if ( server_port . getText ( ) . toString ( ) . equals ( "443" ) ) { hostname . append ( server_path . getText ( ) . toString ( ) ) ; ( ( TextView ) findViewById ( R . id . warn_url ) ) . setVisibility ( View . GONE ) ; } else { hostname . append ( "/" ) ; hostname . append ( server_port . getText ( ) . toString ( ) ) . append ( server_path . getText ( ) . toString ( ) ) ; } if ( ! hostname . toString ( ) . equals ( "@/" ) ) uri . setText ( hostname ) ; } break; default: break; } } }
private void splitURI ( ) { EditText server_uri = ( EditText ) findViewById ( R . id . clone_uri ) ; EditText server_url = ( ( EditText ) findViewById ( R . id . server_url ) ) ; EditText server_port = ( ( EditText ) findViewById ( R . id . server_port ) ) ; EditText server_path = ( ( EditText ) findViewById ( R . id . server_path ) ) ; EditText server_user = ( ( EditText ) findViewById ( R . id . server_user ) ) ; String uri = server_uri . getText ( ) . toString ( ) ; Pattern pattern = Pattern . compile ( "(.+)@([\\w\\d\\.]+):([\\d]+)*(.*)" ) ; Matcher matcher = pattern . matcher ( uri ) ; if ( matcher . find ( ) ) { int count = matcher . groupCount ( ) ; if ( count > 1 ) { server_user . setText ( matcher . group ( 1 ) ) ; server_url . setText ( matcher . group ( 2 ) ) ; } if ( count == 4 ) { server_port . setText ( matcher . group ( 3 ) ) ; server_path . setText ( matcher . group ( 4 ) ) ; TextView warn_url = ( TextView ) findViewById ( R . id . warn_url ) ; if ( ! server_path . getText ( ) . toString ( ) . matches ( "/.*" ) && ! server_port . getText ( ) . toString ( ) . isEmpty ( ) ) { warn_url . setText ( R . string . warn_malformed_url_port ) ; warn_url . setVisibility ( View . VISIBLE ) ; } else { warn_url . setVisibility ( View . GONE ) ; } } } }
@ Override public void onResume ( ) { super. onResume ( ) ; updateURI ( ) ; }
@ Override public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . git_clone , menu ) ; return true ; }
@ Override public boolean onOptionsItemSelected ( MenuItem item ) { int id = item . getItemId ( ) ; switch ( id ) { case R . id . user_pref : try { Intent intent = new Intent ( this , UserPreference .class ) ; startActivity ( intent ) ; } catch ( Exception e ) { System . out . println ( "Exception caught :(" ) ; e . printStackTrace ( ) ; } return true ; } return super. onOptionsItemSelected ( item ) ; }
private boolean saveConfiguration ( ) { SharedPreferences . Editor editor = settings . edit ( ) ; editor . putString ( "git_remote_server" , ( ( EditText ) findViewById ( R . id . server_url ) ) . getText ( ) . toString ( ) ) ; editor . putString ( "git_remote_location" , ( ( EditText ) findViewById ( R . id . server_path ) ) . getText ( ) . toString ( ) ) ; editor . putString ( "git_remote_username" , ( ( EditText ) findViewById ( R . id . server_user ) ) . getText ( ) . toString ( ) ) ; editor . putString ( "git_remote_protocol" , protocol ) ; editor . putString ( "git_remote_auth" , connectionMode ) ; editor . putString ( "git_remote_port" , ( ( EditText ) findViewById ( R . id . server_port ) ) . getText ( ) . toString ( ) ) ; editor . putString ( "git_remote_uri" , ( ( EditText ) findViewById ( R . id . clone_uri ) ) . getText ( ) . toString ( ) ) ; hostname = ( ( EditText ) findViewById ( R . id . clone_uri ) ) . getText ( ) . toString ( ) ; port = ( ( EditText ) findViewById ( R . id . server_port ) ) . getText ( ) . toString ( ) ; hostname = hostname . replaceFirst ( "^.+: , "" ) ; ( ( TextView ) findViewById ( R . id . clone_uri ) ) . setText ( hostname ) ; if ( ! protocol . equals ( "ssh: ) ) { hostname = protocol + hostname ; } else { if ( ! port . isEmpty ( ) && ! port . equals ( "22" ) ) hostname = protocol + hostname ; if ( ! hostname . matches ( "^.+@.+" ) ) { new AlertDialog . Builder ( this ) . setMessage ( activity . getResources ( ) . getString ( R . string . forget_username_dialog_text ) ) . setPositiveButton ( activity . getResources ( ) . getString ( R . string . dialog_oops ) , null ) . show ( ) ; return false ; } } if ( PasswordRepository . isInitialized ( ) ) { PasswordRepository . addRemote ( "origin" , hostname , true ) ; } editor . apply ( ) ; return true ; }
public void saveConfiguration ( View view ) { if ( ! saveConfiguration ( ) ) return; finish ( ) ; }
public void cloneRepository ( View view ) { if ( PasswordRepository . getRepository ( null ) == null ) { PasswordRepository . initialize ( this ) ; } localDir = PasswordRepository . getRepositoryDirectory ( context ) ; if ( ! saveConfiguration ( ) ) return; if ( localDir . exists ( ) && localDir . listFiles ( ) . length != 0 && ! ( localDir . listFiles ( ) . length == 1 && localDir . listFiles ( ) [ 0 ] . getName ( ) . equals ( ".git" ) ) ) { new AlertDialog . Builder ( this ) . setTitle ( R . string . dialog_delete_title ) . setMessage ( getResources ( ) . getString ( R . string . dialog_delete_msg ) + " " + localDir . toString ( ) ) . setCancelable ( false ) . setPositiveButton ( R . string . dialog_delete , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int id ) { try { FileUtils . deleteDirectory ( localDir ) ; try { new CloneOperation ( localDir , activity ) . setCommand ( hostname ) . executeAfterAuthentication ( connectionMode , settings . getString ( "git_remote_username" , "git" ) , new File ( getFilesDir ( ) + "/.ssh_key" ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; new AlertDialog . Builder ( GitActivity .this ) . setMessage ( e . getMessage ( ) ) . show ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; new AlertDialog . Builder ( GitActivity .this ) . setMessage ( e . getMessage ( ) ) . show ( ) ; } dialog . cancel ( ) ; } } ) . setNegativeButton ( R . string . dialog_do_not_delete , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int id ) { dialog . cancel ( ) ; } } ) . show ( ) ; } else { try { if ( localDir . listFiles ( ) . length == 1 && localDir . listFiles ( ) [ 0 ] . getName ( ) . equals ( ".git" ) ) { try { FileUtils . deleteDirectory ( localDir ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; new AlertDialog . Builder ( GitActivity .this ) . setMessage ( e . getMessage ( ) ) . show ( ) ; } } new CloneOperation ( localDir , activity ) . setCommand ( hostname ) . executeAfterAuthentication ( connectionMode , settings . getString ( "git_remote_username" , "git" ) , new File ( getFilesDir ( ) + "/.ssh_key" ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; new AlertDialog . Builder ( this ) . setMessage ( e . getMessage ( ) ) . show ( ) ; } } }
public void onClick ( DialogInterface dialog , int id ) { try { FileUtils . deleteDirectory ( localDir ) ; try { new CloneOperation ( localDir , activity ) . setCommand ( hostname ) . executeAfterAuthentication ( connectionMode , settings . getString ( "git_remote_username" , "git" ) , new File ( getFilesDir ( ) + "/.ssh_key" ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; new AlertDialog . Builder ( GitActivity .this ) . setMessage ( e . getMessage ( ) ) . show ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; new AlertDialog . Builder ( GitActivity .this ) . setMessage ( e . getMessage ( ) ) . show ( ) ; } dialog . cancel ( ) ; }
public void onClick ( DialogInterface dialog , int id ) { dialog . cancel ( ) ; }
private void syncRepository ( int operation ) { if ( settings . getString ( "git_remote_username" , "" ) . isEmpty ( ) || settings . getString ( "git_remote_server" , "" ) . isEmpty ( ) || settings . getString ( "git_remote_location" , "" ) . isEmpty ( ) ) new AlertDialog . Builder ( this ) . setMessage ( activity . getResources ( ) . getString ( R . string . set_information_dialog_text ) ) . setPositiveButton ( activity . getResources ( ) . getString ( R . string . dialog_positive ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialogInterface , int i ) { Intent intent = new Intent ( activity , UserPreference .class ) ; startActivityForResult ( intent , REQUEST_PULL ) ; } } ) . setNegativeButton ( activity . getResources ( ) . getString ( R . string . dialog_negative ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialogInterface , int i ) { setResult ( RESULT_OK ) ; finish ( ) ; } } ) . show ( ) ; else { PasswordRepository . addRemote ( "origin" , hostname , false ) ; GitOperation op ; switch ( operation ) { case REQUEST_PULL : op = new PullOperation ( localDir , activity ) . setCommand ( ) ; break; case REQUEST_PUSH : op = new PushOperation ( localDir , activity ) . setCommand ( ) ; break; case REQUEST_SYNC : op = new SyncOperation ( localDir , activity ) . setCommands ( ) ; break; default: Log . e ( TAG , "Sync operation not recognized : " + operation ) ; return; } try { op . executeAfterAuthentication ( connectionMode , settings . getString ( "git_remote_username" , "git" ) , new File ( getFilesDir ( ) + "/.ssh_key" ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
@ Override public void onClick ( DialogInterface dialogInterface , int i ) { Intent intent = new Intent ( activity , UserPreference .class ) ; startActivityForResult ( intent , REQUEST_PULL ) ; }
@ Override public void onClick ( DialogInterface dialogInterface , int i ) { setResult ( RESULT_OK ) ; finish ( ) ; }
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { if ( resultCode == RESULT_CANCELED ) { setResult ( RESULT_CANCELED ) ; finish ( ) ; return; } if ( resultCode == RESULT_OK ) { GitOperation op ; switch ( requestCode ) { case REQUEST_CLONE : setResult ( RESULT_OK ) ; finish ( ) ; return; case REQUEST_PULL : op = new PullOperation ( localDir , activity ) . setCommand ( ) ; break; case REQUEST_PUSH : op = new PushOperation ( localDir , activity ) . setCommand ( ) ; break; case GitOperation . GET_SSH_KEY_FROM_CLONE : op = new CloneOperation ( localDir , activity ) . setCommand ( hostname ) ; break; default: Log . e ( TAG , "Operation not recognized : " + resultCode ) ; setResult ( RESULT_CANCELED ) ; finish ( ) ; return; } try { op . executeAfterAuthentication ( connectionMode , settings . getString ( "git_remote_username" , "git" ) , new File ( getFilesDir ( ) + "/.ssh_key" ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
void onFocusChanged ( ObaStop stop , HashMap < String , ObaRoute > routes , Location location );
void onProgressBarChanged ( boolean showProgressBar );
public static BaseMapFragment newInstance ( ) { return new BaseMapFragment ( ) ; }
@ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View v = super. onCreateView ( inflater , container , savedInstanceState ) ; mLocationHelper = new LocationHelper ( getActivity ( ) ) ; mLocationHelper . registerListener ( this ) ; if ( MapHelpV2 . isMapsInstalled ( getActivity ( ) ) ) { mLastSavedInstanceState = savedInstanceState ; getMapAsync ( this ) ; } else { MapHelpV2 . promptUserInstallMaps ( getActivity ( ) ) ; } Location l = Application . getLastKnownLocation ( getActivity ( ) , mLocationHelper . getGoogleApiClient ( ) ) ; if ( l != null ) { final long TIME_THRESHOLD = TimeUnit . MINUTES . toMillis ( 5 ) ; if ( System . currentTimeMillis ( ) - l . getTime ( ) < TIME_THRESHOLD ) { onLocationChanged ( l ) ; } } return v ; }
@ Override public void onMapReady ( com . google . android . gms . maps . GoogleMap map ) { mMap = map ; initMap ( mLastSavedInstanceState ) ; }
private void initMap ( Bundle savedInstanceState ) { UiSettings uiSettings = mMap . getUiSettings ( ) ; mMap . setMyLocationEnabled ( true ) ; mMap . setLocationSource ( this ) ; mMap . setOnCameraChangeListener ( this ) ; uiSettings . setMyLocationButtonEnabled ( false ) ; uiSettings . setZoomControlsEnabled ( false ) ; uiSettings . setMapToolbarEnabled ( false ) ; mSimpleMarkerOverlay = new SimpleMarkerOverlay ( mMap ) ; if ( savedInstanceState != null ) { initMapState ( savedInstanceState ) ; } else { Bundle args = getActivity ( ) . getIntent ( ) . getExtras ( ) ; if ( args == null ) { args = new Bundle ( ) ; } double lat = args . getDouble ( MapParams . CENTER_LAT , 0.0d ) ; double lon = args . getDouble ( MapParams . CENTER_LON , 0.0d ) ; if ( lat == 0.0d && lon == 0.0d ) { PreferenceUtils . maybeRestoreMapViewToBundle ( args ) ; } initMapState ( args ) ; } }
private void initMapState ( Bundle args ) { mFocusStopId = args . getString ( MapParams . STOP_ID ) ; mMapPaddingLeft = args . getInt ( MapParams . MAP_PADDING_LEFT , MapParams . DEFAULT_MAP_PADDING ) ; mMapPaddingTop = args . getInt ( MapParams . MAP_PADDING_TOP , MapParams . DEFAULT_MAP_PADDING ) ; mMapPaddingRight = args . getInt ( MapParams . MAP_PADDING_RIGHT , MapParams . DEFAULT_MAP_PADDING ) ; mMapPaddingBottom = args . getInt ( MapParams . MAP_PADDING_BOTTOM , MapParams . DEFAULT_MAP_PADDING ) ; setPadding ( mMapPaddingLeft , mMapPaddingTop , mMapPaddingRight , mMapPaddingBottom ) ; String mode = args . getString ( MapParams . MODE ) ; if ( mode == null ) { mode = MapParams . MODE_STOP ; } setMapMode ( mode , args ) ; }
@ Override public void onDestroy ( ) { if ( mController != null ) { mController . destroy ( ) ; } super. onDestroy ( ) ; }
@ Override public void onPause ( ) { if ( mLocationHelper != null ) { mLocationHelper . onPause ( ) ; } if ( mController != null ) { mController . onPause ( ) ; } Location center = getMapCenterAsLocation ( ) ; if ( center != null ) { PreferenceUtils . saveMapViewToPreferences ( center . getLatitude ( ) , center . getLongitude ( ) , getZoomLevelAsFloat ( ) ) ; } mRunning = false ; super. onPause ( ) ; }
@ Override public void onHiddenChanged ( boolean hidden ) { if ( mController != null ) { mController . onHidden ( hidden ) ; } super. onHiddenChanged ( hidden ) ; }
@ Override public void onResume ( ) { if ( mLocationHelper != null ) { mLocationHelper . onResume ( ) ; } mRunning = true ; if ( mController != null ) { mController . onResume ( ) ; } super. onResume ( ) ; }
@ Override public void onSaveInstanceState ( Bundle outState ) { if ( mController != null ) { mController . onSaveInstanceState ( outState ) ; } outState . putString ( MapParams . MODE , getMapMode ( ) ) ; outState . putString ( MapParams . STOP_ID , mFocusStopId ) ; Location center = getMapCenterAsLocation ( ) ; if ( mMap != null ) { outState . putDouble ( MapParams . CENTER_LAT , center . getLatitude ( ) ) ; outState . putDouble ( MapParams . CENTER_LON , center . getLongitude ( ) ) ; outState . putFloat ( MapParams . ZOOM , getZoomLevelAsFloat ( ) ) ; } outState . putInt ( MapParams . MAP_PADDING_LEFT , mMapPaddingLeft ) ; outState . putInt ( MapParams . MAP_PADDING_TOP , mMapPaddingTop ) ; outState . putInt ( MapParams . MAP_PADDING_RIGHT , mMapPaddingRight ) ; outState . putInt ( MapParams . MAP_PADDING_BOTTOM , mMapPaddingBottom ) ; }
@ Override public void onViewStateRestored ( Bundle savedInstanceState ) { if ( mController != null ) { mController . onViewStateRestored ( savedInstanceState ) ; } super. onViewStateRestored ( savedInstanceState ) ; }
public boolean isRouteDisplayed ( ) { return ( mController != null ) && MapParams . MODE_ROUTE . equals ( mController . getMode ( ) ) ; }
public boolean setupStopOverlay ( ) { if ( mStopOverlay != null ) { return true ; } if ( mMap == null ) { return false ; } mStopOverlay = new StopOverlay ( getActivity ( ) , mMap ) ; mStopOverlay . setOnFocusChangeListener ( this ) ; return true ; }
public void setupVehicleOverlay ( ) { Activity a = getActivity ( ) ; if ( mVehicleOverlay == null && a != null ) { mVehicleOverlay = new VehicleOverlay ( a , mMap ) ; mVehicleOverlay . setController ( this ) ; } }
protected void showDialog ( int id ) { MapDialogFragment . newInstance ( id , this ) . show ( getFragmentManager ( ) , MapDialogFragment . TAG ) ; }
@ Override public String getMapMode ( ) { if ( mController != null ) { return mController . getMode ( ) ; } return null ; }
@ Override public void setMapMode ( String mode , Bundle args ) { String oldMode = getMapMode ( ) ; if ( oldMode != null && oldMode . equals ( mode ) ) { mController . setState ( args ) ; return; } if ( mController != null ) { mController . destroy ( ) ; } if ( mStopOverlay != null ) { mStopOverlay . clear ( false ) ; } if ( MapParams . MODE_ROUTE . equals ( mode ) ) { mController = new RouteMapController ( this ) ; } else if ( MapParams . MODE_STOP . equals ( mode ) ) { mController = new StopMapController ( this ) ; } else if ( MapParams . MODE_DIRECTIONS . equals ( mode ) ) { mController = new DirectionsMapController ( this ) ; } mController . setState ( args ) ; mController . onResume ( ) ; }
@ Override public MapModeController . ObaMapView getMapView ( ) { return this ; }
@ Override public int addMarker ( Location location , Float hue ) { if ( mSimpleMarkerOverlay == null ) { return - 1 ; } return mSimpleMarkerOverlay . addMarker ( location , hue ) ; }
@ Override public void removeMarker ( int markerId ) { if ( mSimpleMarkerOverlay == null ) { return; } mSimpleMarkerOverlay . removeMarker ( markerId ) ; }
@ Override public void setPadding ( Integer left , Integer top , Integer right , Integer bottom ) { if ( left != null ) { mMapPaddingLeft = left ; } if ( top != null ) { mMapPaddingTop = top ; } if ( right != null ) { mMapPaddingRight = right ; } if ( bottom != null ) { mMapPaddingBottom = bottom ; } if ( mMap != null ) { mMap . setPadding ( mMapPaddingLeft , mMapPaddingTop , mMapPaddingRight , mMapPaddingBottom ) ; } }
@ Override public void showProgress ( boolean show ) { if ( mOnProgressBarChangedListener != null ) { mOnProgressBarChangedListener . onProgressBarChanged ( show ) ; } }
@ Override public void showStops ( List < ObaStop > stops , ObaReferences refs ) { if ( setupStopOverlay ( ) && stops != null ) { mStopOverlay . populateStops ( stops , refs ) ; } }
@ Override public void notifyOutOfRange ( ) { String serverName = Application . get ( ) . getCustomApiUrl ( ) ; if ( mWarnOutOfRange && ( Application . get ( ) . getCurrentRegion ( ) != null || ! TextUtils . isEmpty ( serverName ) ) ) { if ( mRunning && UIUtils . canManageDialog ( getActivity ( ) ) ) { showDialog ( MapDialogFragment . OUTOFRANGE_DIALOG ) ; } } }
@ Override public void onRegionTaskFinished ( boolean currentRegionChanged ) { if ( ! isAdded ( ) ) { return; } Location l = Application . getLastKnownLocation ( getActivity ( ) , mLocationHelper . getGoogleApiClient ( ) ) ; Location mapCenter = getMapCenterAsLocation ( ) ; if ( currentRegionChanged && ( l == null || ( mapCenter != null && mapCenter . getLatitude ( ) == 0.0 && mapCenter . getLongitude ( ) == 0.0 ) ) ) { zoomToRegion ( ) ; } }
public void setOnFocusChangeListener ( OnFocusChangedListener onFocusChangedListener ) { mOnFocusChangedListener = onFocusChangedListener ; }
public void setOnProgressBarChangedListener ( OnProgressBarChangedListener onProgressBarChangedListener ) { mOnProgressBarChangedListener = onProgressBarChangedListener ; }
public void onFocusChanged ( final ObaStop stop , final HashMap < String , ObaRoute > routes , final Location location ) { mStopChangedHandler . post ( new Runnable ( ) { public void run ( ) { if ( stop != null ) { mFocusStopId = stop . getId ( ) ; } else { mFocusStopId = null ; } if ( mOnFocusChangedListener != null ) { mOnFocusChangedListener . onFocusChanged ( stop , routes , location ) ; } } } ) ; }
public void run ( ) { if ( stop != null ) { mFocusStopId = stop . getId ( ) ; } else { mFocusStopId = null ; } if ( mOnFocusChangedListener != null ) { mOnFocusChangedListener . onFocusChanged ( stop , routes , location ) ; } }
@ Override @ SuppressWarnings ( "deprecation" ) public boolean setMyLocation ( boolean useDefaultZoom , boolean animateToLocation ) { if ( ! LocationUtils . isLocationEnabled ( getActivity ( ) ) && mRunning && UIUtils . canManageDialog ( getActivity ( ) ) ) { SharedPreferences prefs = Application . getPrefs ( ) ; if ( ! prefs . getBoolean ( getString ( R . string . preference_key_never_show_location_dialog ) , false ) ) { showDialog ( MapDialogFragment . NOLOCATION_DIALOG ) ; } return false ; } GoogleApiClient apiClient = null ; if ( mLocationHelper != null ) { apiClient = mLocationHelper . getGoogleApiClient ( ) ; } Location lastLocation = Application . getLastKnownLocation ( getActivity ( ) , apiClient ) ; if ( lastLocation == null ) { Toast . makeText ( getActivity ( ) , getResources ( ) . getString ( R . string . main_waiting_for_location ) , Toast . LENGTH_SHORT ) . show ( ) ; return false ; } setMyLocation ( lastLocation , useDefaultZoom , animateToLocation ) ; return true ; }
private void setMyLocation ( Location l , boolean useDefaultZoom , boolean animateToLocation ) { if ( mMap != null ) { CameraPosition . Builder cameraPosition = new CameraPosition . Builder ( ) . target ( MapHelpV2 . makeLatLng ( l ) ) ; if ( useDefaultZoom ) { cameraPosition . zoom ( CAMERA_DEFAULT_ZOOM ) ; } else { cameraPosition . zoom ( mMap . getCameraPosition ( ) . zoom ) ; } if ( animateToLocation ) { mMap . animateCamera ( CameraUpdateFactory . newCameraPosition ( cameraPosition . build ( ) ) ) ; } else { mMap . moveCamera ( CameraUpdateFactory . newCameraPosition ( cameraPosition . build ( ) ) ) ; } } if ( mController != null ) { mController . onLocation ( ) ; } }
public void zoomToRegion ( ) { ObaRegion region = Application . get ( ) . getCurrentRegion ( ) ; if ( region != null && mMap != null ) { LatLngBounds b = MapHelpV2 . getRegionBounds ( region ) ; int width = getResources ( ) . getDisplayMetrics ( ) . widthPixels ; int height = getResources ( ) . getDisplayMetrics ( ) . heightPixels ; int padding = 0 ; mMap . animateCamera ( ( CameraUpdateFactory . newLatLngBounds ( b , width , height , padding ) ) ) ; } }
public static void showMapError ( ObaResponse response ) { Context context = Application . get ( ) . getApplicationContext ( ) ; int code ; if ( response != null ) { code = response . getCode ( ) ; } else { code = ObaApi . OBA_INTERNAL_ERROR ; } if ( UIUtils . canManageDialog ( context ) ) { Toast . makeText ( context , context . getString ( UIUtils . getMapErrorString ( context , code ) ) , Toast . LENGTH_LONG ) . show ( ) ; } }
@ Override public void setZoom ( float zoomLevel ) { if ( mMap != null ) { mMap . moveCamera ( CameraUpdateFactory . zoomTo ( zoomLevel ) ) ; } }
@ Override public Location getMapCenterAsLocation ( ) { if ( mMap != null ) { LatLng center = mMap . getCameraPosition ( ) . target ; if ( mCenter == null || mCenter != center ) { mCenter = center ; mCenterLocation = MapHelpV2 . makeLocation ( mCenter ) ; } } return mCenterLocation ; }
@ Override public void setMapCenter ( Location location , boolean animateToLocation , boolean overlayExpanded ) { if ( mMap != null ) { CameraPosition cp = mMap . getCameraPosition ( ) ; LatLng target = MapHelpV2 . makeLatLng ( location ) ; LatLng offsetTarget ; if ( isRouteDisplayed ( ) && overlayExpanded ) { double percentageOffset = 0.2 ; double bias = ( getLongitudeSpanInDecDegrees ( ) * percentageOffset ) / 2 ; offsetTarget = new LatLng ( target . latitude - bias , target . longitude ) ; target = offsetTarget ; } if ( animateToLocation ) { mMap . animateCamera ( CameraUpdateFactory . newCameraPosition ( new CameraPosition . Builder ( ) . target ( target ) . zoom ( cp . zoom ) . bearing ( cp . bearing ) . tilt ( cp . tilt ) . build ( ) ) ) ; } else { mMap . moveCamera ( CameraUpdateFactory . newCameraPosition ( new CameraPosition . Builder ( ) . target ( target ) . zoom ( cp . zoom ) . bearing ( cp . bearing ) . tilt ( cp . tilt ) . build ( ) ) ) ; } } }
@ Override public double getLatitudeSpanInDecDegrees ( ) { VisibleRegion vr = mMap . getProjection ( ) . getVisibleRegion ( ) ; return Math . abs ( vr . latLngBounds . northeast . latitude - vr . latLngBounds . southwest . latitude ) ; }
@ Override public double getLongitudeSpanInDecDegrees ( ) { VisibleRegion vr = mMap . getProjection ( ) . getVisibleRegion ( ) ; return Math . abs ( vr . latLngBounds . northeast . longitude - vr . latLngBounds . southwest . longitude ) ; }
@ Override public float getZoomLevelAsFloat ( ) { return mMap . getCameraPosition ( ) . zoom ; }
@ Override public void setRouteOverlay ( int lineOverlayColor , ObaShape [] shapes , boolean clear ) { if ( mMap != null ) { if ( clear ) { mLineOverlay . clear ( ) ; } PolylineOptions lineOptions ; int totalPoints = 0 ; for ( ObaShape s : shapes ) { lineOptions = new PolylineOptions ( ) ; lineOptions . color ( lineOverlayColor ) ; for ( Location l : s . getPoints ( ) ) { lineOptions . add ( MapHelpV2 . makeLatLng ( l ) ) ; } mLineOverlay . add ( mMap . addPolyline ( lineOptions ) ) ; totalPoints += lineOptions . getPoints ( ) . size ( ) ; } Log . d ( TAG , "Total points for route polylines = " + totalPoints ) ; } }
@ Override public void setRouteOverlay ( int lineOverlayColor , ObaShape [] shapes ) { setRouteOverlay ( lineOverlayColor , shapes , true ) ; }
@ Override public void updateVehicles ( HashSet < String > routeIds , ObaTripsForRouteResponse response ) { setupVehicleOverlay ( ) ; if ( mVehicleOverlay != null ) { mVehicleOverlay . updateVehicles ( routeIds , response ) ; } }
@ Override public void removeVehicleOverlay ( ) { if ( mVehicleOverlay != null ) { mVehicleOverlay . clear ( ) ; } }
@ Override public void zoomToRoute ( ) { if ( mMap != null ) { if ( ! mLineOverlay . isEmpty ( ) ) { LatLngBounds . Builder builder = new LatLngBounds . Builder ( ) ; for ( Polyline p : mLineOverlay ) { for ( LatLng l : p . getPoints ( ) ) { builder . include ( l ) ; } } Activity a = getActivity ( ) ; if ( a != null ) { int padding = UIUtils . dpToPixels ( a , DEFAULT_MAP_PADDING_DP ) ; mMap . moveCamera ( ( CameraUpdateFactory . newLatLngBounds ( builder . build ( ) , padding ) ) ) ; } } else { Toast . makeText ( getActivity ( ) , getString ( R . string . route_info_no_shape_data ) , Toast . LENGTH_SHORT ) . show ( ) ; } } }
@ Override public void zoomToItinerary ( ) { if ( mMap != null ) { if ( ! mLineOverlay . isEmpty ( ) ) { LatLngBounds . Builder builder = new LatLngBounds . Builder ( ) ; for ( Polyline p : mLineOverlay ) { for ( LatLng l : p . getPoints ( ) ) { builder . include ( l ) ; } } Activity a = getActivity ( ) ; if ( a != null ) { int padding = UIUtils . dpToPixels ( a , DEFAULT_MAP_PADDING_DP ) ; mMap . moveCamera ( ( CameraUpdateFactory . newLatLngBounds ( builder . build ( ) , getResources ( ) . getDisplayMetrics ( ) . widthPixels , getResources ( ) . getDisplayMetrics ( ) . heightPixels , padding ) ) ) ; } } } }
@ Override public void zoomIncludeClosestVehicle ( HashSet < String > routeIds , ObaTripsForRouteResponse response ) { if ( mMap == null ) { return; } LatLng closestVehicleLocation = MapHelpV2 . getClosestVehicle ( response , routeIds , getMapCenterAsLocation ( ) ) ; LatLngBounds visibleBounds = mMap . getProjection ( ) . getVisibleRegion ( ) . latLngBounds ; if ( closestVehicleLocation == null || visibleBounds . contains ( closestVehicleLocation ) ) { return; } LatLngBounds . Builder builder = new LatLngBounds . Builder ( ) ; builder . include ( visibleBounds . northeast ) ; builder . include ( visibleBounds . southwest ) ; builder . include ( closestVehicleLocation ) ; Activity a = getActivity ( ) ; if ( a != null ) { int padding = UIUtils . dpToPixels ( a , DEFAULT_MAP_PADDING_DP ) ; mMap . animateCamera ( CameraUpdateFactory . newLatLngBounds ( builder . build ( ) , padding ) ) ; } }
@ Override public void removeRouteOverlay ( ) { for ( Polyline p : mLineOverlay ) { p . remove ( ) ; } mLineOverlay . clear ( ) ; }
@ Override public void removeStopOverlay ( boolean clearFocusedStop ) { if ( mStopOverlay != null ) { mStopOverlay . clear ( clearFocusedStop ) ; } }
@ Override public boolean canWatchMapChanges ( ) { return true ; }
@ Override public void setFocusStop ( ObaStop stop , List < ObaRoute > routes ) { if ( setupStopOverlay ( ) ) { mStopOverlay . setFocus ( stop , routes ) ; } }
@ Override public void onCameraChange ( CameraPosition cameraPosition ) { Log . d ( TAG , "onCameraChange" ) ; if ( mController != null ) { mController . notifyMapChanged ( ) ; } }
@ Override public void activate ( OnLocationChangedListener listener ) { mListener = listener ; }
@ Override public void deactivate ( ) { mListener = null ; }
public void onLocationChanged ( Location l ) { if ( mListener != null ) { mListener . onLocationChanged ( l ) ; } }
@ Override public void postInvalidate ( ) { }
@ Override public String getFocusedStopId ( ) { return mFocusStopId ; }
static MapDialogFragment newInstance ( int dialogType , BaseMapFragment fragment ) { mMapFragment = fragment ; MapDialogFragment f = new MapDialogFragment ( ) ; Bundle args = new Bundle ( ) ; args . putInt ( DIALOG_TYPE_KEY , dialogType ) ; f . setArguments ( args ) ; f . setCancelable ( false ) ; return f ; }
@ Override public Dialog onCreateDialog ( Bundle savedInstanceState ) { mDialogType = getArguments ( ) . getInt ( DIALOG_TYPE_KEY ) ; switch ( mDialogType ) { case NOLOCATION_DIALOG : return createNoLocationDialog ( ) ; case OUTOFRANGE_DIALOG : return createOutOfRangeDialog ( ) ; default: throw new IllegalArgumentException ( "Invalid map dialog type - " + DIALOG_TYPE_KEY ) ; } }
private Dialog createOutOfRangeDialog ( ) { Drawable icon = getResources ( ) . getDrawable ( android . R . drawable . ic_dialog_map ) ; DrawableCompat . setTint ( icon , getResources ( ) . getColor ( R . color . theme_primary ) ) ; AlertDialog . Builder builder = new AlertDialog . Builder ( getActivity ( ) ) . setTitle ( R . string . main_outofrange_title ) . setIcon ( icon ) . setCancelable ( false ) . setMessage ( getString ( R . string . main_outofrange , Application . get ( ) . getCurrentRegion ( ) != null ? Application . get ( ) . getCurrentRegion ( ) . getName ( ) : "" ) ) . setPositiveButton ( R . string . main_outofrange_yes , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { mMapFragment . zoomToRegion ( ) ; } } ) . setNegativeButton ( R . string . main_outofrange_no , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { mMapFragment . mWarnOutOfRange = false ; } } ) ; return builder . create ( ) ; }
@ Override public void onClick ( DialogInterface dialog , int which ) { mMapFragment . zoomToRegion ( ) ; }
@ Override public void onClick ( DialogInterface dialog , int which ) { mMapFragment . mWarnOutOfRange = false ; }
@ SuppressWarnings ( "deprecation" ) private Dialog createNoLocationDialog ( ) { View view = getActivity ( ) . getLayoutInflater ( ) . inflate ( R . layout . no_location_dialog , null ) ; CheckBox neverShowDialog = ( CheckBox ) view . findViewById ( R . id . location_never_ask_again ) ; neverShowDialog . setOnCheckedChangeListener ( new CompoundButton . OnCheckedChangeListener ( ) { @ Override public void onCheckedChanged ( CompoundButton compoundButton , boolean isChecked ) { PreferenceUtils . saveBoolean ( getString ( R . string . preference_key_never_show_location_dialog ) , isChecked ) ; } } ) ; Drawable icon = getResources ( ) . getDrawable ( android . R . drawable . ic_dialog_map ) ; DrawableCompat . setTint ( icon , getResources ( ) . getColor ( R . color . theme_primary ) ) ; AlertDialog . Builder builder = new AlertDialog . Builder ( getActivity ( ) ) . setTitle ( R . string . main_nolocation_title ) . setIcon ( icon ) . setCancelable ( false ) . setView ( view ) . setPositiveButton ( R . string . rt_yes , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { startActivityForResult ( new Intent ( Settings . ACTION_LOCATION_SOURCE_SETTINGS ) , REQUEST_NO_LOCATION ) ; } } ) . setNegativeButton ( R . string . rt_no , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { mMapFragment . mController . onLocation ( ) ; } } ) ; return builder . create ( ) ; }
@ Override public void onCheckedChanged ( CompoundButton compoundButton , boolean isChecked ) { PreferenceUtils . saveBoolean ( getString ( R . string . preference_key_never_show_location_dialog ) , isChecked ) ; }
@ Override public void onClick ( DialogInterface dialog , int which ) { startActivityForResult ( new Intent ( Settings . ACTION_LOCATION_SOURCE_SETTINGS ) , REQUEST_NO_LOCATION ) ; }
@ Override public void onClick ( DialogInterface dialog , int which ) { mMapFragment . mController . onLocation ( ) ; }
public void execute ( ) MojoExecutionException , MojoFailureException { if ( ! generateApk ) { return; } ConfigHandler cfh = new ConfigHandler ( this , this . session , this . execution ) ; cfh . parseConfiguration ( ) ; generateIntermediateApk ( ) ; if ( excludeJarResources != null && excludeJarResources . length > 0 ) { getLog ( ) . debug ( "Compiling " + excludeJarResources . length + " patterns" ) ; excludeJarResourcesPatterns = new Pattern [ excludeJarResources . length ] ; for ( int index = 0 ; index < excludeJarResources . length ; ++ index ) { excludeJarResourcesPatterns [ index ] = Pattern . compile ( excludeJarResources [ index ] ) ; } } File outputFile = new File ( outputApk ) ; final boolean signWithDebugKeyStore = getAndroidSigner ( ) . isSignWithDebugKeyStore ( ) ; if ( getAndroidSigner ( ) . shouldCreateBothSignedAndUnsignedApk ( ) ) { getLog ( ) . info ( "Creating debug key signed apk file " + outputFile ) ; createApkFile ( outputFile , true ) ; final File unsignedOutputFile = new File ( targetDirectory , finalName + "-unsigned." + APK ) ; getLog ( ) . info ( "Creating additional unsigned apk file " + unsignedOutputFile ) ; createApkFile ( unsignedOutputFile , false ) ; projectHelper . attachArtifact ( project , unsignedOutputFile , classifier == null ? "unsigned" : classifier + "_unsigned" ) ; } else { createApkFile ( outputFile , signWithDebugKeyStore ) ; } if ( classifier == null ) { project . getArtifact ( ) . setFile ( outputFile ) ; } else { projectHelper . attachArtifact ( project , AndroidExtension . APK , classifier , outputFile ) ; } }
void createApkFile ( File outputFile , boolean signWithDebugKeyStore ) throws MojoExecutionException { File dexFile = new File ( targetDirectory , "classes.dex" ) ; if ( ! dexFile . exists ( ) ) { dexFile = new File ( targetDirectory , "classes.zip" ) ; } File zipArchive = new File ( targetDirectory , finalName + ".ap_" ) ; ArrayList < File > sourceFolders = new ArrayList < File > ( ) ; if ( sourceDirectories != null ) { sourceFolders . addAll ( Arrays . asList ( sourceDirectories ) ) ; } ArrayList < File > jarFiles = new ArrayList < File > ( ) ; final Collection < File > nativeFolders = getNativeLibraryFolders ( ) ; getLog ( ) . info ( "Adding native libraries : " + nativeFolders ) ; doAPKWithAPKBuilder ( outputFile , dexFile , zipArchive , sourceFolders , jarFiles , nativeFolders , signWithDebugKeyStore ) ; if ( this . apkMetaInf != null ) { File outputJar = new File ( outputApk . substring ( 0 , outputApk . length ( ) - 3 ) + "jar" ) ; if ( outputJar . exists ( ) ) { jarFiles . add ( outputJar ) ; } else { getLog ( ) . warn ( "Output jar doesn't exist:" + outputJar ) ; } try { addMetaInf ( outputFile , jarFiles ) ; } catch ( IOException e ) { throw new MojoExecutionException ( "Could not add META-INF resources." , e ) ; } } }
private void addMetaInf ( File outputFile , ArrayList < File > jarFiles ) throws IOException { File tmp = File . createTempFile ( outputFile . getName ( ) , ".add" , outputFile . getParentFile ( ) ) ; FileOutputStream fos = new FileOutputStream ( tmp ) ; JarOutputStream zos = new JarOutputStream ( fos ) ; Set < String > entries = new HashSet < String > ( ) ; updateWithMetaInf ( zos , outputFile , entries , false ) ; for ( File f : jarFiles ) { updateWithMetaInf ( zos , f , entries , true ) ; } if ( transformers != null ) { for ( ResourceTransformer transformer : transformers ) { if ( transformer . hasTransformedResource ( ) ) { transformer . modifyOutputStream ( zos ) ; } } } zos . close ( ) ; outputFile . delete ( ) ; if ( ! tmp . renameTo ( outputFile ) ) { throw new IOException ( String . format ( "Cannot rename %s to %s" , tmp , outputFile . getName ( ) ) ) ; } }
private void updateWithMetaInf ( ZipOutputStream zos , File jarFile , Set < String > entries , boolean metaInfOnly )            throws IOException { ZipFile zin = new ZipFile ( jarFile ) ; for ( Enumeration < ? extends ZipEntry > en = zin . entries ( ) ; en . hasMoreElements ( ) ; ) { ZipEntry ze = en . nextElement ( ) ; if ( ze . isDirectory ( ) ) { continue; } String zn = ze . getName ( ) ; if ( metaInfOnly ) { if ( ! zn . startsWith ( "META-INF/" ) ) { continue; } if ( ! this . apkMetaInf . isIncluded ( zn ) ) { continue; } } boolean resourceTransformed = false ; if ( transformers != null ) { for ( ResourceTransformer transformer : transformers ) { if ( transformer . canTransformResource ( zn ) ) { getLog ( ) . info ( "Transforming " + zn + " using " + transformer . getClass ( ) . getName ( ) ) ; InputStream is = zin . getInputStream ( ze ) ; transformer . processResource ( zn , is , null ) ; is . close ( ) ; resourceTransformed = true ; break; } } } if ( ! resourceTransformed ) { if ( metaInfOnly && this . extractDuplicates && ! entries . add ( zn ) ) { continue; } InputStream is = zin . getInputStream ( ze ) ; final ZipEntry ne ; if ( ze . getMethod ( ) == ZipEntry . STORED ) { ne = new ZipEntry ( ze ) ; } else { ne = new ZipEntry ( zn ) ; } zos . putNextEntry ( ne ) ; copyStreamWithoutClosing ( is , zos ) ; is . close ( ) ; zos . closeEntry ( ) ; } } zin . close ( ) ; }
private void computeDuplicateFiles ( File jar ) throws IOException { ZipFile file = new ZipFile ( jar ) ; Enumeration < ? extends ZipEntry > list = file . entries ( ) ; while ( list . hasMoreElements ( ) ) { ZipEntry ze = list . nextElement ( ) ; if ( ! ( ze . getName ( ) . contains ( "META-INF/" ) || ze . isDirectory ( ) ) ) { List < File > l = jars . get ( ze . getName ( ) ) ; if ( l == null ) { l = new ArrayList < File > ( ) ; jars . put ( ze . getName ( ) , l ) ; } l . add ( jar ) ; } } }
private void computeDuplicateFilesInSource ( File folder ) { String rPath = folder . getAbsolutePath ( ) ; for ( File file : Files . fileTreeTraverser ( ) . breadthFirstTraversal ( folder ) . toList ( ) ) { String lPath = file . getAbsolutePath ( ) ; if ( lPath . equals ( rPath ) ) { continue; } lPath = lPath . substring ( rPath . length ( ) + 1 ) ; if ( jars . get ( lPath ) == null ) { jars . put ( lPath , new ArrayList < File > ( ) ) ; } jars . get ( lPath ) . add ( folder ) ; } }
private void extractDuplicateFiles ( List < File > jarFiles , Collection < File > sourceFolders ) throws IOException { getLog ( ) . debug ( "Extracting duplicates" ) ; List < String > duplicates = new ArrayList < String > ( ) ; List < File > jarToModify = new ArrayList < File > ( ) ; for ( String s : jars . keySet ( ) ) { List < File > l = jars . get ( s ) ; if ( l . size ( ) > 1 ) { getLog ( ) . warn ( "Duplicate file " + s + " : " + l ) ; duplicates . add ( s ) ; for ( int i = 0 ; i < l . size ( ) ; i ++ ) { if ( ! jarToModify . contains ( l . get ( i ) ) ) { jarToModify . add ( l . get ( i ) ) ; } } } } File tmp = new File ( targetDirectory . getAbsolutePath ( ) , "unpacked-embedded-jars" ) ; tmp . mkdirs ( ) ; File duplicatesJar = new File ( tmp , "duplicate-resources.jar" ) ; Set < String > duplicatesAdded = new HashSet < String > ( ) ; duplicatesJar . createNewFile ( ) ; final FileOutputStream fos = new FileOutputStream ( duplicatesJar ) ; final JarOutputStream zos = new JarOutputStream ( fos ) ; for ( File file : jarToModify ) { final int index = jarFiles . indexOf ( file ) ; if ( index != - 1 ) { final File newJar = removeDuplicatesFromJar ( file , duplicates , duplicatesAdded , zos , index ) ; getLog ( ) . debug ( "Removed duplicates from " + newJar ) ; if ( newJar != null ) { jarFiles . set ( index , newJar ) ; } } else { removeDuplicatesFromFolder ( file , file , duplicates , duplicatesAdded , zos ) ; getLog ( ) . debug ( "Removed duplicates from " + file ) ; } } if ( transformers != null ) { for ( ResourceTransformer transformer : transformers ) { if ( transformer . hasTransformedResource ( ) ) { transformer . modifyOutputStream ( zos ) ; } } } zos . close ( ) ; fos . close ( ) ; if ( ! jarToModify . isEmpty ( ) && duplicatesJar . length ( ) > 0 ) { jarFiles . add ( duplicatesJar ) ; } }
private void doAPKWithAPKBuilder ( File outputFile , File dexFile , File zipArchive , Collection < File > sourceFolders , List < File > jarFiles , Collection < File > nativeFolders , boolean signWithDebugKeyStore ) throws MojoExecutionException { getLog ( ) . debug ( "Building APK with internal APKBuilder" ) ; if ( projectOutputDirectory . exists ( ) || ! getJack ( ) . isEnabled ( ) ) { sourceFolders . add ( projectOutputDirectory ) ; } for ( Artifact artifact : filterArtifacts ( getRelevantCompileArtifacts ( ) , skipDependencies , artifactTypeSet . getIncludes ( ) , artifactTypeSet . getExcludes ( ) , artifactSet . getIncludes ( ) , artifactSet . getExcludes ( ) ) ) { getLog ( ) . debug ( "Found artifact for APK :" + artifact ) ; if ( extractDuplicates ) { try { computeDuplicateFiles ( artifact . getFile ( ) ) ; } catch ( Exception e ) { getLog ( ) . warn ( "Cannot compute duplicates files from " + artifact . getFile ( ) . getAbsolutePath ( ) , e ) ; } } jarFiles . add ( artifact . getFile ( ) ) ; } for ( File src : sourceFolders ) { computeDuplicateFilesInSource ( src ) ; } if ( extractDuplicates ) { try { extractDuplicateFiles ( jarFiles , sourceFolders ) ; } catch ( IOException e ) { getLog ( ) . error ( "Could not extract duplicates to duplicate-resources.jar" , e ) ; } } try { final String debugKeyStore = signWithDebugKeyStore ? ApkBuilder . getDebugKeystore ( ) : null ; final ApkBuilder apkBuilder = new ApkBuilder ( outputFile , zipArchive , dexFile , debugKeyStore , null ) ; if ( apkDebug ) { apkBuilder . setDebugMode ( true ) ; } for ( File sourceFolder : sourceFolders ) { getLog ( ) . debug ( "Adding source folder : " + sourceFolder ) ; apkBuilder . addSourceFolder ( sourceFolder ) ; } for ( File jarFile : jarFiles ) { boolean excluded = false ; if ( excludeJarResourcesPatterns != null ) { final String name = jarFile . getName ( ) ; getLog ( ) . debug ( "Checking " + name + " against patterns" ) ; for ( Pattern pattern : excludeJarResourcesPatterns ) { final Matcher matcher = pattern . matcher ( name ) ; if ( matcher . matches ( ) ) { getLog ( ) . debug ( "Jar " + name + " excluded by pattern " + pattern ) ; excluded = true ; break; } else { getLog ( ) . debug ( "Jar " + name + " not excluded by pattern " + pattern ) ; } } } if ( excluded ) { continue; } if ( jarFile . isDirectory ( ) ) { getLog ( ) . debug ( "Adding resources from jar folder : " + jarFile ) ; final String [] filenames = jarFile . list ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return PATTERN_JAR_EXT . matcher ( name ) . matches ( ) ; } } ) ; for ( String filename : filenames ) { final File innerJar = new File ( jarFile , filename ) ; getLog ( ) . debug ( "Adding resources from innerJar : " + innerJar ) ; apkBuilder . addResourcesFromJar ( innerJar ) ; } } else { getLog ( ) . debug ( "Adding resources from : " + jarFile ) ; apkBuilder . addResourcesFromJar ( jarFile ) ; } } addSecondaryDexes ( dexFile , apkBuilder ) ; for ( File nativeFolder : nativeFolders ) { getLog ( ) . debug ( "Adding native library : " + nativeFolder ) ; apkBuilder . addNativeLibraries ( nativeFolder ) ; } apkBuilder . sealApk ( ) ; } catch ( ApkCreationException e ) { throw new MojoExecutionException ( e . getMessage ( ) ) ; } catch ( DuplicateFileException e ) { final String msg = String . format ( "Duplicated file: %s, found in archive %s and %s" , e . getArchivePath ( ) , e . getFile1 ( ) , e . getFile2 ( ) ) ; throw new MojoExecutionException ( msg , e ) ; } catch ( SealedApkException e ) { throw new MojoExecutionException ( e . getMessage ( ) ) ; } }
public boolean accept ( File dir , String name ) { return PATTERN_JAR_EXT . matcher ( name ) . matches ( ) ; }
private void addSecondaryDexes ( File dexFile , ApkBuilder apkBuilder ) throws ApkCreationException , SealedApkException , DuplicateFileException { int dexNumber = 2 ; String dexFileName = getNextDexFileName ( dexNumber ) ; File secondDexFile = createNextDexFile ( dexFile , dexFileName ) ; while ( secondDexFile . exists ( ) ) { apkBuilder . addFile ( secondDexFile , dexFileName ) ; dexNumber ++ ; dexFileName = getNextDexFileName ( dexNumber ) ; secondDexFile = createNextDexFile ( dexFile , dexFileName ) ; } }
private File createNextDexFile ( File dexFile , String dexFileName ) { return new File ( dexFile . getParentFile ( ) , dexFileName ) ; }
private String getNextDexFileName ( int dexNumber ) { return CLASSES + dexNumber + DEX_SUFFIX ; }
private File removeDuplicatesFromJar ( File in , List < String > duplicates , Set < String > duplicatesAdded , ZipOutputStream duplicateZos , int num ) { String target = targetDirectory . getAbsolutePath ( ) ; File tmp = new File ( target , "unpacked-embedded-jars" ) ; tmp . mkdirs ( ) ; String jarName = String . format ( "%s-%d.%s" , Files . getNameWithoutExtension ( in . getName ( ) ) , num , Files . getFileExtension ( in . getName ( ) ) ) ; File out = new File ( tmp , jarName ) ; if ( out . exists ( ) ) { return out ; } else { try { out . createNewFile ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } final FileOutputStream fos ; final ZipOutputStream jos ; try { fos = new FileOutputStream ( out ) ; jos = new ZipOutputStream ( fos ) ; } catch ( FileNotFoundException e1 ) { getLog ( ) . error ( "Cannot remove duplicates : the output file " + out . getAbsolutePath ( ) + " does not found" ) ; return null ; } final ZipFile inZip ; try { inZip = new ZipFile ( in ) ; Enumeration < ? extends ZipEntry > entries = inZip . entries ( ) ; while ( entries . hasMoreElements ( ) ) { ZipEntry entry = entries . nextElement ( ) ; if ( ! duplicates . contains ( entry . getName ( ) ) ) { jos . putNextEntry ( entry ) ; InputStream currIn = inZip . getInputStream ( entry ) ; copyStreamWithoutClosing ( currIn , jos ) ; currIn . close ( ) ; jos . closeEntry ( ) ; } else { boolean resourceTransformed = false ; if ( transformers != null ) { for ( ResourceTransformer transformer : transformers ) { if ( transformer . canTransformResource ( entry . getName ( ) ) ) { getLog ( ) . info ( "Transforming " + entry . getName ( ) + " using " + transformer . getClass ( ) . getName ( ) ) ; InputStream currIn = inZip . getInputStream ( entry ) ; transformer . processResource ( entry . getName ( ) , currIn , null ) ; currIn . close ( ) ; resourceTransformed = true ; break; } } } if ( ! resourceTransformed ) { if ( ! duplicatesAdded . contains ( entry . getName ( ) ) ) { duplicatesAdded . add ( entry . getName ( ) ) ; duplicateZos . putNextEntry ( entry ) ; InputStream currIn = inZip . getInputStream ( entry ) ; copyStreamWithoutClosing ( currIn , duplicateZos ) ; currIn . close ( ) ; duplicateZos . closeEntry ( ) ; } } } } } catch ( IOException e ) { getLog ( ) . error ( "Cannot removing duplicates : " + e . getMessage ( ) ) ; return null ; } try { inZip . close ( ) ; jos . close ( ) ; fos . close ( ) ; } catch ( IOException e ) { } getLog ( ) . info ( in . getName ( ) + " rewritten without duplicates : " + out . getAbsolutePath ( ) ) ; return out ; }
private void removeDuplicatesFromFolder ( File root , File in , List < String > duplicates , Set < String > duplicatesAdded , ZipOutputStream duplicateZos ) { String rPath = root . getAbsolutePath ( ) ; try { for ( File f : in . listFiles ( ) ) { if ( f . isDirectory ( ) ) { removeDuplicatesFromFolder ( root , f , duplicates , duplicatesAdded , duplicateZos ) ; } else { String lName = f . getAbsolutePath ( ) ; lName = lName . substring ( rPath . length ( ) + 1 ) ; if ( duplicates . contains ( lName ) ) { boolean resourceTransformed = false ; if ( transformers != null ) { for ( ResourceTransformer transformer : transformers ) { if ( transformer . canTransformResource ( lName ) ) { getLog ( ) . info ( "Transforming " + lName + " using " + transformer . getClass ( ) . getName ( ) ) ; InputStream currIn = new FileInputStream ( f ) ; transformer . processResource ( lName , currIn , null ) ; currIn . close ( ) ; resourceTransformed = true ; break; } } } if ( ! resourceTransformed ) { if ( ! duplicatesAdded . contains ( lName ) ) { duplicatesAdded . add ( lName ) ; ZipEntry entry = new ZipEntry ( lName ) ; duplicateZos . putNextEntry ( entry ) ; InputStream currIn = new FileInputStream ( f ) ; copyStreamWithoutClosing ( currIn , duplicateZos ) ; currIn . close ( ) ; duplicateZos . closeEntry ( ) ; } } f . delete ( ) ; } } } } catch ( IOException e ) { getLog ( ) . error ( "Cannot removing duplicates : " + e . getMessage ( ) ) ; } }
private static void copyStreamWithoutClosing ( InputStream in , OutputStream out ) throws IOException { final int bufferSize = 4096 ; byte [] b = new byte [ bufferSize ] ; int n ; while ( ( n = in . read ( b ) ) != - 1 ) { out . write ( b , 0 , n ) ; } }
private Collection < File > getNativeLibraryFolders ( ) MojoExecutionException { final List < File > natives = new ArrayList < File > ( ) ; if ( nativeLibrariesDirectory . exists ( ) ) { copyLocalNativeLibraries ( nativeLibrariesDirectory , ndkOutputDirectory ) ; } final Set < Artifact > artifacts = getNativeLibraryArtifacts ( ) ; for ( Artifact resolvedArtifact : artifacts ) { if ( APKLIB . equals ( resolvedArtifact . getType ( ) ) || AAR . equals ( resolvedArtifact . getType ( ) ) ) { final File folder = getUnpackedLibNativesFolder ( resolvedArtifact ) ; getLog ( ) . debug ( "Adding native library folder " + folder ) ; natives . add ( folder ) ; } for ( String ndkArchitecture : AndroidNdk . NDK_ARCHITECTURES ) { if ( NativeHelper . artifactHasHardwareArchitecture ( resolvedArtifact , ndkArchitecture , nativeLibrariesDependenciesHardwareArchitectureDefault ) ) { copyNativeLibraryArtifact ( resolvedArtifact , ndkOutputDirectory , ndkArchitecture ) ; } } } if ( apkDebug ) { for ( String ndkArchitecture : AndroidNdk . NDK_ARCHITECTURES ) { copyGdbServer ( ndkOutputDirectory , ndkArchitecture ) ; } } if ( ndkOutputDirectory . exists ( ) ) { getLog ( ) . debug ( "Adding built native library folder " + ndkOutputDirectory ) ; natives . add ( ndkOutputDirectory ) ; } return natives ; }
private Set < Artifact > getNativeLibraryArtifacts ( ) MojoExecutionException { return getNativeHelper ( ) . getNativeDependenciesArtifacts ( this , getUnpackedLibsDirectory ( ) , true ) ; }
private void copyNativeLibraryArtifact ( Artifact artifact , File destinationDirectory , String ndkArchitecture ) throws MojoExecutionException { final File artifactFile = getArtifactResolverHelper ( ) . resolveArtifactToFile ( artifact ) ; try { final String artifactId = artifact . getArtifactId ( ) ; String filename = artifactId . startsWith ( "lib" ) ? artifactId + ".so" : "lib" + artifactId + ".so" ; if ( ndkFinalLibraryName != null && artifact . getFile ( ) . getName ( ) . startsWith ( "lib" + ndkFinalLibraryName ) ) { filename = artifact . getFile ( ) . getName ( ) ; } final File folder = new File ( destinationDirectory , ndkArchitecture ) ; final File file = new File ( folder , filename ) ; getLog ( ) . debug ( "Copying native dependency " + artifactId + " (" + artifact . getGroupId ( ) + ") to " + file ) ; FileUtils . copyFile ( artifactFile , file ) ; } catch ( IOException e ) { throw new MojoExecutionException ( "Could not copy native dependency." , e ) ; } }
private void copyGdbServer ( File destinationDirectory , String architecture ) throws MojoExecutionException { try { final File destDir = new File ( destinationDirectory , architecture ) ; if ( destDir . exists ( ) ) { final File gdbServerFile = getAndroidNdk ( ) . getGdbServer ( architecture ) ; final File destFile = new File ( destDir , "gdbserver" ) ; if ( ! destFile . exists ( ) ) { getLog ( ) . debug ( "Copying gdbServer to " + destFile ) ; FileUtils . copyFile ( gdbServerFile , destFile ) ; } else { getLog ( ) . info ( "Note: gdbserver binary already exists at destination, will not copy over" ) ; } } } catch ( Exception e ) { getLog ( ) . error ( "Error while copying gdbserver: " + e . getMessage ( ) , e ) ; throw new MojoExecutionException ( "Error while copying gdbserver: " + e . getMessage ( ) , e ) ; } }
private void copyLocalNativeLibraries ( final File localNativeLibrariesDirectory , final File destinationDirectory )            throws MojoExecutionException { getLog ( ) . debug ( "Copying existing native libraries from " + localNativeLibrariesDirectory ) ; try { IOFileFilter libSuffixFilter = FileFilterUtils . suffixFileFilter ( ".so" ) ; IOFileFilter gdbserverNameFilter = FileFilterUtils . nameFileFilter ( "gdbserver" ) ; IOFileFilter orFilter = FileFilterUtils . or ( libSuffixFilter , gdbserverNameFilter ) ; IOFileFilter libFiles = FileFilterUtils . and ( FileFileFilter . FILE , orFilter ) ; FileFilter filter = FileFilterUtils . or ( DirectoryFileFilter . DIRECTORY , libFiles ) ; org . apache . commons . io . FileUtils . copyDirectory ( localNativeLibrariesDirectory , destinationDirectory , filter ) ; } catch ( IOException e ) { getLog ( ) . error ( "Could not copy native libraries: " + e . getMessage ( ) , e ) ; throw new MojoExecutionException ( "Could not copy native dependency." , e ) ; } }
private void generateIntermediateApk ( ) MojoExecutionException { CommandExecutor executor = CommandExecutor . Factory . createDefaultCommmandExecutor ( ) ; executor . setLogger ( this . getLog ( ) ) ; File [] overlayDirectories = getResourceOverlayDirectories ( ) ; File androidJar = getAndroidSdk ( ) . getAndroidJar ( ) ; File outputFile = new File ( targetDirectory , finalName + ".ap_" ) ; List < File > dependencyArtifactResDirectoryList = new ArrayList < File > ( ) ; for ( Artifact libraryArtifact : getTransitiveDependencyArtifacts ( APKLIB , AAR ) ) { final File libraryResDir = getUnpackedLibResourceFolder ( libraryArtifact ) ; if ( libraryResDir . exists ( ) ) { dependencyArtifactResDirectoryList . add ( libraryResDir ) ; } } AaptCommandBuilder commandBuilder = AaptCommandBuilder . packageResources ( getLog ( ) ) . forceOverwriteExistingFiles ( ) . setPathToAndroidManifest ( destinationManifestFile ) . addResourceDirectoriesIfExists ( overlayDirectories ) . addResourceDirectoryIfExists ( resourceDirectory ) . addResourceDirectoriesIfExists ( dependencyArtifactResDirectoryList ) . autoAddOverlay ( ) . addRawAssetsDirectoryIfExists ( combinedAssets ) . renameManifestPackage ( renameManifestPackage ) . renameInstrumentationTargetPackage ( renameInstrumentationTargetPackage ) . addExistingPackageToBaseIncludeSet ( androidJar ) . setOutputApkFile ( outputFile ) . addConfigurations ( configurations ) . setVerbose ( aaptVerbose ) . setDebugMode ( ! release ) . addExtraArguments ( aaptExtraArgs ) ; getLog ( ) . debug ( getAndroidSdk ( ) . getAaptPath ( ) + " " + commandBuilder . toString ( ) ) ; try { executor . setCaptureStdOut ( true ) ; List < String > commands = commandBuilder . build ( ) ; executor . executeCommand ( getAndroidSdk ( ) . getAaptPath ( ) , commands , project . getBasedir ( ) , false ) ; } catch ( ExecutionException e ) { throw new MojoExecutionException ( "" , e ) ; } }
protected AndroidSigner getAndroidSigner ( ) { if ( sign == null ) { return new AndroidSigner ( signDebug ) ; } else { return new AndroidSigner ( sign . getDebug ( ) ) ; } }
private MetaInf getDefaultMetaInf ( ) { if ( apkMetaIncludes != null && apkMetaIncludes . length > 0 ) { return new MetaInf ( ) . include ( apkMetaIncludes ) ; } return this . pluginMetaInf ; }
public CommonSQLiteOpenHelper ( @ Nonnull Context context , @ Nonnull SQLiteOpenHelperConfiguration configuration ) { super( context . getApplicationContext ( ) , configuration . getName ( ) , configuration . getCursorFactory ( ) , configuration . getVersion ( ) ); this . context = context . getApplicationContext ( ) ; this . databaseName = configuration . getName ( ) ; this . version = configuration . getVersion ( ) ; }
@ Override public void onCreate ( @ Nonnull SQLiteDatabase db ) { onUpgrade ( db , 0 , this . version ) ; }
@ Override public void onUpgrade ( @ Nonnull SQLiteDatabase db , int oldVersion , int newVersion ) { Log . d ( TAG , "Upgrading database, old version: " + oldVersion + ", new version: " + newVersion ) ; final DecimalFormat decimalFormat = new DecimalFormat ( "000" , new DecimalFormatSymbols ( Locale . US ) ) ; for ( int version = oldVersion + 1 ; version <= newVersion ; version ++ ) { try { final String fileVersionPostfix = decimalFormat . format ( version ) ; final String fileName = "db_" + databaseName + "_" + fileVersionPostfix + ".sql" ; Log . d ( TAG , "Reading " + fileName + "..." ) ; final String sqls = convertStreamToString ( context . getAssets ( ) . open ( fileName ) ) ; Log . d ( TAG , fileName + " successfully read, size: " + sqls . length ( ) ) ; new BatchDbTransaction ( sqls , ";\n" ) . batchQuery ( db ) ; } catch ( FileNotFoundException e ) { Log . d ( TAG , e . getMessage ( ) ) ; } catch ( IOException e ) { Log . e ( TAG , e . getMessage ( ) ) ; throw new RuntimeException ( e ) ; } } }
@ Nonnull public String convertStreamToString ( java . io . InputStream is ) { try { return new Scanner ( is , "UTF-8" ) . useDelimiter ( "\\A" ) . next ( ) ; } catch ( java . util . NoSuchElementException e ) { return "" ; } }
public MatcherPattern ( TableInfo tableInfo , SubType subType , String pattern , int patternCode ) { this . tableInfo = tableInfo ; this . subType = subType ; this . pattern = pattern ; this . patternCode = patternCode ; if ( this . tableInfo . getDefaultContentUriInfo ( ) . isValid ( ) ) { this . contentUriInfo = this . tableInfo . getDefaultContentUriInfo ( ) ; } else { this . contentUriInfo = null ; } if ( this . tableInfo . getDefaultContentMimeTypeVndInfo ( ) . isValid ( ) ) { this . contentMimeTypeVndInfo = this . tableInfo . getDefaultContentMimeTypeVndInfo ( ) ; } else { this . contentMimeTypeVndInfo = null ; } if ( this . contentMimeTypeVndInfo != null ) { this . mimeTypeVnd = new MimeTypeVnd ( this . subType , this . contentMimeTypeVndInfo ) ; } else { this . mimeTypeVnd = null ; } }
@ Override public boolean isValid ( ) { return isValid ( false ) ; }
@ Override public boolean isValid ( boolean throwException ) { boolean result = true ; if ( this . tableInfo == null ) { result = false ; if ( throwException && ! result ) { throw new IllegalStateException ( "tableInfo is null." ) ; } } else if ( this . subType == null ) { result = false ; if ( throwException && ! result ) { throw new IllegalStateException ( "subType is null." ) ; } } else if ( pattern == null ) { result = false ; if ( throwException && ! result ) { throw new IllegalStateException ( "pattern is null." ) ; } } else if ( this . patternCode <= 0 ) { result = false ; if ( throwException && ! result ) { throw new IllegalStateException ( "patternCode is zero." ) ; } } else if ( this . contentUriInfo == null || ! this . contentUriInfo . isValid ( ) ) { result = false ; if ( throwException && ! result ) { throw new IllegalStateException ( "contentUriInfo is invalid." ) ; } } else if ( this . contentMimeTypeVndInfo == null || ! this . contentMimeTypeVndInfo . isValid ( ) ) { result = false ; if ( throwException && ! result ) { throw new IllegalStateException ( "contentMimeTypeVndInfo is invalid." ) ; } } else if ( this . mimeTypeVnd == null || ! this . mimeTypeVnd . isValid ( ) ) { result = false ; if ( throwException && ! result ) { throw new IllegalStateException ( "mimeTypeVnd is invalid." ) ; } } return result ; }
protected void initialize ( ) { this . initialized = true ; }
public MatcherPattern setContentUri ( ContentUriInfo contentUriInfo ) { if ( this . initialized ) { throw new IllegalStateException ( "Can't change the settings after initialization." ) ; } this . contentUriInfo = contentUriInfo ; return this ; }
public MatcherPattern setContentUri ( String authority , String path ) { return this . setContentUri ( new ContentUriInfo ( authority , path ) ) ; }
public MatcherPattern setContentMimeTypeVnd ( ContentMimeTypeVndInfo contentMimeTypeVndInfo ) { if ( this . initialized ) { throw new IllegalStateException ( "Can't change the settings after initialization." ) ; } this . contentMimeTypeVndInfo = contentMimeTypeVndInfo ; this . mimeTypeVnd = new MimeTypeVnd ( this . subType , this . contentMimeTypeVndInfo ) ; return this ; }
public MatcherPattern setContentMimeTypeVnd ( String name , String type ) { return this . setContentMimeTypeVnd ( new ContentMimeTypeVndInfo ( name , type ) ) ; }
public TableInfo getTableInfo ( ) { return this . tableInfo ; }
public SubType getSubType ( ) { return this . subType ; }
public String getPattern ( ) { return this . pattern ; }
public int getPatternCode ( ) { return this . patternCode ; }
public ContentUriInfo getContentUriInfo ( ) { return this . contentUriInfo ; }
public MimeTypeVnd getMimeTypeVnd ( ) { return this . mimeTypeVnd ; }
public String getPathAndPatternString ( ) { return this . contentUriInfo . getPath ( ) + "/" + this . pattern ; }
public Uri getContentUriPattern ( ) { return Uri . parse ( this . contentUriInfo . getContentUri ( ) + "/" + this . pattern ) ; }
public String getMimeTypeVndString ( ) { return this . mimeTypeVnd . getMimeTypeString ( ) ; }
@ Override public String toString ( ) { return getContentUriPattern ( ) . toString ( ) ; }
public UiSettingsAssert ( UiSettings actual ) { super( actual , UiSettingsAssert .class ); }
public UiSettingsAssert hasCompassEnabled ( ) { isNotNull ( ) ; assertThat ( actual . isCompassEnabled ( ) ) . overridingErrorMessage ( "Expected compass to be enabled but was disabled." ) . isTrue ( ) ; return this ; }
public UiSettingsAssert hasCompassDisabled ( ) { isNotNull ( ) ; assertThat ( actual . isCompassEnabled ( ) ) . overridingErrorMessage ( "Expected compass to be disabled but was enabled." ) . isFalse ( ) ; return this ; }
public UiSettingsAssert hasIndoorLevelPickerEnabled ( ) { isNotNull ( ) ; assertThat ( actual . isIndoorLevelPickerEnabled ( ) ) . overridingErrorMessage ( "Expected indoor level picker to be enabled but was disabled." ) . isTrue ( ) ; return this ; }
public UiSettingsAssert hasIndoorLevelPickerDisabled ( ) { isNotNull ( ) ; assertThat ( actual . isIndoorLevelPickerEnabled ( ) ) . overridingErrorMessage ( "Expected indoor level picker to be disabled but was enabled." ) . isFalse ( ) ; return this ; }
public UiSettingsAssert hasMyLocationButtonEnabled ( ) { isNotNull ( ) ; assertThat ( actual . isMyLocationButtonEnabled ( ) ) . overridingErrorMessage ( "Expected my location button to be enabled but was disabled." ) . isTrue ( ) ; return this ; }
public UiSettingsAssert hasMyLocationButtonDisabled ( ) { isNotNull ( ) ; assertThat ( actual . isMyLocationButtonEnabled ( ) ) . overridingErrorMessage ( "Expected my location button to be disabled but was enabled." ) . isFalse ( ) ; return this ; }
public UiSettingsAssert hasRotateGesturesEnabled ( ) { isNotNull ( ) ; assertThat ( actual . isRotateGesturesEnabled ( ) ) . overridingErrorMessage ( "Expected rotate gestures to be enabled but was disabled." ) . isTrue ( ) ; return this ; }
public UiSettingsAssert hasRotateGesturesDisabled ( ) { isNotNull ( ) ; assertThat ( actual . isRotateGesturesEnabled ( ) ) . overridingErrorMessage ( "Expected rotate gestures to be disabled but was enabled." ) . isFalse ( ) ; return this ; }
public UiSettingsAssert hasScrollGesturesEnabled ( ) { isNotNull ( ) ; assertThat ( actual . isScrollGesturesEnabled ( ) ) . overridingErrorMessage ( "Expected scroll gestures to be enabled but was disabled." ) . isTrue ( ) ; return this ; }
public UiSettingsAssert hasScrollGesturesDisabled ( ) { isNotNull ( ) ; assertThat ( actual . isScrollGesturesEnabled ( ) ) . overridingErrorMessage ( "Expected scroll gestures to be disabled but was enabled." ) . isFalse ( ) ; return this ; }
public UiSettingsAssert hasTiltGesturesEnabled ( ) { isNotNull ( ) ; assertThat ( actual . isTiltGesturesEnabled ( ) ) . overridingErrorMessage ( "Expected tilt gestures to be enabled but was disabled." ) . isTrue ( ) ; return this ; }
public UiSettingsAssert hasTiltGesturesDisabled ( ) { isNotNull ( ) ; assertThat ( actual . isTiltGesturesEnabled ( ) ) . overridingErrorMessage ( "Expected tilt gestures to be disabled but was enabled." ) . isFalse ( ) ; return this ; }
public UiSettingsAssert hasZoomControlsEnabled ( ) { isNotNull ( ) ; assertThat ( actual . isZoomControlsEnabled ( ) ) . overridingErrorMessage ( "Expected zoom controls to be enabled but was disabled." ) . isTrue ( ) ; return this ; }
public UiSettingsAssert hasZoomControlsDisabled ( ) { isNotNull ( ) ; assertThat ( actual . isZoomControlsEnabled ( ) ) . overridingErrorMessage ( "Expected zoom controls to be disabled but was enabled." ) . isFalse ( ) ; return this ; }
public UiSettingsAssert hasZoomGesturesEnabled ( ) { isNotNull ( ) ; assertThat ( actual . isZoomGesturesEnabled ( ) ) . overridingErrorMessage ( "Expected zoom gestures to be enabled but was disabled." ) . isTrue ( ) ; return this ; }
public UiSettingsAssert hasZoomGesturesDisabled ( ) { isNotNull ( ) ; assertThat ( actual . isZoomGesturesEnabled ( ) ) . overridingErrorMessage ( "Expected zoom gestures to be disabled but was enabled." ) . isFalse ( ) ; return this ; }
public GPUImageSmoothToonFilter ( ) { blurFilter = new GPUImageGaussianBlurFilter ( ) ; addFilter ( blurFilter ) ; toonFilter = new GPUImageToonFilter ( ) ; addFilter ( toonFilter ) ; getFilters ( ) . add ( blurFilter ) ; setBlurSize ( 0.5f ) ; setThreshold ( 0.2f ) ; setQuantizationLevels ( 10.0f ) ; }
public void setTexelWidth ( float value ) { toonFilter . setTexelWidth ( value ) ; }
public void setTexelHeight ( float value ) { toonFilter . setTexelHeight ( value ) ; }
public void setBlurSize ( float value ) { blurFilter . setBlurSize ( value ) ; }
public void setThreshold ( float value ) { toonFilter . setThreshold ( value ) ; }
public void setQuantizationLevels ( float value ) { toonFilter . setQuantizationLevels ( value ) ; }
@ Before public void setUp ( ) { RxJavaPlugins . reset ( ) ; pauseMainLooper ( ) ; }
@ After public void tearDown ( ) { RxJavaPlugins . reset ( ) ; unPauseMainLooper ( ) ; }
@ Test public void directScheduleOncePostsImmediately ( ) { CountingRunnable counter = new CountingRunnable ( ) ; scheduler . scheduleDirect ( counter ) ; runUiThreadTasks ( ) ; assertEquals ( 1 , counter . get ( ) ) ; }
@ Test public void directScheduleOnceWithNegativeDelayPostsImmediately ( ) { CountingRunnable counter = new CountingRunnable ( ) ; scheduler . scheduleDirect ( counter , - 1 , TimeUnit . MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 1 , counter . get ( ) ) ; }
@ Test public void directScheduleOnceUsesHook ( ) { final CountingRunnable newCounter = new CountingRunnable ( ) ; final AtomicReference < Runnable > runnableRef = new AtomicReference <> ( ) ; RxJavaPlugins . setScheduleHandler ( new Function < Runnable , Runnable > ( ) { @ Override public Runnable apply ( Runnable runnable ) { runnableRef . set ( runnable ) ; return newCounter ; } } ) ; CountingRunnable counter = new CountingRunnable ( ) ; scheduler . scheduleDirect ( counter ) ; assertSame ( counter , runnableRef . get ( ) ) ; runUiThreadTasks ( ) ; assertEquals ( 1 , newCounter . get ( ) ) ; assertEquals ( 0 , counter . get ( ) ) ; }
@ Override public Runnable apply ( Runnable runnable ) { runnableRef . set ( runnable ) ; return newCounter ; }
@ Test public void directScheduleOnceDisposedDoesNotRun ( ) { CountingRunnable counter = new CountingRunnable ( ) ; Disposable disposable = scheduler . scheduleDirect ( counter ) ; disposable . dispose ( ) ; runUiThreadTasks ( ) ; assertEquals ( 0 , counter . get ( ) ) ; }
@ Test public void directScheduleOnceWithDelayPostsWithDelay ( ) { CountingRunnable counter = new CountingRunnable ( ) ; scheduler . scheduleDirect ( counter , 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 0 , counter . get ( ) ) ; idleMainLooper ( 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 1 , counter . get ( ) ) ; }
@ Test public void directScheduleOnceWithDelayUsesHook ( ) { final CountingRunnable newCounter = new CountingRunnable ( ) ; final AtomicReference < Runnable > runnableRef = new AtomicReference <> ( ) ; RxJavaPlugins . setScheduleHandler ( new Function < Runnable , Runnable > ( ) { @ Override public Runnable apply ( Runnable runnable ) { runnableRef . set ( runnable ) ; return newCounter ; } } ) ; CountingRunnable counter = new CountingRunnable ( ) ; scheduler . scheduleDirect ( counter , 1 , MINUTES ) ; assertSame ( counter , runnableRef . get ( ) ) ; idleMainLooper ( 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 1 , newCounter . get ( ) ) ; assertEquals ( 0 , counter . get ( ) ) ; }
@ Override public Runnable apply ( Runnable runnable ) { runnableRef . set ( runnable ) ; return newCounter ; }
@ Test public void directScheduleOnceWithDelayDisposedDoesNotRun ( ) { CountingRunnable counter = new CountingRunnable ( ) ; Disposable disposable = scheduler . scheduleDirect ( counter , 1 , MINUTES ) ; idleMainLooper ( 30 , SECONDS ) ; disposable . dispose ( ) ; idleMainLooper ( 30 , SECONDS ) ; runUiThreadTasks ( ) ; assertEquals ( 0 , counter . get ( ) ) ; }
@ Test @ Ignore ( "Implementation delegated to default RxJava implementation" ) public void directSchedulePeriodicallyReschedulesItself ( ) { CountingRunnable counter = new CountingRunnable ( ) ; scheduler . schedulePeriodicallyDirect ( counter , 1 , 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 0 , counter . get ( ) ) ; idleMainLooper ( 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 1 , counter . get ( ) ) ; idleMainLooper ( 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 2 , counter . get ( ) ) ; idleMainLooper ( 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 3 , counter . get ( ) ) ; }
@ Test @ Ignore ( "Implementation delegated to default RxJava implementation" ) public void directSchedulePeriodicallyUsesHookOnce ( ) { final CountingRunnable newCounter = new CountingRunnable ( ) ; final AtomicReference < Runnable > runnableRef = new AtomicReference <> ( ) ; RxJavaPlugins . setScheduleHandler ( new Function < Runnable , Runnable > ( ) { @ Override public Runnable apply ( Runnable runnable ) { runnableRef . set ( runnable ) ; return newCounter ; } } ) ; CountingRunnable counter = new CountingRunnable ( ) ; scheduler . schedulePeriodicallyDirect ( counter , 1 , 1 , MINUTES ) ; assertSame ( counter , runnableRef . get ( ) ) ; runnableRef . set ( null ) ; idleMainLooper ( 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 1 , newCounter . get ( ) ) ; assertEquals ( 0 , counter . get ( ) ) ; assertNull ( runnableRef . get ( ) ) ; }
@ Override public Runnable apply ( Runnable runnable ) { runnableRef . set ( runnable ) ; return newCounter ; }
@ Test @ Ignore ( "Implementation delegated to default RxJava implementation" ) public void directSchedulePeriodicallyDisposedDoesNotRun ( ) { CountingRunnable counter = new CountingRunnable ( ) ; Disposable disposable = scheduler . schedulePeriodicallyDirect ( counter , 1 , 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 0 , counter . get ( ) ) ; idleMainLooper ( 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 1 , counter . get ( ) ) ; idleMainLooper ( 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 2 , counter . get ( ) ) ; disposable . dispose ( ) ; idleMainLooper ( 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 2 , counter . get ( ) ) ; }
@ Test @ Ignore ( "Implementation delegated to default RxJava implementation" ) public void directSchedulePeriodicallyDisposedDuringRunDoesNotReschedule ( ) { final AtomicReference < Disposable > disposableRef = new AtomicReference <> ( ) ; CountingRunnable counter = new CountingRunnable ( ) { @ Override public void run ( ) { super. run ( ) ; if ( get ( ) == 2 ) { disposableRef . get ( ) . dispose ( ) ; } } } ; Disposable disposable = scheduler . schedulePeriodicallyDirect ( counter , 1 , 1 , MINUTES ) ; disposableRef . set ( disposable ) ; runUiThreadTasks ( ) ; assertEquals ( 0 , counter . get ( ) ) ; idleMainLooper ( 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 1 , counter . get ( ) ) ; idleMainLooper ( 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 2 , counter . get ( ) ) ; idleMainLooper ( 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 2 , counter . get ( ) ) ; }
@ Override public void run ( ) { super. run ( ) ; if ( get ( ) == 2 ) { disposableRef . get ( ) . dispose ( ) ; } }
@ Test @ Ignore ( "Implementation delegated to default RxJava implementation" ) public void directSchedulePeriodicallyThrowingDoesNotReschedule ( ) { CountingRunnable counter = new CountingRunnable ( ) { @ Override public void run ( ) { super. run ( ) ; if ( get ( ) == 2 ) { throw new RuntimeException ( "Broken!" ) ; } } } ; scheduler . schedulePeriodicallyDirect ( counter , 1 , 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 0 , counter . get ( ) ) ; idleMainLooper ( 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 1 , counter . get ( ) ) ; idleMainLooper ( 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 2 , counter . get ( ) ) ; idleMainLooper ( 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 2 , counter . get ( ) ) ; }
@ Override public void run ( ) { super. run ( ) ; if ( get ( ) == 2 ) { throw new RuntimeException ( "Broken!" ) ; } }
@ Test public void workerScheduleOncePostsImmediately ( ) { Worker worker = scheduler . createWorker ( ) ; CountingRunnable counter = new CountingRunnable ( ) ; worker . schedule ( counter ) ; runUiThreadTasks ( ) ; assertEquals ( 1 , counter . get ( ) ) ; }
@ Test public void workerScheduleOnceWithNegativeDelayPostsImmediately ( ) { Worker worker = scheduler . createWorker ( ) ; CountingRunnable counter = new CountingRunnable ( ) ; worker . schedule ( counter , - 1 , TimeUnit . MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 1 , counter . get ( ) ) ; }
@ Test public void workerScheduleOnceUsesHook ( ) { final CountingRunnable newCounter = new CountingRunnable ( ) ; final AtomicReference < Runnable > runnableRef = new AtomicReference <> ( ) ; RxJavaPlugins . setScheduleHandler ( new Function < Runnable , Runnable > ( ) { @ Override public Runnable apply ( Runnable runnable ) { runnableRef . set ( runnable ) ; return newCounter ; } } ) ; Worker worker = scheduler . createWorker ( ) ; CountingRunnable counter = new CountingRunnable ( ) ; worker . schedule ( counter ) ; assertSame ( counter , runnableRef . get ( ) ) ; runUiThreadTasks ( ) ; assertEquals ( 1 , newCounter . get ( ) ) ; assertEquals ( 0 , counter . get ( ) ) ; }
@ Override public Runnable apply ( Runnable runnable ) { runnableRef . set ( runnable ) ; return newCounter ; }
@ Test public void workerScheduleOnceDisposedDoesNotRun ( ) { Worker worker = scheduler . createWorker ( ) ; CountingRunnable counter = new CountingRunnable ( ) ; Disposable disposable = worker . schedule ( counter ) ; disposable . dispose ( ) ; runUiThreadTasks ( ) ; assertEquals ( 0 , counter . get ( ) ) ; }
@ Test public void workerScheduleOnceWithDelayPostsWithDelay ( ) { Worker worker = scheduler . createWorker ( ) ; CountingRunnable counter = new CountingRunnable ( ) ; worker . schedule ( counter , 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 0 , counter . get ( ) ) ; idleMainLooper ( 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 1 , counter . get ( ) ) ; }
@ Test public void workerScheduleOnceWithDelayUsesHook ( ) { final CountingRunnable newCounter = new CountingRunnable ( ) ; final AtomicReference < Runnable > runnableRef = new AtomicReference <> ( ) ; RxJavaPlugins . setScheduleHandler ( new Function < Runnable , Runnable > ( ) { @ Override public Runnable apply ( Runnable runnable ) { runnableRef . set ( runnable ) ; return newCounter ; } } ) ; Worker worker = scheduler . createWorker ( ) ; CountingRunnable counter = new CountingRunnable ( ) ; worker . schedule ( counter , 1 , MINUTES ) ; assertSame ( counter , runnableRef . get ( ) ) ; idleMainLooper ( 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 1 , newCounter . get ( ) ) ; assertEquals ( 0 , counter . get ( ) ) ; }
@ Override public Runnable apply ( Runnable runnable ) { runnableRef . set ( runnable ) ; return newCounter ; }
@ Test public void workerScheduleOnceWithDelayDisposedDoesNotRun ( ) { Worker worker = scheduler . createWorker ( ) ; CountingRunnable counter = new CountingRunnable ( ) ; Disposable disposable = worker . schedule ( counter , 1 , MINUTES ) ; idleMainLooper ( 30 , SECONDS ) ; disposable . dispose ( ) ; idleMainLooper ( 30 , SECONDS ) ; runUiThreadTasks ( ) ; assertEquals ( 0 , counter . get ( ) ) ; }
@ Test @ Ignore ( "Implementation delegated to default RxJava implementation" ) public void workerSchedulePeriodicallyReschedulesItself ( ) { Worker worker = scheduler . createWorker ( ) ; CountingRunnable counter = new CountingRunnable ( ) ; worker . schedulePeriodically ( counter , 1 , 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 0 , counter . get ( ) ) ; idleMainLooper ( 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 1 , counter . get ( ) ) ; idleMainLooper ( 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 2 , counter . get ( ) ) ; idleMainLooper ( 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 3 , counter . get ( ) ) ; }
@ Test @ Ignore ( "Implementation delegated to default RxJava implementation" ) public void workerSchedulePeriodicallyUsesHookOnce ( ) { Worker worker = scheduler . createWorker ( ) ; final CountingRunnable newCounter = new CountingRunnable ( ) ; final AtomicReference < Runnable > runnableRef = new AtomicReference <> ( ) ; RxJavaPlugins . setScheduleHandler ( new Function < Runnable , Runnable > ( ) { @ Override public Runnable apply ( Runnable runnable ) { runnableRef . set ( runnable ) ; return newCounter ; } } ) ; CountingRunnable counter = new CountingRunnable ( ) ; worker . schedulePeriodically ( counter , 1 , 1 , MINUTES ) ; assertSame ( counter , runnableRef . get ( ) ) ; runnableRef . set ( null ) ; idleMainLooper ( 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 1 , newCounter . get ( ) ) ; assertEquals ( 0 , counter . get ( ) ) ; assertNull ( runnableRef . get ( ) ) ; }
@ Override public Runnable apply ( Runnable runnable ) { runnableRef . set ( runnable ) ; return newCounter ; }
@ Test @ Ignore ( "Implementation delegated to default RxJava implementation" ) public void workerSchedulePeriodicallyDisposedDoesNotRun ( ) { Worker worker = scheduler . createWorker ( ) ; CountingRunnable counter = new CountingRunnable ( ) ; Disposable disposable = worker . schedulePeriodically ( counter , 1 , 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 0 , counter . get ( ) ) ; idleMainLooper ( 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 1 , counter . get ( ) ) ; idleMainLooper ( 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 2 , counter . get ( ) ) ; disposable . dispose ( ) ; idleMainLooper ( 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 2 , counter . get ( ) ) ; }
@ Test @ Ignore ( "Implementation delegated to default RxJava implementation" ) public void workerSchedulePeriodicallyDisposedDuringRunDoesNotReschedule ( ) { Worker worker = scheduler . createWorker ( ) ; final AtomicReference < Disposable > disposableRef = new AtomicReference <> ( ) ; CountingRunnable counter = new CountingRunnable ( ) { @ Override public void run ( ) { super. run ( ) ; if ( get ( ) == 2 ) { disposableRef . get ( ) . dispose ( ) ; } } } ; Disposable disposable = worker . schedulePeriodically ( counter , 1 , 1 , MINUTES ) ; disposableRef . set ( disposable ) ; runUiThreadTasks ( ) ; assertEquals ( 0 , counter . get ( ) ) ; idleMainLooper ( 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 1 , counter . get ( ) ) ; idleMainLooper ( 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 2 , counter . get ( ) ) ; idleMainLooper ( 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 2 , counter . get ( ) ) ; }
@ Override public void run ( ) { super. run ( ) ; if ( get ( ) == 2 ) { disposableRef . get ( ) . dispose ( ) ; } }
@ Test @ Ignore ( "Implementation delegated to default RxJava implementation" ) public void workerSchedulePeriodicallyThrowingDoesNotReschedule ( ) { Worker worker = scheduler . createWorker ( ) ; CountingRunnable counter = new CountingRunnable ( ) { @ Override public void run ( ) { super. run ( ) ; if ( get ( ) == 2 ) { throw new RuntimeException ( "Broken!" ) ; } } } ; worker . schedulePeriodically ( counter , 1 , 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 0 , counter . get ( ) ) ; idleMainLooper ( 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 1 , counter . get ( ) ) ; idleMainLooper ( 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 2 , counter . get ( ) ) ; idleMainLooper ( 1 , MINUTES ) ; runUiThreadTasks ( ) ; assertEquals ( 2 , counter . get ( ) ) ; }
@ Override public void run ( ) { super. run ( ) ; if ( get ( ) == 2 ) { throw new RuntimeException ( "Broken!" ) ; } }
@ Test public void workerDisposableTracksDisposedState ( ) { Worker worker = scheduler . createWorker ( ) ; CountingRunnable counter = new CountingRunnable ( ) ; Disposable disposable = worker . schedule ( counter ) ; assertFalse ( disposable . isDisposed ( ) ) ; disposable . dispose ( ) ; assertTrue ( disposable . isDisposed ( ) ) ; }
@ Test public void workerUnsubscriptionDuringSchedulingCancelsScheduledAction ( ) { final AtomicReference < Worker > workerRef = new AtomicReference <> ( ) ; RxJavaPlugins . setScheduleHandler ( new Function < Runnable , Runnable > ( ) { @ Override public Runnable apply ( Runnable runnable ) { workerRef . get ( ) . dispose ( ) ; return runnable ; } } ) ; Worker worker = scheduler . createWorker ( ) ; workerRef . set ( worker ) ; CountingRunnable counter = new CountingRunnable ( ) ; worker . schedule ( counter ) ; runUiThreadTasks ( ) ; assertEquals ( 0 , counter . get ( ) ) ; }
@ Override public Runnable apply ( Runnable runnable ) { workerRef . get ( ) . dispose ( ) ; return runnable ; }
@ Test public void workerDisposeCancelsScheduled ( ) { Worker worker = scheduler . createWorker ( ) ; CountingRunnable counter = new CountingRunnable ( ) ; worker . schedule ( counter , 1 , MINUTES ) ; worker . dispose ( ) ; runUiThreadTasks ( ) ; assertEquals ( 0 , counter . get ( ) ) ; }
@ Test public void workerUnsubscriptionDoesNotAffectOtherWorkers ( ) { Worker workerA = scheduler . createWorker ( ) ; CountingRunnable counterA = new CountingRunnable ( ) ; workerA . schedule ( counterA , 1 , MINUTES ) ; Worker workerB = scheduler . createWorker ( ) ; CountingRunnable counterB = new CountingRunnable ( ) ; workerB . schedule ( counterB , 1 , MINUTES ) ; workerA . dispose ( ) ; runUiThreadTasksIncludingDelayedTasks ( ) ; assertEquals ( 0 , counterA . get ( ) ) ; assertEquals ( 1 , counterB . get ( ) ) ; }
@ Test public void workerTracksDisposedState ( ) { Worker worker = scheduler . createWorker ( ) ; assertFalse ( worker . isDisposed ( ) ) ; worker . dispose ( ) ; assertTrue ( worker . isDisposed ( ) ) ; }
@ Test public void disposedWorkerReturnsDisposedDisposables ( ) { Worker worker = scheduler . createWorker ( ) ; worker . dispose ( ) ; Disposable disposable = worker . schedule ( new CountingRunnable ( ) ) ; assertTrue ( disposable . isDisposed ( ) ) ; }
@ Test public void throwingActionRoutedToHookAndThreadHandler ( ) { Thread thread = Thread . currentThread ( ) ; UncaughtExceptionHandler originalHandler = thread . getUncaughtExceptionHandler ( ) ; final AtomicReference < Throwable > throwableRef = new AtomicReference <> ( ) ; thread . setUncaughtExceptionHandler ( new UncaughtExceptionHandler ( ) { @ Override public void uncaughtException ( Thread thread , Throwable ex ) { throwableRef . set ( ex ) ; } } ) ; Worker worker = scheduler . createWorker ( ) ; final NullPointerException npe = new NullPointerException ( ) ; Runnable action = new Runnable ( ) { @ Override public void run ( ) { throw npe ; } } ; worker . schedule ( action ) ; runUiThreadTasks ( ) ; Throwable throwable = throwableRef . get ( ) ; assertTrue ( throwable instanceof IllegalStateException ) ; assertEquals ( "Fatal Exception thrown on Scheduler." , throwable . getMessage ( ) ) ; assertSame ( npe , throwable . getCause ( ) ) ; thread . setUncaughtExceptionHandler ( originalHandler ) ; }
@ Override public void uncaughtException ( Thread thread , Throwable ex ) { throwableRef . set ( ex ) ; }
@ Override public void run ( ) { throw npe ; }
@ Test public void directScheduleOnceInputValidation ( ) { try { scheduler . scheduleDirect ( null ) ; fail ( ) ; } catch ( NullPointerException e ) { assertEquals ( "run == null" , e . getMessage ( ) ) ; } try { scheduler . scheduleDirect ( null , 1 , MINUTES ) ; fail ( ) ; } catch ( NullPointerException e ) { assertEquals ( "run == null" , e . getMessage ( ) ) ; } try { scheduler . scheduleDirect ( new CountingRunnable ( ) , 1 , null ) ; fail ( ) ; } catch ( NullPointerException e ) { assertEquals ( "unit == null" , e . getMessage ( ) ) ; } }
@ Test @ Ignore ( "Implementation delegated to default RxJava implementation" ) public void directSchedulePeriodicallyInputValidation ( ) { try { scheduler . schedulePeriodicallyDirect ( null , 1 , 1 , MINUTES ) ; fail ( ) ; } catch ( NullPointerException e ) { assertEquals ( "run == null" , e . getMessage ( ) ) ; } try { scheduler . schedulePeriodicallyDirect ( new CountingRunnable ( ) , 1 , - 1 , MINUTES ) ; fail ( ) ; } catch ( IllegalArgumentException e ) { assertEquals ( "period < 0: -1" , e . getMessage ( ) ) ; } try { scheduler . schedulePeriodicallyDirect ( new CountingRunnable ( ) , 1 , 1 , null ) ; fail ( ) ; } catch ( NullPointerException e ) { assertEquals ( "unit == null" , e . getMessage ( ) ) ; } }
@ Test public void workerScheduleOnceInputValidation ( ) { Worker worker = scheduler . createWorker ( ) ; try { worker . schedule ( null ) ; fail ( ) ; } catch ( NullPointerException e ) { assertEquals ( "run == null" , e . getMessage ( ) ) ; } try { worker . schedule ( null , 1 , MINUTES ) ; fail ( ) ; } catch ( NullPointerException e ) { assertEquals ( "run == null" , e . getMessage ( ) ) ; } try { worker . schedule ( new CountingRunnable ( ) , 1 , null ) ; fail ( ) ; } catch ( NullPointerException e ) { assertEquals ( "unit == null" , e . getMessage ( ) ) ; } }
@ Test @ Ignore ( "Implementation delegated to default RxJava implementation" ) public void workerSchedulePeriodicallyInputValidation ( ) { Worker worker = scheduler . createWorker ( ) ; try { worker . schedulePeriodically ( null , 1 , 1 , MINUTES ) ; fail ( ) ; } catch ( NullPointerException e ) { assertEquals ( "run == null" , e . getMessage ( ) ) ; } try { worker . schedulePeriodically ( new CountingRunnable ( ) , 1 , - 1 , MINUTES ) ; fail ( ) ; } catch ( IllegalArgumentException e ) { assertEquals ( "period < 0: -1" , e . getMessage ( ) ) ; } try { worker . schedulePeriodically ( new CountingRunnable ( ) , 1 , 1 , null ) ; fail ( ) ; } catch ( NullPointerException e ) { assertEquals ( "unit == null" , e . getMessage ( ) ) ; } }
private static void idleMainLooper ( long amount , TimeUnit unit ) { ShadowLooper . idleMainLooper ( unit . toMillis ( amount ) ) ; }
public ObservableScrollView ( Context context ) { super( context ); }
public ObservableScrollView ( Context context , AttributeSet attrs ) { super( context , attrs ); }
public ObservableScrollView ( Context context , AttributeSet attrs , int defStyle ) { super( context , attrs , defStyle ); }
@ Override public void onRestoreInstanceState ( Parcelable state ) { SavedState ss = ( SavedState ) state ; mPrevScrollY = ss . prevScrollY ; mScrollY = ss . scrollY ; super. onRestoreInstanceState ( ss . getSuperState ( ) ) ; }
@ Override public Parcelable onSaveInstanceState ( ) { Parcelable superState = super. onSaveInstanceState ( ) ; SavedState ss = new SavedState ( superState ) ; ss . prevScrollY = mPrevScrollY ; ss . scrollY = mScrollY ; return ss ; }
@ Override protected void onScrollChanged ( int l , int t , int oldl , int oldt ) { super. onScrollChanged ( l , t , oldl , oldt ) ; if ( hasNoCallbacks ( ) ) { return; } mScrollY = t ; dispatchOnScrollChanged ( t , mFirstScroll , mDragging ) ; if ( mFirstScroll ) { mFirstScroll = false ; } if ( mPrevScrollY < t ) { mScrollState = ScrollState . UP ; } else if ( t < mPrevScrollY ) { mScrollState = ScrollState . DOWN ; } mPrevScrollY = t ; }
@ Override public boolean onInterceptTouchEvent ( MotionEvent ev ) { if ( hasNoCallbacks ( ) ) { return super. onInterceptTouchEvent ( ev ) ; } switch ( ev . getActionMasked ( ) ) { case MotionEvent . ACTION_DOWN : mFirstScroll = mDragging = true ; dispatchOnDownMotionEvent ( ) ; break; } return super. onInterceptTouchEvent ( ev ) ; }
@ Override public boolean onTouchEvent ( MotionEvent ev ) { if ( hasNoCallbacks ( ) ) { return super. onTouchEvent ( ev ) ; } switch ( ev . getActionMasked ( ) ) { case MotionEvent . ACTION_UP : case MotionEvent . ACTION_CANCEL : mIntercepted = false ; mDragging = false ; dispatchOnUpOrCancelMotionEvent ( mScrollState ) ; break; case MotionEvent . ACTION_MOVE : if ( mPrevMoveEvent == null ) { mPrevMoveEvent = ev ; } float diffY = ev . getY ( ) - mPrevMoveEvent . getY ( ) ; mPrevMoveEvent = MotionEvent . obtainNoHistory ( ev ) ; if ( getCurrentScrollY ( ) - diffY <= 0 ) { if ( mIntercepted ) { return false ; } final ViewGroup parent ; if ( mTouchInterceptionViewGroup == null ) { parent = ( ViewGroup ) getParent ( ) ; } else { parent = mTouchInterceptionViewGroup ; } float offsetX = 0 ; float offsetY = 0 ; for ( View v = this ; v != null && v != parent ; v = ( View ) v . getParent ( ) ) { offsetX += v . getLeft ( ) - v . getScrollX ( ) ; offsetY += v . getTop ( ) - v . getScrollY ( ) ; } final MotionEvent event = MotionEvent . obtainNoHistory ( ev ) ; event . offsetLocation ( offsetX , offsetY ) ; if ( parent . onInterceptTouchEvent ( event ) ) { mIntercepted = true ; event . setAction ( MotionEvent . ACTION_DOWN ) ; post ( new Runnable ( ) { @ Override public void run ( ) { parent . dispatchTouchEvent ( event ) ; } } ) ; return false ; } return super. onTouchEvent ( ev ) ; } break; } return super. onTouchEvent ( ev ) ; }
@ Override public void run ( ) { parent . dispatchTouchEvent ( event ) ; }
@ Override public void setScrollViewCallbacks ( ObservableScrollViewCallbacks listener ) { mCallbacks = listener ; }
@ Override public void addScrollViewCallbacks ( ObservableScrollViewCallbacks listener ) { if ( mCallbackCollection == null ) { mCallbackCollection = new ArrayList <> ( ) ; } mCallbackCollection . add ( listener ) ; }
@ Override public void removeScrollViewCallbacks ( ObservableScrollViewCallbacks listener ) { if ( mCallbackCollection != null ) { mCallbackCollection . remove ( listener ) ; } }
@ Override public void clearScrollViewCallbacks ( ) { if ( mCallbackCollection != null ) { mCallbackCollection . clear ( ) ; } }
@ Override public void setTouchInterceptionViewGroup ( ViewGroup viewGroup ) { mTouchInterceptionViewGroup = viewGroup ; }
@ Override public void scrollVerticallyTo ( int y ) { scrollTo ( 0 , y ) ; }
@ Override public int getCurrentScrollY ( ) { return mScrollY ; }
private void dispatchOnDownMotionEvent ( ) { if ( mCallbacks != null ) { mCallbacks . onDownMotionEvent ( ) ; } if ( mCallbackCollection != null ) { for ( int i = 0 ; i < mCallbackCollection . size ( ) ; i ++ ) { ObservableScrollViewCallbacks callbacks = mCallbackCollection . get ( i ) ; callbacks . onDownMotionEvent ( ) ; } } }
private void dispatchOnScrollChanged ( int scrollY , boolean firstScroll , boolean dragging ) { if ( mCallbacks != null ) { mCallbacks . onScrollChanged ( scrollY , firstScroll , dragging ) ; } if ( mCallbackCollection != null ) { for ( int i = 0 ; i < mCallbackCollection . size ( ) ; i ++ ) { ObservableScrollViewCallbacks callbacks = mCallbackCollection . get ( i ) ; callbacks . onScrollChanged ( scrollY , firstScroll , dragging ) ; } } }
private void dispatchOnUpOrCancelMotionEvent ( ScrollState scrollState ) { if ( mCallbacks != null ) { mCallbacks . onUpOrCancelMotionEvent ( scrollState ) ; } if ( mCallbackCollection != null ) { for ( int i = 0 ; i < mCallbackCollection . size ( ) ; i ++ ) { ObservableScrollViewCallbacks callbacks = mCallbackCollection . get ( i ) ; callbacks . onUpOrCancelMotionEvent ( scrollState ) ; } } }
private boolean hasNoCallbacks ( ) { return mCallbacks == null && mCallbackCollection == null ; }
SavedState ( Parcelable superState ) { super( superState ); }
private SavedState ( Parcel in ) { super( in ); prevScrollY = in . readInt ( ) ; scrollY = in . readInt ( ) ; }
@ Override public void writeToParcel ( Parcel out , int flags ) { super. writeToParcel ( out , flags ) ; out . writeInt ( prevScrollY ) ; out . writeInt ( scrollY ) ; }
@ Override public SavedState createFromParcel ( Parcel in ) { return new SavedState ( in ) ; }
@ Override public SavedState [] newArray ( int size ) { return new SavedState [ size ] ; }
protected void setMatcherController ( MatcherController controller ) { this . controller = controller ; controller . initialize ( ) ; }
public abstract Cursor onQuery ( T helper , SQLiteDatabase db , MatcherPattern target , QueryParameters parameter );
public abstract Uri onInsert ( T helper , SQLiteDatabase db , MatcherPattern target , InsertParameters parameter );
public abstract int onDelete ( T helper , SQLiteDatabase db , MatcherPattern target , DeleteParameters parameter );
public abstract int onUpdate ( T helper , SQLiteDatabase db , MatcherPattern target , UpdateParameters parameter );
@ Override public String getType ( Uri uri ) { if ( ! controller . hasPreinitialized ( ) ) { throw new IllegalStateException ( "Controller has not been initialized." ) ; } int patternCode = controller . getUriMatcher ( ) . match ( uri ) ; MatcherPattern pattern = controller . findMatcherPattern ( patternCode ) ; if ( pattern == null ) { throw new IllegalArgumentException ( "unknown uri : " + uri . toString ( ) ) ; } return pattern . getMimeTypeVndString ( ) ; }
@ Override public Cursor query ( Uri uri , String [] projection , String selection , String [] selectionArgs , String sortOrder ) { Cursor result = null ; if ( ! controller . hasPreinitialized ( ) ) { throw new IllegalStateException ( "Controller has not been initialized." ) ; } int patternCode = controller . getUriMatcher ( ) . match ( uri ) ; MatcherPattern pattern = controller . findMatcherPattern ( patternCode ) ; if ( pattern == null ) { throw new IllegalArgumentException ( "unknown uri : " + uri . toString ( ) ) ; } Parameter parameter = new Parameter ( uri , projection , selection , selectionArgs , sortOrder ) ; SQLiteDatabase db = this . getHelper ( ) . getReadableDatabase ( ) ; result = onQuery ( this . getHelper ( ) , db , pattern , parameter ) ; if ( result != null ) { this . onQueryCompleted ( result , uri , pattern , parameter ) ; } return result ; }
protected void onQueryCompleted ( Cursor result , Uri uri , MatcherPattern target , QueryParameters parameter ) { result . setNotificationUri ( this . getContext ( ) . getContentResolver ( ) , uri ) ; }
@ Override public Uri insert ( Uri uri , ContentValues values ) { Uri result = null ; if ( ! controller . hasPreinitialized ( ) ) { throw new IllegalStateException ( "Controller has not been initialized." ) ; } int patternCode = controller . getUriMatcher ( ) . match ( uri ) ; MatcherPattern pattern = controller . findMatcherPattern ( patternCode ) ; if ( pattern == null ) { throw new IllegalArgumentException ( "unknown uri : " + uri . toString ( ) ) ; } Parameter parameter = new Parameter ( uri , values ) ; SQLiteDatabase db = this . getHelper ( ) . getWritableDatabase ( ) ; result = onInsert ( this . getHelper ( ) , db , pattern , parameter ) ; if ( result != null ) { this . onInsertCompleted ( result , uri , pattern , parameter ) ; } return result ; }
protected void onInsertCompleted ( Uri result , Uri uri , MatcherPattern target , InsertParameters parameter ) { this . getContext ( ) . getContentResolver ( ) . notifyChange ( result , null ) ; }
@ Override public int delete ( Uri uri , String selection , String [] selectionArgs ) { int result = - 1 ; if ( ! controller . hasPreinitialized ( ) ) { throw new IllegalStateException ( "Controller has not been initialized." ) ; } int patternCode = controller . getUriMatcher ( ) . match ( uri ) ; MatcherPattern pattern = controller . findMatcherPattern ( patternCode ) ; if ( pattern == null ) { throw new IllegalArgumentException ( "unknown uri : " + uri . toString ( ) ) ; } Parameter parameter = new Parameter ( uri , selection , selectionArgs ) ; SQLiteDatabase db = this . getHelper ( ) . getWritableDatabase ( ) ; result = onDelete ( this . getHelper ( ) , db , pattern , parameter ) ; if ( result >= 0 ) { this . onDeleteCompleted ( result , uri , pattern , parameter ) ; } return result ; }
protected void onDeleteCompleted ( int result , Uri uri , MatcherPattern target , DeleteParameters parameter ) { this . getContext ( ) . getContentResolver ( ) . notifyChange ( uri , null ) ; }
@ Override public int update ( Uri uri , ContentValues values , String selection , String [] selectionArgs ) { int result = - 1 ; if ( ! controller . hasPreinitialized ( ) ) { throw new IllegalStateException ( "Controller has not been initialized." ) ; } int patternCode = controller . getUriMatcher ( ) . match ( uri ) ; MatcherPattern pattern = controller . findMatcherPattern ( patternCode ) ; if ( pattern == null ) { throw new IllegalArgumentException ( "unknown uri : " + uri . toString ( ) ) ; } Parameter parameter = new Parameter ( uri , values , selection , selectionArgs ) ; SQLiteDatabase db = this . getHelper ( ) . getWritableDatabase ( ) ; result = onUpdate ( this . getHelper ( ) , db , pattern , parameter ) ; if ( result >= 0 ) { this . onUpdateCompleted ( result , uri , pattern , parameter ) ; } return result ; }
protected void onUpdateCompleted ( int result , Uri uri , MatcherPattern target , UpdateParameters parameter ) { this . getContext ( ) . getContentResolver ( ) . notifyChange ( uri , null ) ; }
@ Override public int bulkInsert ( Uri uri , ContentValues [] values ) { int result = 0 ; if ( ! controller . hasPreinitialized ( ) ) { throw new IllegalStateException ( "Controller has not been initialized." ) ; } int patternCode = controller . getUriMatcher ( ) . match ( uri ) ; MatcherPattern pattern = controller . findMatcherPattern ( patternCode ) ; if ( pattern == null ) { throw new IllegalArgumentException ( "unknown uri : " + uri . toString ( ) ) ; } SQLiteDatabase db = this . getHelper ( ) . getWritableDatabase ( ) ; db . beginTransaction ( ) ; try { for ( ContentValues value : values ) { Parameter parameter = new Parameter ( uri , value ) ; Uri resultBulkInsert = this . onBulkInsert ( this . getHelper ( ) , db , pattern , parameter ) ; if ( resultBulkInsert != null ) { result ++ ; } } db . setTransactionSuccessful ( ) ; if ( result >= 1 ) { this . onBulkInsertCompleted ( result , uri ) ; } } finally { db . endTransaction ( ) ; } return result ; }
public Uri onBulkInsert ( T helper , SQLiteDatabase db , MatcherPattern target , InsertParameters parameter ) { return onInsert ( helper , db , target , parameter ) ; }
protected void onBulkInsertCompleted ( int result , Uri uri ) { this . getContext ( ) . getContentResolver ( ) . notifyChange ( uri , null ) ; }
@ Override public ContentProviderResult [] applyBatch ( ArrayList < ContentProviderOperation > operations ) throws OperationApplicationException { ContentProviderResult [] result = null ; SQLiteDatabase db = this . getHelper ( ) . getWritableDatabase ( ) ; db . beginTransaction ( ) ; try { result = super. applyBatch ( operations ) ; db . setTransactionSuccessful ( ) ; } finally { db . endTransaction ( ) ; } return result ; }
private Fragments ( ) {	}
public static void showDialog ( @ Nonnull DialogFragment dialogFragment , @ Nonnull String fragmentTag , @ Nonnull FragmentManager fm ) { showDialog ( dialogFragment , fragmentTag , fm , true ) ; }
public static void showDialog ( DialogFragment dialogFragment , String fragmentTag , FragmentManager fm , boolean useExisting ) { Fragment prev = fm . findFragmentByTag ( fragmentTag ) ; if ( prev != null ) { if ( ! useExisting ) { final FragmentTransaction ft = fm . beginTransaction ( ) ; ft . remove ( prev ) ; ft . addToBackStack ( null ) ; dialogFragment . show ( ft , fragmentTag ) ; fm . executePendingTransactions ( ) ; } } else { final FragmentTransaction ft = fm . beginTransaction ( ) ; ft . addToBackStack ( null ) ; dialogFragment . show ( ft , fragmentTag ) ; fm . executePendingTransactions ( ) ; } }
public ExperimentalRegionsPreference ( Context context ) { super( context ); initCheckedState ( ) ; }
public ExperimentalRegionsPreference ( Context context , AttributeSet attrs ) { super( context , attrs ); initCheckedState ( ) ; }
public ExperimentalRegionsPreference ( Context context , AttributeSet attrs , int defStyle ) { super( context , attrs , defStyle ); initCheckedState ( ) ; }
protected void initCheckedState ( ) { setChecked ( Application . getPrefs ( ) . getBoolean ( getContext ( ) . getString ( R . string . preference_key_experimental_regions ) , DEFAULT_VALUE ) ) ; }
@ Override public boolean isPersistent ( ) { return true ; }
@ Override protected void onClick ( ) { if ( ! isChecked ( ) ) { AlertDialog dialog = new AlertDialog . Builder ( getContext ( ) ) . setMessage ( R . string . preferences_experimental_regions_enable_warning ) . setPositiveButton ( android . R . string . ok , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { dialog . dismiss ( ) ; setValue ( true ) ; } } ) . setNegativeButton ( android . R . string . cancel , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { dialog . dismiss ( ) ; } } ) . create ( ) ; dialog . show ( ) ; } else { if ( Application . get ( ) . getCurrentRegion ( ) != null && Application . get ( ) . getCurrentRegion ( ) . getExperimental ( ) ) { AlertDialog dialog = new AlertDialog . Builder ( getContext ( ) ) . setMessage ( R . string . preferences_experimental_regions_disable_warning ) . setPositiveButton ( android . R . string . ok , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { dialog . dismiss ( ) ; Application . get ( ) . setCurrentRegion ( null ) ; setValue ( false ) ; } } ) . setNegativeButton ( android . R . string . cancel , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { dialog . dismiss ( ) ; } } ) . create ( ) ; dialog . show ( ) ; } else { setValue ( false ) ; } } }
@ Override public void onClick ( DialogInterface dialog , int which ) { dialog . dismiss ( ) ; setValue ( true ) ; }
@ Override public void onClick ( DialogInterface dialog , int which ) { dialog . dismiss ( ) ; }
@ Override public void onClick ( DialogInterface dialog , int which ) { dialog . dismiss ( ) ; Application . get ( ) . setCurrentRegion ( null ) ; setValue ( false ) ; }
@ Override public void onClick ( DialogInterface dialog , int which ) { dialog . dismiss ( ) ; }
public void setValue ( boolean newValue ) { mCurrentValue = newValue ; setChecked ( newValue ) ; PreferenceUtils . saveBoolean ( getContext ( ) . getString ( R . string . preference_key_experimental_regions ) , newValue ) ; }
@ Override protected void onSetInitialValue ( boolean restorePersistedValue , Object defaultValue ) { if ( restorePersistedValue ) { mCurrentValue = this . getPersistedBoolean ( mCurrentValue ) ; } else { mCurrentValue = ( Boolean ) defaultValue ; persistBoolean ( mCurrentValue ) ; } }
@ Override protected Object onGetDefaultValue ( TypedArray a , int index ) { return a . getBoolean ( index , DEFAULT_VALUE ) ; }
@ Override protected Parcelable onSaveInstanceState ( ) { final Parcelable superState = super. onSaveInstanceState ( ) ; final SavedState myState = new SavedState ( superState ) ; myState . value = mCurrentValue ; return myState ; }
@ Override protected void onRestoreInstanceState ( Parcelable state ) { if ( state == null || ! state . getClass ( ) . equals ( SavedState .class ) ) { super. onRestoreInstanceState ( state ) ; return; } SavedState myState = ( SavedState ) state ; super. onRestoreInstanceState ( myState . getSuperState ( ) ) ; setValue ( myState . value ) ; }
public SavedState ( Parcelable superState ) { super( superState ); }
public SavedState ( Parcel source ) { super( source ); value = source . readByte ( ) != 0 ; }
@ Override public void writeToParcel ( Parcel dest , int flags ) { super. writeToParcel ( dest , flags ) ; dest . writeByte ( ( byte ) ( value ? 1 : 0 ) ) ; }
public SavedState createFromParcel ( Parcel in ) { return new SavedState ( in ) ; }
public SavedState [] newArray ( int size ) { return new SavedState [ size ] ; }
public HelloFlashLightSampleIT ( MavenRuntimeBuilder builder ) throws Exception { this . mavenRuntime = builder . build ( ) ; }
@ Test public void buildDeployAndRun ( ) Exception { File basedir = resources . getBasedir ( "helloflashlight" ) ; MavenExecutionResult result = mavenRuntime . forProject ( basedir ) . execute ( "clean" , PluginInfo . getQualifiedGoal ( "undeploy" ) , "install" , PluginInfo . getQualifiedGoal ( "deploy" ) , PluginInfo . getQualifiedGoal ( "run" ) ) ; result . assertErrorFreeLog ( ) ; result . assertLogText ( "Successfully installed" ) ; result . assertLogText ( "Attempting to start com.simpligility.android.helloflashlight/com.simpligility.android.helloflashlight.HelloFlashlight" ) ; }
Location getStopLocation ( )
String getStopName ( )
String getStopDirection ( )
String getUserStopName ( )
String getStopId ( )
void setUserStopName ( String userName );
long getLastGoodResponseTime ( )
ArrayList < ArrivalInfo > getArrivalInfo ( )
ArrayList < String > getRoutesFilter ( )
void setRoutesFilter ( ArrayList < String > filter );
int getNumRoutes ( )
boolean isFavoriteStop ( )
boolean setFavoriteStop ( boolean favorite );
AlertList getAlertList ( )
List < String > getRouteDisplayNames ( )
int getMinutesAfter ( )
void showListItemMenu ( View v , final ArrivalInfo stop );
void refreshLocal ( )
void refresh ( )
ArrivalsListHeader ( Context context , Controller controller , FragmentManager fm ) { mController = controller ; mContext = context ; mResources = context . getResources ( ) ; mFragmentManager = fm ; mShortAnimationDuration = mResources . getInteger ( android . R . integer . config_shortAnimTime ) ; }
void initView ( View view ) { mArrivalInfo = null ; mHeaderArrivalInfo . clear ( ) ; mNumHeaderArrivals = - 1 ; HEADER_HEIGHT_NO_ARRIVALS_DP = view . getResources ( ) . getDimension ( R . dimen . arrival_header_height_no_arrivals ) / view . getResources ( ) . getDisplayMetrics ( ) . density ; HEADER_HEIGHT_ONE_ARRIVAL_DP = view . getResources ( ) . getDimension ( R . dimen . arrival_header_height_one_arrival ) / view . getResources ( ) . getDisplayMetrics ( ) . density ; HEADER_HEIGHT_TWO_ARRIVALS_DP = view . getResources ( ) . getDimension ( R . dimen . arrival_header_height_two_arrivals ) / view . getResources ( ) . getDisplayMetrics ( ) . density ; HEADER_OFFSET_FILTER_ROUTES_DP = view . getResources ( ) . getDimension ( R . dimen . arrival_header_height_offset_filter_routes ) / view . getResources ( ) . getDisplayMetrics ( ) . density ; HEADER_HEIGHT_EDIT_NAME_DP = view . getResources ( ) . getDimension ( R . dimen . arrival_header_height_edit_name ) / view . getResources ( ) . getDisplayMetrics ( ) . density ; mView = view ; mMainContainerView = mView . findViewById ( R . id . main_header_content ) ; mNameContainerView = mView . findViewById ( R . id . stop_name_and_info_container ) ; mEditNameContainerView = mView . findViewById ( R . id . edit_name_container ) ; mNameView = ( TextView ) mView . findViewById ( R . id . stop_name ) ; mDirectionView = ( TextView ) mView . findViewById ( R . id . stop_direction ) ; mEditNameView = ( EditText ) mView . findViewById ( R . id . edit_name ) ; mStopFavorite = ( ImageButton ) mView . findViewById ( R . id . stop_favorite ) ; mStopFavorite . setColorFilter ( mView . getResources ( ) . getColor ( R . color . header_text_color ) ) ; mFilterGroup = mView . findViewById ( R . id . filter_group ) ; mShowAllView = ( TextView ) mView . findViewById ( R . id . show_all ) ; UIUtils . removeAllClickableSpans ( mShowAllView ) ; mShowAllClick = new ClickableSpan ( ) { public void onClick ( View v ) { mController . setRoutesFilter ( new ArrayList < String > ( ) ) ; } } ; UIUtils . setClickableSpan ( mShowAllView , mShowAllClick ) ; mNoArrivals = ( TextView ) mView . findViewById ( R . id . no_arrivals ) ; mEtaContainer1 = mView . findViewById ( R . id . eta_container1 ) ; mEtaRouteFavorite1 = ( ImageButton ) mEtaContainer1 . findViewById ( R . id . eta_route_favorite ) ; mEtaRouteFavorite1 . setColorFilter ( mView . getResources ( ) . getColor ( R . color . header_text_color ) ) ; mEtaReminder1 = ( ImageButton ) mEtaContainer1 . findViewById ( R . id . reminder ) ; mEtaReminder1 . setColorFilter ( mView . getResources ( ) . getColor ( R . color . header_text_color ) ) ; mEtaRouteName1 = ( TextView ) mEtaContainer1 . findViewById ( R . id . eta_route_name ) ; mEtaRouteDirection1 = ( TextView ) mEtaContainer1 . findViewById ( R . id . eta_route_direction ) ; mEtaAndMin1 = ( RelativeLayout ) mEtaContainer1 . findViewById ( R . id . eta_and_min ) ; mEtaArrivalInfo1 = ( TextView ) mEtaContainer1 . findViewById ( R . id . eta ) ; mEtaMin1 = ( TextView ) mEtaContainer1 . findViewById ( R . id . eta_min ) ; mEtaRealtime1 = ( ViewGroup ) mEtaContainer1 . findViewById ( R . id . eta_realtime_indicator ) ; mEtaMoreVert1 = ( ImageButton ) mEtaContainer1 . findViewById ( R . id . eta_more_vert ) ; mEtaMoreVert1 . setColorFilter ( mView . getResources ( ) . getColor ( R . color . header_text_color ) ) ; mEtaSeparator = mView . findViewById ( R . id . eta_separator ) ; mEtaContainer2 = mView . findViewById ( R . id . eta_container2 ) ; mEtaRouteFavorite2 = ( ImageButton ) mEtaContainer2 . findViewById ( R . id . eta_route_favorite ) ; mEtaRouteFavorite2 . setColorFilter ( mView . getResources ( ) . getColor ( R . color . header_text_color ) ) ; mEtaReminder2 = ( ImageButton ) mEtaContainer2 . findViewById ( R . id . reminder ) ; mEtaReminder2 . setColorFilter ( mView . getResources ( ) . getColor ( R . color . header_text_color ) ) ; mEtaRouteName2 = ( TextView ) mEtaContainer2 . findViewById ( R . id . eta_route_name ) ; mEtaAndMin2 = ( RelativeLayout ) mEtaContainer2 . findViewById ( R . id . eta_and_min ) ; mEtaRouteDirection2 = ( TextView ) mEtaContainer2 . findViewById ( R . id . eta_route_direction ) ; mEtaArrivalInfo2 = ( TextView ) mEtaContainer2 . findViewById ( R . id . eta ) ; mEtaMin2 = ( TextView ) mEtaContainer2 . findViewById ( R . id . eta_min ) ; mEtaRealtime2 = ( ViewGroup ) mEtaContainer2 . findViewById ( R . id . eta_realtime_indicator ) ; mEtaMoreVert2 = ( ImageButton ) mEtaContainer2 . findViewById ( R . id . eta_more_vert ) ; mEtaMoreVert2 . setColorFilter ( mView . getResources ( ) . getColor ( R . color . header_text_color ) ) ; mProgressBar = ( ProgressBar ) mView . findViewById ( R . id . header_loading_spinner ) ; mStopInfo = ( ImageButton ) mView . findViewById ( R . id . stop_info_button ) ; mExpandCollapse = ( ImageView ) mView . findViewById ( R . id . expand_collapse ) ; mAlertView = ( ImageView ) mView . findViewById ( R . id . alert ) ; mAlertView . setColorFilter ( mView . getResources ( ) . getColor ( R . color . header_text_color ) ) ; mAlertView . setVisibility ( View . GONE ) ; resetExpandCollapseAnimation ( ) ; UIUtils . showViewWithAnimation ( mProgressBar , mShortAnimationDuration ) ; UIUtils . hideViewWithAnimation ( mEtaContainer1 , mShortAnimationDuration ) ; UIUtils . hideViewWithAnimation ( mEtaSeparator , mShortAnimationDuration ) ; UIUtils . hideViewWithAnimation ( mEtaContainer2 , mShortAnimationDuration ) ; final ObaRegion obaRegion = Application . get ( ) . getCurrentRegion ( ) ; if ( obaRegion == null || TextUtils . isEmpty ( obaRegion . getStopInfoUrl ( ) ) ) { mStopInfo . setVisibility ( View . GONE ) ; } else { mStopInfo . setVisibility ( View . VISIBLE ) ; mStopInfo . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { Uri stopInfoUri = Uri . parse ( obaRegion . getStopInfoUrl ( ) ) ; Uri . Builder stopInfoBuilder = stopInfoUri . buildUpon ( ) ; stopInfoBuilder . appendPath ( mContext . getString ( R . string . stop_info_url_path ) ) ; stopInfoBuilder . appendPath ( mController . getStopId ( ) ) ; Log . d ( TAG , "StopInfoUrl - " + stopInfoBuilder . build ( ) ) ; Intent i = new Intent ( Intent . ACTION_VIEW ) ; i . setData ( stopInfoBuilder . build ( ) ) ; mContext . startActivity ( i ) ; if ( obaRegion != null && obaRegion . getName ( ) != null ) ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , mContext . getString ( R . string . analytics_action_button_press ) , mContext . getString ( R . string . analytics_label_button_press_stopinfo ) + obaRegion . getName ( ) ) ; } } ) ; } mStopFavorite . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { mController . setFavoriteStop ( ! mController . isFavoriteStop ( ) ) ; refreshStopFavorite ( ) ; } } ) ; mNameView . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { beginNameEdit ( null ) ; } } ) ; View save = mView . findViewById ( R . id . edit_name_save ) ; save . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { mController . setUserStopName ( mEditNameView . getText ( ) . toString ( ) ) ; endNameEdit ( ) ; } } ) ; mEditNameView . setOnEditorActionListener ( new TextView . OnEditorActionListener ( ) { @ Override public boolean onEditorAction ( TextView v , int actionId , KeyEvent event ) { if ( actionId == EditorInfo . IME_ACTION_DONE ) { mController . setUserStopName ( mEditNameView . getText ( ) . toString ( ) ) ; endNameEdit ( ) ; return true ; } return false ; } } ) ; View cancel = mView . findViewById ( R . id . edit_name_cancel ) ; cancel . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { endNameEdit ( ) ; } } ) ; View clear = mView . findViewById ( R . id . edit_name_revert ) ; clear . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { mController . setUserStopName ( null ) ; endNameEdit ( ) ; } } ) ; }
public void onClick ( View v ) { mController . setRoutesFilter ( new ArrayList < String > ( ) ) ; }
@ Override public void onClick ( View v ) { Uri stopInfoUri = Uri . parse ( obaRegion . getStopInfoUrl ( ) ) ; Uri . Builder stopInfoBuilder = stopInfoUri . buildUpon ( ) ; stopInfoBuilder . appendPath ( mContext . getString ( R . string . stop_info_url_path ) ) ; stopInfoBuilder . appendPath ( mController . getStopId ( ) ) ; Log . d ( TAG , "StopInfoUrl - " + stopInfoBuilder . build ( ) ) ; Intent i = new Intent ( Intent . ACTION_VIEW ) ; i . setData ( stopInfoBuilder . build ( ) ) ; mContext . startActivity ( i ) ; if ( obaRegion != null && obaRegion . getName ( ) != null ) ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , mContext . getString ( R . string . analytics_action_button_press ) , mContext . getString ( R . string . analytics_label_button_press_stopinfo ) + obaRegion . getName ( ) ) ; }
@ Override public void onClick ( View v ) { mController . setFavoriteStop ( ! mController . isFavoriteStop ( ) ) ; refreshStopFavorite ( ) ; }
@ Override public void onClick ( View v ) { beginNameEdit ( null ) ; }
@ Override public void onClick ( View v ) { mController . setUserStopName ( mEditNameView . getText ( ) . toString ( ) ) ; endNameEdit ( ) ; }
@ Override public boolean onEditorAction ( TextView v , int actionId , KeyEvent event ) { if ( actionId == EditorInfo . IME_ACTION_DONE ) { mController . setUserStopName ( mEditNameView . getText ( ) . toString ( ) ) ; endNameEdit ( ) ; return true ; } return false ; }
@ Override public void onClick ( View v ) { endNameEdit ( ) ; }
@ Override public void onClick ( View v ) { mController . setUserStopName ( null ) ; endNameEdit ( ) ; }
public void setSlidingPanelController ( HomeActivity . SlidingPanelController controller ) { mSlidingPanelController = controller ; }
public void onPause ( ) { if ( mInNameEdit ) { mController . setUserStopName ( null ) ; endNameEdit ( ) ; } }
synchronized public void setSlidingPanelCollapsed ( boolean collapsed ) { if ( mExpandCollapse != null && collapsed != mIsSlidingPanelCollapsed ) { mIsSlidingPanelCollapsed = collapsed ; doExpandCollapseRotation ( collapsed ) ; } }
public void setTripsForStop ( ContentQueryMap tripsForStop ) { mTripsForStop = tripsForStop ; refreshArrivalInfoVisibilityAndListeners ( ) ; }
@ TargetApi ( Build . VERSION_CODES . HONEYCOMB_MR1 ) private void doExpandCollapseRotation ( boolean collapsed ) { if ( ! UIUtils . canAnimateViewModern ( ) ) { rotateExpandCollapseImageViewLegacy ( collapsed ) ; return; } if ( ! collapsed ) { mExpandCollapse . animate ( ) . setDuration ( ANIM_DURATION ) . rotationBy ( ANIM_STATE_INVERTED ) ; } else { mExpandCollapse . animate ( ) . setDuration ( ANIM_DURATION ) . rotationBy ( - ANIM_STATE_INVERTED ) ; } }
private void rotateExpandCollapseImageViewLegacy ( boolean isSlidingPanelCollapsed ) { RotateAnimation rotate ; if ( ! isSlidingPanelCollapsed ) { rotate = getRotation ( ANIM_STATE_NORMAL , ANIM_STATE_INVERTED ) ; } else { rotate = getRotation ( ANIM_STATE_INVERTED , ANIM_STATE_NORMAL ) ; } mExpandCollapse . setAnimation ( rotate ) ; }
@ TargetApi ( Build . VERSION_CODES . HONEYCOMB_MR1 ) private synchronized void resetExpandCollapseAnimation ( ) { if ( mExpandCollapse == null ) { return; } if ( UIUtils . canAnimateViewModern ( ) ) { if ( mExpandCollapse . getRotation ( ) != 0 ) { mExpandCollapse . setRotation ( 0 ) ; } } else { mExpandCollapse . clearAnimation ( ) ; } }
public void showExpandCollapseIndicator ( boolean value ) { if ( mExpandCollapse != null ) { if ( value ) { mExpandCollapse . setVisibility ( View . VISIBLE ) ; } else { mExpandCollapse . setVisibility ( View . GONE ) ; } } }
public void showArrivals ( boolean value ) { mShowArrivals = value ; if ( mView != null ) { TableLayout arrivalTable = ( TableLayout ) mView . findViewById ( R . id . eta_table ) ; if ( arrivalTable != null ) { if ( mShowArrivals ) { arrivalTable . setVisibility ( View . VISIBLE ) ; mProgressBar . setVisibility ( View . VISIBLE ) ; } else { arrivalTable . setVisibility ( View . GONE ) ; mProgressBar . setVisibility ( View . GONE ) ; } } } }
public boolean isShowingArrivals ( ) { return mShowArrivals ; }
private static RotateAnimation getRotation ( float startState , float endState ) { RotateAnimation r = new RotateAnimation ( startState , endState , Animation . RELATIVE_TO_SELF , ANIM_PIVOT_VALUE , Animation . RELATIVE_TO_SELF , ANIM_PIVOT_VALUE ) ; r . setDuration ( ANIM_DURATION ) ; r . setFillAfter ( true ) ; return r ; }
synchronized void refresh ( ) { refreshName ( ) ; refreshArrivalInfoData ( ) ; refreshStopFavorite ( ) ; refreshFilter ( ) ; refreshError ( ) ; refreshHiddenAlerts ( ) ; refreshArrivalInfoVisibilityAndListeners ( ) ; refreshHeaderSize ( ) ; }
private void refreshName ( ) { String name = mController . getStopName ( ) ; String userName = mController . getUserStopName ( ) ; String stopDirection = mController . getStopDirection ( ) ; if ( ! TextUtils . isEmpty ( userName ) ) { mNameView . setText ( UIUtils . formatDisplayText ( userName ) ) ; } else if ( name != null ) { mNameView . setText ( UIUtils . formatDisplayText ( name ) ) ; } if ( ! TextUtils . isEmpty ( stopDirection ) ) { mDirectionView . setText ( mContext . getString ( R . string . arrival_list_stop_directions , stopDirection ) ) ; mDirectionView . setVisibility ( View . VISIBLE ) ; } else { mDirectionView . setVisibility ( View . GONE ) ; } }
private void refreshArrivalInfoData ( ) { mArrivalInfo = mController . getArrivalInfo ( ) ; mHeaderArrivalInfo . clear ( ) ; if ( mArrivalInfo != null && ! mInNameEdit ) { ArrayList < Integer > etaIndexes = ArrivalInfoUtils . findPreferredArrivalIndexes ( mArrivalInfo ) ; if ( etaIndexes != null ) { final int i1 = etaIndexes . get ( 0 ) ; ObaArrivalInfo info1 = mArrivalInfo . get ( i1 ) . getInfo ( ) ; boolean isFavorite = ObaContract . RouteHeadsignFavorites . isFavorite ( info1 . getRouteId ( ) , info1 . getHeadsign ( ) , info1 . getStopId ( ) ) ; mEtaRouteFavorite1 . setImageResource ( isFavorite ? R . drawable . focus_star_on : R . drawable . focus_star_off ) ; mEtaRouteName1 . setText ( info1 . getShortName ( ) ) ; mEtaRouteDirection1 . setText ( UIUtils . formatDisplayText ( info1 . getHeadsign ( ) ) ) ; long eta = mArrivalInfo . get ( i1 ) . getEta ( ) ; if ( eta == 0 ) { mEtaArrivalInfo1 . setText ( mContext . getString ( R . string . stop_info_eta_now ) ) ; mEtaArrivalInfo1 . setTextSize ( ETA_TEXT_NOW_SIZE_SP ) ; UIUtils . hideViewWithAnimation ( mEtaMin1 , mShortAnimationDuration ) ; } else if ( eta > 0 ) { mEtaArrivalInfo1 . setText ( Long . toString ( eta ) ) ; mEtaArrivalInfo1 . setTextSize ( ETA_TEXT_SIZE_SP ) ; UIUtils . showViewWithAnimation ( mEtaMin1 , mShortAnimationDuration ) ; } mEtaAndMin1 . setBackgroundResource ( R . drawable . round_corners_style_b_header_status ) ; GradientDrawable d1 = ( GradientDrawable ) mEtaAndMin1 . getBackground ( ) ; final int c1 = mArrivalInfo . get ( i1 ) . getColor ( ) ; if ( c1 != R . color . stop_info_ontime ) { d1 . setColor ( mResources . getColor ( c1 ) ) ; } else { d1 . setColor ( mResources . getColor ( R . color . header_stop_info_ontime ) ) ; } mEtaAndMin1 . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { if ( mPopup1 != null && mPopup1 . isShowing ( ) ) { mPopup1 . dismiss ( ) ; return; } mPopup1 = setupPopup ( 0 , c1 , mArrivalInfo . get ( i1 ) . getStatusText ( ) ) ; mPopup1 . showAsDropDown ( mEtaAndMin1 ) ; } } ) ; if ( mArrivalInfo . get ( i1 ) . getPredicted ( ) ) { UIUtils . showViewWithAnimation ( mEtaRealtime1 , mShortAnimationDuration ) ; } else { mEtaRealtime1 . setVisibility ( View . INVISIBLE ) ; if ( mArrivalInfo . get ( i1 ) . getInfo ( ) . getFrequency ( ) != null ) { mEtaArrivalInfo1 . setText ( mResources . getString ( R . string . stop_info_frequency_approximate ) + mEtaArrivalInfo1 . getText ( ) ) ; } } mHeaderArrivalInfo . add ( mArrivalInfo . get ( i1 ) ) ; if ( etaIndexes . size ( ) >= 2 ) { final int i2 = etaIndexes . get ( 1 ) ; ObaArrivalInfo info2 = mArrivalInfo . get ( i2 ) . getInfo ( ) ; boolean isFavorite2 = ObaContract . RouteHeadsignFavorites . isFavorite ( info2 . getRouteId ( ) , info2 . getHeadsign ( ) , info2 . getStopId ( ) ) ; mEtaRouteFavorite2 . setImageResource ( isFavorite2 ? R . drawable . focus_star_on : R . drawable . focus_star_off ) ; mEtaRouteName2 . setText ( info2 . getShortName ( ) ) ; mEtaRouteDirection2 . setText ( UIUtils . formatDisplayText ( info2 . getHeadsign ( ) ) ) ; eta = mArrivalInfo . get ( i2 ) . getEta ( ) ; if ( eta == 0 ) { mEtaArrivalInfo2 . setText ( mContext . getString ( R . string . stop_info_eta_now ) ) ; mEtaArrivalInfo2 . setTextSize ( ETA_TEXT_NOW_SIZE_SP ) ; UIUtils . hideViewWithAnimation ( mEtaMin2 , mShortAnimationDuration ) ; } else if ( eta > 0 ) { mEtaArrivalInfo2 . setText ( Long . toString ( eta ) ) ; mEtaArrivalInfo2 . setTextSize ( ETA_TEXT_SIZE_SP ) ; UIUtils . showViewWithAnimation ( mEtaMin2 , mShortAnimationDuration ) ; } mEtaAndMin2 . setBackgroundResource ( R . drawable . round_corners_style_b_header_status ) ; GradientDrawable d2 = ( GradientDrawable ) mEtaAndMin2 . getBackground ( ) ; final int c2 = mArrivalInfo . get ( i2 ) . getColor ( ) ; if ( c2 != R . color . stop_info_ontime ) { d2 . setColor ( mResources . getColor ( c2 ) ) ; } else { d2 . setColor ( mResources . getColor ( R . color . header_stop_info_ontime ) ) ; } mEtaAndMin2 . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { if ( mPopup2 != null && mPopup2 . isShowing ( ) ) { mPopup2 . dismiss ( ) ; return; } mPopup2 = setupPopup ( 1 , c2 , mArrivalInfo . get ( i2 ) . getStatusText ( ) ) ; mPopup2 . showAsDropDown ( mEtaAndMin2 ) ; } } ) ; if ( mArrivalInfo . get ( i2 ) . getPredicted ( ) ) { UIUtils . showViewWithAnimation ( mEtaRealtime2 , mShortAnimationDuration ) ; } else { mEtaRealtime2 . setVisibility ( View . INVISIBLE ) ; if ( mArrivalInfo . get ( i2 ) . getInfo ( ) . getFrequency ( ) != null ) { mEtaArrivalInfo2 . setText ( mResources . getString ( R . string . stop_info_frequency_approximate ) + mEtaArrivalInfo2 . getText ( ) ) ; } } mNumHeaderArrivals = 2 ; mHeaderArrivalInfo . add ( mArrivalInfo . get ( i2 ) ) ; } else { mNumHeaderArrivals = 1 ; } } else { int minAfter = mController . getMinutesAfter ( ) ; if ( minAfter != - 1 ) { mNoArrivals . setText ( UIUtils . getNoArrivalsMessage ( mContext , minAfter , false , false ) ) ; } else { minAfter = 35 ; mNoArrivals . setText ( UIUtils . getNoArrivalsMessage ( mContext , minAfter , false , false ) ) ; } mNumHeaderArrivals = 0 ; } } }
@ Override public void onClick ( View v ) { if ( mPopup1 != null && mPopup1 . isShowing ( ) ) { mPopup1 . dismiss ( ) ; return; } mPopup1 = setupPopup ( 0 , c1 , mArrivalInfo . get ( i1 ) . getStatusText ( ) ) ; mPopup1 . showAsDropDown ( mEtaAndMin1 ) ; }
@ Override public void onClick ( View v ) { if ( mPopup2 != null && mPopup2 . isShowing ( ) ) { mPopup2 . dismiss ( ) ; return; } mPopup2 = setupPopup ( 1 , c2 , mArrivalInfo . get ( i2 ) . getStatusText ( ) ) ; mPopup2 . showAsDropDown ( mEtaAndMin2 ) ; }
private PopupWindow setupPopup ( final int index , int color , String statusText ) { LayoutInflater inflater = LayoutInflater . from ( mContext ) ; TextView statusView = ( TextView ) inflater . inflate ( R . layout . arrivals_list_tv_template_style_b_status_large , null ) ; statusView . setBackgroundResource ( R . drawable . round_corners_style_b_status ) ; GradientDrawable d = ( GradientDrawable ) statusView . getBackground ( ) ; if ( color != R . color . stop_info_ontime ) { d . setColor ( mResources . getColor ( color ) ) ; } else { d . setColor ( mResources . getColor ( R . color . header_stop_info_ontime ) ) ; } d . setStroke ( UIUtils . dpToPixels ( mContext , 1 ) , mResources . getColor ( R . color . header_text_color ) ) ; int pSides = UIUtils . dpToPixels ( mContext , 5 ) ; int pTopBottom = UIUtils . dpToPixels ( mContext , 2 ) ; statusView . setPadding ( pSides , pTopBottom , pSides , pTopBottom ) ; statusView . setLayoutParams ( new ViewGroup . LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ) ; statusView . measure ( TextView . MeasureSpec . UNSPECIFIED , TextView . MeasureSpec . UNSPECIFIED ) ; statusView . setText ( statusText ) ; PopupWindow p = new PopupWindow ( statusView , statusView . getWidth ( ) , statusView . getHeight ( ) ) ; p . setWindowLayoutMode ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ; p . setBackgroundDrawable ( new ColorDrawable ( mResources . getColor ( android . R . color . transparent ) ) ) ; p . setOutsideTouchable ( true ) ; p . setTouchInterceptor ( new View . OnTouchListener ( ) { @ Override public boolean onTouch ( View v , MotionEvent event ) { boolean touchInView ; if ( index == 0 ) { touchInView = UIUtils . isTouchInView ( mEtaAndMin1 , event ) ; } else { touchInView = UIUtils . isTouchInView ( mEtaAndMin2 , event ) ; } return touchInView ; } } ) ; return p ; }
@ Override public boolean onTouch ( View v , MotionEvent event ) { boolean touchInView ; if ( index == 0 ) { touchInView = UIUtils . isTouchInView ( mEtaAndMin1 , event ) ; } else { touchInView = UIUtils . isTouchInView ( mEtaAndMin2 , event ) ; } return touchInView ; }
private void refreshStopFavorite ( ) { mStopFavorite . setImageResource ( mController . isFavoriteStop ( ) ? R . drawable . focus_star_on : R . drawable . focus_star_off ) ; }
private void refreshFilter ( ) { TextView v = ( TextView ) mView . findViewById ( R . id . filter_text ) ; ArrayList < String > routesFilter = mController . getRoutesFilter ( ) ; final int num = ( routesFilter != null ) ? routesFilter . size ( ) : 0 ; if ( num > 0 ) { final int total = mController . getNumRoutes ( ) ; v . setText ( mContext . getString ( R . string . stop_info_filter_header , num , total ) ) ; if ( mInNameEdit ) { mFilterGroup . setVisibility ( View . GONE ) ; } else { mFilterGroup . setVisibility ( View . VISIBLE ) ; } } else { mFilterGroup . setVisibility ( View . GONE ) ; } }
private boolean isFilteringRoutes ( ) { ArrayList < String > routesFilter = mController . getRoutesFilter ( ) ; final int num = ( routesFilter != null ) ? routesFilter . size ( ) : 0 ; return num > 0 ; }
@ TargetApi ( Build . VERSION_CODES . HONEYCOMB ) private void refreshArrivalInfoVisibilityAndListeners ( ) { if ( mInNameEdit ) { return; } if ( mArrivalInfo == null ) { UIUtils . showViewWithAnimation ( mProgressBar , mShortAnimationDuration ) ; UIUtils . hideViewWithAnimation ( mNoArrivals , mShortAnimationDuration ) ; UIUtils . hideViewWithAnimation ( mEtaContainer1 , mShortAnimationDuration ) ; UIUtils . hideViewWithAnimation ( mEtaSeparator , mShortAnimationDuration ) ; UIUtils . hideViewWithAnimation ( mEtaContainer2 , mShortAnimationDuration ) ; return; } if ( mNumHeaderArrivals == 0 ) { UIUtils . showViewWithAnimation ( mNoArrivals , mShortAnimationDuration ) ; UIUtils . hideViewWithAnimation ( mEtaContainer1 , mShortAnimationDuration ) ; UIUtils . hideViewWithAnimation ( mEtaSeparator , mShortAnimationDuration ) ; UIUtils . hideViewWithAnimation ( mEtaContainer2 , mShortAnimationDuration ) ; } if ( mNumHeaderArrivals >= 1 ) { UIUtils . showViewWithAnimation ( mEtaContainer1 , mShortAnimationDuration ) ; UIUtils . hideViewWithAnimation ( mNoArrivals , mShortAnimationDuration ) ; final ObaArrivalInfo info1 = mHeaderArrivalInfo . get ( 0 ) . getInfo ( ) ; final boolean isRouteFavorite = ObaContract . RouteHeadsignFavorites . isFavorite ( info1 . getRouteId ( ) , info1 . getHeadsign ( ) , info1 . getStopId ( ) ) ; mEtaRouteFavorite1 . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { RouteFavoriteDialogFragment dialog = new RouteFavoriteDialogFragment . Builder ( info1 . getRouteId ( ) , UIUtils . formatDisplayText ( info1 . getHeadsign ( ) ) ) . setRouteShortName ( info1 . getShortName ( ) ) . setRouteLongName ( info1 . getRouteLongName ( ) ) . setStopId ( info1 . getStopId ( ) ) . setFavorite ( ! isRouteFavorite ) . build ( ) ; dialog . setCallback ( new RouteFavoriteDialogFragment . Callback ( ) { @ Override public void onSelectionComplete ( boolean savedFavorite ) { if ( savedFavorite ) { mController . refreshLocal ( ) ; } } } ) ; dialog . show ( mFragmentManager , RouteFavoriteDialogFragment . TAG ) ; } } ) ; mEtaReminder1 . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { TripInfoActivity . start ( mContext , info1 . getTripId ( ) , mController . getStopId ( ) , info1 . getRouteId ( ) , info1 . getShortName ( ) , mController . getStopName ( ) , info1 . getScheduledDepartureTime ( ) , info1 . getHeadsign ( ) ) ; } } ) ; mEtaMoreVert1 . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { mController . showListItemMenu ( mEtaContainer1 , mHeaderArrivalInfo . get ( 0 ) ) ; } } ) ; View r = mEtaContainer1 . findViewById ( R . id . reminder ) ; refreshReminder ( mHeaderArrivalInfo . get ( 0 ) . getInfo ( ) . getTripId ( ) , r ) ; } if ( mNumHeaderArrivals >= 2 ) { UIUtils . showViewWithAnimation ( mEtaSeparator , mShortAnimationDuration ) ; UIUtils . showViewWithAnimation ( mEtaContainer2 , mShortAnimationDuration ) ; final ObaArrivalInfo info2 = mHeaderArrivalInfo . get ( 1 ) . getInfo ( ) ; final boolean isRouteFavorite2 = ObaContract . RouteHeadsignFavorites . isFavorite ( info2 . getRouteId ( ) , info2 . getHeadsign ( ) , info2 . getStopId ( ) ) ; mEtaRouteFavorite2 . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { RouteFavoriteDialogFragment dialog = new RouteFavoriteDialogFragment . Builder ( info2 . getRouteId ( ) , info2 . getHeadsign ( ) ) . setRouteShortName ( info2 . getShortName ( ) ) . setRouteLongName ( info2 . getRouteLongName ( ) ) . setStopId ( info2 . getStopId ( ) ) . setFavorite ( ! isRouteFavorite2 ) . build ( ) ; dialog . setCallback ( new RouteFavoriteDialogFragment . Callback ( ) { @ Override public void onSelectionComplete ( boolean savedFavorite ) { if ( savedFavorite ) { mController . refreshLocal ( ) ; } } } ) ; dialog . show ( mFragmentManager , RouteFavoriteDialogFragment . TAG ) ; } } ) ; mEtaReminder2 . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { TripInfoActivity . start ( mContext , info2 . getTripId ( ) , mController . getStopId ( ) , info2 . getRouteId ( ) , info2 . getShortName ( ) , mController . getStopName ( ) , info2 . getScheduledDepartureTime ( ) , info2 . getHeadsign ( ) ) ; } } ) ; mEtaMoreVert2 . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { mController . showListItemMenu ( mEtaContainer2 , mHeaderArrivalInfo . get ( 1 ) ) ; } } ) ; View r = mEtaContainer2 . findViewById ( R . id . reminder ) ; refreshReminder ( mHeaderArrivalInfo . get ( 1 ) . getInfo ( ) . getTripId ( ) , r ) ; } else { UIUtils . hideViewWithAnimation ( mEtaSeparator , mShortAnimationDuration ) ; UIUtils . hideViewWithAnimation ( mEtaContainer2 , mShortAnimationDuration ) ; } UIUtils . hideViewWithAnimation ( mProgressBar , mShortAnimationDuration ) ; }
@ Override public void onClick ( View v ) { RouteFavoriteDialogFragment dialog = new RouteFavoriteDialogFragment . Builder ( info1 . getRouteId ( ) , UIUtils . formatDisplayText ( info1 . getHeadsign ( ) ) ) . setRouteShortName ( info1 . getShortName ( ) ) . setRouteLongName ( info1 . getRouteLongName ( ) ) . setStopId ( info1 . getStopId ( ) ) . setFavorite ( ! isRouteFavorite ) . build ( ) ; dialog . setCallback ( new RouteFavoriteDialogFragment . Callback ( ) { @ Override public void onSelectionComplete ( boolean savedFavorite ) { if ( savedFavorite ) { mController . refreshLocal ( ) ; } } } ) ; dialog . show ( mFragmentManager , RouteFavoriteDialogFragment . TAG ) ; }
@ Override public void onSelectionComplete ( boolean savedFavorite ) { if ( savedFavorite ) { mController . refreshLocal ( ) ; } }
@ Override public void onClick ( View v ) { TripInfoActivity . start ( mContext , info1 . getTripId ( ) , mController . getStopId ( ) , info1 . getRouteId ( ) , info1 . getShortName ( ) , mController . getStopName ( ) , info1 . getScheduledDepartureTime ( ) , info1 . getHeadsign ( ) ) ; }
@ Override public void onClick ( View v ) { mController . showListItemMenu ( mEtaContainer1 , mHeaderArrivalInfo . get ( 0 ) ) ; }
@ Override public void onClick ( View v ) { RouteFavoriteDialogFragment dialog = new RouteFavoriteDialogFragment . Builder ( info2 . getRouteId ( ) , info2 . getHeadsign ( ) ) . setRouteShortName ( info2 . getShortName ( ) ) . setRouteLongName ( info2 . getRouteLongName ( ) ) . setStopId ( info2 . getStopId ( ) ) . setFavorite ( ! isRouteFavorite2 ) . build ( ) ; dialog . setCallback ( new RouteFavoriteDialogFragment . Callback ( ) { @ Override public void onSelectionComplete ( boolean savedFavorite ) { if ( savedFavorite ) { mController . refreshLocal ( ) ; } } } ) ; dialog . show ( mFragmentManager , RouteFavoriteDialogFragment . TAG ) ; }
@ Override public void onSelectionComplete ( boolean savedFavorite ) { if ( savedFavorite ) { mController . refreshLocal ( ) ; } }
@ Override public void onClick ( View v ) { TripInfoActivity . start ( mContext , info2 . getTripId ( ) , mController . getStopId ( ) , info2 . getRouteId ( ) , info2 . getShortName ( ) , mController . getStopName ( ) , info2 . getScheduledDepartureTime ( ) , info2 . getHeadsign ( ) ) ; }
@ Override public void onClick ( View v ) { mController . showListItemMenu ( mEtaContainer2 , mHeaderArrivalInfo . get ( 1 ) ) ; }
void refreshReminder ( String tripId , View v ) { ContentValues values = null ; if ( mTripsForStop != null ) { values = mTripsForStop . getValues ( tripId ) ; } if ( values != null ) { v . setVisibility ( View . VISIBLE ) ; } else { v . setVisibility ( View . GONE ) ; } }
void refreshHeaderSize ( ) { if ( mInNameEdit ) { if ( ! mShowArrivals ) { setHeaderSize ( HEADER_HEIGHT_EDIT_NAME_DP ) ; } return; } float newSize = 0 ; if ( ! mShowArrivals ) { newSize = HEADER_HEIGHT_NO_ARRIVALS_DP ; } else if ( mNumHeaderArrivals == 0 || mNumHeaderArrivals == 1 ) { newSize = HEADER_HEIGHT_ONE_ARRIVAL_DP ; } else if ( mNumHeaderArrivals == 2 ) { newSize = HEADER_HEIGHT_TWO_ARRIVALS_DP ; } if ( isFilteringRoutes ( ) ) { newSize += HEADER_OFFSET_FILTER_ROUTES_DP ; } if ( newSize != 0 ) { setHeaderSize ( newSize ) ; } }
void setHeaderSize ( float newHeightDp ) { int heightPixels = UIUtils . dpToPixels ( mContext , newHeightDp ) ; if ( mSlidingPanelController != null ) { mSlidingPanelController . setPanelHeightPixels ( heightPixels ) ; } else { mView . getLayoutParams ( ) . height = heightPixels ; mMainContainerView . getLayoutParams ( ) . height = heightPixels ; } }
ResponseError ( CharSequence seq ) { mString = seq ; }
@ Override public String getId ( ) { return "STATIC: RESPONSE ERROR" ; }
@ Override public int getType ( ) { return TYPE_ERROR ; }
@ Override public int getFlags ( ) { return 0 ; }
@ Override public CharSequence getString ( ) { return mString ; }
@ Override public void onClick ( ) {        }
@ Override public int hashCode ( ) { return getId ( ) . hashCode ( ) ; }
@ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } ResponseError other = ( ResponseError ) obj ; if ( ! getId ( ) . equals ( other . getId ( ) ) ) { return false ; } return true ; }
private void refreshError ( ) { final long now = System . currentTimeMillis ( ) ; final long responseTime = mController . getLastGoodResponseTime ( ) ; AlertList alerts = mController . getAlertList ( ) ; mHasWarning = false ; mHasError = false ; if ( mResponseError != null ) { alerts . remove ( mResponseError ) ; } if ( ( responseTime ) != 0 && ( ( now - responseTime ) >= 2 * DateUtils . MINUTE_IN_MILLIS ) ) { CharSequence relativeTime = DateUtils . getRelativeTimeSpanString ( responseTime , now , DateUtils . MINUTE_IN_MILLIS , 0 ) ; CharSequence s = mContext . getString ( R . string . stop_info_old_data , relativeTime ) ; mResponseError = new ResponseError ( s ) ; alerts . insert ( mResponseError , 0 ) ; } for ( int i = 0 ; i < alerts . getCount ( ) ; i ++ ) { AlertList . Alert a = alerts . getItem ( i ) ; if ( a . getType ( ) == AlertList . Alert . TYPE_WARNING ) { mHasWarning = true ; } if ( a . getType ( ) == AlertList . Alert . TYPE_ERROR ) { mHasError = true ; } } if ( mHasError ) { mAlertView . setVisibility ( View . VISIBLE ) ; mAlertView . setColorFilter ( mResources . getColor ( R . color . alert_icon_error ) ) ; mAlertView . setContentDescription ( mResources . getString ( R . string . alert_content_description_error ) ) ; } else if ( mHasWarning ) { mAlertView . setVisibility ( View . VISIBLE ) ; mAlertView . setColorFilter ( mResources . getColor ( R . color . alert_icon_warning ) ) ; mAlertView . setContentDescription ( mResources . getString ( R . string . alert_content_description_warning ) ) ; } else { mAlertView . setVisibility ( View . GONE ) ; mAlertView . setContentDescription ( "" ) ; } }
ShowHiddenAlert ( CharSequence seq , Controller controller ) { mString = seq ; mController = controller ; }
@ Override public String getId ( ) { return "STATIC: SHOW HIDDEN ALERT" ; }
@ Override public int getType ( ) { return TYPE_SHOW_HIDDEN_ALERTS ; }
@ Override public int getFlags ( ) { return FLAG_HASMORE ; }
@ Override public CharSequence getString ( ) { return mString ; }
@ Override public void onClick ( ) { ObaContract . ServiceAlerts . showAllAlerts ( ) ; mController . refresh ( ) ; }
@ Override public int hashCode ( ) { return getId ( ) . hashCode ( ) ; }
@ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } ShowHiddenAlert other = ( ShowHiddenAlert ) obj ; return getId ( ) . equals ( other . getId ( ) ) ; }
private void refreshHiddenAlerts ( ) { AlertList alerts = mController . getAlertList ( ) ; mIsAlertHidden = alerts . isAlertHidden ( ) ; if ( mShowHiddenAlert != null ) { alerts . remove ( mShowHiddenAlert ) ; } if ( mIsAlertHidden ) { CharSequence cs = mContext . getResources ( ) . getQuantityString ( R . plurals . alert_filter_text , alerts . getHiddenAlertCount ( ) , alerts . getHiddenAlertCount ( ) ) ; mShowHiddenAlert = new ShowHiddenAlert ( cs , mController ) ; alerts . insert ( mShowHiddenAlert , alerts . getCount ( ) ) ; } }
synchronized void beginNameEdit ( String initial ) { mEditNameView . setText ( ( initial != null ) ? initial : mNameView . getText ( ) ) ; mNameContainerView . setVisibility ( View . GONE ) ; mFilterGroup . setVisibility ( View . GONE ) ; mStopFavorite . setVisibility ( View . GONE ) ; mEtaContainer1 . setVisibility ( View . GONE ) ; mEtaSeparator . setVisibility ( View . GONE ) ; mEtaContainer2 . setVisibility ( View . GONE ) ; mNoArrivals . setVisibility ( View . GONE ) ; mAlertView . setVisibility ( View . GONE ) ; cachedExpandCollapseViewVisibility = mExpandCollapse . getVisibility ( ) ; if ( ! UIUtils . canAnimateViewModern ( ) ) { mExpandCollapse . clearAnimation ( ) ; } mExpandCollapse . setVisibility ( View . GONE ) ; mEditNameContainerView . setVisibility ( View . VISIBLE ) ; if ( ! mShowArrivals ) { setHeaderSize ( HEADER_HEIGHT_EDIT_NAME_DP ) ; } mEditNameView . requestFocus ( ) ; mEditNameView . setSelection ( mEditNameView . getText ( ) . length ( ) ) ; mInNameEdit = true ; UIUtils . openKeyboard ( mContext ) ; }
synchronized void endNameEdit ( ) { mInNameEdit = false ; mNameContainerView . setVisibility ( View . VISIBLE ) ; mEditNameContainerView . setVisibility ( View . GONE ) ; mStopFavorite . setVisibility ( View . VISIBLE ) ; mExpandCollapse . setVisibility ( cachedExpandCollapseViewVisibility ) ; mNoArrivals . setVisibility ( View . VISIBLE ) ; if ( mHasError || mHasWarning ) { mAlertView . setVisibility ( View . VISIBLE ) ; } UIUtils . closeKeyboard ( mContext , mEditNameView ) ; refresh ( ) ; }
public void closeStatusPopups ( ) { if ( mPopup1 != null ) { mPopup1 . dismiss ( ) ; } if ( mPopup2 != null ) { mPopup2 . dismiss ( ) ; } }
public void showProgress ( boolean visibility ) { if ( mProgressBar == null ) return; if ( visibility ) { mProgressBar . setVisibility ( View . VISIBLE ) ; } else { mProgressBar . setVisibility ( View . GONE ) ; } }
public ObaContext ( ) {    }
public void setAppInfo ( int version , String uuid ) { mAppVer = version ; mAppUid = uuid ; }
public void setAppInfo ( Uri . Builder builder ) { if ( mAppVer != 0 ) { builder . appendQueryParameter ( "app_ver" , String . valueOf ( mAppVer ) ) ; } if ( mAppUid != null ) { builder . appendQueryParameter ( "app_uid" , mAppUid ) ; } }
public void setApiKey ( String apiKey ) { mApiKey = apiKey ; }
public String getApiKey ( ) { return mApiKey ; }
public void setRegion ( ObaRegion region ) { mRegion = region ; }
public ObaRegion getRegion ( ) { return mRegion ; }
public ObaConnectionFactory setConnectionFactory ( ObaConnectionFactory factory ) { ObaConnectionFactory prev = mConnectionFactory ; mConnectionFactory = factory ; return prev ; }
public ObaConnectionFactory getConnectionFactory ( ) { return mConnectionFactory ; }
public void setBaseUrl ( Context context , Uri . Builder builder ) { String serverName = Application . get ( ) . getCustomApiUrl ( ) ; if ( ! TextUtils . isEmpty ( serverName ) || mRegion != null ) { Uri baseUrl = null ; if ( ! TextUtils . isEmpty ( serverName ) ) { Log . d ( TAG , "Using custom API URL set by user '" + serverName + "'." ) ; try { URL url = new URL ( serverName ) ; } catch ( MalformedURLException e ) { serverName = context . getString ( R . string . http_prefix ) + serverName ; } baseUrl = Uri . parse ( serverName ) ; } else if ( mRegion != null ) { Log . d ( TAG , "Using region base URL '" + mRegion . getObaBaseUrl ( ) + "'." ) ; baseUrl = Uri . parse ( mRegion . getObaBaseUrl ( ) ) ; } Uri . Builder path = new Uri . Builder ( ) ; path . encodedPath ( baseUrl . getEncodedPath ( ) ) ; path . appendEncodedPath ( builder . build ( ) . getPath ( ) ) ; builder . scheme ( baseUrl . getScheme ( ) ) ; builder . encodedAuthority ( baseUrl . getEncodedAuthority ( ) ) ; builder . encodedPath ( path . build ( ) . getEncodedPath ( ) ) ; } else { String fallBack = "api.pugetsound.onebusaway.org" ; Log . e ( TAG , "Accessing default fallback '" + fallBack + "' ...this is wrong!!" ) ; builder . scheme ( "http" ) ; builder . authority ( fallBack ) ; } }
@ Override public ObaContext clone ( ) { ObaContext result = new ObaContext ( ) ; result . setApiKey ( mApiKey ) ; result . setAppInfo ( mAppVer , mAppUid ) ; result . setConnectionFactory ( mConnectionFactory ) ; return result ; }
public GitOperation ( File fileDir , Activity callingActivity ) { this . repository = PasswordRepository . getRepository ( fileDir ) ; this . callingActivity = callingActivity ; }
public GitOperation setAuthentication ( String username , String password ) { SshSessionFactory . setInstance ( new GitConfigSessionFactory ( ) ) ; this . provider = new UsernamePasswordCredentialsProvider ( username , password ) ; return this ; }
public GitOperation setAuthentication ( File sshKey , String username , String passphrase ) { JschConfigSessionFactory sessionFactory = new SshConfigSessionFactory ( sshKey . getAbsolutePath ( ) , username , passphrase ) ; SshSessionFactory . setInstance ( sessionFactory ) ; this . provider = null ; return this ; }
public abstract void execute ( )
public void executeAfterAuthentication ( final String connectionMode , final String username , @ Nullable final File sshKey ) { executeAfterAuthentication ( connectionMode , username , sshKey , false ) ; }
private void executeAfterAuthentication ( final String connectionMode , final String username , @ Nullable final File sshKey , final boolean showError ) { if ( connectionMode . equalsIgnoreCase ( "ssh-key" ) ) { if ( sshKey == null || ! sshKey . exists ( ) ) { new AlertDialog . Builder ( callingActivity ) . setMessage ( callingActivity . getResources ( ) . getString ( R . string . ssh_preferences_dialog_text ) ) . setTitle ( callingActivity . getResources ( ) . getString ( R . string . ssh_preferences_dialog_title ) ) . setPositiveButton ( callingActivity . getResources ( ) . getString ( R . string . ssh_preferences_dialog_import ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int id ) { try { Intent intent = new Intent ( callingActivity . getApplicationContext ( ) , UserPreference .class ) ; intent . putExtra ( "operation" , "get_ssh_key" ) ; callingActivity . startActivityForResult ( intent , GET_SSH_KEY_FROM_CLONE ) ; } catch ( Exception e ) { System . out . println ( "Exception caught :(" ) ; e . printStackTrace ( ) ; } } } ) . setNegativeButton ( callingActivity . getResources ( ) . getString ( R . string . ssh_preferences_dialog_generate ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { try { Intent intent = new Intent ( callingActivity . getApplicationContext ( ) , UserPreference .class ) ; intent . putExtra ( "operation" , "make_ssh_key" ) ; callingActivity . startActivityForResult ( intent , GET_SSH_KEY_FROM_CLONE ) ; } catch ( Exception e ) { System . out . println ( "Exception caught :(" ) ; e . printStackTrace ( ) ; } } } ) . setNeutralButton ( callingActivity . getResources ( ) . getString ( R . string . dialog_cancel ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int id ) { callingActivity . finish ( ) ; } } ) . show ( ) ; } else { final EditText passphrase = new EditText ( callingActivity ) ; passphrase . setHint ( "Passphrase" ) ; passphrase . setWidth ( LinearLayout . LayoutParams . MATCH_PARENT ) ; passphrase . setInputType ( InputType . TYPE_CLASS_TEXT | InputType . TYPE_TEXT_VARIATION_PASSWORD ) ; if ( showError ) { passphrase . setError ( "Wrong passphrase" ) ; } JSch jsch = new JSch ( ) ; try { final KeyPair keyPair = KeyPair . load ( jsch , callingActivity . getFilesDir ( ) + "/.ssh_key" ) ; if ( keyPair . isEncrypted ( ) ) { new AlertDialog . Builder ( callingActivity ) . setTitle ( callingActivity . getResources ( ) . getString ( R . string . passphrase_dialog_title ) ) . setMessage ( callingActivity . getResources ( ) . getString ( R . string . passphrase_dialog_text ) ) . setView ( passphrase ) . setPositiveButton ( callingActivity . getResources ( ) . getString ( R . string . dialog_ok ) , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int whichButton ) { if ( keyPair . decrypt ( passphrase . getText ( ) . toString ( ) ) ) { setAuthentication ( sshKey , username , passphrase . getText ( ) . toString ( ) ) . execute ( ) ; } else { executeAfterAuthentication ( connectionMode , username , sshKey , true ) ; } } } ) . setNegativeButton ( callingActivity . getResources ( ) . getString ( R . string . dialog_cancel ) , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int whichButton ) { } } ) . show ( ) ; } else { setAuthentication ( sshKey , username , "" ) . execute ( ) ; } } catch ( JSchException e ) { new AlertDialog . Builder ( callingActivity ) . setTitle ( "Unable to open the ssh-key" ) . setMessage ( "Please check that it was imported." ) . setPositiveButton ( "Ok" , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialogInterface , int i ) {                                } } ) . show ( ) ; } } } else { final EditText password = new EditText ( callingActivity ) ; password . setHint ( "Password" ) ; password . setWidth ( LinearLayout . LayoutParams . MATCH_PARENT ) ; password . setInputType ( InputType . TYPE_CLASS_TEXT | InputType . TYPE_TEXT_VARIATION_PASSWORD ) ; new AlertDialog . Builder ( callingActivity ) . setTitle ( callingActivity . getResources ( ) . getString ( R . string . passphrase_dialog_title ) ) . setMessage ( callingActivity . getResources ( ) . getString ( R . string . password_dialog_text ) ) . setView ( password ) . setPositiveButton ( callingActivity . getResources ( ) . getString ( R . string . dialog_ok ) , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int whichButton ) { setAuthentication ( username , password . getText ( ) . toString ( ) ) . execute ( ) ; } } ) . setNegativeButton ( callingActivity . getResources ( ) . getString ( R . string . dialog_cancel ) , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int whichButton ) { } } ) . show ( ) ; } }
@ Override public void onClick ( DialogInterface dialog , int id ) { try { Intent intent = new Intent ( callingActivity . getApplicationContext ( ) , UserPreference .class ) ; intent . putExtra ( "operation" , "get_ssh_key" ) ; callingActivity . startActivityForResult ( intent , GET_SSH_KEY_FROM_CLONE ) ; } catch ( Exception e ) { System . out . println ( "Exception caught :(" ) ; e . printStackTrace ( ) ; } }
@ Override public void onClick ( DialogInterface dialog , int which ) { try { Intent intent = new Intent ( callingActivity . getApplicationContext ( ) , UserPreference .class ) ; intent . putExtra ( "operation" , "make_ssh_key" ) ; callingActivity . startActivityForResult ( intent , GET_SSH_KEY_FROM_CLONE ) ; } catch ( Exception e ) { System . out . println ( "Exception caught :(" ) ; e . printStackTrace ( ) ; } }
@ Override public void onClick ( DialogInterface dialog , int id ) { callingActivity . finish ( ) ; }
public void onClick ( DialogInterface dialog , int whichButton ) { if ( keyPair . decrypt ( passphrase . getText ( ) . toString ( ) ) ) { setAuthentication ( sshKey , username , passphrase . getText ( ) . toString ( ) ) . execute ( ) ; } else { executeAfterAuthentication ( connectionMode , username , sshKey , true ) ; } }
public void onClick ( DialogInterface dialog , int whichButton ) { }
@ Override public void onClick ( DialogInterface dialogInterface , int i ) {                                }
public void onClick ( DialogInterface dialog , int whichButton ) { setAuthentication ( username , password . getText ( ) . toString ( ) ) . execute ( ) ; }
public void onClick ( DialogInterface dialog , int whichButton ) { }
public void onTaskEnded ( String result ) { new AlertDialog . Builder ( callingActivity ) . setTitle ( callingActivity . getResources ( ) . getString ( R . string . jgit_error_dialog_title ) ) . setMessage ( "Error occurred during a Git operation, " + callingActivity . getResources ( ) . getString ( R . string . jgit_error_dialog_text ) + result + "\nPlease check the FAQ for possible reasons why this error might occur." ) . setPositiveButton ( callingActivity . getResources ( ) . getString ( R . string . dialog_ok ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialogInterface , int i ) { callingActivity . setResult ( Activity . RESULT_CANCELED ) ; callingActivity . finish ( ) ; } } ) . show ( ) ; }
@ Override public void onClick ( DialogInterface dialogInterface , int i ) { callingActivity . setResult ( Activity . RESULT_CANCELED ) ; callingActivity . finish ( ) ; }
public String getShortName ( )
public String getShapeId ( )
public int getDirectionId ( )
public String getServiceId ( )
public String getHeadsign ( )
public String getTimezone ( )
public String getRouteId ( )
public String getBlockId ( )
public BuildConfigInjectionSampleIT ( MavenRuntimeBuilder builder ) throws Exception { this . mavenRuntime = builder . build ( ) ; }
@ Test public void buildDeployAndRun ( ) Exception { File basedir = resources . getBasedir ( "buildConfigInjection" ) ; MavenExecutionResult result = mavenRuntime . forProject ( basedir ) . execute ( "clean" , PluginInfo . getQualifiedGoal ( "undeploy" ) , "install" , PluginInfo . getQualifiedGoal ( "deploy" ) , PluginInfo . getQualifiedGoal ( "run" ) ) ; result . assertErrorFreeLog ( ) ; result . assertLogText ( "Successfully installed" ) ; result . assertLogText ( "Attempting to start com.simpligility.android.helloflashlightinjection/com.simpligility.android.helloflashlightinjection.HelloFlashlight" ) ; }
@ Override public void onCreate ( ) { super. onCreate ( ) ; component = createComponent ( ) ; AppCompatDelegate . setCompatVectorFromResourcesEnabled ( true ) ; installLeakCanary ( ) ; AndroidThreeTen . init ( this ) ; initTraceDroid ( ) ; AppCompatDelegate . setDefaultNightMode ( component . settings ( ) . getNightMode ( ) ) ; }
public void installLeakCanary ( ) { LeakCanary . install ( this ) ; }
public AppComponent createComponent ( ) { return DaggerAppComponent . builder ( ) . appModule ( new AppModule ( this ) ) . trackerModule ( new TrackerModule ( this ) ) . build ( ) ; }
private void initTraceDroid ( ) { TraceDroid . init ( this ) ; Log . setTAG ( "PassAndroid" ) ; }
public static AppComponent component ( ) { return component ; }
@ VisibleForTesting public static void setComponent ( AppComponent newComponent ) { component = newComponent ; }
static void notifyLoadFinished ( Context context ) { sendBroadcast ( context , CATEGORY_TEST , ACTION_LOAD_FINISHED ) ; }
static void sendBroadcast ( Context context , String action , String category ) { if ( BuildConfig . DEBUG ) { Intent intent = new Intent ( ) ; intent . setAction ( action ) ; intent . addCategory ( category ) ; context . sendBroadcast ( intent ) ; } }
public static void waitForLoadFinished ( Context context ) throws InterruptedException { waitForBroadcast ( context , ACTION_LOAD_FINISHED , CATEGORY_TEST ) ; }
public static void waitForBroadcast ( Context context , String action , String category )            throws InterruptedException { final CountDownLatch signal = new CountDownLatch ( 1 ) ; IntentFilter intentFilter = new IntentFilter ( action ) ; intentFilter . addCategory ( category ) ; BroadcastReceiver broadcastReceiver = new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { signal . countDown ( ) ; } } ; context . registerReceiver ( broadcastReceiver , intentFilter ) ; signal . await ( 10000 , TimeUnit . MILLISECONDS ) ; context . unregisterReceiver ( broadcastReceiver ) ; Thread . sleep ( 1000 ) ; }
@ Override public void onReceive ( Context context , Intent intent ) { signal . countDown ( ) ; }
public static boolean isRunningOnEmulator ( ) { return Build . FINGERPRINT . contains ( "generic" ) ; }
PassSortOrder getSortOrder ( )
boolean doTraceDroidEmailSend ( )
File getPassesDir ( )
File getStateDir ( )
boolean isCondensedModeEnabled ( )
boolean isAutomaticLightEnabled ( )
@ AppCompatDelegate . NightMode int getNightMode ( )
@ Override public void onActivityCreated ( Bundle savedInstanceState ) { super. onActivityCreated ( savedInstanceState ) ; mAdapter = new MyAdapter ( getActivity ( ) ) ; setListAdapter ( mAdapter ) ; }
@ Override public View onCreateView ( LayoutInflater inflater , ViewGroup root , Bundle savedInstanceState ) { if ( root == null ) { return null ; } return inflater . inflate ( R . layout . my_search_route_list , null ) ; }
@ Override public Loader < ObaRoutesForLocationResponse > onCreateLoader ( int id , Bundle args ) { String query = args . getString ( QUERY_TEXT ) ; return new MyLoader ( getActivity ( ) , query , getSearchCenter ( ) ) ; }
@ Override public void onLoadFinished ( Loader < ObaRoutesForLocationResponse > loader , ObaRoutesForLocationResponse response ) { UIUtils . showProgress ( this , false ) ; final int code = response . getCode ( ) ; if ( code == ObaApi . OBA_OK ) { setEmptyText ( getString ( R . string . find_hint_noresults ) ) ; mAdapter . setData ( Arrays . asList ( response . getRoutesForLocation ( ) ) ) ; } else if ( code != 0 ) { setEmptyText ( getString ( R . string . find_hint_noresults ) ) ; } else { setEmptyText ( getString ( R . string . generic_comm_error ) ) ; } }
@ Override public void onLoaderReset ( Loader < ObaRoutesForLocationResponse > loader ) { mAdapter . clear ( ) ; }
@ Override protected void doSearch ( String text ) { UIUtils . showProgress ( this , true ) ; Bundle args = new Bundle ( ) ; args . putString ( QUERY_TEXT , text ) ; Loader < ? > loader = getLoaderManager ( ) . restartLoader ( 0 , args , this ) ; loader . onContentChanged ( ) ; }
@ Override protected int getEditBoxHintText ( ) { return R . string . search_route_hint ; }
@ Override protected int getMinSearchLength ( ) { return 1 ; }
@ Override protected CharSequence getHintText ( ) { return getString ( R . string . find_hint_nofavoriteroutes ) ; }
@ Override public void onListItemClick ( ListView l , View v , int position , long id ) { ListAdapter adapter = l . getAdapter ( ) ; ObaRoute route = ( ObaRoute ) adapter . getItem ( position - l . getHeaderViewsCount ( ) ) ; final String routeId = route . getId ( ) ; final String routeName = UIUtils . getRouteDisplayName ( route ) ; if ( isShortcutMode ( ) ) { Intent intent = RouteInfoActivity . makeIntent ( getActivity ( ) , routeId ) ; makeShortcut ( routeName , intent ) ; } else { RouteInfoActivity . start ( getActivity ( ) , routeId ) ; } }
@ Override public void onCreateContextMenu ( ContextMenu menu , View v , ContextMenuInfo menuInfo ) { super. onCreateContextMenu ( menu , v , menuInfo ) ; AdapterContextMenuInfo info = ( AdapterContextMenuInfo ) menuInfo ; final TextView text = ( TextView ) info . targetView . findViewById ( R . id . short_name ) ; menu . setHeaderTitle ( getString ( R . string . route_name , text . getText ( ) ) ) ; if ( isShortcutMode ( ) ) { menu . add ( 0 , CONTEXT_MENU_DEFAULT , 0 , R . string . my_context_create_shortcut ) ; } else { menu . add ( 0 , CONTEXT_MENU_DEFAULT , 0 , R . string . my_context_get_route_info ) ; } menu . add ( 0 , CONTEXT_MENU_SHOW_ON_MAP , 0 , R . string . my_context_showonmap ) ; final String url = getUrl ( getListView ( ) , info . position ) ; if ( url != null ) { menu . add ( 0 , CONTEXT_MENU_SHOW_URL , 0 , R . string . my_context_show_schedule ) ; } }
@ Override public boolean onContextItemSelected ( MenuItem item ) { AdapterContextMenuInfo info = ( AdapterContextMenuInfo ) item . getMenuInfo ( ) ; switch ( item . getItemId ( ) ) { case CONTEXT_MENU_DEFAULT : onListItemClick ( getListView ( ) , info . targetView , info . position , info . id ) ; return true ; case CONTEXT_MENU_SHOW_ON_MAP : HomeActivity . start ( getActivity ( ) , getId ( getListView ( ) , info . position ) ) ; return true ; case CONTEXT_MENU_SHOW_URL : UIUtils . goToUrl ( getActivity ( ) , getUrl ( getListView ( ) , info . position ) ) ; return true ; default: return super. onContextItemSelected ( item ) ; } }
private String getId ( ListView l , int position ) { ListAdapter adapter = l . getAdapter ( ) ; ObaRoute route = ( ObaRoute ) adapter . getItem ( position - l . getHeaderViewsCount ( ) ) ; return route . getId ( ) ; }
private String getUrl ( ListView l , int position ) { ListAdapter adapter = l . getAdapter ( ) ; ObaRoute route = ( ObaRoute ) adapter . getItem ( position - l . getHeaderViewsCount ( ) ) ; return route . getUrl ( ) ; }
public MyAdapter ( Context context ) { super( context , R . layout . route_list_item ); }
@ Override protected void initView ( View view , ObaRoute route ) { UIUtils . setRouteView ( view , route ) ; }
public MyLoader ( Context context , String query , Location center ) { super( context ); mQueryText = query ; mCenter = center ; }
@ Override public ObaRoutesForLocationResponse loadInBackground ( ) { ObaRoutesForLocationResponse response = new ObaRoutesForLocationRequest . Builder ( getContext ( ) , mCenter ) . setQuery ( mQueryText ) . build ( ) . call ( ) ; if ( response . getCode ( ) == ObaApi . OBA_OK ) { ObaRoute [] routes = response . getRoutesForLocation ( ) ; if ( routes . length != 0 ) { return response ; } } Location center = LocationUtils . getDefaultSearchCenter ( ) ; if ( center != null ) { return new ObaRoutesForLocationRequest . Builder ( getContext ( ) , center ) . setRadius ( LocationUtils . DEFAULT_SEARCH_RADIUS ) . setQuery ( mQueryText ) . build ( ) . call ( ) ; } return response ; }
public ObaStopElement ( ) { id = "" ; lat = 0 ; lon = 0 ; direction = "" ; locationType = LOCATION_STOP ; name = "" ; code = "" ; routeIds = EMPTY_ROUTES ; }
public ObaStopElement ( String id , double lat , double lon , String name , String code ) { this . id = id ; this . lat = lat ; this . lon = lon ; direction = "" ; locationType = LOCATION_STOP ; this . name = name ; this . code = code ; routeIds = EMPTY_ROUTES ; }
public String getId ( ) { return id ; }
public String getStopCode ( ) { return code ; }
public String getName ( ) { return name ; }
public Location getLocation ( ) { return LocationUtils . makeLocation ( lat , lon ) ; }
public double getLatitude ( ) { return lat ; }
public double getLongitude ( ) { return lon ; }
public String getDirection ( ) { return direction ; }
public int getLocationType ( ) { return locationType ; }
public String [] getRouteIds ( ) { return routeIds ; }
@ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( id == null ) ? 0 : id . hashCode ( ) ) ; return result ; }
@ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( ! ( obj instanceof ObaStopElement ) ) { return false ; } ObaStopElement other = ( ObaStopElement ) obj ; if ( id == null ) { if ( other . id != null ) { return false ; } } else if ( ! id . equals ( other . id ) ) { return false ; } return true ; }
@ Override public String toString ( ) { return "ObaStopElement [direction=" + direction + ", id=" + id + ", name=" + name + "]" ; }
public StoryListAdapter ( @ NonNull Context context , List < Story > storyList , StoryListAdapterListener listener , boolean nightMode ) { mContext = context ; mStoryList = storyList ; mListener = listener ; mNightMode = nightMode ; }
@ Override public StoryViewHolder onCreateViewHolder ( ViewGroup parent , int viewType ) { return StoryViewHolder . create ( mContext , parent ) ; }
@ Override public void onBindViewHolder ( StoryViewHolder viewHolder , int position ) { StoryViewHolder . bind ( viewHolder , position , getItem ( position ) , mListener , mNightMode ) ; }
@ Override public int getItemCount ( ) { return mStoryList . size ( ) ; }
@ Override public long getItemId ( int position ) { return mStoryList . get ( position ) . getStoryId ( ) ; }
public Story getItem ( int position ) { return mStoryList . get ( position ) ; }
public void clear ( ) { mStoryList . clear ( ) ; notifyDataSetChanged ( ) ; }
public void addStories ( @ NonNull List < Story > storyList ) { mStoryList . addAll ( storyList ) ; notifyDataSetChanged ( ) ; }
public int getPositionOfItem ( @ NonNull Story story ) { return mStoryList . indexOf ( story ) ; }
public void addStory ( @ NonNull Story story ) { mStoryList . add ( story ) ; notifyItemInserted ( mStoryList . size ( ) ) ; }
public void removeItem ( int position ) { mStoryList . remove ( position ) ; notifyItemRemoved ( position ) ; }
public void removeAllItems ( ) { mStoryList . clear ( ) ; notifyDataSetChanged ( ) ; }
public void markStoryAsRead ( int position , Story story ) { mStoryList . remove ( position ) ; mStoryList . add ( position , story ) ; notifyItemChanged ( position ) ; }
void onStoryClick ( int position );
void onStorySave ( int position , boolean save );
public RegionsTest ( ) { super( ObaProvider .class , ObaContract . AUTHORITY ); }
public void testInsertOrUpdate ( ) { ContentResolver cr = getMockContentResolver ( ) ; ContentValues values = new ContentValues ( ) ; values . put ( Regions . NAME , "Test region" ) ; values . put ( Regions . OBA_BASE_URL , "http: ) ; values . put ( Regions . SIRI_BASE_URL , "" ) ; values . put ( Regions . LANGUAGE , "en_US" ) ; values . put ( Regions . CONTACT_EMAIL , "contact@onebusaway.org" ) ; values . put ( Regions . SUPPORTS_OBA_DISCOVERY , true ) ; values . put ( Regions . SUPPORTS_OBA_REALTIME , false ) ; values . put ( Regions . SUPPORTS_SIRI_REALTIME , false ) ; Uri uri1 = cr . insert ( Regions . CONTENT_URI , values ) ; final String [] PROJECTION = { ObaContract . Regions . _ID , ObaContract . Regions . NAME , ObaContract . Regions . SUPPORTS_OBA_DISCOVERY , ObaContract . Regions . SUPPORTS_SIRI_REALTIME } ; Cursor c1 = cr . query ( uri1 , PROJECTION , null , null , null ) ; assertNotNull ( c1 ) ; assertEquals ( 1 , c1 . getCount ( ) ) ; c1 . moveToFirst ( ) ; int id = c1 . getInt ( 0 ) ; c1 . close ( ) ; values = new ContentValues ( ) ; values . put ( Regions . SUPPORTS_SIRI_REALTIME , 1 ) ; Uri uri2 = Regions . insertOrUpdate ( cr , id , values ) ; assertEquals ( uri1 , uri2 ) ; Cursor c2 = cr . query ( uri2 , PROJECTION , null , null , null ) ; assertNotNull ( c2 ) ; assertEquals ( 1 , c2 . getCount ( ) ) ; c2 . moveToFirst ( ) ; assertEquals ( id , c2 . getInt ( 0 ) ) ; assertEquals ( "Test region" , c2 . getString ( 1 ) ) ; assertEquals ( 1 , c2 . getInt ( 2 ) ) ; assertEquals ( 1 , c2 . getInt ( 3 ) ) ; c2 . close ( ) ; cr . delete ( uri1 , null , null ) ; }
public void testBounds ( ) { ContentResolver cr = getMockContentResolver ( ) ; ContentValues values = new ContentValues ( ) ; values . put ( Regions . NAME , "Test region" ) ; values . put ( Regions . OBA_BASE_URL , "http: ) ; values . put ( Regions . SIRI_BASE_URL , "" ) ; values . put ( Regions . LANGUAGE , "en_US" ) ; values . put ( Regions . CONTACT_EMAIL , "contact@onebusaway.org" ) ; values . put ( Regions . SUPPORTS_OBA_DISCOVERY , true ) ; values . put ( Regions . SUPPORTS_OBA_REALTIME , false ) ; values . put ( Regions . SUPPORTS_SIRI_REALTIME , false ) ; Uri uri1 = cr . insert ( Regions . CONTENT_URI , values ) ; long regionId = ContentUris . parseId ( uri1 ) ; values = new ContentValues ( ) ; values . put ( RegionBounds . REGION_ID , regionId ) ; values . put ( RegionBounds . LATITUDE , 47.5607395 ) ; values . put ( RegionBounds . LONGITUDE , - 122.1462785 ) ; values . put ( RegionBounds . LAT_SPAN , 0.7432510000000008 ) ; values . put ( RegionBounds . LON_SPAN , 0.720901000000012 ) ; cr . insert ( RegionBounds . CONTENT_URI , values ) ; Cursor c1 = cr . query ( RegionBounds . CONTENT_URI , null , null , null , null ) ; assertNotNull ( c1 ) ; assertEquals ( 1 , c1 . getCount ( ) ) ; cr . delete ( uri1 , null , null ) ; Cursor c2 = cr . query ( RegionBounds . CONTENT_URI , null , null , null , null ) ; assertNotNull ( c2 ) ; assertEquals ( 0 , c2 . getCount ( ) ) ; }
public HelloAndroidActivityRobotiumTest ( ) { super( HelloAndroidActivity .class ); }
@ Override public void setUp ( ) Exception { solo = new Solo ( getInstrumentation ( ) , getActivity ( ) ) ; }
public void testCompute ( ) Exception { solo . clickOnButton ( "Click !" ) ; Assert . assertTrue ( solo . searchText ( "42" ) ) ; }
@ Override public void tearDown ( ) Exception { solo . finishOpenedActivities ( ) ; }
public CloneOperation ( File fileDir , Activity callingActivity ) { super( fileDir , callingActivity ); }
public CloneOperation setCommand ( String uri ) { this . command = Git . cloneRepository ( ) . setCloneAllBranches ( true ) . setDirectory ( repository . getWorkTree ( ) ) . setURI ( uri ) ; return this ; }
@ Override public CloneOperation setAuthentication ( String username , String password ) { super. setAuthentication ( username , password ) ; return this ; }
@ Override public CloneOperation setAuthentication ( File sshKey , String username , String passphrase ) { super. setAuthentication ( sshKey , username , passphrase ) ; return this ; }
@ Override public void execute ( ) { if ( this . provider != null ) { ( ( CloneCommand ) this . command ) . setCredentialsProvider ( this . provider ) ; } new GitAsyncTask ( callingActivity , true , false , this ) . execute ( this . command ) ; }
@ Override public void onTaskEnded ( String result ) { new AlertDialog . Builder ( callingActivity ) . setTitle ( callingActivity . getResources ( ) . getString ( R . string . jgit_error_dialog_title ) ) . setMessage ( "Error occured during the clone operation, " + callingActivity . getResources ( ) . getString ( R . string . jgit_error_dialog_text ) + result + "\nPlease check the FAQ for possible reasons why this error might occur." ) . setPositiveButton ( callingActivity . getResources ( ) . getString ( R . string . dialog_ok ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialogInterface , int i ) {                    } } ) . show ( ) ; }
@ Override public void onClick ( DialogInterface dialogInterface , int i ) {                    }
@ Override protected void onCreate ( Bundle savedInstanceState ) { requestWindowFeature ( Window . FEATURE_INDETERMINATE_PROGRESS ) ; super. onCreate ( savedInstanceState ) ; UIUtils . setupActionBar ( this ) ; setSupportProgressBarIndeterminateVisibility ( false ) ; final Intent intent = getIntent ( ) ; final String action = intent . getAction ( ) ; mShortcutMode = Intent . ACTION_CREATE_SHORTCUT . equals ( action ) ; if ( ! mShortcutMode ) { setTitle ( R . string . app_name ) ; } mSearchCenter = getSearchCenter ( intent ) ; if ( savedInstanceState != null ) { mDefaultTab = savedInstanceState . getString ( "tab" ) ; } final Uri data = intent . getData ( ) ; if ( data != null && mDefaultTab == null ) { mDefaultTab = getDefaultTabFromUri ( data ) ; } }
@ Override public void onDestroy ( ) { if ( mDefaultTab == null ) { final ActionBar bar = getSupportActionBar ( ) ; final ActionBar . Tab tab = bar . getSelectedTab ( ) ; PreferenceUtils . saveString ( getLastTabPref ( ) , ( String ) tab . getTag ( ) ) ; } super. onDestroy ( ) ; }
@ Override public boolean onOptionsItemSelected ( MenuItem item ) { if ( item . getItemId ( ) == android . R . id . home ) { NavHelp . goHome ( this , false ) ; return true ; } return false ; }
protected void restoreDefaultTab ( ) { final String def ; if ( mDefaultTab != null ) { def = mDefaultTab ; } else { SharedPreferences settings = Application . getPrefs ( ) ; def = settings . getString ( getLastTabPref ( ) , null ) ; } if ( def != null ) { final ActionBar bar = getSupportActionBar ( ) ; for ( int i = 0 ; i < bar . getTabCount ( ) ; ++ i ) { ActionBar . Tab tab = bar . getTabAt ( i ) ; if ( def . equals ( tab . getTag ( ) ) ) { tab . select ( ) ; } } } }
boolean isShortcutMode ( ) { return mShortcutMode ; }
Location getSearchCenter ( ) { return mSearchCenter ; }
public static final Uri getDefaultTabUri ( String tab ) { return Uri . fromParts ( TAB_SCHEME , tab , null ) ; }
public static String getDefaultTabFromUri ( Uri uri ) { if ( TAB_SCHEME . equals ( uri . getScheme ( ) ) ) { return uri . getSchemeSpecificPart ( ) ; } return null ; }
protected abstract String getLastTabPref ( )
public static final Intent putSearchCenter ( Intent intent , Location pt ) { if ( pt != null ) { double [] p = { pt . getLatitude ( ) , pt . getLongitude ( ) } ; intent . putExtra ( EXTRA_SEARCHCENTER , p ) ; } return intent ; }
private static final Location getSearchCenter ( Intent intent ) { double [] p = intent . getDoubleArrayExtra ( EXTRA_SEARCHCENTER ) ; if ( p != null && p . length == 2 ) { return LocationUtils . makeLocation ( p [ 0 ] , p [ 1 ] ) ; } return null ; }
public IntentAssert ( Intent actual ) { super( actual , IntentAssert .class ); }
public IntentAssert hasAction ( String action ) { isNotNull ( ) ; String actualAction = actual . getAction ( ) ; assertThat ( actualAction ) . overridingErrorMessage ( "Expected action <%s> but was <%s>." , action , actualAction ) . isEqualTo ( action ) ; return this ; }
public IntentAssert hasType ( String type ) { isNotNull ( ) ; String actualType = actual . getType ( ) ; assertThat ( actualType ) . overridingErrorMessage ( "Expected type <%s> but was <%s>." , type , actualType ) . isEqualTo ( type ) ; return this ; }
public IntentAssert hasExtra ( String name ) { isNotNull ( ) ; assertThat ( actual . hasExtra ( name ) ) . overridingErrorMessage ( "Expected extra <%s> to be present but was not present." , name ) . isTrue ( ) ; return this ; }
public IntentAssert hasExtra ( String name , Object expectedValue ) { hasExtra ( name ) ; Object actualValue = this . actual . getExtras ( ) . get ( name ) ; assertThat ( actualValue ) . overridingErrorMessage ( "Expected extra <%s> to be <%s> but was <%s>." , name , expectedValue , actualValue ) . isEqualTo ( expectedValue ) ; return this ; }
public IntentAssert hasFlags ( @ IntentFlags int flags ) { isNotNull ( ) ; int actualFlags = actual . getFlags ( ) ; assertThat ( actualFlags ) . overridingErrorMessage ( "Expected <%s> but was <%s>." , flagsToString ( flags ) , flagsToString ( actualFlags ) ) . isEqualTo ( flags ) ; return this ; }
public IntentAssert hasPackage ( String packageName ) { isNotNull ( ) ; String actualPackage = actual . getPackage ( ) ; assertThat ( packageName ) . overridingErrorMessage ( "Expected package <%s> but was <%s>." , packageName , actualPackage ) . isEqualTo ( actualPackage ) ; return this ; }
public IntentAssert hasData ( String uri ) { return hasData ( Uri . parse ( uri ) ) ; }
public IntentAssert hasData ( Uri uri ) { isNotNull ( ) ; Uri actualUri = actual . getData ( ) ; assertThat ( actualUri . compareTo ( uri ) ) . overridingErrorMessage ( "Expected data Uri <%s> but was <%s>." , uri , actualUri ) . isEqualTo ( 0 ) ; return this ; }
public IntentAssert hasComponent ( ComponentName expected ) { isNotNull ( ) ; ComponentName componentName = actual . getComponent ( ) ; assertThat ( componentName ) . isNotNull ( ) . overridingErrorMessage ( "Expected component name <%s> but was <%s>." , expected . flattenToString ( ) , componentName . flattenToString ( ) ) . isEqualTo ( expected ) ; return this ; }
public IntentAssert hasComponent ( Context context , Class < ? > cls ) { return hasComponent ( new ComponentName ( context , cls . getName ( ) ) ) ; }
public IntentAssert hasComponent ( String appPkg , Class < ? > cls ) { return hasComponent ( new ComponentName ( appPkg , cls . getName ( ) ) ) ; }
public static String flagsToString ( @ IntentFlags int flags ) { return buildBitMaskString ( flags ) . flag ( FLAG_GRANT_PERSISTABLE_URI_PERMISSION , "grant_persistable_uri_permission" ) . flag ( FLAG_GRANT_READ_URI_PERMISSION , "grant_read_uri_permission" ) . flag ( FLAG_GRANT_WRITE_URI_PERMISSION , "grant_write_uri_permission" ) . flag ( FLAG_DEBUG_LOG_RESOLUTION , "debug_log_resolution" ) . flag ( FLAG_FROM_BACKGROUND , "from_background" ) . flag ( FLAG_ACTIVITY_BROUGHT_TO_FRONT , "activity_brought_to_front" ) . flag ( FLAG_ACTIVITY_CLEAR_TASK , "activity_clear_task" ) . flag ( FLAG_ACTIVITY_CLEAR_TOP , "activity_clear_top" ) . flag ( FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET , "activity_clear_when_task_reset" ) . flag ( FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS , "activity_exclude_from_recents" ) . flag ( FLAG_ACTIVITY_FORWARD_RESULT , "activity_forward_result" ) . flag ( FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY , "activity_launched_from_history" ) . flag ( FLAG_ACTIVITY_MULTIPLE_TASK , "activity_multiple_task" ) . flag ( FLAG_ACTIVITY_NEW_TASK , "activity_new_task" ) . flag ( FLAG_ACTIVITY_NO_ANIMATION , "activity_no_animation" ) . flag ( FLAG_ACTIVITY_NO_HISTORY , "activity_no_history" ) . flag ( FLAG_RECEIVER_NO_ABORT , "receiver_no_abort" ) . flag ( FLAG_RECEIVER_REGISTERED_ONLY , "receiver_registered_only" ) . flag ( FLAG_ACTIVITY_NO_USER_ACTION , "activity_no_user_action" ) . flag ( FLAG_ACTIVITY_PREVIOUS_IS_TOP , "activity_previous_is_top" ) . flag ( FLAG_ACTIVITY_RESET_TASK_IF_NEEDED , "activity_reset_task_if" ) . flag ( FLAG_ACTIVITY_REORDER_TO_FRONT , "activity_reorder_to_front" ) . flag ( FLAG_ACTIVITY_SINGLE_TOP , "activity_single_top" ) . flag ( FLAG_ACTIVITY_TASK_ON_HOME , "activity_task_on_home" ) . flag ( FLAG_INCLUDE_STOPPED_PACKAGES , "include_stopped_packages" ) . get ( ) ; }
Frequency ( ) { startTime = 0 ; endTime = 0 ; headway = 0 ; }
public long getStartTime ( ) { return startTime ; }
public long getEndTime ( ) { return endTime ; }
public long getHeadway ( ) { return headway ; }
ObaArrivalInfo ( ) { routeId = "" ; routeShortName = "" ; routeLongName = "" ; tripId = "" ; tripHeadsign = "" ; stopId = "" ; predictedArrivalTime = 0 ; scheduledArrivalTime = 0 ; predictedDepartureTime = 0 ; scheduledDepartureTime = 0 ; status = "" ; frequency = null ; vehicleId = null ; distanceFromStop = null ; numberOfStopsAway = null ; serviceDate = 0 ; lastUpdateTime = 0 ; predicted = null ; tripStatus = null ; situationIds = null ; arrivalEnabled = true ; departureEnabled = true ; stopSequence = 0 ; totalStopsInTrip = 0 ; blockTripSequence = 0 ; }
public String getRouteId ( ) { return routeId ; }
public String getShortName ( ) { return routeShortName ; }
public String getRouteLongName ( ) { return routeLongName ; }
public String getTripId ( ) { return tripId ; }
public String getHeadsign ( ) { return tripHeadsign ; }
public String getStopId ( ) { return stopId ; }
public long getScheduledArrivalTime ( ) { return scheduledArrivalTime ; }
public long getPredictedArrivalTime ( ) { return predictedArrivalTime ; }
public long getScheduledDepartureTime ( ) { return scheduledDepartureTime ; }
public long getPredictedDepartureTime ( ) { return predictedDepartureTime ; }
public String getStatus ( ) { return status ; }
public Frequency getFrequency ( ) { return frequency ; }
public String getVehicleId ( ) { return vehicleId ; }
public Double getDistanceFromStop ( ) { return distanceFromStop ; }
public Integer getNumberOfStopsAway ( ) { return numberOfStopsAway ; }
public long getServiceDate ( ) { return serviceDate ; }
public long getLastUpdateTime ( ) { return lastUpdateTime ; }
public boolean getPredicted ( ) { return ( predicted != null ) ? predicted : ( predictedDepartureTime != 0 ) ; }
public ObaTripStatus getTripStatus ( ) { return tripStatus ; }
public String [] getSituationIds ( ) { return situationIds ; }
public boolean getArrivalEnabled ( ) { return arrivalEnabled ; }
public boolean getDepartureEnabled ( ) { return departureEnabled ; }
public int getStopSequence ( ) { return stopSequence ; }
public int getTotalStopsInTrip ( ) { return totalStopsInTrip ; }
public int getBlockTripSequence ( ) { return blockTripSequence ; }
public RouteMapController ( Callback callback ) { mFragment = callback ; mLineOverlayColor = mFragment . getActivity ( ) . getResources ( ) . getColor ( R . color . route_line_color_default ) ; mShortAnimationDuration = mFragment . getActivity ( ) . getResources ( ) . getInteger ( android . R . integer . config_shortAnimTime ) ; mRoutePopup = new RoutePopup ( ) ; mRouteLoaderListener = new RouteLoaderListener ( ) ; mVehicleLoaderListener = new VehicleLoaderListener ( ) ; }
@ Override public void setState ( Bundle args ) { if ( args == null ) { throw new IllegalArgumentException ( "args cannot be null" ) ; } String routeId = args . getString ( MapParams . ROUTE_ID ) ; float mapZoom = args . getFloat ( MapParams . ZOOM , MapParams . DEFAULT_ZOOM ) ; if ( mapZoom != MapParams . DEFAULT_ZOOM ) { mFragment . getMapView ( ) . setZoom ( mapZoom ) ; } mZoomToRoute = args . getBoolean ( MapParams . ZOOM_TO_ROUTE , false ) ; mZoomIncludeClosestVehicle = args . getBoolean ( MapParams . ZOOM_INCLUDE_CLOSEST_VEHICLE , false ) ; if ( ! routeId . equals ( mRouteId ) ) { if ( mRouteId != null ) { clearCurrentState ( ) ; } mRouteId = routeId ; mRoutePopup . showLoading ( ) ; mFragment . showProgress ( true ) ; mRouteLoader = mRouteLoaderListener . onCreateLoader ( ROUTES_LOADER , null ) ; mRouteLoader . registerListener ( 0 , mRouteLoaderListener ) ; mRouteLoader . startLoading ( ) ; mVehiclesLoader = mVehicleLoaderListener . onCreateLoader ( VEHICLES_LOADER , null ) ; mVehiclesLoader . registerListener ( 0 , mVehicleLoaderListener ) ; mVehiclesLoader . startLoading ( ) ; } else { mRoutePopup . show ( ) ; } }
private void clearCurrentState ( ) { mRouteLoader . stopLoading ( ) ; mRouteLoader . reset ( ) ; mVehiclesLoader . stopLoading ( ) ; mVehiclesLoader . reset ( ) ; mVehicleRefreshHandler . removeCallbacks ( mVehicleRefresh ) ; mFragment . getMapView ( ) . removeRouteOverlay ( ) ; mFragment . getMapView ( ) . removeVehicleOverlay ( ) ; mFragment . getMapView ( ) . removeStopOverlay ( false ) ; }
@ Override public String getMode ( ) { return MapParams . MODE_ROUTE ; }
@ Override public void destroy ( ) { mRoutePopup . hide ( ) ; mFragment . getMapView ( ) . removeRouteOverlay ( ) ; mVehicleRefreshHandler . removeCallbacks ( mVehicleRefresh ) ; mFragment . getMapView ( ) . removeVehicleOverlay ( ) ; }
@ Override public void onPause ( ) { mVehicleRefreshHandler . removeCallbacks ( mVehicleRefresh ) ; }
@ Override public void onHidden ( boolean hidden ) { if ( hidden ) { mRoutePopup . hide ( ) ; } else { mRoutePopup . show ( ) ; } }
@ Override public void onResume ( ) { mVehicleRefreshHandler . removeCallbacks ( mVehicleRefresh ) ; if ( mLastUpdatedTimeVehicles == 0 ) { mVehicleRefreshHandler . postDelayed ( mVehicleRefresh , VEHICLE_REFRESH_PERIOD ) ; return; } long elapsedTimeMillis = TimeUnit . NANOSECONDS . toMillis ( UIUtils . getCurrentTimeForComparison ( ) - mLastUpdatedTimeVehicles ) ; long refreshPeriod ; if ( elapsedTimeMillis > VEHICLE_REFRESH_PERIOD ) { refreshPeriod = 100 ; } else { refreshPeriod = VEHICLE_REFRESH_PERIOD - elapsedTimeMillis ; } mVehicleRefreshHandler . postDelayed ( mVehicleRefresh , refreshPeriod ) ; }
@ Override public void onSaveInstanceState ( Bundle outState ) { outState . putString ( MapParams . ROUTE_ID , mRouteId ) ; outState . putBoolean ( MapParams . ZOOM_TO_ROUTE , mZoomToRoute ) ; outState . putBoolean ( MapParams . ZOOM_INCLUDE_CLOSEST_VEHICLE , mZoomIncludeClosestVehicle ) ; Location centerLocation = mFragment . getMapView ( ) . getMapCenterAsLocation ( ) ; outState . putDouble ( MapParams . CENTER_LAT , centerLocation . getLatitude ( ) ) ; outState . putDouble ( MapParams . CENTER_LON , centerLocation . getLongitude ( ) ) ; outState . putFloat ( MapParams . ZOOM , mFragment . getMapView ( ) . getZoomLevelAsFloat ( ) ) ; }
@ Override public void onViewStateRestored ( Bundle savedInstanceState ) { if ( savedInstanceState == null ) { return; } String stopId = savedInstanceState . getString ( MapParams . STOP_ID ) ; if ( stopId == null ) { float mapZoom = savedInstanceState . getFloat ( MapParams . ZOOM , MapParams . DEFAULT_ZOOM ) ; if ( mapZoom != MapParams . DEFAULT_ZOOM ) { mFragment . getMapView ( ) . setZoom ( mapZoom ) ; } double lat = savedInstanceState . getDouble ( MapParams . CENTER_LAT ) ; double lon = savedInstanceState . getDouble ( MapParams . CENTER_LON ) ; if ( lat != 0.0d && lon != 0.0d ) { Location location = LocationUtils . makeLocation ( lat , lon ) ; mFragment . getMapView ( ) . setMapCenter ( location , false , false ) ; } } }
@ Override public void onLocation ( ) { }
@ Override public void onNoLocation ( ) { }
@ Override public void notifyMapChanged ( ) { }
RoutePopup ( ) { mActivity = mFragment . getActivity ( ) ; float paddingDp = mActivity . getResources ( ) . getDimension ( R . dimen . map_route_vehicle_markers_padding ) / mActivity . getResources ( ) . getDisplayMetrics ( ) . density ; VEHICLE_MARKER_PADDING = UIUtils . dpToPixels ( mActivity , paddingDp ) ; mView = mActivity . findViewById ( R . id . route_info ) ; mFragment . getMapView ( ) . setPadding ( null , mView . getHeight ( ) + VEHICLE_MARKER_PADDING , null , null ) ; mRouteShortName = ( TextView ) mView . findViewById ( R . id . short_name ) ; mRouteLongName = ( TextView ) mView . findViewById ( R . id . long_name ) ; mAgencyName = ( TextView ) mView . findViewById ( R . id . agency ) ; mProgressBar = ( ProgressBar ) mView . findViewById ( R . id . route_info_loading_spinner ) ; View cancel = mView . findViewById ( R . id . cancel_route_mode ) ; cancel . setVisibility ( View . VISIBLE ) ; cancel . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { ObaMapView obaMapView = mFragment . getMapView ( ) ; Bundle bundle = new Bundle ( ) ; bundle . putBoolean ( MapParams . DO_N0T_CENTER_ON_LOCATION , true ) ; bundle . putFloat ( MapParams . ZOOM , obaMapView . getZoomLevelAsFloat ( ) ) ; Location point = obaMapView . getMapCenterAsLocation ( ) ; bundle . putDouble ( MapParams . CENTER_LAT , point . getLatitude ( ) ) ; bundle . putDouble ( MapParams . CENTER_LON , point . getLongitude ( ) ) ; mFragment . setMapMode ( MapParams . MODE_STOP , bundle ) ; } } ) ; }
@ Override public void onClick ( View v ) { ObaMapView obaMapView = mFragment . getMapView ( ) ; Bundle bundle = new Bundle ( ) ; bundle . putBoolean ( MapParams . DO_N0T_CENTER_ON_LOCATION , true ) ; bundle . putFloat ( MapParams . ZOOM , obaMapView . getZoomLevelAsFloat ( ) ) ; Location point = obaMapView . getMapCenterAsLocation ( ) ; bundle . putDouble ( MapParams . CENTER_LAT , point . getLatitude ( ) ) ; bundle . putDouble ( MapParams . CENTER_LON , point . getLongitude ( ) ) ; mFragment . setMapMode ( MapParams . MODE_STOP , bundle ) ; }
void showLoading ( ) { mFragment . getMapView ( ) . setPadding ( null , mView . getHeight ( ) + VEHICLE_MARKER_PADDING , null , null ) ; UIUtils . hideViewWithoutAnimation ( mRouteShortName ) ; UIUtils . hideViewWithoutAnimation ( mRouteLongName ) ; UIUtils . showViewWithoutAnimation ( mView ) ; UIUtils . showViewWithoutAnimation ( mProgressBar ) ; }
void show ( ObaRoute route , String agencyName ) { mRouteShortName . setText ( UIUtils . formatDisplayText ( UIUtils . getRouteDisplayName ( route ) ) ) ; mRouteLongName . setText ( UIUtils . formatDisplayText ( UIUtils . getRouteDescription ( route ) ) ) ; mAgencyName . setText ( agencyName ) ; show ( ) ; }
void show ( ) { UIUtils . hideViewWithAnimation ( mProgressBar , mShortAnimationDuration ) ; UIUtils . showViewWithAnimation ( mRouteShortName , mShortAnimationDuration ) ; UIUtils . showViewWithAnimation ( mRouteLongName , mShortAnimationDuration ) ; UIUtils . showViewWithAnimation ( mView , mShortAnimationDuration ) ; mFragment . getMapView ( ) . setPadding ( null , mView . getHeight ( ) + VEHICLE_MARKER_PADDING , null , null ) ; }
void hide ( ) { mFragment . getMapView ( ) . setPadding ( null , 0 , null , null ) ; UIUtils . hideViewWithAnimation ( mView , mShortAnimationDuration ) ; }
public void run ( ) { refresh ( ) ; }
private void refresh ( ) { if ( mVehiclesLoader != null ) { mVehiclesLoader . onContentChanged ( ) ; } }
public RoutesLoader ( Context context , String routeId ) { super( context ); mRouteId = routeId ; }
@ Override public ObaStopsForRouteResponse loadInBackground ( ) { if ( Application . get ( ) . getCurrentRegion ( ) == null && TextUtils . isEmpty ( Application . get ( ) . getCustomApiUrl ( ) ) ) { Log . d ( TAG , "Trying to load stops for route from server " + "without OBA REST API endpoint, aborting..." ) ; return null ; } return new ObaStopsForRouteRequest . Builder ( getContext ( ) , mRouteId ) . setIncludeShapes ( true ) . build ( ) . call ( ) ; }
@ Override public void deliverResult ( ObaStopsForRouteResponse data ) { super. deliverResult ( data ) ; }
@ Override public void onStartLoading ( ) { forceLoad ( ) ; }
@ Override public Loader < ObaStopsForRouteResponse > onCreateLoader ( int id , Bundle args ) { return new RoutesLoader ( mFragment . getActivity ( ) , mRouteId ) ; }
@ Override public void onLoadFinished ( Loader < ObaStopsForRouteResponse > loader , ObaStopsForRouteResponse response ) { ObaMapView obaMapView = mFragment . getMapView ( ) ; if ( response == null || response . getCode ( ) != ObaApi . OBA_OK ) { BaseMapFragment . showMapError ( response ) ; return; } ObaRoute route = response . getRoute ( response . getRouteId ( ) ) ; mRoutePopup . show ( route , response . getAgency ( route . getAgencyId ( ) ) . getName ( ) ) ; if ( route . getColor ( ) != null ) { mLineOverlayColor = route . getColor ( ) ; } obaMapView . setRouteOverlay ( mLineOverlayColor , response . getShapes ( ) ) ; List < ObaStop > stops = response . getStops ( ) ; mFragment . showStops ( stops , response ) ; mFragment . showProgress ( false ) ; if ( mZoomToRoute ) { obaMapView . zoomToRoute ( ) ; mZoomToRoute = false ; } obaMapView . postInvalidate ( ) ; }
@ Override public void onLoaderReset ( Loader < ObaStopsForRouteResponse > loader ) { mFragment . getMapView ( ) . removeRouteOverlay ( ) ; mFragment . getMapView ( ) . removeVehicleOverlay ( ) ; }
@ Override public void onLoadComplete ( Loader < ObaStopsForRouteResponse > loader , ObaStopsForRouteResponse response ) { onLoadFinished ( loader , response ) ; }
public VehiclesLoader ( Context context , String routeId ) { super( context ); mRouteId = routeId ; }
@ Override public ObaTripsForRouteResponse loadInBackground ( ) { if ( Application . get ( ) . getCurrentRegion ( ) == null && TextUtils . isEmpty ( Application . get ( ) . getCustomApiUrl ( ) ) ) { Log . d ( TAG , "Trying to load trips (vehicles) for route from server " + "without OBA REST API endpoint, aborting..." ) ; return null ; } return new ObaTripsForRouteRequest . Builder ( getContext ( ) , mRouteId ) . setIncludeStatus ( true ) . build ( ) . call ( ) ; }
@ Override public void deliverResult ( ObaTripsForRouteResponse data ) { super. deliverResult ( data ) ; }
@ Override public void onStartLoading ( ) { forceLoad ( ) ; }
@ Override public Loader < ObaTripsForRouteResponse > onCreateLoader ( int id , Bundle args ) { return new VehiclesLoader ( mFragment . getActivity ( ) , mRouteId ) ; }
@ Override public void onLoadFinished ( Loader < ObaTripsForRouteResponse > loader , ObaTripsForRouteResponse response ) { ObaMapView obaMapView = mFragment . getMapView ( ) ; if ( response == null || response . getCode ( ) != ObaApi . OBA_OK ) { BaseMapFragment . showMapError ( response ) ; return; } routes . clear ( ) ; routes . add ( mRouteId ) ; obaMapView . updateVehicles ( routes , response ) ; if ( mZoomIncludeClosestVehicle ) { obaMapView . zoomIncludeClosestVehicle ( routes , response ) ; mZoomIncludeClosestVehicle = false ; } mLastUpdatedTimeVehicles = UIUtils . getCurrentTimeForComparison ( ) ; mVehicleRefreshHandler . removeCallbacks ( mVehicleRefresh ) ; mVehicleRefreshHandler . postDelayed ( mVehicleRefresh , VEHICLE_REFRESH_PERIOD ) ; }
@ Override public void onLoaderReset ( Loader < ObaTripsForRouteResponse > loader ) { mFragment . getMapView ( ) . removeVehicleOverlay ( ) ; }
@ Override public void onLoadComplete ( Loader < ObaTripsForRouteResponse > loader , ObaTripsForRouteResponse response ) { onLoadFinished ( loader , response ) ; }
@ TargetApi ( 9 ) public static void saveString ( SharedPreferences prefs , String key , String value ) { SharedPreferences . Editor edit = prefs . edit ( ) ; edit . putString ( key , value ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . GINGERBREAD ) { edit . apply ( ) ; } else { edit . commit ( ) ; } }
public static void saveString ( String key , String value ) { saveString ( Application . getPrefs ( ) , key , value ) ; }
@ TargetApi ( 9 ) public static void saveInt ( SharedPreferences prefs , String key , int value ) { SharedPreferences . Editor edit = prefs . edit ( ) ; edit . putInt ( key , value ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . GINGERBREAD ) { edit . apply ( ) ; } else { edit . commit ( ) ; } }
public static void saveInt ( String key , int value ) { saveInt ( Application . getPrefs ( ) , key , value ) ; }
@ TargetApi ( 9 ) public static void saveLong ( SharedPreferences prefs , String key , long value ) { SharedPreferences . Editor edit = prefs . edit ( ) ; edit . putLong ( key , value ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . GINGERBREAD ) { edit . apply ( ) ; } else { edit . commit ( ) ; } }
public static void saveLong ( String key , long value ) { saveLong ( Application . getPrefs ( ) , key , value ) ; }
@ TargetApi ( 9 ) public static void saveBoolean ( SharedPreferences prefs , String key , boolean value ) { SharedPreferences . Editor edit = prefs . edit ( ) ; edit . putBoolean ( key , value ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . GINGERBREAD ) { edit . apply ( ) ; } else { edit . commit ( ) ; } }
public static void saveBoolean ( String key , boolean value ) { saveBoolean ( Application . getPrefs ( ) , key , value ) ; }
public static org . assertj . android . support . v4 . api . app . ActionBarDrawerToggleAssert assertThat ( android . support . v4 . app . ActionBarDrawerToggle actual ) { return new org . assertj . android . support . v4 . api . app . ActionBarDrawerToggleAssert ( actual ) ; }
public static org . assertj . android . support . v4 . api . app . DialogFragmentAssert assertThat ( android . support . v4 . app . DialogFragment actual ) { return new org . assertj . android . support . v4 . api . app . DialogFragmentAssert ( actual ) ; }
public static org . assertj . android . support . v4 . api . app . FragmentAssert assertThat ( android . support . v4 . app . Fragment actual ) { return new org . assertj . android . support . v4 . api . app . FragmentAssert ( actual ) ; }
public static org . assertj . android . support . v4 . api . app . FragmentManagerAssert assertThat ( android . support . v4 . app . FragmentManager actual ) { return new org . assertj . android . support . v4 . api . app . FragmentManagerAssert ( actual ) ; }
public static org . assertj . android . support . v4 . api . app . FragmentTransactionAssert assertThat ( android . support . v4 . app . FragmentTransaction actual ) { return new org . assertj . android . support . v4 . api . app . FragmentTransactionAssert ( actual ) ; }
public static org . assertj . android . support . v4 . api . app . ListFragmentAssert assertThat ( android . support . v4 . app . ListFragment actual ) { return new org . assertj . android . support . v4 . api . app . ListFragmentAssert ( actual ) ; }
public static org . assertj . android . support . v4 . api . app . LoaderManagerAssert assertThat ( android . support . v4 . app . LoaderManager actual ) { return new org . assertj . android . support . v4 . api . app . LoaderManagerAssert ( actual ) ; }
public static org . assertj . android . support . v4 . api . content . CursorLoaderAssert assertThat ( android . support . v4 . content . CursorLoader actual ) { return new org . assertj . android . support . v4 . api . content . CursorLoaderAssert ( actual ) ; }
public static org . assertj . android . support . v4 . api . content . LoaderAssert assertThat ( android . support . v4 . content . Loader actual ) { return new org . assertj . android . support . v4 . api . content . LoaderAssert ( actual ) ; }
public static org . assertj . android . support . v4 . api . media . TransportControllerAssert assertThat ( android . support . v4 . media . TransportController actual ) { return new org . assertj . android . support . v4 . api . media . TransportControllerAssert ( actual ) ; }
public static org . assertj . android . support . v4 . api . media . TransportMediatorAssert assertThat ( android . support . v4 . media . TransportMediator actual ) { return new org . assertj . android . support . v4 . api . media . TransportMediatorAssert ( actual ) ; }
public static org . assertj . android . support . v4 . api . print . PrintHelperAssert assertThat ( android . support . v4 . print . PrintHelper actual ) { return new org . assertj . android . support . v4 . api . print . PrintHelperAssert ( actual ) ; }
public static org . assertj . android . support . v4 . api . util . AtomicFileAssert assertThat ( android . support . v4 . util . AtomicFile actual ) { return new org . assertj . android . support . v4 . api . util . AtomicFileAssert ( actual ) ; }
public static < E > org . assertj . android . support . v4 . api . util . CircularArrayAssert < E > assertThat ( android . support . v4 . util . CircularArray < E > actual ) { return new org . assertj . android . support . v4 . api . util . CircularArrayAssert <> ( actual ) ; }
public static org . assertj . android . support . v4 . api . util . LongSparseArrayAssert assertThat ( android . support . v4 . util . LongSparseArray actual ) { return new org . assertj . android . support . v4 . api . util . LongSparseArrayAssert ( actual ) ; }
public static < K , V > org . assertj . android . support . v4 . api . util . LruCacheAssert < K , V > assertThat ( android . support . v4 . util . LruCache < K , V > actual ) { return new org . assertj . android . support . v4 . api . util . LruCacheAssert <> ( actual ) ; }
public static < E > org . assertj . android . support . v4 . api . util . SparseArrayCompatAssert < E > assertThat ( android . support . v4 . util . SparseArrayCompat < E > actual ) { return new org . assertj . android . support . v4 . api . util . SparseArrayCompatAssert <> ( actual ) ; }
public static org . assertj . android . support . v4 . api . view . PagerAdapterAssert assertThat ( android . support . v4 . view . PagerAdapter actual ) { return new org . assertj . android . support . v4 . api . view . PagerAdapterAssert ( actual ) ; }
public static org . assertj . android . support . v4 . api . view . ViewPagerAssert assertThat ( android . support . v4 . view . ViewPager actual ) { return new org . assertj . android . support . v4 . api . view . ViewPagerAssert ( actual ) ; }
public static org . assertj . android . support . v4 . api . widget . CursorAdapterAssert assertThat ( android . support . v4 . widget . CursorAdapter actual ) { return new org . assertj . android . support . v4 . api . widget . CursorAdapterAssert ( actual ) ; }
public static org . assertj . android . support . v4 . api . widget . SimpleCursorAdapterAssert assertThat ( android . support . v4 . widget . SimpleCursorAdapter actual ) { return new org . assertj . android . support . v4 . api . widget . SimpleCursorAdapterAssert ( actual ) ; }
public static org . assertj . android . support . v4 . api . widget . SlidingPaneLayoutAssert assertThat ( android . support . v4 . widget . SlidingPaneLayout actual ) { return new org . assertj . android . support . v4 . api . widget . SlidingPaneLayoutAssert ( actual ) ; }
public static org . assertj . android . support . v4 . api . widget . SwipeRefreshLayoutAssert assertThat ( android . support . v4 . widget . SwipeRefreshLayout actual ) { return new org . assertj . android . support . v4 . api . widget . SwipeRefreshLayoutAssert ( actual ) ; }
private Assertions ( ) { throw new AssertionError ( "No instances." ) ; }
private Security ( ) { throw new AssertionError ( ) ; }
@ Nonnull public static Cipherer < byte [] , byte [] > newAndroidAesByteCipherer ( ) { return org . solovyev . common . security . Security . newCipherer ( CIPHER_ALGORITHM , PROVIDER , InitialVectorDef . newRandom ( IV_RANDOM_ALGORITHM , IV_LENGTH ) ) ; }
@ Nonnull public static Cipherer < byte [] , byte [] > newAndroidAesByteCipherer ( final byte [] initialVector ) { return org . solovyev . common . security . Security . newCipherer ( CIPHER_ALGORITHM , PROVIDER , InitialVectorDef . newPredefined ( initialVector ) ) ; }
@ Nonnull public static SecretKeyProvider newAndroidAesSecretKeyProvider ( ) { return org . solovyev . common . security . Security . newPbeSecretKeyProvider ( PBE_ITERATION_COUNT , PBE_ALGORITHM , CIPHERER_ALGORITHM_AES , PROVIDER , PBE_KEY_LENGTH , SALT_LENGTH ) ; }
@ Nonnull public static HashProvider < byte [] , byte [] > newAndroidSha512ByteHashProvider ( ) { return org . solovyev . common . security . Security . newHashProvider ( HASH_ALGORITHM , PROVIDER ) ; }
@ Nonnull public static HashProvider < String , String > newAndroidSha512StringHashProvider ( ) { return TypedHashProvider . newInstance ( newAndroidSha512ByteHashProvider ( ) , StringDecoder . getInstance ( ) , ABase64StringEncoder . getInstance ( ) ) ; }
@ Nonnull public static SaltGenerator newAndroidSaltGenerator ( ) { return org . solovyev . common . security . Security . newSaltGenerator ( IV_RANDOM_ALGORITHM , SALT_LENGTH ) ; }
@ Nonnull public static Cipherer < String , String > newAndroidAesStringCipherer ( ) { return TypedCipherer . newInstance ( newAndroidAesByteCipherer ( ) , StringDecoder . getInstance ( ) , StringEncoder . getInstance ( ) , ABase64StringDecoder . getInstance ( ) , ABase64StringEncoder . getInstance ( ) ) ; }
@ Nonnull public static Cipherer < String , String > newAndroidAesStringCipherer ( final byte [] initialVector ) { return TypedCipherer . newInstance ( newAndroidAesByteCipherer ( initialVector ) , StringDecoder . getInstance ( ) , StringEncoder . getInstance ( ) , ABase64StringDecoder . getInstance ( ) , ABase64StringEncoder . getInstance ( ) ) ; }
@ Nonnull public static SecurityService < byte [] , byte [] , byte [] > newAndroidAesByteSecurityService ( ) { return newSecurityService ( newAndroidAesByteCipherer ( ) , newAndroidAesSecretKeyProvider ( ) , newAndroidSaltGenerator ( ) , newAndroidSha512ByteHashProvider ( ) ) ; }
@ Nonnull public static SecurityService < byte [] , byte [] , byte [] > newAndroidAesByteSecurityService ( final byte [] initialVector ) { return newSecurityService ( newAndroidAesByteCipherer ( initialVector ) , newAndroidAesSecretKeyProvider ( ) , newAndroidSaltGenerator ( ) , newAndroidSha512ByteHashProvider ( ) ) ; }
@ Nonnull public static SecurityService < String , String , String > newAndroidAesStringSecurityService ( ) { return newSecurityService ( newAndroidAesStringCipherer ( ) , newAndroidAesSecretKeyProvider ( ) , newAndroidSaltGenerator ( ) , newAndroidSha512StringHashProvider ( ) ) ; }
@ Nonnull public static SecurityService < String , String , String > newAndroidStringSecurityService ( @ Nonnull SecurityService < byte [] , byte [] , byte [] > securityService ) { return SecurityServiceConverter . wrap ( securityService , StringDecoder . getInstance ( ) , StringEncoder . getInstance ( ) , ABase64StringDecoder . getInstance ( ) , ABase64StringEncoder . getInstance ( ) ) ; }
public Junit4TestBuildExampleIT ( MavenRuntimeBuilder builder ) throws Exception { this . mavenRuntime = builder . build ( ) ; }
@ Test public void buildInstall ( ) Exception { File basedir = resources . getBasedir ( "aar-child-junit-tests" ) ; MavenExecutionResult result = mavenRuntime . forProject ( basedir ) . withCliOptions ( "-Psupport_test" ) . execute ( "clean" , PluginInfo . getQualifiedGoal ( "undeploy" ) , "install" ) ; result . assertErrorFreeLog ( ) ; result . assertLogText ( "Tests run: 1,  Failures: 0,  Errors: 0" ) ; }
public ColumnInfo ( Field columnField ) { if ( ! columnField . isAnnotationPresent ( DatabaseField .class ) ) { throw new IllegalArgumentException ( "Parameter does not implement the DatabaseField annotation." ) ; } this . field = columnField ; this . columnName = OrmLiteAnnotationAccessor . getAnnotationColumnName ( columnField ) ; this . defaultSortOrderInfo = new SortOrderInfo ( columnField ) ; this . projectionMapInfo = new ProjectionMapInfo ( columnField ) ; }
@ Override public boolean isValid ( ) { return isValid ( false ) ; }
@ Override public boolean isValid ( boolean throwException ) { boolean result = true ; return result ; }
public Field getField ( ) { return this . field ; }
public String getColumnName ( ) { return this . columnName ; }
public String getProjectionColumnName ( ) { String result = this . columnName ; if ( this . projectionMapInfo . isValid ( ) ) { result = this . projectionMapInfo . getName ( ) ; } return result ; }
public SortOrderInfo getDefaultSortOrderInfo ( ) { return this . defaultSortOrderInfo ; }
public ProjectionMapInfo getProjectionMapInfo ( ) { return this . projectionMapInfo ; }
@ Before @ After public void setUpAndTearDown ( ) { RxAndroidPlugins . reset ( ) ; }
@ Test public void mainThreadCallsThroughToHook ( ) { final AtomicInteger called = new AtomicInteger ( ) ; final Scheduler newScheduler = new EmptyScheduler ( ) ; RxAndroidPlugins . setMainThreadSchedulerHandler ( new Function < Scheduler , Scheduler > ( ) { @ Override public Scheduler apply ( Scheduler scheduler ) { called . getAndIncrement ( ) ; return newScheduler ; } } ) ; assertSame ( newScheduler , AndroidSchedulers . mainThread ( ) ) ; assertEquals ( 1 , called . get ( ) ) ; assertSame ( newScheduler , AndroidSchedulers . mainThread ( ) ) ; assertEquals ( 2 , called . get ( ) ) ; }
@ Override public Scheduler apply ( Scheduler scheduler ) { called . getAndIncrement ( ) ; return newScheduler ; }
@ Test public void fromNullThrows ( ) { try { AndroidSchedulers . from ( null ) ; fail ( ) ; } catch ( NullPointerException e ) { assertEquals ( "looper == null" , e . getMessage ( ) ) ; } }
@ Test public void fromReturnsUsableScheduler ( ) { assertNotNull ( AndroidSchedulers . from ( Looper . getMainLooper ( ) ) ) ; }
@ Override protected int getLayoutResId ( ) { return R . layout . activity_toolbarcontrolwebview ; }
@ Override protected ObservableWebView createScrollable ( ) { ObservableWebView webView = ( ObservableWebView ) findViewById ( R . id . scrollable ) ; webView . loadUrl ( "file: ) ; return webView ; }
protected abstract Class < T > getHelperClass ( )
public T getHelper ( ) { if ( this . helper == null ) { if ( this . destroyed ) { throw new IllegalStateException ( "A call to shutdown has already been made and the helper cannot be used after that point" ) ; } this . helper = this . createHelper ( ) ; logger . trace ( "{}: got new helper {} from OpenHelperManager" , this , this . helper ) ; } return this . helper ; }
protected T createHelper ( ) { return OpenHelperManager . getHelper ( this . getContext ( ) , this . getHelperClass ( ) ) ; }
protected void releaseHelper ( ) { OpenHelperManager . releaseHelper ( ) ; }
public ConnectionSource getConnectionSource ( ) { return getHelper ( ) . getConnectionSource ( ) ; }
@ Override public void shutdown ( ) { super. shutdown ( ) ; if ( this . helper != null ) { this . helper . close ( ) ; this . helper = null ; this . releaseHelper ( ) ; logger . trace ( "{}: helper {} was released, set to null" , this , this . helper ) ; this . destroyed = true ; } }
@ Override public String toString ( ) { return getClass ( ) . getSimpleName ( ) + "@" + Integer . toHexString ( super. hashCode ( ) ) ; }
private OrmLiteAnnotationAccessor ( ) { }
public static String getAnnotationTableName ( AnnotatedElement element ) { String result = "" ; result = DatabaseTableConfig . extractTableName ( ( Class < ? > ) element ) ; return result ; }
public static String getAnnotationColumnName ( AnnotatedElement element ) { String result = "" ; DatabaseField databaseField = element . getAnnotation ( DatabaseField .class ) ; if ( databaseField != null ) { result = databaseField . columnName ( ) ; if ( TextUtils . isEmpty ( result ) ) { result = ( ( Field ) element ) . getName ( ) ; } } return result ; }
boolean isValid ( )
boolean isValid ( boolean throwException );
public void testDowntownSeattle1 ( ) { final Location pt = LocationUtils . makeLocation ( 47.610980 , - 122.33845 ) ; ObaRoutesForLocationRequest . Builder builder = new ObaRoutesForLocationRequest . Builder ( getContext ( ) , pt ) ; ObaRoutesForLocationRequest request = builder . build ( ) ; ObaRoutesForLocationResponse response = request . call ( ) ; assertOK ( response ) ; final ObaRoute [] list = response . getRoutesForLocation ( ) ; assertTrue ( list . length > 0 ) ; assertTrue ( response . getLimitExceeded ( ) ) ; final ObaRoute first = list [ 0 ] ; assertEquals ( ObaRoute . TYPE_BUS , first . getType ( ) ) ; final ObaAgency agency = response . getAgency ( first . getAgencyId ( ) ) ; assertEquals ( "1" , agency . getId ( ) ) ; }
public void testQuery ( ) { final Location pt = LocationUtils . makeLocation ( 47.25331 , - 122.44040 ) ; ObaRoutesForLocationResponse response = new ObaRoutesForLocationRequest . Builder ( getContext ( ) , pt ) . setQuery ( "11" ) . build ( ) . call ( ) ; assertOK ( response ) ; final ObaRoute [] list = response . getRoutesForLocation ( ) ; assertTrue ( list . length > 0 ) ; assertFalse ( response . getLimitExceeded ( ) ) ; assertFalse ( response . getOutOfRange ( ) ) ; final ObaRoute first = list [ 0 ] ; assertEquals ( first . getType ( ) , ObaRoute . TYPE_BUS ) ; final ObaAgency agency = response . getAgency ( first . getAgencyId ( ) ) ; assertEquals ( "3" , agency . getId ( ) ) ; }
public void testQueryFail ( ) { final Location pt = LocationUtils . makeLocation ( 47.25331 , - 122.44040 ) ; ObaRoutesForLocationResponse response = new ObaRoutesForLocationRequest . Builder ( getContext ( ) , pt ) . setQuery ( "112423" ) . build ( ) . call ( ) ; assertOK ( response ) ; final ObaRoute [] list = response . getRoutesForLocation ( ) ; assertEquals ( 0 , list . length ) ; assertFalse ( response . getLimitExceeded ( ) ) ; assertFalse ( response . getOutOfRange ( ) ) ; }
public void testOutOfRange ( ) { final Location pt = LocationUtils . makeLocation ( 48.85808 , 2.29498 ) ; ObaRoutesForLocationRequest request = new ObaRoutesForLocationRequest . Builder ( getContext ( ) , pt ) . build ( ) ; ObaRoutesForLocationResponse response = request . call ( ) ; assertOK ( response ) ; assertTrue ( response . getOutOfRange ( ) ) ; }
public MultiPaneFragmentManager ( @ Nonnull FragmentActivity activity , int mainPaneViewId , @ Nonnull Class < ? extends Fragment > emptyFragmentClass , @ Nonnull String emptyFragmentTag ) { this . activity = activity ; this . mainPaneViewId = mainPaneViewId ; this . emptyFragmentClass = emptyFragmentClass ; this . emptyFragmentTag = emptyFragmentTag ; }
public MultiPaneFragmentManager ( @ Nonnull FragmentActivity activity , int mainPaneViewId , @ Nonnull Class < ? extends Fragment > emptyFragmentClass , @ Nonnull String emptyFragmentTag , int startingAnimationResId , int endingAnimationResId ) { this . activity = activity ; this . mainPaneViewId = mainPaneViewId ; this . emptyFragmentClass = emptyFragmentClass ; this . emptyFragmentTag = emptyFragmentTag ; this . startingAnimationResId = startingAnimationResId ; this . endingAnimationResId = endingAnimationResId ; }
@ Nonnull public FragmentActivity getActivity ( ) { return activity ; }
@ Nonnull private MultiPaneFragmentDef createEmptyMultiPaneFragmentDef ( int paneViewId ) { return MultiPaneFragmentDef . forClass ( getEmptyFragmentTag ( paneViewId ) , false , emptyFragmentClass , activity , null ) ; }
@ Nonnull private String getEmptyFragmentTag ( int paneViewId ) { return emptyFragmentTag + "-" + paneViewId ; }
protected void setFragment ( int fragmentViewId , @ Nonnull MultiPaneFragmentDef mpfd ) { final FragmentManager fm = activity . getSupportFragmentManager ( ) ; final FragmentTransaction ft = fm . beginTransaction ( ) ; setFragment ( fragmentViewId , mpfd , fm , ft ) ; ft . commitAllowingStateLoss ( ) ; executePendingTransactions ( fm ) ; }
private void setFragment ( final int fragmentViewId , @ Nonnull final MultiPaneFragmentDef mpfd , @ Nonnull final FragmentManager fm , @ Nonnull final FragmentTransaction ft ) { hideKeyboard ( ) ; boolean canContinue = executePendingTransactions ( fm ) ; if ( canContinue ) { if ( startingAnimationResId != NO_ANIMATION && endingAnimationResId != NO_ANIMATION ) { ft . setCustomAnimations ( startingAnimationResId , endingAnimationResId , startingAnimationResId , endingAnimationResId ) ; } if ( mpfd . isAddToBackStack ( ) ) { ft . addToBackStack ( mpfd . getTag ( ) ) ; } final Fragment fragmentByTag = fm . findFragmentByTag ( mpfd . getTag ( ) ) ; final Fragment fragmentById = fm . findFragmentById ( fragmentViewId ) ; if ( fragmentByTag != null ) { if ( mpfd . canReuse ( fragmentByTag ) ) { if ( fragmentByTag . isDetached ( ) ) { if ( fragmentById != null ) { tryRemoveFragment ( ft , fragmentById ) ; } ft . attach ( fragmentByTag ) ; } else { if ( fragmentByTag . equals ( fragmentById ) ) { } else { if ( fragmentById != null ) { ft . remove ( fragmentById ) ; } final Fragment newFragment = mpfd . build ( ) ; copyState ( fragmentByTag , newFragment , fm ) ; ft . remove ( fragmentByTag ) ; ft . add ( fragmentViewId , newFragment , mpfd . getTag ( ) ) ; } } } else { ft . remove ( fragmentByTag ) ; if ( fragmentById != null && fragmentById != fragmentByTag ) { tryRemoveFragment ( ft , fragmentById ) ; } ft . add ( fragmentViewId , mpfd . build ( ) , mpfd . getTag ( ) ) ; } } else { if ( fragmentById != null ) { tryRemoveFragment ( ft , fragmentById ) ; } ft . add ( fragmentViewId , mpfd . build ( ) , mpfd . getTag ( ) ) ; } } }
public void copyState ( @ Nonnull Fragment source , @ Nonnull Fragment destination , @ Nonnull FragmentManager fm ) { final Fragment . SavedState savedState = fm . saveFragmentInstanceState ( source ) ; destination . setInitialSavedState ( savedState ) ; }
public void hideKeyboard ( ) { final View focusedView = activity . getCurrentFocus ( ) ; if ( focusedView != null ) { final InputMethodManager imm = ( InputMethodManager ) activity . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; imm . hideSoftInputFromWindow ( focusedView . getWindowToken ( ) , 0 ) ; } }
private boolean executePendingTransactions ( @ Nonnull FragmentManager fm ) { boolean success ; try { fm . executePendingTransactions ( ) ; success = true ; } catch ( RuntimeException e ) { success = false ; Log . e ( TAG , e . getMessage ( ) , e ) ; Activities . restartActivity ( activity ) ; } return success ; }
private void tryRemoveFragment ( @ Nonnull FragmentTransaction ft , @ Nonnull Fragment fragment ) { if ( fragment instanceof DetachableFragment ) { if ( ! fragment . isDetached ( ) ) { ft . detach ( fragment ) ; } } else { ft . remove ( fragment ) ; } }
public void removeFragment ( int fragmentViewId ) { final FragmentManager fm = activity . getSupportFragmentManager ( ) ; final FragmentTransaction ft = fm . beginTransaction ( ) ; final Fragment fragmentById = fm . findFragmentById ( fragmentViewId ) ; if ( fragmentById != null ) { tryRemoveFragment ( ft , fragmentById ) ; } ft . commitAllowingStateLoss ( ) ; executePendingTransactions ( fm ) ; }
public void goBack ( ) { hideKeyboard ( ) ; activity . getSupportFragmentManager ( ) . popBackStack ( ) ; }
public boolean goBackImmediately ( ) { hideKeyboard ( ) ; return activity . getSupportFragmentManager ( ) . popBackStackImmediate ( ) ; }
public void goBack ( @ Nonnull String tag ) { hideKeyboard ( ) ; activity . getSupportFragmentManager ( ) . popBackStack ( tag , FragmentManager . POP_BACK_STACK_INCLUSIVE ) ; }
public boolean isFragmentShown ( @ Nonnull String fragmentTag ) { final FragmentManager fm = activity . getSupportFragmentManager ( ) ; final Fragment fragment = fm . findFragmentByTag ( fragmentTag ) ; if ( fragment != null && fragment . isAdded ( ) && ! fragment . isDetached ( ) ) { return true ; } else { return false ; } }
@ Nullable public < F extends Fragment > F getFragment ( @ Nonnull String fragmentTag ) { final FragmentManager fm = activity . getSupportFragmentManager ( ) ; return ( F ) fm . findFragmentByTag ( fragmentTag ) ; }
protected void emptifyFragmentPane ( int paneViewId ) { setFragment ( paneViewId , createEmptyMultiPaneFragmentDef ( paneViewId ) ) ; }
@ Deprecated public void setMainFragment ( @ Nonnull Class < ? extends Fragment > fragmentClass , @ Nullable Bundle fragmentArgs , @ Nullable JPredicate < Fragment > reuseCondition , @ Nonnull String fragmentTag , boolean addToBackStack ) { setMainFragment ( MultiPaneFragmentDef . newInstance ( fragmentTag , addToBackStack , ReflectionFragmentBuilder . forClass ( activity , fragmentClass , fragmentArgs ) , reuseCondition ) ) ; }
@ Deprecated public void setMainFragment ( @ Nonnull Builder < Fragment > fragmentBuilder , @ Nullable JPredicate < Fragment > reuseCondition , @ Nonnull String fragmentTag ) { setMainFragment ( fragmentBuilder , reuseCondition , fragmentTag , false ) ; }
@ Deprecated public void setMainFragment ( @ Nonnull Builder < Fragment > fragmentBuilder , @ Nullable JPredicate < Fragment > reuseCondition , @ Nonnull String fragmentTag , boolean addToBackStack ) { setMainFragment ( MultiPaneFragmentDef . newInstance ( fragmentTag , addToBackStack , fragmentBuilder , reuseCondition ) ) ; }
public void setMainFragment ( @ Nonnull MultiPaneFragmentDef mpfd ) { setFragment ( mainPaneViewId , mpfd ) ; }
protected void emptifyMainFragment ( ) { setMainFragment ( createEmptyMultiPaneFragmentDef ( mainPaneViewId ) ) ; }
public void setMainFragment ( @ Nonnull FragmentDef fragmentDef , @ Nonnull FragmentManager fm , @ Nonnull FragmentTransaction ft ) { setFragment ( mainPaneViewId , MultiPaneFragmentDef . fromFragmentDef ( fragmentDef , null , activity ) , fm , ft ) ; }
public void setMainFragment ( @ Nonnull FragmentDef fragmentDef , @ Nullable Bundle fragmentArgs ) { setFragment ( mainPaneViewId , MultiPaneFragmentDef . fromFragmentDef ( fragmentDef , fragmentArgs , activity ) ) ; }
public void setMainFragment ( @ Nonnull FragmentDef fragmentDef ) { setMainFragment ( fragmentDef , null ) ; }
static void show ( ActionBarActivity activity , ObaSituation situation ) { FragmentManager fm = activity . getSupportFragmentManager ( ) ; Bundle args = new Bundle ( ) ; args . putString ( TITLE , situation . getSummary ( ) ) ; args . putString ( DESCRIPTION , situation . getDescription ( ) ) ; SituationFragment content = new SituationFragment ( ) ; content . setArguments ( args ) ; FragmentTransaction ft = fm . beginTransaction ( ) ; ft . replace ( android . R . id . content , content ) ; ft . addToBackStack ( null ) ; ft . commit ( ) ; }
@ Override public View onCreateView ( LayoutInflater inflater , ViewGroup root , Bundle savedInstanceState ) { if ( root == null ) { return null ; } return inflater . inflate ( R . layout . situation , null ) ; }
@ Override public void onViewCreated ( View view , Bundle savedInstanceState ) { Bundle args = getArguments ( ) ; TextView title = ( TextView ) view . findViewById ( R . id . alert_title ) ; title . setText ( args . getString ( TITLE ) ) ; TextView desc = ( TextView ) view . findViewById ( R . id . alert_description ) ; desc . setText ( args . getString ( DESCRIPTION ) ) ; }
protected ObaRouteIdsForAgencyRequest ( Uri uri ) { super( uri ); }
public Builder ( Context context , String agencyId ) { super( context , getPathWithId ( "/route-ids-for-agency/" , agencyId ) ); }
public ObaRouteIdsForAgencyRequest build ( ) { return new ObaRouteIdsForAgencyRequest ( buildUri ( ) ) ; }
public static ObaRouteIdsForAgencyRequest newRequest ( Context context , String agencyId ) { return new Builder ( context , agencyId ) . build ( ) ; }
@ Override public ObaRouteIdsForAgencyResponse call ( ) { return call ( ObaRouteIdsForAgencyResponse .class ) ; }
@ Override public String toString ( ) { return "ObaRouteIdsForAgencyRequest [mUri=" + mUri + "]" ; }
@ Override public void onActivityCreated ( Bundle savedInstanceState ) { super. onActivityCreated ( savedInstanceState ) ; getLoaderManager ( ) . initLoader ( 0 , null , this ) ; }
@ Override public void onListItemClick ( ListView l , View v , int position , long id ) { MaterialListItem item = ( MaterialListItem ) mAdapter . getItem ( position ) ; ObaAgency agency = mResponse . getAgency ( item . getId ( ) ) ; if ( ! TextUtils . isEmpty ( agency . getUrl ( ) ) ) { UIUtils . goToUrl ( getActivity ( ) , agency . getUrl ( ) ) ; } }
@ Override public Loader < ObaAgenciesWithCoverageResponse > onCreateLoader ( int id , Bundle args ) { return new AgenciesLoader ( getActivity ( ) ) ; }
@ Override public void onLoadFinished ( Loader < ObaAgenciesWithCoverageResponse > l , ObaAgenciesWithCoverageResponse result ) { mResponse = result ; List < MaterialListItem > materialListItems = createListItems ( result ) ; mAdapter = new MaterialListAdapter ( getContext ( ) , materialListItems ) ; setListAdapter ( mAdapter ) ; }
@ Override public void onLoaderReset ( Loader < ObaAgenciesWithCoverageResponse > l ) { setListAdapter ( null ) ; mAdapter = null ; }
AgenciesLoader ( Context context ) { super( context ); }
@ Override public void onStartLoading ( ) { forceLoad ( ) ; }
@ Override public ObaAgenciesWithCoverageResponse loadInBackground ( ) { return ObaAgenciesWithCoverageRequest . newRequest ( getContext ( ) ) . call ( ) ; }
private List < MaterialListItem > createListItems ( ObaAgenciesWithCoverageResponse result ) { List < MaterialListItem > materialListItems = new ArrayList <> ( ) ; for ( int i = 0 ; i < result . getAgencies ( ) . length ; i ++ ) { ObaAgencyWithCoverage obaAgencyWithCoverage = result . getAgencies ( ) [ i ] ; ObaAgency agency = result . getAgency ( obaAgencyWithCoverage . getId ( ) ) ; MaterialListItem item = new MaterialListItem ( agency . getName ( ) , agency . getUrl ( ) , obaAgencyWithCoverage . getId ( ) , R . drawable . ic_maps_directions_bus ) ; materialListItems . add ( item ) ; } return materialListItems ; }
public GitAsyncTask ( Activity activity , boolean finishOnEnd , boolean refreshListOnEnd , GitOperation operation ) { this . activity = activity ; this . finishOnEnd = finishOnEnd ; this . refreshListOnEnd = refreshListOnEnd ; this . operation = operation ; dialog = new ProgressDialog ( this . activity ) ; }
protected void onPreExecute ( ) { this . dialog . setMessage ( activity . getResources ( ) . getString ( R . string . running_dialog_text ) ) ; this . dialog . setCancelable ( false ) ; this . dialog . show ( ) ; }
@ Override protected String doInBackground ( GitCommand ... cmd ) { for ( GitCommand aCmd : cmd ) { try { aCmd . call ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return e . getMessage ( ) + "\nCaused by:\n" + e . getCause ( ) ; } } return "" ; }
protected void onPostExecute ( String result ) { if ( this . dialog != null ) try { this . dialog . dismiss ( ) ; } catch ( Exception e ) { } if ( result == null ) result = "Unexpected error" ; if ( ! result . isEmpty ( ) ) { this . operation . onTaskEnded ( result ) ; } else { if ( finishOnEnd ) { this . activity . setResult ( Activity . RESULT_OK ) ; this . activity . finish ( ) ; } if ( refreshListOnEnd ) { try { ( ( PasswordStore ) this . activity ) . updateListAdapter ( ) ; } catch ( ClassCastException e ) { } } } }
@ Override public void onActivityCreated ( Bundle savedInstanceState ) { mStopUserMap = new UIUtils . StopUserInfoMap ( getActivity ( ) ) ; super. onActivityCreated ( savedInstanceState ) ; mAdapter = new MyAdapter ( ) ; setListAdapter ( mAdapter ) ; }
@ Override public View onCreateView ( LayoutInflater inflater , ViewGroup root , Bundle savedInstanceState ) { if ( root == null ) { return null ; } return inflater . inflate ( R . layout . my_search_stop_list , null ) ; }
@ Override public void onDestroy ( ) { if ( mStopUserMap != null ) { mStopUserMap . close ( ) ; } super. onDestroy ( ) ; }
@ Override public Loader < ObaStopsForLocationResponse > onCreateLoader ( int id , Bundle args ) { String query = args . getString ( QUERY_TEXT ) ; return new MyLoader ( getActivity ( ) , query , getSearchCenter ( ) ) ; }
@ Override public void onLoadFinished ( Loader < ObaStopsForLocationResponse > loader , ObaStopsForLocationResponse response ) { UIUtils . showProgress ( this , false ) ; final int code = response . getCode ( ) ; if ( code == ObaApi . OBA_OK ) { setEmptyText ( getString ( R . string . find_hint_noresults ) ) ; mAdapter . setData ( Arrays . asList ( response . getStops ( ) ) ) ; } else if ( code != 0 ) { setEmptyText ( getString ( R . string . find_hint_noresults ) ) ; } else { setEmptyText ( getString ( R . string . generic_comm_error ) ) ; } }
@ Override public void onLoaderReset ( Loader < ObaStopsForLocationResponse > loader ) { mAdapter . clear ( ) ; }
@ Override protected void doSearch ( String text ) { UIUtils . showProgress ( this , true ) ; Bundle args = new Bundle ( ) ; args . putString ( QUERY_TEXT , text ) ; Loader < ? > loader = getLoaderManager ( ) . restartLoader ( 0 , args , this ) ; loader . onContentChanged ( ) ; }
@ Override protected int getEditBoxHintText ( ) { return R . string . search_stop_hint ; }
@ Override protected int getMinSearchLength ( ) { return 5 ; }
@ Override protected CharSequence getHintText ( ) { return getText ( R . string . find_hint_nofavoritestops ) ; }
@ Override public void onListItemClick ( ListView l , View v , int position , long id ) { ObaStop stop = ( ObaStop ) l . getAdapter ( ) . getItem ( position - l . getHeaderViewsCount ( ) ) ; final String shortcutName = stop . getName ( ) ; ArrivalsListActivity . Builder b = new ArrivalsListActivity . Builder ( getActivity ( ) , stop . getId ( ) ) ; if ( isShortcutMode ( ) ) { makeShortcut ( shortcutName , b . getIntent ( ) ) ; } else { b . setUpMode ( NavHelp . UP_MODE_BACK ) ; b . start ( ) ; } }
@ Override public void onCreateContextMenu ( ContextMenu menu , View v , ContextMenuInfo menuInfo ) { super. onCreateContextMenu ( menu , v , menuInfo ) ; AdapterContextMenuInfo info = ( AdapterContextMenuInfo ) menuInfo ; final TextView text = ( TextView ) info . targetView . findViewById ( R . id . stop_name ) ; menu . setHeaderTitle ( UIUtils . formatDisplayText ( text . getText ( ) . toString ( ) ) ) ; if ( isShortcutMode ( ) ) { menu . add ( 0 , CONTEXT_MENU_DEFAULT , 0 , R . string . my_context_create_shortcut ) ; } else { menu . add ( 0 , CONTEXT_MENU_DEFAULT , 0 , R . string . my_context_get_stop_info ) ; } menu . add ( 0 , CONTEXT_MENU_SHOW_ON_MAP , 0 , R . string . my_context_showonmap ) ; }
@ Override public boolean onContextItemSelected ( MenuItem item ) { AdapterContextMenuInfo info = ( AdapterContextMenuInfo ) item . getMenuInfo ( ) ; switch ( item . getItemId ( ) ) { case CONTEXT_MENU_DEFAULT : onListItemClick ( getListView ( ) , info . targetView , info . position , info . id ) ; return true ; case CONTEXT_MENU_SHOW_ON_MAP : showOnMap ( getListView ( ) , info . position ) ; return true ; default: return super. onContextItemSelected ( item ) ; } }
private void showOnMap ( ListView l , int position ) { ObaStop stop = ( ObaStop ) l . getAdapter ( ) . getItem ( position - l . getHeaderViewsCount ( ) ) ; final String stopId = stop . getId ( ) ; final double lat = stop . getLatitude ( ) ; final double lon = stop . getLongitude ( ) ; HomeActivity . start ( getActivity ( ) , stopId , lat , lon ) ; }
public MyAdapter ( ) { super( getActivity ( ) , R . layout . stop_list_item ); }
@ Override protected void initView ( View view , ObaStop stop ) { mStopUserMap . setView ( view , stop . getId ( ) , stop . getName ( ) ) ; UIUtils . setStopDirection ( view . findViewById ( R . id . direction ) , stop . getDirection ( ) , true ) ; }
public MyLoader ( Context context , String query , Location center ) { super( context ); mQueryText = query ; mCenter = center ; }
@ Override public ObaStopsForLocationResponse loadInBackground ( ) { return new ObaStopsForLocationRequest . Builder ( getContext ( ) , mCenter ) . setQuery ( mQueryText ) . build ( ) . call ( ) ; }
@ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View view = inflater . inflate ( R . layout . fragment_recyclerview , container , false ) ; Activity parentActivity = getActivity ( ) ; final ObservableRecyclerView recyclerView = ( ObservableRecyclerView ) view . findViewById ( R . id . scroll ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( parentActivity ) ) ; recyclerView . setHasFixedSize ( false ) ; View headerView = LayoutInflater . from ( parentActivity ) . inflate ( R . layout . padding , null ) ; setDummyDataWithHeader ( recyclerView , headerView ) ; if ( parentActivity instanceof ObservableScrollViewCallbacks ) { Bundle args = getArguments ( ) ; if ( args != null && args . containsKey ( ARG_INITIAL_POSITION ) ) { final int initialPosition = args . getInt ( ARG_INITIAL_POSITION , 0 ) ; ScrollUtils . addOnGlobalLayoutListener ( recyclerView , new Runnable ( ) { @ Override public void run ( ) { recyclerView . scrollVerticallyToPosition ( initialPosition ) ; } } ) ; } recyclerView . setTouchInterceptionViewGroup ( ( ViewGroup ) parentActivity . findViewById ( R . id . root ) ) ; recyclerView . setScrollViewCallbacks ( ( ObservableScrollViewCallbacks ) parentActivity ) ; } return view ; }
@ Override public void run ( ) { recyclerView . scrollVerticallyToPosition ( initialPosition ) ; }
public NativeSampleIT ( MavenRuntimeBuilder builder ) throws Exception { this . mavenRuntime = builder . build ( ) ; }
@ Test public void buildDeployAndRun ( ) Exception { File basedir = resources . getBasedir ( "native" ) ; MavenExecutionResult result = mavenRuntime . forProject ( basedir ) . withCliOption ( "-X" ) . execute ( "clean" , "install" ) ; result . assertErrorFreeLog ( ) ; }
public FragmentManagerAssert ( FragmentManager actual ) { super( actual , FragmentManagerAssert .class ); }
public FragmentManagerAssert hasFragmentWithId ( int id ) { isNotNull ( ) ; assertThat ( actual . findFragmentById ( id ) ) . overridingErrorMessage ( "Expected fragment with ID <%d> but was not found." , id ) . isNotNull ( ) ; return this ; }
public FragmentManagerAssert hasFragmentWithTag ( String tag ) { isNotNull ( ) ; assertThat ( actual . findFragmentByTag ( tag ) ) . overridingErrorMessage ( "Expected fragment with tag <%s> but was not found." , tag ) . isNotNull ( ) ; return this ; }
public FragmentManagerAssert hasBackStackEntryCount ( int count ) { isNotNull ( ) ; int actualCount = actual . getBackStackEntryCount ( ) ; assertThat ( actualCount ) . overridingErrorMessage ( "Expected back stack entry count <%s> but was <%s>." , count , actualCount ) . isEqualTo ( count ) ; return this ; }
public FragmentManagerAssert doesNotHaveFragmentWithId ( int id ) { isNotNull ( ) ; assertThat ( actual . findFragmentById ( id ) ) . overridingErrorMessage ( "Expected fragment with ID <%s> not to be present but was." , id ) . isNull ( ) ; return this ; }
public FragmentManagerAssert doesNotHaveFragmentWithTag ( String tag ) { isNotNull ( ) ; assertThat ( actual . findFragmentByTag ( tag ) ) . overridingErrorMessage ( "Expected fragment with tag <%s> not to be present but was." , tag ) . isNull ( ) ; return this ; }
protected ObaScheduleForStopRequest ( Uri uri ) { super( uri ); }
public Builder ( Context context , String stopId ) { super( context , getPathWithId ( "/schedule-for-stop/" , stopId ) ); }
public Builder setDate ( Time date ) { mBuilder . appendQueryParameter ( "date" , date . format ( "%Y-%m-%d" ) ) ; return this ; }
public ObaScheduleForStopRequest build ( ) { return new ObaScheduleForStopRequest ( buildUri ( ) ) ; }
@ Override public ObaScheduleForStopResponse call ( ) { return call ( ObaScheduleForStopResponse .class ) ; }
@ Override public String toString ( ) { return "ObaScheduleForStopRequest [mUri=" + mUri + "]" ; }
private void assertBounds ( ObaRegion . Bounds bound , double lat , double lon , double latSpan , double lonSpan ) { assertEquals ( lat , bound . getLat ( ) ) ; assertEquals ( lon , bound . getLon ( ) ) ; assertEquals ( latSpan , bound . getLatSpan ( ) ) ; assertEquals ( lonSpan , bound . getLonSpan ( ) ) ; }
private void _assertTampa ( ObaRegion tampa ) { assertEquals ( 0 , tampa . getId ( ) ) ; assertEquals ( "Tampa Bay" , tampa . getName ( ) ) ; ObaRegion . Bounds [] bounds = tampa . getBounds ( ) ; assertNotNull ( bounds ) ; assertEquals ( 2 , bounds . length ) ; assertBounds ( bounds [ 0 ] , 27.976910500000002 , - 82.445851 , 0.5424609999999994 , 0.576357999999999 ) ; assertBounds ( bounds [ 1 ] , 27.919249999999998 , - 82.652145 , 0.47208000000000183 , 0.3967700000000036 ) ; assertEquals ( "http: , tampa . getOtpBaseUrl ( ) ) ; assertEquals ( "otp-tampa@onebusaway.org" , tampa . getOtpContactEmail ( ) ) ; }
private void _assertPugetSound ( ObaRegion ps ) { assertEquals ( 1 , ps . getId ( ) ) ; assertEquals ( "Puget Sound" , ps . getName ( ) ) ; ObaRegion . Bounds [] bounds = ps . getBounds ( ) ; assertNotNull ( bounds ) ; assertEquals ( 9 , bounds . length ) ; assertBounds ( bounds [ 0 ] , 47.221315 , - 122.4051325 , 0.33704 , 0.440483 ) ; assertBounds ( bounds [ 1 ] , 47.5607395 , - 122.1462785 , 0.743251 , 0.720901 ) ; assertBounds ( bounds [ 2 ] , 47.556288 , - 122.4013255 , 0.090694 , 0.126793 ) ; assertNull ( ps . getOtpBaseUrl ( ) ) ; assertNull ( ps . getOtpContactEmail ( ) ) ; }
private void _assertAtlanta ( ObaRegion at ) { assertEquals ( 3 , at . getId ( ) ) ; assertEquals ( "Atlanta" , at . getName ( ) ) ; ObaRegion . Bounds [] bounds = at . getBounds ( ) ; assertNotNull ( bounds ) ; assertEquals ( 7 , bounds . length ) ; assertBounds ( bounds [ 0 ] , 33.7901797681045 , - 84.39483216212469 , 0.002537628406997783 , 0.016058977126604645 ) ; assertBounds ( bounds [ 1 ] , 33.84859251766493 , - 84.36189486914657 , 0.006806584025866869 , 0.035245473959491846 ) ; }
public void testLoader ( ) InterruptedException { ArrayList < ObaRegion > regionsFromResources = RegionUtils . getRegionsFromResources ( getContext ( ) ) ; RegionUtils . saveToProvider ( getContext ( ) , regionsFromResources ) ; ArrayList < ObaRegion > regions = RegionUtils . getRegionsFromProvider ( getContext ( ) ) ; assertNotNull ( regions ) ; assertEquals ( 7 , regions . size ( ) ) ; _assertTampa ( regions . get ( 0 ) ) ; _assertPugetSound ( regions . get ( 1 ) ) ; _assertAtlanta ( regions . get ( 2 ) ) ; }
@ Before @ After public void setUpAndTearDown ( ) { RxAndroidPlugins . reset ( ) ; }
@ Test public void mainThreadHandlerCalled ( ) { final AtomicReference < Scheduler > schedulerRef = new AtomicReference <> ( ) ; final Scheduler newScheduler = new EmptyScheduler ( ) ; RxAndroidPlugins . setMainThreadSchedulerHandler ( new Function < Scheduler , Scheduler > ( ) { @ Override public Scheduler apply ( Scheduler scheduler ) { schedulerRef . set ( scheduler ) ; return newScheduler ; } } ) ; Scheduler scheduler = new EmptyScheduler ( ) ; Scheduler actual = RxAndroidPlugins . onMainThreadScheduler ( scheduler ) ; assertSame ( newScheduler , actual ) ; assertSame ( scheduler , schedulerRef . get ( ) ) ; }
@ Override public Scheduler apply ( Scheduler scheduler ) { schedulerRef . set ( scheduler ) ; return newScheduler ; }
@ Test public void resetClearsMainThreadHandler ( ) { RxAndroidPlugins . setMainThreadSchedulerHandler ( new Function < Scheduler , Scheduler > ( ) { @ Override public Scheduler apply ( Scheduler scheduler ) { throw new AssertionError ( ) ; } } ) ; RxAndroidPlugins . reset ( ) ; Scheduler scheduler = new EmptyScheduler ( ) ; Scheduler actual = RxAndroidPlugins . onMainThreadScheduler ( scheduler ) ; assertSame ( scheduler , actual ) ; }
@ Override public Scheduler apply ( Scheduler scheduler ) { throw new AssertionError ( ) ; }
@ Test public void initMainThreadHandlerCalled ( ) { final AtomicReference < Callable < Scheduler > > schedulerRef = new AtomicReference <> ( ) ; final Scheduler newScheduler = new EmptyScheduler ( ) ; RxAndroidPlugins . setInitMainThreadSchedulerHandler ( new Function < Callable < Scheduler > , Scheduler > ( ) { @ Override public Scheduler apply ( Callable < Scheduler > scheduler ) { schedulerRef . set ( scheduler ) ; return newScheduler ; } } ) ; Callable < Scheduler > scheduler = new Callable < Scheduler > ( ) { @ Override public Scheduler call ( ) Exception { throw new AssertionError ( ) ; } } ; Scheduler actual = RxAndroidPlugins . initMainThreadScheduler ( scheduler ) ; assertSame ( newScheduler , actual ) ; assertSame ( scheduler , schedulerRef . get ( ) ) ; }
@ Override public Scheduler apply ( Callable < Scheduler > scheduler ) { schedulerRef . set ( scheduler ) ; return newScheduler ; }
@ Override public Scheduler call ( ) Exception { throw new AssertionError ( ) ; }
@ Test public void resetClearsInitMainThreadHandler ( ) Exception { RxAndroidPlugins . setInitMainThreadSchedulerHandler ( new Function < Callable < Scheduler > , Scheduler > ( ) { @ Override public Scheduler apply ( Callable < Scheduler > scheduler ) { throw new AssertionError ( ) ; } } ) ; final Scheduler scheduler = new EmptyScheduler ( ) ; Callable < Scheduler > schedulerCallable = new Callable < Scheduler > ( ) { @ Override public Scheduler call ( ) Exception { return scheduler ; } } ; RxAndroidPlugins . reset ( ) ; Scheduler actual = RxAndroidPlugins . initMainThreadScheduler ( schedulerCallable ) ; assertSame ( schedulerCallable . call ( ) , actual ) ; }
@ Override public Scheduler apply ( Callable < Scheduler > scheduler ) { throw new AssertionError ( ) ; }
@ Override public Scheduler call ( ) Exception { return scheduler ; }
@ Test public void defaultMainThreadSchedulerIsInitializedLazily ( ) { Function < Callable < Scheduler > , Scheduler > safeOverride = new Function < Callable < Scheduler > , Scheduler > ( ) { @ Override public Scheduler apply ( Callable < Scheduler > scheduler ) { return new EmptyScheduler ( ) ; } } ; Callable < Scheduler > unsafeDefault = new Callable < Scheduler > ( ) { @ Override public Scheduler call ( ) Exception { throw new AssertionError ( ) ; } } ; RxAndroidPlugins . setInitMainThreadSchedulerHandler ( safeOverride ) ; RxAndroidPlugins . initMainThreadScheduler ( unsafeDefault ) ; }
@ Override public Scheduler apply ( Callable < Scheduler > scheduler ) { return new EmptyScheduler ( ) ; }
@ Override public Scheduler call ( ) Exception { throw new AssertionError ( ) ; }
@ Test public void overrideInitMainSchedulerThrowsWhenSchedulerCallableIsNull ( ) { try { RxAndroidPlugins . initMainThreadScheduler ( null ) ; fail ( ) ; } catch ( NullPointerException e ) { assertEquals ( "scheduler == null" , e . getMessage ( ) ) ; } }
@ Test public void overrideInitMainSchedulerThrowsWhenSchedulerCallableReturnsNull ( ) { Callable < Scheduler > nullResultCallable = new Callable < Scheduler > ( ) { @ Override public Scheduler call ( ) Exception { return null ; } } ; try { RxAndroidPlugins . initMainThreadScheduler ( nullResultCallable ) ; fail ( ) ; } catch ( NullPointerException e ) { assertEquals ( "Scheduler Callable returned null" , e . getMessage ( ) ) ; } }
@ Override public Scheduler call ( ) Exception { return null ; }
@ Test public void getInitMainThreadSchedulerHandlerReturnsHandler ( ) { Function < Callable < Scheduler > , Scheduler > handler = new Function < Callable < Scheduler > , Scheduler > ( ) { @ Override public Scheduler apply ( Callable < Scheduler > schedulerCallable ) throws Exception { return Schedulers . trampoline ( ) ; } } ; RxAndroidPlugins . setInitMainThreadSchedulerHandler ( handler ) ; assertSame ( handler , RxAndroidPlugins . getInitMainThreadSchedulerHandler ( ) ) ; }
@ Override public Scheduler apply ( Callable < Scheduler > schedulerCallable ) throws Exception { return Schedulers . trampoline ( ) ; }
@ Test public void getMainThreadSchedulerHandlerReturnsHandler ( ) { Function < Scheduler , Scheduler > handler = new Function < Scheduler , Scheduler > ( ) { @ Override public Scheduler apply ( Scheduler scheduler ) { return Schedulers . trampoline ( ) ; } } ; RxAndroidPlugins . setMainThreadSchedulerHandler ( handler ) ; assertSame ( handler , RxAndroidPlugins . getOnMainThreadSchedulerHandler ( ) ) ; }
@ Override public Scheduler apply ( Scheduler scheduler ) { return Schedulers . trampoline ( ) ; }
@ Test public void getInitMainThreadSchedulerHandlerReturnsNullIfNotSet ( ) { RxAndroidPlugins . reset ( ) ; assertNull ( RxAndroidPlugins . getInitMainThreadSchedulerHandler ( ) ) ; }
@ Test public void getMainThreadSchedulerHandlerReturnsNullIfNotSet ( ) { RxAndroidPlugins . reset ( ) ; assertNull ( RxAndroidPlugins . getOnMainThreadSchedulerHandler ( ) ) ; }
private ObaTripElement ( ) { id = "" ; tripShortName = "" ; shapeId = "" ; directionId = "" ; serviceId = "" ; tripHeadsign = "" ; timeZone = "" ; routeId = "" ; blockId = "" ; }
@ Override public String getId ( ) { return id ; }
@ Override public String getShortName ( ) { return tripShortName ; }
@ Override public String getShapeId ( ) { return shapeId ; }
@ Override public int getDirectionId ( ) { return Integer . getInteger ( directionId , DIRECTION_OUTBOUND ) ; }
@ Override public String getServiceId ( ) { return serviceId ; }
@ Override public String getHeadsign ( ) { return tripHeadsign ; }
@ Override public String getTimezone ( ) { return timeZone ; }
@ Override public String getRouteId ( ) { return routeId ; }
@ Override public String getBlockId ( ) { return blockId ; }
public void execute ( ) MojoExecutionException , MojoFailureException { if ( ! AndroidExtension . isAndroidPackaging ( project . getPackaging ( ) ) ) { return; } if ( androidManifestFile == null ) { getLog ( ) . debug ( "skip, no androidmanifest.xml defined (androidManifestFile rare case)" ) ; return; } parseConfiguration ( ) ; getLog ( ) . info ( "Attempting to update manifest " + androidManifestFile ) ; getLog ( ) . debug ( "    usesSdk=" + parsedUsesSdk ) ; getLog ( ) . debug ( "    versionName=" + parsedVersionName ) ; getLog ( ) . debug ( "    versionCode=" + parsedVersionCode ) ; getLog ( ) . debug ( "    usesSdk=" + parsedUsesSdk ) ; getLog ( ) . debug ( "    versionCodeUpdateFromVersion=" + parsedVersionCodeUpdateFromVersion ) ; getLog ( ) . debug ( "    versionNamingPattern=" + parsedVersionNamingPattern ) ; getLog ( ) . debug ( "    versionDigits=" + parsedVersionDigits ) ; getLog ( ) . debug ( "    mergeLibraries=" + parsedMergeLibraries ) ; getLog ( ) . debug ( "    mergeReportFile=" + parsedMergeReportFile ) ; if ( ! androidManifestFile . exists ( ) ) { return; } getLog ( ) . debug ( "Using manifest merger V2" ) ; manifestMergerV2 ( ) ; }
private void parseConfiguration ( ) { if ( manifestMerger != null ) { if ( StringUtils . isNotEmpty ( manifestMerger . getVersionName ( ) ) ) { parsedVersionName = manifestMerger . getVersionName ( ) ; } else { parsedVersionName = manifestVersionName ; } if ( manifestMerger . getVersionCode ( ) != null ) { parsedVersionCode = manifestMerger . getVersionCode ( ) ; } else { parsedVersionCode = manifestVersionCode ; } if ( manifestMerger . getVersionCodeUpdateFromVersion ( ) != null ) { parsedVersionCodeUpdateFromVersion = manifestMerger . getVersionCodeUpdateFromVersion ( ) ; } else { parsedVersionCodeUpdateFromVersion = manifestVersionCodeUpdateFromVersion ; } if ( manifestMerger . getVersionNamingPattern ( ) != null ) { parsedVersionNamingPattern = manifestMerger . getVersionNamingPattern ( ) ; } else { parsedVersionNamingPattern = manifestVersionNamingPattern ; } if ( manifestMerger . getVersionDigits ( ) != null ) { parsedVersionDigits = manifestMerger . getVersionDigits ( ) ; } else { parsedVersionDigits = manifestVersionDigits ; } if ( manifestMerger . getUsesSdk ( ) != null ) { parsedUsesSdk = manifestMerger . getUsesSdk ( ) ; } else { parsedUsesSdk = manifestUsesSdk ; } if ( manifestMerger . getMergeLibraries ( ) != null ) { parsedMergeLibraries = manifestMerger . getMergeLibraries ( ) ; } else { parsedMergeLibraries = manifestMergeLibraries ; } if ( manifestMerger . getMergeReportFile ( ) != null ) { parsedMergeReportFile = manifestMerger . getMergeReportFile ( ) ; } else { parsedMergeReportFile = manifestMergeReportFile ; } } else { parsedVersionName = manifestVersionName ; parsedVersionCode = manifestVersionCode ; parsedUsesSdk = manifestUsesSdk ; parsedVersionCodeUpdateFromVersion = manifestVersionCodeUpdateFromVersion ; parsedVersionNamingPattern = manifestVersionNamingPattern ; parsedVersionDigits = manifestVersionDigits ; parsedMergeLibraries = manifestMergeLibraries ; parsedMergeReportFile = manifestMergeReportFile ; } }
public void manifestMergerV2 ( ) MojoExecutionException , MojoFailureException { ILogger logger = new MavenILogger ( getLog ( ) , ( parsedMergeReportFile != null ) ) ; AndroidBuilder builder = new AndroidBuilder ( project . toString ( ) , "created by Android Maven Plugin" , new DefaultProcessExecutor ( logger ) , new DefaultJavaProcessExecutor ( logger ) , new MavenErrorReporter ( logger , ErrorReporter . EvaluationMode . STANDARD ) , logger , false ) ; String minSdkVersion = null ; String targetSdkVersion = null ; int versionCode ; if ( parsedUsesSdk != null ) { minSdkVersion = parsedUsesSdk . getMinSdkVersion ( ) ; targetSdkVersion = parsedUsesSdk . getTargetSdkVersion ( ) ; } if ( parsedVersionCodeUpdateFromVersion ) { VersionGenerator gen = new VersionGenerator ( parsedVersionDigits , parsedVersionNamingPattern ) ; versionCode = gen . generate ( parsedVersionName ) ; } else { versionCode = parsedVersionCode ; } List < AndroidDependency > manifestDependencies = new ArrayList <> ( ) ; if ( parsedMergeLibraries ) { final Set < Artifact > allArtifacts = project . getDependencyArtifacts ( ) ; Set < Artifact > dependencyArtifacts = getArtifactResolverHelper ( ) . getFilteredArtifacts ( allArtifacts ) ; for ( Artifact dependency : dependencyArtifacts ) { final File unpackedLibFolder = getUnpackedLibFolder ( dependency ) ; final File manifestFile = new File ( unpackedLibFolder , SdkConstants . FN_ANDROID_MANIFEST_XML ) ; if ( manifestFile . exists ( ) ) { manifestDependencies . add ( AndroidDependency . createExplodedAarLibrary ( manifestFile , null , dependency . getArtifactId ( ) , unpackedLibFolder . getPath ( ) , unpackedLibFolder ) ) ; } } } builder . mergeManifestsForApplication ( androidManifestFile , new ArrayList < File > ( ) , manifestDependencies , "" , versionCode , parsedVersionName , minSdkVersion , targetSdkVersion , null , destinationManifestFile . getPath ( ) , null , null , ManifestMerger2 . MergeType . APPLICATION , new HashMap < String , Object > ( ) , new ArrayList < ManifestMerger2 . Invoker . Feature > ( ) , parsedMergeReportFile ) ; }
private State ( int value ) { mValue = value ; }
public int getValue ( ) { return mValue ; }
public static State fromInt ( int i ) { for ( State s : values ( ) ) { if ( s . getValue ( ) == i ) { return s ; } } return EMPTY ; }
abstract void onCellSelected ( )
public GameView ( Context context , AttributeSet attrs ) { super( context , attrs ); requestFocus ( ) ; mDrawableBg = getResources ( ) . getDrawable ( R . drawable . lib_bg ) ; setBackgroundDrawable ( mDrawableBg ) ; mBmpPlayer1 = getResBitmap ( R . drawable . lib_cross ) ; mBmpPlayer2 = getResBitmap ( R . drawable . lib_circle ) ; if ( mBmpPlayer1 != null ) { mSrcRect . set ( 0 , 0 , mBmpPlayer1 . getWidth ( ) - 1 , mBmpPlayer1 . getHeight ( ) - 1 ) ; } mBmpPaint = new Paint ( Paint . ANTI_ALIAS_FLAG ) ; mLinePaint = new Paint ( ) ; mLinePaint . setColor ( 0xFFFFFFFF ) ; mLinePaint . setStrokeWidth ( 5 ) ; mLinePaint . setStyle ( Style . STROKE ) ; mWinPaint = new Paint ( Paint . ANTI_ALIAS_FLAG ) ; mWinPaint . setColor ( 0xFFFF0000 ) ; mWinPaint . setStrokeWidth ( 10 ) ; mWinPaint . setStyle ( Style . STROKE ) ; for ( int i = 0 ; i < mData . length ; i ++ ) { mData [ i ] = State . EMPTY ; } if ( isInEditMode ( ) ) { Random rnd = new Random ( ) ; for ( int i = 0 ; i < mData . length ; i ++ ) { mData [ i ] = State . fromInt ( rnd . nextInt ( 3 ) ) ; } } }
public State [] getData ( ) { return mData ; }
public void setCell ( int cellIndex , State value ) { mData [ cellIndex ] = value ; invalidate ( ) ; }
public void setCellListener ( ICellListener cellListener ) { mCellListener = cellListener ; }
public int getSelection ( ) { if ( mSelectedValue == mCurrentPlayer ) { return mSelectedCell ; } return - 1 ; }
public State getCurrentPlayer ( ) { return mCurrentPlayer ; }
public void setCurrentPlayer ( State player ) { mCurrentPlayer = player ; mSelectedCell = - 1 ; }
public State getWinner ( ) { return mWinner ; }
public void setWinner ( State winner ) { mWinner = winner ; }
public void setFinished ( int col , int row , int diagonal ) { mWinCol = col ; mWinRow = row ; mWinDiag = diagonal ; }
@ Override protected void onDraw ( Canvas canvas ) { super. onDraw ( canvas ) ; int sxy = mSxy ; int s3 = sxy * 3 ; int x7 = mOffetX ; int y7 = mOffetY ; for ( int i = 0 , k = sxy ; i < 2 ; i ++ , k += sxy ) { canvas . drawLine ( x7 , y7 + k , x7 + s3 - 1 , y7 + k , mLinePaint ) ; canvas . drawLine ( x7 + k , y7 , x7 + k , y7 + s3 - 1 , mLinePaint ) ; } for ( int j = 0 , k = 0 , y = y7 ; j < 3 ; j ++ , y += sxy ) { for ( int i = 0 , x = x7 ; i < 3 ; i ++ , k ++ , x += sxy ) { mDstRect . offsetTo ( MARGIN + x , MARGIN + y ) ; State v ; if ( mSelectedCell == k ) { if ( mBlinkDisplayOff ) { continue; } v = mSelectedValue ; } else { v = mData [ k ] ; } switch( v ) { case PLAYER1 : if ( mBmpPlayer1 != null ) { canvas . drawBitmap ( mBmpPlayer1 , mSrcRect , mDstRect , mBmpPaint ) ; } break; case PLAYER2 : if ( mBmpPlayer2 != null ) { canvas . drawBitmap ( mBmpPlayer2 , mSrcRect , mDstRect , mBmpPaint ) ; } break; } } } if ( mWinRow >= 0 ) { int y = y7 + mWinRow * sxy + sxy / 2 ; canvas . drawLine ( x7 + MARGIN , y , x7 + s3 - 1 - MARGIN , y , mWinPaint ) ; } else if ( mWinCol >= 0 ) { int x = x7 + mWinCol * sxy + sxy / 2 ; canvas . drawLine ( x , y7 + MARGIN , x , y7 + s3 - 1 - MARGIN , mWinPaint ) ; } else if ( mWinDiag == 0 ) { canvas . drawLine ( x7 + MARGIN , y7 + MARGIN , x7 + s3 - 1 - MARGIN , y7 + s3 - 1 - MARGIN , mWinPaint ) ; } else if ( mWinDiag == 1 ) { canvas . drawLine ( x7 + MARGIN , y7 + s3 - 1 - MARGIN , x7 + s3 - 1 - MARGIN , y7 + MARGIN , mWinPaint ) ; } }
@ Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { int w = MeasureSpec . getSize ( widthMeasureSpec ) ; int h = MeasureSpec . getSize ( heightMeasureSpec ) ; int d = w == 0 ? h : h == 0 ? w : w < h ? w : h ; setMeasuredDimension ( d , d ) ; }
@ Override protected void onSizeChanged ( int w , int h , int oldw , int oldh ) { super. onSizeChanged ( w , h , oldw , oldh ) ; int sx = ( w - 2 * MARGIN ) / 3 ; int sy = ( h - 2 * MARGIN ) / 3 ; int size = sx < sy ? sx : sy ; mSxy = size ; mOffetX = ( w - 3 * size ) / 2 ; mOffetY = ( h - 3 * size ) / 2 ; mDstRect . set ( MARGIN , MARGIN , size - MARGIN , size - MARGIN ) ; }
@ Override public boolean onTouchEvent ( MotionEvent event ) { int action = event . getAction ( ) ; if ( action == MotionEvent . ACTION_DOWN ) { return true ; } else if ( action == MotionEvent . ACTION_UP ) { int x = ( int ) event . getX ( ) ; int y = ( int ) event . getY ( ) ; int sxy = mSxy ; x = ( x - MARGIN ) / sxy ; y = ( y - MARGIN ) / sxy ; if ( isEnabled ( ) && x >= 0 && x < 3 && y >= 0 & y < 3 ) { int cell = x + 3 * y ; State state = cell == mSelectedCell ? mSelectedValue : mData [ cell ] ; state = state == State . EMPTY ? mCurrentPlayer : State . EMPTY ; stopBlink ( ) ; mSelectedCell = cell ; mSelectedValue = state ; mBlinkDisplayOff = false ; mBlinkRect . set ( MARGIN + x * sxy , MARGIN + y * sxy , MARGIN + ( x + 1 ) * sxy , MARGIN + ( y + 1 ) * sxy ) ; if ( state != State . EMPTY ) { mHandler . sendEmptyMessageDelayed ( MSG_BLINK , FPS_MS ) ; } if ( mCellListener != null ) { mCellListener . onCellSelected ( ) ; } } return true ; } return false ; }
public void stopBlink ( ) { boolean hadSelection = mSelectedCell != - 1 && mSelectedValue != State . EMPTY ; mSelectedCell = - 1 ; mSelectedValue = State . EMPTY ; if ( ! mBlinkRect . isEmpty ( ) ) { invalidate ( mBlinkRect ) ; } mBlinkDisplayOff = false ; mBlinkRect . setEmpty ( ) ; mHandler . removeMessages ( MSG_BLINK ) ; if ( hadSelection && mCellListener != null ) { mCellListener . onCellSelected ( ) ; } }
@ Override protected Parcelable onSaveInstanceState ( ) { Bundle b = new Bundle ( ) ; Parcelable s = super. onSaveInstanceState ( ) ; b . putParcelable ( "gv_super_state" , s ) ; b . putBoolean ( "gv_en" , isEnabled ( ) ) ; int [] data = new int [ mData . length ] ; for ( int i = 0 ; i < data . length ; i ++ ) { data [ i ] = mData [ i ] . getValue ( ) ; } b . putIntArray ( "gv_data" , data ) ; b . putInt ( "gv_sel_cell" , mSelectedCell ) ; b . putInt ( "gv_sel_val" , mSelectedValue . getValue ( ) ) ; b . putInt ( "gv_curr_play" , mCurrentPlayer . getValue ( ) ) ; b . putInt ( "gv_winner" , mWinner . getValue ( ) ) ; b . putInt ( "gv_win_col" , mWinCol ) ; b . putInt ( "gv_win_row" , mWinRow ) ; b . putInt ( "gv_win_diag" , mWinDiag ) ; b . putBoolean ( "gv_blink_off" , mBlinkDisplayOff ) ; b . putParcelable ( "gv_blink_rect" , mBlinkRect ) ; return b ; }
@ Override protected void onRestoreInstanceState ( Parcelable state ) { if ( ! ( state instanceof Bundle ) ) { super. onRestoreInstanceState ( state ) ; return; } Bundle b = ( Bundle ) state ; Parcelable superState = b . getParcelable ( "gv_super_state" ) ; setEnabled ( b . getBoolean ( "gv_en" , true ) ) ; int [] data = b . getIntArray ( "gv_data" ) ; if ( data != null && data . length == mData . length ) { for ( int i = 0 ; i < data . length ; i ++ ) { mData [ i ] = State . fromInt ( data [ i ] ) ; } } mSelectedCell = b . getInt ( "gv_sel_cell" , - 1 ) ; mSelectedValue = State . fromInt ( b . getInt ( "gv_sel_val" , State . EMPTY . getValue ( ) ) ) ; mCurrentPlayer = State . fromInt ( b . getInt ( "gv_curr_play" , State . EMPTY . getValue ( ) ) ) ; mWinner = State . fromInt ( b . getInt ( "gv_winner" , State . EMPTY . getValue ( ) ) ) ; mWinCol = b . getInt ( "gv_win_col" , - 1 ) ; mWinRow = b . getInt ( "gv_win_row" , - 1 ) ; mWinDiag = b . getInt ( "gv_win_diag" , - 1 ) ; mBlinkDisplayOff = b . getBoolean ( "gv_blink_off" , false ) ; Rect r = b . getParcelable ( "gv_blink_rect" ) ; if ( r != null ) { mBlinkRect . set ( r ) ; } mHandler . sendEmptyMessage ( MSG_BLINK ) ; super. onRestoreInstanceState ( superState ) ; }
public boolean handleMessage ( Message msg ) { if ( msg . what == MSG_BLINK ) { if ( mSelectedCell >= 0 && mSelectedValue != State . EMPTY && mBlinkRect . top != 0 ) { mBlinkDisplayOff = ! mBlinkDisplayOff ; invalidate ( mBlinkRect ) ; if ( ! mHandler . hasMessages ( MSG_BLINK ) ) { mHandler . sendEmptyMessageDelayed ( MSG_BLINK , FPS_MS ) ; } } return true ; } return false ; }
private Bitmap getResBitmap ( int bmpResId ) { Options opts = new Options ( ) ; opts . inDither = false ; Resources res = getResources ( ) ; Bitmap bmp = BitmapFactory . decodeResource ( res , bmpResId , opts ) ; if ( bmp == null && isInEditMode ( ) ) { Drawable d = res . getDrawable ( bmpResId ) ; int w = d . getIntrinsicWidth ( ) ; int h = d . getIntrinsicHeight ( ) ; bmp = Bitmap . createBitmap ( w , h , Config . ARGB_8888 ) ; Canvas c = new Canvas ( bmp ) ; d . setBounds ( 0 , 0 , w - 1 , h - 1 ) ; d . draw ( c ) ; } return bmp ; }
protected ObaTripsForLocationRequest ( Uri uri ) { super( uri ); }
public Builder ( Context context , Location location ) { super( context , BASE_PATH + "/trips-for-location.json" ); mBuilder . appendQueryParameter ( "lat" , String . valueOf ( location . getLatitude ( ) ) ) ; mBuilder . appendQueryParameter ( "lon" , String . valueOf ( location . getLongitude ( ) ) ) ; }
public Builder setSpan ( double latSpan , double lonSpan ) { mBuilder . appendQueryParameter ( "latSpan" , String . valueOf ( latSpan ) ) ; mBuilder . appendQueryParameter ( "lonSpan" , String . valueOf ( lonSpan ) ) ; return this ; }
public Builder setIncludeTrip ( boolean includeTrip ) { mBuilder . appendQueryParameter ( "includeTrip" , String . valueOf ( includeTrip ) ) ; return this ; }
public Builder setIncludeSchedule ( boolean includeSchedule ) { mBuilder . appendQueryParameter ( "includeSchedule" , String . valueOf ( includeSchedule ) ) ; return this ; }
public ObaTripsForLocationRequest build ( ) { return new ObaTripsForLocationRequest ( buildUri ( ) ) ; }
@ Override public ObaTripsForLocationResponse call ( ) { return call ( ObaTripsForLocationResponse .class ) ; }
@ Override public String toString ( ) { return "ObaTripsForLocationRequest [mUri=" + mUri + "]" ; }
private ArtifactPrototype ( String groupId , String artifactId ) { this . groupId = groupId ; this . artifactId = artifactId ; }
ProGuardInput ( String path , Collection < String > excludedFilter ) { this . path = path ; this . excludedFilter = excludedFilter ; }
public String toPath ( ) { if ( excludedFilter != null && ! excludedFilter . isEmpty ( ) ) { String middleQuote , endQuote ; if ( ! Os . isFamily ( Os . FAMILY_WINDOWS ) ) { middleQuote = "(" ; endQuote = ")" ; } else { middleQuote = "(" ; endQuote = ")" ; } StringBuilder sb = new StringBuilder ( ) ; sb . append ( path ) ; sb . append ( middleQuote ) ; for ( Iterator < String > it = excludedFilter . iterator ( ) ; it . hasNext ( ) ; ) { sb . append ( '!' ) . append ( it . next ( ) ) ; if ( it . hasNext ( ) ) { sb . append ( ',' ) ; } } sb . append ( endQuote ) ; return sb . toString ( ) ; } else { return path ; } }
@ Override public String toString ( ) { return "ProGuardInput{" + "path='" + path + '\'' + ", excludedFilter=" + excludedFilter + '}' ; }
@ Override public void execute ( ) MojoExecutionException , MojoFailureException { if ( getJack ( ) . isEnabled ( ) ) { return; } ConfigHandler configHandler = new ConfigHandler ( this , this . session , this . execution ) ; configHandler . parseConfiguration ( ) ; if ( ! parsedSkip ) { if ( parsedConfig . exists ( ) ) { project . getProperties ( ) . setProperty ( "android.proguard.obfuscatedJar" , obfuscatedJar ) ; executeProguard ( ) ; } else { getLog ( ) . info ( String . format ( "Proguard skipped because the configuration file doesn't exist: %s" , parsedConfig ) ) ; } } }
private void executeProguard ( ) MojoExecutionException { final File proguardDir = this . parsedOutputDirectory ; if ( ! proguardDir . exists ( ) && ! proguardDir . mkdir ( ) ) { throw new MojoExecutionException ( "Cannot create proguard output directory" ) ; } else { if ( proguardDir . exists ( ) && ! proguardDir . isDirectory ( ) ) { throw new MojoExecutionException ( "Non-directory exists at " + proguardDir . getAbsolutePath ( ) ) ; } } getLog ( ) . info ( "Proguarding output" ) ; CommandExecutor executor = CommandExecutor . Factory . createDefaultCommmandExecutor ( ) ; executor . setLogger ( this . getLog ( ) ) ; List < String > commands = new ArrayList < String > ( ) ; collectJvmArguments ( commands ) ; commands . add ( "-jar" ) ; commands . add ( parsedProguardJarPath ) ; List < String > proguardCommands = new ArrayList < String > ( ) ; proguardCommands . add ( "@" + parsedConfig + "" ) ; for ( String config : parsedConfigs ) { proguardCommands . add ( "@" + config ) ; } if ( proguardFile != null ) { proguardCommands . add ( "@" + proguardFile . getAbsolutePath ( ) ) ; } for ( Artifact artifact : getTransitiveDependencyArtifacts ( AAR ) ) { File unpackedLibFolder = getUnpackedLibFolder ( artifact ) ; File proguardFile = new File ( unpackedLibFolder , "proguard.txt" ) ; if ( proguardFile . exists ( ) ) { proguardCommands . add ( "@" + proguardFile . getAbsolutePath ( ) ) ; } } collectInputFiles ( proguardCommands ) ; proguardCommands . add ( "-outjars" ) ; proguardCommands . add ( obfuscatedJar ) ; proguardCommands . add ( "-dump" ) ; proguardCommands . add ( proguardDir + File . separator + "dump.txt" ) ; proguardCommands . add ( "-printseeds" ) ; proguardCommands . add ( proguardDir + File . separator + "seeds.txt" ) ; proguardCommands . add ( "-printusage" ) ; proguardCommands . add ( proguardDir + File . separator + "usage.txt" ) ; File mapFile = new File ( proguardDir , "mapping.txt" ) ; proguardCommands . add ( "-printmapping" ) ; proguardCommands . add ( mapFile . toString ( ) ) ; proguardCommands . addAll ( Arrays . asList ( parsedOptions ) ) ; final String javaExecutable = getJavaExecutable ( ) . getAbsolutePath ( ) ; getLog ( ) . debug ( javaExecutable + " " + commands . toString ( ) + proguardCommands . toString ( ) ) ; FileOutputStream tempConfigFileOutputStream = null ; try { File tempConfigFile = new File ( proguardDir , "temp_config.cfg" ) ; StringBuilder commandStringBuilder = new StringBuilder ( ) ; for ( String command : proguardCommands ) { commandStringBuilder . append ( command ) ; commandStringBuilder . append ( SystemUtils . LINE_SEPARATOR ) ; } tempConfigFileOutputStream = new FileOutputStream ( tempConfigFile ) ; IOUtils . write ( commandStringBuilder , tempConfigFileOutputStream ) ; executor . setCaptureStdOut ( true ) ; commands . add ( "@" + tempConfigFile . getAbsolutePath ( ) + "" ) ; executor . executeCommand ( javaExecutable , commands , project . getBasedir ( ) , false ) ; } catch ( ExecutionException e ) { throw new MojoExecutionException ( "" , e ) ; } catch ( IOException e ) { throw new MojoExecutionException ( "Error writing proguard commands to temporary file" , e ) ; } finally { IOUtils . closeQuietly ( tempConfigFileOutputStream ) ; } if ( parsedAttachMap ) { projectHelper . attachArtifact ( project , "map" , mapFile ) ; } }
private void collectJvmArguments ( List < String > commands ) { if ( parsedJvmArguments != null ) { for ( String jvmArgument : parsedJvmArguments ) { if ( ! jvmArgument . startsWith ( "-" ) ) { jvmArgument = "-" + jvmArgument ; } commands . add ( jvmArgument ) ; } } }
private void collectInputFiles ( List < String > commands ) throws MojoExecutionException { skipArtifact ( "commons-logging" , "commons-logging" , true ) ; final List < ProGuardInput > inJars = getProgramInputFiles ( ) ; if ( isAPKBuild ( ) ) { inJars . addAll ( getProjectDependencyFiles ( ) ) ; } for ( final ProGuardInput injar : inJars ) { getLog ( ) . debug ( "Added injar : " + injar ) ; commands . add ( "-injars" ) ; commands . add ( injar . toPath ( ) ) ; } final List < ProGuardInput > libraryJars = getLibraryInputFiles ( ) ; if ( ! isAPKBuild ( ) ) { getLog ( ) . info ( "Library project - not adding project dependencies to the obfuscated JAR" ) ; libraryJars . addAll ( getProjectDependencyFiles ( ) ) ; } for ( final ProGuardInput libraryjar : libraryJars ) { getLog ( ) . debug ( "Added libraryJar : " + libraryjar ) ; commands . add ( "-libraryjars" ) ; commands . add ( libraryjar . toPath ( ) ) ; } }
private static File getJavaExecutable ( ) { final String javaHome = System . getProperty ( "java.home" ) ; final String slash = File . separator ; return new File ( javaHome + slash + "bin" + slash + "java" ) ; }
private void skipArtifact ( String groupId , String artifactId , boolean shiftToLibraries )            throws MojoExecutionException { final ArtifactPrototype artifact = new ArtifactPrototype ( groupId , artifactId ) ; artifactBlacklist . add ( artifact ) ; if ( shiftToLibraries ) { artifactsToShift . add ( artifact ) ; } }
private boolean isBlacklistedArtifact ( Artifact artifact ) { for ( ArtifactPrototype artifactToSkip : artifactBlacklist ) { if ( artifactToSkip . groupId . equals ( artifact . getGroupId ( ) ) && artifactToSkip . artifactId . equals ( artifact . getArtifactId ( ) ) ) { return true ; } } return false ; }
private boolean isShiftedArtifact ( Artifact artifact ) { for ( ArtifactPrototype artifactToShift : artifactsToShift ) { if ( artifactToShift . groupId . equals ( artifact . getGroupId ( ) ) && artifactToShift . artifactId . equals ( artifact . getArtifactId ( ) ) ) { return true ; } } return false ; }
private List < ProGuardInput > getProgramInputFiles ( ) { final List < ProGuardInput > inJars = new LinkedList < ProguardMojo . ProGuardInput > ( ) ; inJars . add ( createProguardInput ( projectOutputDirectory . getAbsolutePath ( ) ) ) ; return inJars ; }
private List < ProGuardInput > getProjectDependencyFiles ( ) { final Collection < String > globalInJarExcludes = new HashSet < String > ( ) ; final List < ProGuardInput > inJars = new LinkedList < ProguardMojo . ProGuardInput > ( ) ; if ( parsedFilterManifest ) { globalInJarExcludes . addAll ( META_INF_MANIFEST ) ; } if ( parsedFilterMavenDescriptor ) { globalInJarExcludes . addAll ( MAVEN_DESCRIPTOR ) ; } if ( parsedCustomFilter != null ) { globalInJarExcludes . addAll ( Arrays . asList ( parsedCustomFilter . split ( "," ) ) ) ; } for ( Artifact artifact : filterArtifacts ( getTransitiveDependencyArtifacts ( ) , skipDependencies , artifactTypeSet . getIncludes ( ) , artifactTypeSet . getExcludes ( ) , artifactSet . getIncludes ( ) , artifactSet . getExcludes ( ) ) ) { if ( isBlacklistedArtifact ( artifact ) ) { getLog ( ) . debug ( "Excluding (blacklisted) dependency as input jar : " + artifact ) ; continue; } if ( JAR_DEPENDENCY_TYPE . equals ( artifact . getType ( ) ) ) { getLog ( ) . debug ( "Including dependency as input jar : " + artifact ) ; inJars . add ( createProguardInput ( artifact . getFile ( ) . getAbsolutePath ( ) , globalInJarExcludes ) ) ; } else if ( AAR . equals ( artifact . getType ( ) ) ) { } else { getLog ( ) . debug ( "Excluding dependency as input jar : " + artifact ) ; } } return inJars ; }
private ProGuardInput createProguardInput ( String path , Collection < String > filterExpression ) { return new ProGuardInput ( path , filterExpression ) ; }
private ProGuardInput createProguardInput ( String path ) { return createProguardInput ( path , null ) ; }
private List < ProGuardInput > getLibraryInputFiles ( ) { final List < ProGuardInput > libraryJars = new LinkedList < ProguardMojo . ProGuardInput > ( ) ; if ( parsedIncludeJdkLibs ) { File rtJar = getJVMLibrary ( "rt.jar" ) ; if ( rtJar == null ) { rtJar = getJVMLibrary ( "classes.jar" ) ; } if ( rtJar != null ) { libraryJars . add ( createProguardInput ( rtJar . getPath ( ) ) ) ; } File jsseJar = getJVMLibrary ( "jsse.jar" ) ; if ( jsseJar != null ) { libraryJars . add ( createProguardInput ( jsseJar . getPath ( ) ) ) ; } File jceJar = getJVMLibrary ( "jce.jar" ) ; if ( jceJar != null ) { libraryJars . add ( createProguardInput ( jceJar . getPath ( ) ) ) ; } } for ( Artifact artifact : project . getArtifacts ( ) ) { if ( artifact . getScope ( ) . equals ( Artifact . SCOPE_PROVIDED ) ) { if ( artifact . getArtifactId ( ) . equals ( "android" ) && parsedIncludeJdkLibs ) { getLog ( ) . debug ( "Including dependency as (android) library jar : " + artifact ) ; libraryJars . add ( createProguardInput ( artifact . getFile ( ) . getAbsolutePath ( ) , ANDROID_LIBRARY_EXCLUDED_FILTER ) ) ; } else { getLog ( ) . debug ( "Including dependency as (provided) library jar : " + artifact ) ; libraryJars . add ( createProguardInput ( artifact . getFile ( ) . getAbsolutePath ( ) ) ) ; } } else { if ( isShiftedArtifact ( artifact ) ) { getLog ( ) . debug ( "Including dependency as (shifted) library jar : " + artifact ) ; libraryJars . add ( createProguardInput ( artifact . getFile ( ) . getAbsolutePath ( ) ) ) ; } else { getLog ( ) . debug ( "Excluding dependency as library jar : " + artifact ) ; } } } return libraryJars ; }
@ SuppressWarnings ( "unused" ) private String getProguardJarPath ( ) MojoExecutionException { return getProguardJarPathFromDependencies ( ) ; }
private String getProguardJarPathFromDependencies ( ) MojoExecutionException { Artifact proguardArtifact = null ; int proguardArtifactDistance = - 1 ; for ( Artifact artifact : pluginDependencies ) { getLog ( ) . debug ( "pluginArtifact: " + artifact . getFile ( ) ) ; if ( ( "proguard" . equals ( artifact . getArtifactId ( ) ) ) || ( "proguard-base" . equals ( artifact . getArtifactId ( ) ) ) ) { int distance = artifact . getDependencyTrail ( ) . size ( ) ; getLog ( ) . debug ( "proguard DependencyTrail: " + distance ) ; if ( proguardArtifactDistance == - 1 ) { proguardArtifact = artifact ; proguardArtifactDistance = distance ; } else { if ( distance < proguardArtifactDistance ) { proguardArtifact = artifact ; proguardArtifactDistance = distance ; } } } } if ( proguardArtifact != null ) { getLog ( ) . debug ( "proguardArtifact: " + proguardArtifact . getFile ( ) ) ; return proguardArtifact . getFile ( ) . getAbsoluteFile ( ) . toString ( ) ; } else { return null ; } }
@ SuppressWarnings ( "unused" ) private String [] getDefaultJvmArguments ( ) { return new String [] { "-Xmx512M" } ; }
@ SuppressWarnings ( "unused" ) private String [] getDefaultProguardConfigs ( ) { return new String [ 0 ] ; }
@ SuppressWarnings ( "unused" ) private String [] getDefaultProguardOptions ( ) { return new String [ 0 ] ; }
private File getJVMLibrary ( String fileName ) { File libFile = new File ( getJavaLibDir ( ) , fileName ) ; if ( ! libFile . exists ( ) ) { libFile = new File ( getAltJavaLibDir ( ) , fileName ) ; if ( ! libFile . exists ( ) ) { libFile = null ; } } return libFile ; }
private File getJavaHomeDir ( ) { if ( javaHomeDir == null ) { javaHomeDir = new File ( System . getProperty ( "java.home" ) ) ; } return javaHomeDir ; }
private File getJavaLibDir ( ) { if ( javaLibDir == null ) { javaLibDir = new File ( getJavaHomeDir ( ) , "lib" ) ; } return javaLibDir ; }
private File getAltJavaLibDir ( ) { if ( altJavaLibDir == null ) { altJavaLibDir = new File ( getJavaHomeDir ( ) . getParent ( ) , "Classes" ) ; } return altJavaLibDir ; }
public RestorePreference ( Context context ) { super( context ); }
public RestorePreference ( Context context , AttributeSet attrs ) { super( context , attrs ); }
public RestorePreference ( Context context , AttributeSet attrs , int defStyle ) { super( context , attrs , defStyle ); }
@ Override public boolean isPersistent ( ) { return false ; }
@ Override public boolean isEnabled ( ) { final String state = Environment . getExternalStorageState ( ) ; return ( Environment . MEDIA_MOUNTED_READ_ONLY . equals ( state ) || Environment . MEDIA_MOUNTED . equals ( state ) ) && Backup . isRestoreAvailable ( getContext ( ) ) ; }
@ Override protected void onClick ( ) { AlertDialog dialog = new AlertDialog . Builder ( getContext ( ) ) . setMessage ( R . string . preferences_db_restore_warning ) . setPositiveButton ( android . R . string . ok , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { dialog . dismiss ( ) ; doRestore ( ) ; } } ) . setNegativeButton ( android . R . string . cancel , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { dialog . dismiss ( ) ; } } ) . create ( ) ; dialog . show ( ) ; }
@ Override public void onClick ( DialogInterface dialog , int which ) { dialog . dismiss ( ) ; doRestore ( ) ; }
@ Override public void onClick ( DialogInterface dialog , int which ) { dialog . dismiss ( ) ; }
void doRestore ( ) { final Context context = Application . get ( ) . getApplicationContext ( ) ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , context . getString ( R . string . analytics_action_button_press ) , context . getString ( R . string . analytics_label_button_press_restore_preference ) ) ; try { Backup . restore ( context ) ; Context activityContext = getContext ( ) ; if ( activityContext != null ) { List < ObaRegionsTask . Callback > callbacks = new ArrayList <> ( ) ; callbacks . add ( new ObaRegionsTask . Callback ( ) { @ Override public void onRegionTaskFinished ( boolean currentRegionChanged ) { Toast . makeText ( context , R . string . preferences_db_restored , Toast . LENGTH_LONG ) . show ( ) ; } } ) ; ObaRegionsTask task = new ObaRegionsTask ( activityContext , callbacks , true , true ) ; task . setProgressDialogMessage ( context . getString ( R . string . preferences_restore_loading ) ) ; task . execute ( ) ; } } catch ( IOException e ) { Toast . makeText ( context , context . getString ( R . string . preferences_db_restore_error , e . getMessage ( ) ) , Toast . LENGTH_LONG ) . show ( ) ; } }
@ Override public void onRegionTaskFinished ( boolean currentRegionChanged ) { Toast . makeText ( context , R . string . preferences_db_restored , Toast . LENGTH_LONG ) . show ( ) ; }
static protected CursorLoader newRecentQuery ( final Context context , final Uri uri , final String [] projection , final String accessTime , final String useCount ) { final long last = System . currentTimeMillis ( ) - 7 * DateUtils . DAY_IN_MILLIS ; Uri limit = uri . buildUpon ( ) . appendQueryParameter ( "limit" , "20" ) . build ( ) ; String regionWhere = "" ; if ( Application . get ( ) . getCurrentRegion ( ) != null ) { if ( projection . equals ( QueryUtils . StopList . Columns . PROJECTION ) ) { regionWhere = " AND " + StopList . getRegionWhere ( ) ; } else if ( projection . equals ( QueryUtils . RouteList . Columns . PROJECTION ) ) { regionWhere = " AND " + RouteList . getRegionWhere ( ) ; } } return new CursorLoader ( context , limit , projection , "((" + accessTime + " IS NOT NULL AND " + accessTime + " > " + last + ") OR (" + useCount + " > 0))" + regionWhere , null , accessTime + " desc, " + useCount + " desc" ) ; }
public static SimpleCursorAdapter newAdapter ( Context context ) { final String [] from = { ObaContract . Routes . SHORTNAME , ObaContract . Routes . LONGNAME } ; final int [] to = { R . id . short_name , R . id . long_name } ; SimpleCursorAdapter simpleAdapter = new SimpleCursorAdapter ( context , R . layout . route_list_item , null , from , to , 0 ) ; return simpleAdapter ; }
static protected String getId ( ListView l , int position ) { SimpleCursorAdapter cursorAdapter = ( SimpleCursorAdapter ) l . getAdapter ( ) ; Cursor c = cursorAdapter . getCursor ( ) ; c . moveToPosition ( position - l . getHeaderViewsCount ( ) ) ; return c . getString ( Columns . COL_ID ) ; }
static protected String getUrl ( ListView l , int position ) { SimpleCursorAdapter cursorAdapter = ( SimpleCursorAdapter ) l . getAdapter ( ) ; Cursor c = cursorAdapter . getCursor ( ) ; c . moveToPosition ( position - l . getHeaderViewsCount ( ) ) ; return c . getString ( Columns . COL_URL ) ; }
static protected String getRegionWhere ( ) { return Application . get ( ) . getCurrentRegion ( ) == null ? "" : QueryUtils . getRegionWhere ( ObaContract . Routes . REGION_ID , Application . get ( ) . getCurrentRegion ( ) . getId ( ) ) ; }
public static SimpleCursorAdapter newAdapter ( Context context ) { String [] from = new String [] { ObaContract . Stops . UI_NAME , ObaContract . Stops . DIRECTION , ObaContract . Stops . FAVORITE } ; int [] to = new int [] { R . id . stop_name , R . id . direction , R . id . stop_favorite } ; SimpleCursorAdapter simpleAdapter = new SimpleCursorAdapter ( context , R . layout . stop_list_item , null , from , to , 0 ) ; simpleAdapter . setViewBinder ( new SimpleCursorAdapter . ViewBinder ( ) { public boolean setViewValue ( View view , Cursor cursor , int columnIndex ) { if ( columnIndex == Columns . COL_FAVORITE ) { ImageView favorite = ( ImageView ) view . findViewById ( R . id . stop_favorite ) ; if ( cursor . getInt ( columnIndex ) == 1 ) { favorite . setVisibility ( View . VISIBLE ) ; favorite . setColorFilter ( favorite . getResources ( ) . getColor ( R . color . navdrawer_icon_tint ) ) ; } else { favorite . setVisibility ( View . GONE ) ; } return true ; } else if ( columnIndex == Columns . COL_DIRECTION ) { UIUtils . setStopDirection ( view . findViewById ( R . id . direction ) , cursor . getString ( columnIndex ) , true ) ; return true ; } return false ; } } ) ; return simpleAdapter ; }
public boolean setViewValue ( View view , Cursor cursor , int columnIndex ) { if ( columnIndex == Columns . COL_FAVORITE ) { ImageView favorite = ( ImageView ) view . findViewById ( R . id . stop_favorite ) ; if ( cursor . getInt ( columnIndex ) == 1 ) { favorite . setVisibility ( View . VISIBLE ) ; favorite . setColorFilter ( favorite . getResources ( ) . getColor ( R . color . navdrawer_icon_tint ) ) ; } else { favorite . setVisibility ( View . GONE ) ; } return true ; } else if ( columnIndex == Columns . COL_DIRECTION ) { UIUtils . setStopDirection ( view . findViewById ( R . id . direction ) , cursor . getString ( columnIndex ) , true ) ; return true ; } return false ; }
static protected String getId ( ListView l , int position ) { SimpleCursorAdapter cursorAdapter = ( SimpleCursorAdapter ) l . getAdapter ( ) ; Cursor c = cursorAdapter . getCursor ( ) ; c . moveToPosition ( position - l . getHeaderViewsCount ( ) ) ; return c . getString ( Columns . COL_ID ) ; }
static protected String getRegionWhere ( ) { return Application . get ( ) . getCurrentRegion ( ) == null ? "" : QueryUtils . getRegionWhere ( ObaContract . Stops . REGION_ID , Application . get ( ) . getCurrentRegion ( ) . getId ( ) ) ; }
public static String getRegionWhere ( String regionFieldName , long regionId ) { return "(" + regionFieldName + "=" + regionId + " OR " + regionFieldName + " IS NULL)" ; }
public static void setFavoriteRouteAndHeadsign ( Context context , Uri routeUri , String headsign , String stopId , ContentValues routeValues , boolean favorite ) { if ( routeValues == null ) { routeValues = new ContentValues ( ) ; } if ( Application . get ( ) . getCurrentRegion ( ) != null ) { routeValues . put ( ObaContract . Routes . REGION_ID , Application . get ( ) . getCurrentRegion ( ) . getId ( ) ) ; } String routeId = routeUri . getLastPathSegment ( ) ; ObaContract . Routes . insertOrUpdate ( context , routeId , routeValues , true ) ; ObaContract . RouteHeadsignFavorites . markAsFavorite ( context , routeId , headsign , stopId , favorite ) ; }
@ Override protected Class < SampleHelper > getHelperClass ( ) { return SampleHelper .class ; }
@ Override public boolean onCreate ( ) { setMatcherController ( new MatcherController ( ) . add ( Account .class , SubType . DIRECTORY , "" , AccountContract . CONTENT_URI_PATTERN_MANY ) . add ( Account .class , SubType . ITEM , "#" , AccountContract . CONTENT_URI_PATTERN_ONE ) ) ; return true ; }
protected ObaAgencyRequest ( Uri uri ) { super( uri ); }
public Builder ( Context context , String agencyId ) { super( context , getPathWithId ( "/agency/" , agencyId ) ); }
public ObaAgencyRequest build ( ) { return new ObaAgencyRequest ( buildUri ( ) ) ; }
public static ObaAgencyRequest newRequest ( Context context , String agency ) { return new Builder ( context , agency ) . build ( ) ; }
@ Override public ObaAgencyResponse call ( ) { return call ( ObaAgencyResponse .class ) ; }
@ Override public String toString ( ) { return "ObaAgencyRequest [mUri=" + mUri + "]" ; }
public static ObaRegion getClosestRegion ( ArrayList < ObaRegion > regions , Location loc , boolean enforceThreshold ) { if ( loc == null ) { return null ; } float minDist = Float . MAX_VALUE ; ObaRegion closestRegion = null ; Float distToRegion ; NumberFormat fmt = NumberFormat . getInstance ( ) ; if ( fmt instanceof DecimalFormat ) { ( ( DecimalFormat ) fmt ) . setMaximumFractionDigits ( 1 ) ; } double miles ; Log . d ( TAG , "Finding region closest to " + loc . getLatitude ( ) + "," + loc . getLongitude ( ) ) ; for ( ObaRegion region : regions ) { if ( ! isRegionUsable ( region ) ) { Log . d ( TAG , "Excluding '" + region . getName ( ) + "' from 'closest region' consideration" ) ; continue; } distToRegion = getDistanceAway ( region , loc . getLatitude ( ) , loc . getLongitude ( ) ) ; if ( distToRegion == null ) { Log . e ( TAG , "Couldn't measure distance to region '" + region . getName ( ) + "'" ) ; continue; } miles = distToRegion * METERS_TO_MILES ; Log . d ( TAG , "Region '" + region . getName ( ) + "' is " + fmt . format ( miles ) + " miles away" ) ; if ( distToRegion < minDist ) { closestRegion = region ; minDist = distToRegion ; } } if ( enforceThreshold ) { if ( minDist * METERS_TO_MILES < DISTANCE_LIMITER ) { return closestRegion ; } else { return null ; } } return closestRegion ; }
public static String getObaRegionName ( ) { String regionName = null ; ObaRegion region = Application . get ( ) . getCurrentRegion ( ) ; if ( region != null && region . getName ( ) != null ) { regionName = region . getName ( ) ; } else if ( Application . get ( ) . getCustomApiUrl ( ) != null ) { regionName = createHashCode ( Application . get ( ) . getCustomApiUrl ( ) . getBytes ( ) ) ; } return regionName ; }
private static String createHashCode ( byte [] bytes ) { MessageDigest digest ; try { digest = MessageDigest . getInstance ( "SHA-1" ) ; digest . update ( bytes ) ; return Application . get ( ) . getString ( R . string . analytics_label_custom_url ) + ": " + Application . getHex ( digest . digest ( ) ) ; } catch ( Exception e ) { return Application . get ( ) . getString ( R . string . analytics_label_custom_url ) ; } }
public static Float getDistanceAway ( ObaRegion region , double lat , double lon ) { ObaRegion . Bounds [] bounds = region . getBounds ( ) ; if ( bounds == null ) { return null ; } float [] results = new float [ 1 ] ; float minDistance = Float . MAX_VALUE ; for ( ObaRegion . Bounds bound : bounds ) { Location . distanceBetween ( lat , lon , bound . getLat ( ) , bound . getLon ( ) , results ) ; if ( results [ 0 ] < minDistance ) { minDistance = results [ 0 ] ; } } return minDistance ; }
public static Float getDistanceAway ( ObaRegion region , Location loc ) { return getDistanceAway ( region , loc . getLatitude ( ) , loc . getLongitude ( ) ) ; }
public static void getRegionSpan ( ObaRegion region , double [] results ) { if ( results . length < 4 ) { throw new IllegalArgumentException ( "Results array is < 4" ) ; } if ( region == null ) { throw new IllegalArgumentException ( "Region is null" ) ; } double latMin = 90 ; double latMax = - 90 ; double lonMin = 180 ; double lonMax = - 180 ; for ( ObaRegion . Bounds bound : region . getBounds ( ) ) { double lat = bound . getLat ( ) ; double latSpanHalf = bound . getLatSpan ( ) / 2.0 ; double lat1 = lat - latSpanHalf ; double lat2 = lat + latSpanHalf ; if ( lat1 < latMin ) { latMin = lat1 ; } if ( lat2 > latMax ) { latMax = lat2 ; } double lon = bound . getLon ( ) ; double lonSpanHalf = bound . getLonSpan ( ) / 2.0 ; double lon1 = lon - lonSpanHalf ; double lon2 = lon + lonSpanHalf ; if ( lon1 < lonMin ) { lonMin = lon1 ; } if ( lon2 > lonMax ) { lonMax = lon2 ; } } results [ 0 ] = latMax - latMin ; results [ 1 ] = lonMax - lonMin ; results [ 2 ] = latMin + ( ( latMax - latMin ) / 2.0 ) ; results [ 3 ] = lonMin + ( ( lonMax - lonMin ) / 2.0 ) ; }
public static boolean isLocationWithinRegion ( Location location , double [] regionSpan ) { if ( regionSpan == null || regionSpan . length < 4 ) { throw new IllegalArgumentException ( "regionSpan is null or has length < 4" ) ; } if ( location == null || location . getLongitude ( ) > 180.0 || location . getLongitude ( ) < - 180.0 || location . getLatitude ( ) > 90 || location . getLatitude ( ) < - 90 ) { throw new IllegalArgumentException ( "Location must be a valid location" ) ; } double minLat = regionSpan [ 2 ] - ( regionSpan [ 0 ] / 2 ) ; double minLon = regionSpan [ 3 ] - ( regionSpan [ 1 ] / 2 ) ; double maxLat = regionSpan [ 2 ] + ( regionSpan [ 0 ] / 2 ) ; double maxLon = regionSpan [ 3 ] + ( regionSpan [ 1 ] / 2 ) ; return minLat <= location . getLatitude ( ) && location . getLatitude ( ) <= maxLat && minLon <= location . getLongitude ( ) && location . getLongitude ( ) <= maxLon ; }
public static boolean isLocationWithinRegion ( Location location , ObaRegion region ) { double [] regionSpan = new double [ 4 ] ; getRegionSpan ( region , regionSpan ) ; return isLocationWithinRegion ( location , regionSpan ) ; }
public static boolean isRegionUsable ( ObaRegion region ) { if ( ! region . getActive ( ) ) { Log . d ( TAG , "Region '" + region . getName ( ) + "' is not active." ) ; return false ; } if ( ! region . getSupportsObaDiscoveryApis ( ) ) { Log . d ( TAG , "Region '" + region . getName ( ) + "' does not support OBA Discovery APIs." ) ; return false ; } if ( ! region . getSupportsObaRealtimeApis ( ) ) { Log . d ( TAG , "Region '" + region . getName ( ) + "' does not support OBA Realtime APIs." ) ; return false ; } if ( region . getExperimental ( ) && ! Application . getPrefs ( ) . getBoolean ( Application . get ( ) . getString ( R . string . preference_key_experimental_regions ) , false ) ) { Log . d ( TAG , "Region '" + region . getName ( ) + "' is experimental and user hasn't opted in." ) ; return false ; } return true ; }
public static String formatOtpBaseUrl ( String baseUrl ) { return baseUrl . replaceFirst ( "/$" , "" ) ; }
public synchronized static ArrayList < ObaRegion > getRegions ( Context context , boolean forceReload ) { ArrayList < ObaRegion > results ; if ( ! forceReload ) { results = RegionUtils . getRegionsFromProvider ( context ) ; if ( results != null ) { Log . d ( TAG , "Retrieved regions from database." ) ; return results ; } Log . d ( TAG , "Regions list retrieved from database was null." ) ; } results = RegionUtils . getRegionsFromServer ( context ) ; if ( results == null || results . isEmpty ( ) ) { Log . d ( TAG , "Regions list retrieved from server was null or empty." ) ; if ( forceReload ) { results = RegionUtils . getRegionsFromProvider ( context ) ; if ( results != null ) { Log . d ( TAG , "Retrieved regions from database." ) ; return results ; } else { Log . d ( TAG , "Regions list retrieved from database was null." ) ; } } results = RegionUtils . getRegionsFromResources ( context ) ; if ( results == null ) { Log . d ( TAG , "Regions list retrieved from local resource file was null." ) ; return results ; } Log . d ( TAG , "Retrieved regions from local resource file." ) ; } else { Log . d ( TAG , "Retrieved regions list from server." ) ; Application . get ( ) . setLastRegionUpdateDate ( new Date ( ) . getTime ( ) ) ; } RegionUtils . saveToProvider ( context , results ) ; return results ; }
public static ArrayList < ObaRegion > getRegionsFromProvider ( Context context ) { HashMap < Long , ArrayList < ObaRegionElement . Bounds > > allBounds = getBoundsFromProvider ( context ) ; HashMap < Long , ArrayList < ObaRegionElement . Open311Server > > allOpen311Servers = getOpen311ServersFromProvider ( context ) ; Cursor c = null ; try { final String [] PROJECTION = { ObaContract . Regions . _ID , ObaContract . Regions . NAME , ObaContract . Regions . OBA_BASE_URL , ObaContract . Regions . SIRI_BASE_URL , ObaContract . Regions . LANGUAGE , ObaContract . Regions . CONTACT_EMAIL , ObaContract . Regions . SUPPORTS_OBA_DISCOVERY , ObaContract . Regions . SUPPORTS_OBA_REALTIME , ObaContract . Regions . SUPPORTS_SIRI_REALTIME , ObaContract . Regions . TWITTER_URL , ObaContract . Regions . EXPERIMENTAL , ObaContract . Regions . STOP_INFO_URL , ObaContract . Regions . OTP_BASE_URL , ObaContract . Regions . OTP_CONTACT_EMAIL } ; ContentResolver cr = context . getContentResolver ( ) ; c = cr . query ( ObaContract . Regions . CONTENT_URI , PROJECTION , null , null , ObaContract . Regions . _ID ) ; if ( c == null ) { return null ; } if ( c . getCount ( ) == 0 ) { c . close ( ) ; return null ; } ArrayList < ObaRegion > results = new ArrayList < ObaRegion > ( ) ; c . moveToFirst ( ) ; do { long id = c . getLong ( 0 ) ; ArrayList < ObaRegionElement . Bounds > bounds = allBounds . get ( id ) ; ObaRegionElement . Bounds [] bounds2 = ( bounds != null ) ? bounds . toArray ( new ObaRegionElement . Bounds [] {} ) : null ; ArrayList < ObaRegionElement . Open311Server > open311Servers = allOpen311Servers . get ( id ) ; ObaRegionElement . Open311Server [] open311Servers2 = ( open311Servers != null ) ? open311Servers . toArray ( new ObaRegionElement . Open311Server [] {} ) : null ; results . add ( new ObaRegionElement ( id , c . getString ( 1 ) , true , c . getString ( 2 ) , c . getString ( 3 ) , bounds2 , open311Servers2 , c . getString ( 4 ) , c . getString ( 5 ) , c . getInt ( 6 ) > 0 , c . getInt ( 7 ) > 0 , c . getInt ( 8 ) > 0 , c . getString ( 9 ) , c . getInt ( 10 ) > 0 , c . getString ( 11 ) , c . getString ( 12 ) , c . getString ( 13 ) ) ) ; } while ( c . moveToNext ( ) ); return results ; } finally { if ( c != null ) { c . close ( ) ; } } }
private static HashMap < Long , ArrayList < ObaRegionElement . Bounds > > getBoundsFromProvider ( Context context ) { Cursor c = null ; try { final String [] PROJECTION = { ObaContract . RegionBounds . REGION_ID , ObaContract . RegionBounds . LATITUDE , ObaContract . RegionBounds . LONGITUDE , ObaContract . RegionBounds . LAT_SPAN , ObaContract . RegionBounds . LON_SPAN } ; HashMap < Long , ArrayList < ObaRegionElement . Bounds > > results = new HashMap < Long , ArrayList < ObaRegionElement . Bounds > > ( ) ; ContentResolver cr = context . getContentResolver ( ) ; c = cr . query ( ObaContract . RegionBounds . CONTENT_URI , PROJECTION , null , null , null ) ; if ( c == null ) { return results ; } if ( c . getCount ( ) == 0 ) { c . close ( ) ; return results ; } c . moveToFirst ( ) ; do { long regionId = c . getLong ( 0 ) ; ArrayList < ObaRegionElement . Bounds > bounds = results . get ( regionId ) ; ObaRegionElement . Bounds b = new ObaRegionElement . Bounds ( c . getDouble ( 1 ) , c . getDouble ( 2 ) , c . getDouble ( 3 ) , c . getDouble ( 4 ) ) ; if ( bounds != null ) { bounds . add ( b ) ; } else { bounds = new ArrayList < ObaRegionElement . Bounds > ( ) ; bounds . add ( b ) ; results . put ( regionId , bounds ) ; } } while ( c . moveToNext ( ) ); return results ; } finally { if ( c != null ) { c . close ( ) ; } } }
private static HashMap < Long , ArrayList < ObaRegionElement . Open311Server > > getOpen311ServersFromProvider ( Context context ) { Cursor c = null ; try { final String [] PROJECTION = { ObaContract . RegionOpen311Servers . REGION_ID , ObaContract . RegionOpen311Servers . JURISDICTION , ObaContract . RegionOpen311Servers . API_KEY , ObaContract . RegionOpen311Servers . BASE_URL } ; HashMap < Long , ArrayList < ObaRegionElement . Open311Server > > results = new HashMap < Long , ArrayList < ObaRegionElement . Open311Server > > ( ) ; ContentResolver cr = context . getContentResolver ( ) ; c = cr . query ( ObaContract . RegionOpen311Servers . CONTENT_URI , PROJECTION , null , null , null ) ; if ( c == null ) { return results ; } if ( c . getCount ( ) == 0 ) { c . close ( ) ; return results ; } c . moveToFirst ( ) ; do { long regionId = c . getLong ( 0 ) ; ArrayList < ObaRegionElement . Open311Server > open311Servers = results . get ( regionId ) ; ObaRegionElement . Open311Server b = new ObaRegionElement . Open311Server ( c . getString ( 1 ) , c . getString ( 2 ) , c . getString ( 3 ) ) ; if ( open311Servers != null ) { open311Servers . add ( b ) ; } else { open311Servers = new ArrayList < ObaRegionElement . Open311Server > ( ) ; open311Servers . add ( b ) ; results . put ( regionId , open311Servers ) ; } } while ( c . moveToNext ( ) ); return results ; } finally { if ( c != null ) { c . close ( ) ; } } }
private synchronized static ArrayList < ObaRegion > getRegionsFromServer ( Context context ) { ObaRegionsResponse response = ObaRegionsRequest . newRequest ( context ) . call ( ) ; return new ArrayList < ObaRegion > ( Arrays . asList ( response . getRegions ( ) ) ) ; }
public static ArrayList < ObaRegion > getRegionsFromResources ( Context context ) { final Uri . Builder builder = new Uri . Builder ( ) ; builder . scheme ( ContentResolver . SCHEME_ANDROID_RESOURCE ) ; builder . authority ( context . getPackageName ( ) ) ; builder . path ( Integer . toString ( R . raw . regions_v3 ) ) ; ObaRegionsResponse response = ObaRegionsRequest . newRequest ( context , builder . build ( ) ) . call ( ) ; return new ArrayList < ObaRegion > ( Arrays . asList ( response . getRegions ( ) ) ) ; }
public static ObaRegion getRegionFromBuildFlavor ( ) { final int regionId = Integer . MAX_VALUE ; ObaRegionElement . Bounds [] boundsArray = new ObaRegionElement . Bounds [ 1 ] ; ObaRegionElement . Bounds bounds = new ObaRegionElement . Bounds ( BuildConfig . FIXED_REGION_BOUNDS_LAT , BuildConfig . FIXED_REGION_BOUNDS_LON , BuildConfig . FIXED_REGION_BOUNDS_LAT_SPAN , BuildConfig . FIXED_REGION_BOUNDS_LON_SPAN ) ; boundsArray [ 0 ] = bounds ; ObaRegionElement . Open311Server [] open311Array = new ObaRegionElement . Open311Server [ 1 ] ; ObaRegionElement . Open311Server open311Server ; if ( BuildConfig . FIXED_REGION_OPEN311_BASE_URL != null ) { open311Server = new ObaRegionElement . Open311Server ( BuildConfig . FIXED_REGION_OPEN311_JURISDICTION_ID , BuildConfig . FIXED_REGION_OPEN311_API_KEY , BuildConfig . FIXED_REGION_OPEN311_BASE_URL ) ; open311Array [ 0 ] = open311Server ; } else { open311Array = null ; } ObaRegionElement region = new ObaRegionElement ( regionId , BuildConfig . FIXED_REGION_NAME , true , BuildConfig . FIXED_REGION_OBA_BASE_URL , BuildConfig . FIXED_REGION_SIRI_BASE_URL , boundsArray , open311Array , BuildConfig . FIXED_REGION_LANG , BuildConfig . FIXED_REGION_CONTACT_EMAIL , BuildConfig . FIXED_REGION_SUPPORTS_OBA_DISCOVERY_APIS , BuildConfig . FIXED_REGION_SUPPORTS_OBA_REALTIME_APIS , BuildConfig . FIXED_REGION_SUPPORTS_SIRI_REALTIME_APIS , BuildConfig . FIXED_REGION_TWITTER_URL , false , BuildConfig . FIXED_REGION_STOP_INFO_URL , BuildConfig . FIXED_REGION_OTP_BASE_URL , BuildConfig . FIXED_REGION_OTP_CONTACT_EMAIL ) ; return region ; }
public synchronized static void saveToProvider ( Context context , List < ObaRegion > regions ) { ContentResolver cr = context . getContentResolver ( ) ; cr . delete ( ObaContract . Regions . CONTENT_URI , null , null ) ; cr . delete ( ObaContract . RegionBounds . CONTENT_URI , null , null ) ; cr . delete ( ObaContract . RegionOpen311Servers . CONTENT_URI , null , null ) ; for ( ObaRegion region : regions ) { if ( ! isRegionUsable ( region ) ) { Log . d ( TAG , "Skipping insert of '" + region . getName ( ) + "' to provider..." ) ; continue; } cr . insert ( ObaContract . Regions . CONTENT_URI , toContentValues ( region ) ) ; Log . d ( TAG , "Saved region '" + region . getName ( ) + "' to provider" ) ; long regionId = region . getId ( ) ; ObaRegion . Bounds [] bounds = region . getBounds ( ) ; if ( bounds != null ) { ContentValues [] values = new ContentValues [ bounds . length ] ; for ( int i = 0 ; i < bounds . length ; ++ i ) { values [ i ] = toContentValues ( regionId , bounds [ i ] ) ; } cr . bulkInsert ( ObaContract . RegionBounds . CONTENT_URI , values ) ; } ObaRegion . Open311Server [] open311Servers = region . getOpen311Servers ( ) ; if ( open311Servers != null ) { ContentValues [] values = new ContentValues [ open311Servers . length ] ; for ( int i = 0 ; i < open311Servers . length ; ++ i ) { values [ i ] = toContentValues ( regionId , open311Servers [ i ] ) ; } cr . bulkInsert ( ObaContract . RegionOpen311Servers . CONTENT_URI , values ) ; } } }
private static ContentValues toContentValues ( ObaRegion region ) { ContentValues values = new ContentValues ( ) ; values . put ( ObaContract . Regions . _ID , region . getId ( ) ) ; values . put ( ObaContract . Regions . NAME , region . getName ( ) ) ; String obaUrl = region . getObaBaseUrl ( ) ; values . put ( ObaContract . Regions . OBA_BASE_URL , obaUrl != null ? obaUrl : "" ) ; String siriUrl = region . getSiriBaseUrl ( ) ; values . put ( ObaContract . Regions . SIRI_BASE_URL , siriUrl != null ? siriUrl : "" ) ; values . put ( ObaContract . Regions . LANGUAGE , region . getLanguage ( ) ) ; values . put ( ObaContract . Regions . CONTACT_EMAIL , region . getContactEmail ( ) ) ; values . put ( ObaContract . Regions . SUPPORTS_OBA_DISCOVERY , region . getSupportsObaDiscoveryApis ( ) ? 1 : 0 ) ; values . put ( ObaContract . Regions . SUPPORTS_OBA_REALTIME , region . getSupportsObaRealtimeApis ( ) ? 1 : 0 ) ; values . put ( ObaContract . Regions . SUPPORTS_SIRI_REALTIME , region . getSupportsSiriRealtimeApis ( ) ? 1 : 0 ) ; values . put ( ObaContract . Regions . TWITTER_URL , region . getTwitterUrl ( ) ) ; values . put ( ObaContract . Regions . EXPERIMENTAL , region . getExperimental ( ) ) ; values . put ( ObaContract . Regions . STOP_INFO_URL , region . getStopInfoUrl ( ) ) ; values . put ( ObaContract . Regions . OTP_BASE_URL , region . getOtpBaseUrl ( ) ) ; values . put ( ObaContract . Regions . OTP_CONTACT_EMAIL , region . getOtpContactEmail ( ) ) ; return values ; }
private static ContentValues toContentValues ( long region , ObaRegion . Bounds bounds ) { ContentValues values = new ContentValues ( ) ; values . put ( ObaContract . RegionBounds . REGION_ID , region ) ; values . put ( ObaContract . RegionBounds . LATITUDE , bounds . getLat ( ) ) ; values . put ( ObaContract . RegionBounds . LONGITUDE , bounds . getLon ( ) ) ; values . put ( ObaContract . RegionBounds . LAT_SPAN , bounds . getLatSpan ( ) ) ; values . put ( ObaContract . RegionBounds . LON_SPAN , bounds . getLonSpan ( ) ) ; return values ; }
private static ContentValues toContentValues ( long region , ObaRegion . Open311Server open311Server ) { ContentValues values = new ContentValues ( ) ; values . put ( ObaContract . RegionOpen311Servers . REGION_ID , region ) ; values . put ( ObaContract . RegionOpen311Servers . BASE_URL , open311Server . getBaseUrl ( ) ) ; values . put ( ObaContract . RegionOpen311Servers . JURISDICTION , open311Server . getJuridisctionId ( ) ) ; values . put ( ObaContract . RegionOpen311Servers . API_KEY , open311Server . getApiKey ( ) ) ; return values ; }
public SearchViewAssert ( SearchView actual ) { super( actual , SearchViewAssert .class ); }
public SearchViewAssert hasImeOptions ( int options ) { isNotNull ( ) ; int actualOptions = actual . getImeOptions ( ) ; assertThat ( actualOptions ) . overridingErrorMessage ( "Expected IME options <%s> but was <%s>." , options , actualOptions ) . isEqualTo ( options ) ; return this ; }
public SearchViewAssert hasInputType ( int type ) { isNotNull ( ) ; int actualType = actual . getInputType ( ) ; assertThat ( actualType ) . overridingErrorMessage ( "Expected input type <%s> but was <%s>." , type , actualType ) . isEqualTo ( type ) ; return this ; }
public SearchViewAssert hasMaximumWidth ( int width ) { isNotNull ( ) ; int actualWidth = actual . getMaxWidth ( ) ; assertThat ( actualWidth ) . overridingErrorMessage ( "Expected maximum width <%s> but was <%s>." , width , actualWidth ) . isEqualTo ( width ) ; return this ; }
public SearchViewAssert hasQuery ( CharSequence query ) { isNotNull ( ) ; CharSequence actualQuery = actual . getQuery ( ) ; assertThat ( actualQuery ) . overridingErrorMessage ( "Expected query <%s> but was <%s>." , query , actualQuery ) . isEqualTo ( query ) ; return this ; }
public SearchViewAssert hasQueryHint ( CharSequence hint ) { isNotNull ( ) ; CharSequence actualHint = actual . getQueryHint ( ) ; assertThat ( actualHint ) . overridingErrorMessage ( "Expected query hint <%s> but was <%s>." , hint , actualHint ) . isEqualTo ( hint ) ; return this ; }
public SearchViewAssert hasQueryHint ( int resId ) { isNotNull ( ) ; return hasQueryHint ( actual . getContext ( ) . getString ( resId ) ) ; }
public SearchViewAssert hasSuggestionsAdapter ( CursorAdapter adapter ) { isNotNull ( ) ; CursorAdapter actualAdapter = actual . getSuggestionsAdapter ( ) ; assertThat ( actualAdapter ) . overridingErrorMessage ( "Expected suggestions adapter <%s> but was <%s>." , adapter , actualAdapter ) . isSameAs ( adapter ) ; return this ; }
public SearchViewAssert isIconifiedByDefault ( ) { isNotNull ( ) ; assertThat ( actual . isIconfiedByDefault ( ) ) . overridingErrorMessage ( "Expected to be iconified by default but was not." ) . isTrue ( ) ; return this ; }
public SearchViewAssert isNotIconifiedByDefault ( ) { isNotNull ( ) ; assertThat ( actual . isIconfiedByDefault ( ) ) . overridingErrorMessage ( "Expected to not be iconified by default but was not." ) . isFalse ( ) ; return this ; }
public SearchViewAssert isIconified ( ) { isNotNull ( ) ; assertThat ( actual . isIconified ( ) ) . overridingErrorMessage ( "Expected to be iconified but was not." ) . isTrue ( ) ; return this ; }
public SearchViewAssert isNotIconified ( ) { isNotNull ( ) ; assertThat ( actual . isIconified ( ) ) . overridingErrorMessage ( "Expected to not be iconified but was not." ) . isFalse ( ) ; return this ; }
public SearchViewAssert isQueryRefinementEnabled ( ) { isNotNull ( ) ; assertThat ( actual . isQueryRefinementEnabled ( ) ) . overridingErrorMessage ( "Expected query refinement to be enabled but was disabled." ) . isTrue ( ) ; return this ; }
public SearchViewAssert isQueryRefinementDisabled ( ) { isNotNull ( ) ; assertThat ( actual . isQueryRefinementEnabled ( ) ) . overridingErrorMessage ( "Expected query refinement to be disabled but was enabled." ) . isFalse ( ) ; return this ; }
public SearchViewAssert isSubmitButtonEnabled ( ) { isNotNull ( ) ; assertThat ( actual . isSubmitButtonEnabled ( ) ) . overridingErrorMessage ( "Expected submit button to be enabled but was disabled." ) . isTrue ( ) ; return this ; }
public SearchViewAssert isSubmitButtonDisabled ( ) { isNotNull ( ) ; assertThat ( actual . isSubmitButtonEnabled ( ) ) . overridingErrorMessage ( "Expected submit button to be disabled but was enabled." ) . isFalse ( ) ; return this ; }
@ Override public void onReceive ( Context context , Intent intent ) { Log . d ( TAG , "Received alarm" ) ; ReminderUtils . startReminderService ( context , intent , TAG ) ; }
@ Override protected SimpleCursorAdapter newAdapter ( ) { return QueryUtils . StopList . newAdapter ( getActivity ( ) ) ; }
@ Override protected Uri getContentUri ( ) { return ObaContract . Stops . CONTENT_URI ; }
@ Override public void onListItemClick ( ListView l , View v , int position , long id ) { StopData stopData = getStopData ( l , position ) ; ArrivalsListActivity . Builder b = stopData . getArrivalsList ( ) ; if ( isShortcutMode ( ) ) { final Intent shortcut = UIUtils . makeShortcut ( getActivity ( ) , stopData . getUiName ( ) , b . getIntent ( ) ) ; Activity activity = getActivity ( ) ; activity . setResult ( Activity . RESULT_OK , shortcut ) ; activity . finish ( ) ; } else { b . setUpMode ( NavHelp . UP_MODE_BACK ) ; b . start ( ) ; } }
protected StopData getStopData ( ListView l , int position ) { SimpleCursorAdapter cursorAdapter = ( SimpleCursorAdapter ) l . getAdapter ( ) ; return new StopData ( cursorAdapter . getCursor ( ) , position - l . getHeaderViewsCount ( ) ) ; }
@ Override public void onCreateContextMenu ( ContextMenu menu , View v , ContextMenuInfo menuInfo ) { super. onCreateContextMenu ( menu , v , menuInfo ) ; AdapterContextMenuInfo info = ( AdapterContextMenuInfo ) menuInfo ; final TextView text = ( TextView ) info . targetView . findViewById ( R . id . stop_name ) ; menu . setHeaderTitle ( UIUtils . formatDisplayText ( text . getText ( ) . toString ( ) ) ) ; if ( isShortcutMode ( ) ) { menu . add ( 0 , CONTEXT_MENU_DEFAULT , 0 , R . string . my_context_create_shortcut ) ; } else { menu . add ( 0 , CONTEXT_MENU_DEFAULT , 0 , R . string . my_context_get_stop_info ) ; } menu . add ( 0 , CONTEXT_MENU_SHOW_ON_MAP , 0 , R . string . my_context_showonmap ) ; if ( ! isShortcutMode ( ) ) { menu . add ( 0 , CONTEXT_MENU_CREATE_SHORTCUT , 0 , R . string . my_context_create_shortcut ) ; } }
@ Override public boolean onContextItemSelected ( MenuItem item ) { AdapterContextMenuInfo info = ( AdapterContextMenuInfo ) item . getMenuInfo ( ) ; switch ( item . getItemId ( ) ) { case CONTEXT_MENU_DEFAULT : onListItemClick ( getListView ( ) , info . targetView , info . position , info . id ) ; return true ; case CONTEXT_MENU_SHOW_ON_MAP : showOnMap ( getListView ( ) , info . position ) ; return true ; case CONTEXT_MENU_CREATE_SHORTCUT : ShowcaseViewUtils . doNotShowTutorial ( ShowcaseViewUtils . TUTORIAL_STARRED_STOPS_SHORTCUT ) ; StopData stopData = getStopData ( getListView ( ) , info . position ) ; final Intent shortcutIntent = UIUtils . makeShortcut ( getActivity ( ) , stopData . uiName , stopData . getArrivalsList ( ) . getIntent ( ) ) ; shortcutIntent . setAction ( INSTALL_SHORTCUT ) ; shortcutIntent . setFlags ( 0 ) ; getActivity ( ) . sendBroadcast ( shortcutIntent ) ; return true ; default: return super. onContextItemSelected ( item ) ; } }
private void showOnMap ( ListView l , int position ) { SimpleCursorAdapter cursorAdapter = ( SimpleCursorAdapter ) l . getAdapter ( ) ; Cursor c = cursorAdapter . getCursor ( ) ; c . moveToPosition ( position - l . getHeaderViewsCount ( ) ) ; final String stopId = c . getString ( COL_ID ) ; final double lat = c . getDouble ( COL_LATITUDE ) ; final double lon = c . getDouble ( COL_LONGITUDE ) ; HomeActivity . start ( getActivity ( ) , stopId , lat , lon ) ; }
public StopData ( Cursor c , int row ) { c . moveToPosition ( row ) ; id = c . getString ( COL_ID ) ; name = c . getString ( COL_NAME ) ; dir = c . getString ( COL_DIRECTION ) ; uiName = c . getString ( COL_UI_NAME ) ; }
public String getId ( ) { return id ; }
public String getName ( ) { return name ; }
public String getDir ( ) { return dir ; }
public String getUiName ( ) { return uiName ; }
public ArrivalsListActivity . Builder getArrivalsList ( ) { return new ArrivalsListActivity . Builder ( getActivity ( ) , id ) . setStopName ( name ) . setStopDirection ( dir ) ; }
ObaDefaultConnection ( Uri uri ) throws IOException { Log . d ( TAG , uri . toString ( ) ) ; URL url = new URL ( uri . toString ( ) ) ; mConnection = ( HttpURLConnection ) url . openConnection ( ) ; mConnection . setReadTimeout ( 30 * 1000 ) ; }
@ Override public void disconnect ( ) { mConnection . disconnect ( ) ; }
@ Override public Reader get ( ) IOException { return new InputStreamReader ( new BufferedInputStream ( mConnection . getInputStream ( ) , 8 * 1024 ) ) ; }
@ Override public Reader post ( String string ) throws IOException { byte [] data = string . getBytes ( ) ; mConnection . setDoOutput ( true ) ; mConnection . setFixedLengthStreamingMode ( data . length ) ; mConnection . setRequestProperty ( "Content-Type" , "application/x-www-form-urlencoded" ) ; OutputStream stream = mConnection . getOutputStream ( ) ; stream . write ( data ) ; stream . flush ( ) ; stream . close ( ) ; return new InputStreamReader ( new BufferedInputStream ( mConnection . getInputStream ( ) , 8 * 1024 ) ) ; }
@ Override public int getResponseCode ( ) IOException { return mConnection . getResponseCode ( ) ; }
@ Override public void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; Intent myIntent = getIntent ( ) ; if ( Intent . ACTION_CREATE_SHORTCUT . equals ( myIntent . getAction ( ) ) ) { setResult ( RESULT_OK , getShortcutIntent ( ) ) ; } finish ( ) ; }
private Intent getShortcutIntent ( ) { final Uri uri = MyTabActivityBase . getDefaultTabUri ( MyRecentRoutesFragment . TAB_NAME ) ; return UIUtils . makeShortcut ( this , getString ( R . string . recent_routes_shortcut ) , new Intent ( this , MyRoutesActivity .class ) . setData ( uri ) ) ; }
@ Override protected void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; try { final ViewConfiguration config = ViewConfiguration . get ( this ) ; final Field menuKeyField = ViewConfiguration .class . getDeclaredField ( "sHasPermanentMenuKey" ) ; if ( menuKeyField != null ) { menuKeyField . setAccessible ( true ) ; menuKeyField . setBoolean ( config , false ) ; } } catch ( Exception ex ) { } App . component ( ) . inject ( this ) ; }
@ Override protected void onResume ( ) { super. onResume ( ) ; final String uuid = getIntent ( ) . getStringExtra ( EXTRA_KEY_UUID ) ; if ( uuid != null ) { final Pass passbookForId = passStore . getPassbookForId ( uuid ) ; passStore . setCurrentPass ( passbookForId ) ; } currentPass = passStore . getCurrentPass ( ) ; if ( currentPass == null ) { tracker . trackException ( "pass not present in " + this , false ) ; finish ( ) ; } configureActionBar ( ) ; if ( settings . isAutomaticLightEnabled ( ) ) { setToFullBrightness ( ) ; } }
protected void configureActionBar ( ) { if ( getSupportActionBar ( ) != null ) { getSupportActionBar ( ) . setHomeButtonEnabled ( true ) ; getSupportActionBar ( ) . setDisplayHomeAsUpEnabled ( true ) ; } }
protected void refresh ( ) {    }
@ Override public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . activity_pass_view , menu ) ; return true ; }
@ Override public boolean onPrepareOptionsMenu ( Menu menu ) { final boolean res = super. onPrepareOptionsMenu ( menu ) ; menu . findItem ( R . id . menu_light ) . setVisible ( ! fullBrightnessSet ) ; menu . findItem ( R . id . menu_print ) . setVisible ( Build . VERSION . SDK_INT >= 19 ) ; return res ; }
@ Override public boolean onOptionsItemSelected ( MenuItem item ) { if ( new PassMenuOptions ( this , currentPass ) . process ( item ) ) { return true ; } switch ( item . getItemId ( ) ) { case android . R . id . home : finish ( ) ; return true ; case R . id . menu_light : setToFullBrightness ( ) ; return true ; case R . id . install_shortcut : PassViewActivityBasePermissionsDispatcher . createShortcutWithCheck ( this ) ; return true ; case R . id . menu_update : new Thread ( new UpdateAsync ( ) ) . start ( ) ; return true ; } return super. onOptionsItemSelected ( item ) ; }
@ Override public void onRequestPermissionsResult ( int requestCode , @ NonNull String [] permissions , @ NonNull int [] grantResults ) { super. onRequestPermissionsResult ( requestCode , permissions , grantResults ) ; PassViewActivityBasePermissionsDispatcher . onRequestPermissionsResult ( this , requestCode , grantResults ) ; }
@ NeedsPermission ( "com.android.launcher.permission.INSTALL_SHORTCUT" ) public void createShortcut ( ) { final Intent intent = new Intent ( "com.android.launcher.action.INSTALL_SHORTCUT" ) ; final Intent shortcutIntent = new Intent ( ) ; shortcutIntent . putExtra ( EXTRA_KEY_UUID , currentPass . getId ( ) ) ; final ComponentName component = new ComponentName ( BuildConfig . APPLICATION_ID , BuildConfig . APPLICATION_ID + ".ui.PassViewActivity" ) ; shortcutIntent . setComponent ( component ) ; intent . putExtra ( Intent . EXTRA_SHORTCUT_INTENT , shortcutIntent ) ; intent . putExtra ( Intent . EXTRA_SHORTCUT_NAME , currentPass . getDescription ( ) ) ; intent . putExtra ( Intent . EXTRA_SHORTCUT_ICON , Bitmap . createScaledBitmap ( currentPass . getBitmap ( passStore , BITMAP_ICON ) , 128 , 128 , true ) ) ; sendBroadcast ( intent ) ; }
public static boolean mightPassBeAbleToUpdate ( Pass pass ) { return pass != null && pass . getWebServiceURL ( ) != null && pass . getPassIdent ( ) != null && pass . getSerial ( ) != null ; }
@ Override public void run ( ) { final Pass pass = currentPass ; runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { dlg = new ProgressDialog ( PassViewActivityBase .this ) ; dlg . setMessage ( getString ( R . string . downloading_new_pass_version ) ) ; dlg . show ( ) ; } } ) ; final OkHttpClient client = new OkHttpClient ( ) ; final String url = pass . getWebServiceURL ( ) + "/v1/passes/" + pass . getPassIdent ( ) + "/" + pass . getSerial ( ) ; final Request . Builder requestBuilder = new Request . Builder ( ) . url ( url ) ; requestBuilder . addHeader ( "Authorization" , "ApplePass " + pass . getAuthToken ( ) ) ; final Request request = requestBuilder . build ( ) ; final Response response ; try { response = client . newCall ( request ) . execute ( ) ; final InputStreamWithSource inputStreamWithSource = new InputStreamWithSource ( url , response . body ( ) . byteStream ( ) ) ; final InputStreamUnzipControllerSpec spec = new InputStreamUnzipControllerSpec ( inputStreamWithSource , PassViewActivityBase .this , passStore , new MyUnzipSuccessCallback ( dlg ) , new MyUnzipFailCallback ( dlg ) ) ; spec . setOverwrite ( true ) ; UnzipPassController . INSTANCE . processInputStream ( spec ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
@ Override public void run ( ) { dlg = new ProgressDialog ( PassViewActivityBase .this ) ; dlg . setMessage ( getString ( R . string . downloading_new_pass_version ) ) ; dlg . show ( ) ; }
private MyUnzipFailCallback ( final Dialog dlg ) { this . dlg = dlg ; }
@ Override public void fail ( @ NonNull final String reason ) { runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { if ( ! isFinishing ( ) ) { dlg . dismiss ( ) ; new AlertDialog . Builder ( PassViewActivityBase .this ) . setMessage ( "Could not update pass :( " + reason + ")" ) . setPositiveButton ( android . R . string . ok , null ) . show ( ) ; } } } ) ; }
@ Override public void run ( ) { if ( ! isFinishing ( ) ) { dlg . dismiss ( ) ; new AlertDialog . Builder ( PassViewActivityBase .this ) . setMessage ( "Could not update pass :( " + reason + ")" ) . setPositiveButton ( android . R . string . ok , null ) . show ( ) ; } }
private MyUnzipSuccessCallback ( final Dialog dlg ) { this . dlg = dlg ; }
@ Override public void call ( @ NonNull final String uuid ) { runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { if ( isFinishing ( ) ) { return; } dlg . dismiss ( ) ; if ( ! currentPass . getId ( ) . equals ( uuid ) ) { passStore . deletePassWithId ( currentPass . getId ( ) ) ; } final Pass newPass = passStore . getPassbookForId ( uuid ) ; passStore . setCurrentPass ( newPass ) ; currentPass = passStore . getCurrentPass ( ) ; refresh ( ) ; Snackbar . make ( getWindow ( ) . getDecorView ( ) , R . string . pass_updated , Snackbar . LENGTH_LONG ) . show ( ) ; } } ) ; }
@ Override public void run ( ) { if ( isFinishing ( ) ) { return; } dlg . dismiss ( ) ; if ( ! currentPass . getId ( ) . equals ( uuid ) ) { passStore . deletePassWithId ( currentPass . getId ( ) ) ; } final Pass newPass = passStore . getPassbookForId ( uuid ) ; passStore . setCurrentPass ( newPass ) ; currentPass = passStore . getCurrentPass ( ) ; refresh ( ) ; Snackbar . make ( getWindow ( ) . getDecorView ( ) , R . string . pass_updated , Snackbar . LENGTH_LONG ) . show ( ) ; }
private void setToFullBrightness ( ) { final Window win = getWindow ( ) ; final WindowManager . LayoutParams params = win . getAttributes ( ) ; params . screenBrightness = WindowManager . LayoutParams . BRIGHTNESS_OVERRIDE_FULL ; win . setAttributes ( params ) ; fullBrightnessSet = true ; supportInvalidateOptionsMenu ( ) ; }
@ GET ( "/news" ) void getTopStories ( Callback < List < NodeHNAPIStory > > callback );
@ GET ( "/news" ) Observable < List < NodeHNAPIStory > > getTopStories ( )
@ GET ( "/news2" ) void getTopStoriesPageTwo ( Callback < List < NodeHNAPIStory > > callback );
@ GET ( "/news2" ) Observable < List < NodeHNAPIStory > > getTopStoriesPageTwo ( )
@ GET ( "/newest" ) void getNewestStories ( Callback < List < NodeHNAPIStory > > callback );
@ GET ( "/newest" ) Observable < List < NodeHNAPIStory > > getNewestStories ( )
@ GET ( "/best" ) void getBestStories ( Callback < List < NodeHNAPIStory > > callback );
@ GET ( "/best" ) Observable < List < NodeHNAPIStory > > getBestStories ( )
@ GET ( "/show" ) Observable < List < NodeHNAPIStory > > getShowStories ( )
@ GET ( "/shownew" ) Observable < List < NodeHNAPIStory > > getShowNewStories ( )
@ GET ( "/ask" ) Observable < List < NodeHNAPIStory > > getAskStories ( )
@ GET ( "/item/{itemId}" ) void getItemDetails ( @ Path ( "itemId" ) long itemId , Callback < NodeHNAPIStoryDetail > callback );
@ GET ( "/item/{itemId}" ) Observable < NodeHNAPIStoryDetail > getItemDetails ( @ Path ( "itemId" ) long itemId );
@ Override public void afterProjectsRead ( MavenSession session ) throws MavenExecutionException { log . debug ( "" ) ; log . debug ( "ClasspathModifierLifecycleParticipant#afterProjectsRead - start" ) ; log . debug ( "" ) ; log . debug ( "CurrentProject=" + session . getCurrentProject ( ) ) ; final List < MavenProject > projects = session . getProjects ( ) ; final DependencyResolver dependencyResolver = new DependencyResolver ( log , dependencyGraphBuilder ) ; final ArtifactResolverHelper artifactResolverHelper = new ArtifactResolverHelper ( artifactResolver , log ) ; for ( MavenProject project : projects ) { log . debug ( "" ) ; log . debug ( "project=" + project . getArtifact ( ) ) ; if ( ! AndroidExtension . isAndroidPackaging ( project . getPackaging ( ) ) ) { continue; } final String unpackedLibsFolder = getMojoConfigurationParameter ( project , UNPACKED_LIBS_FOLDER_PARAM , null ) ; final UnpackedLibHelper helper = new UnpackedLibHelper ( artifactResolverHelper , project , log , unpackedLibsFolder == null ? null : new File ( unpackedLibsFolder ) ) ; final Set < Artifact > artifacts ; final ClassLoader projectClassLoader = ( project . getClassRealm ( ) != null ) ? project . getClassRealm ( ) : Thread . currentThread ( ) . getContextClassLoader ( ) ; final ClassLoader originalClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; try { Thread . currentThread ( ) . setContextClassLoader ( projectClassLoader ) ; artifacts = dependencyResolver . getProjectDependenciesFor ( project , session ) ; } catch ( DependencyGraphBuilderException e ) { continue; } finally { Thread . currentThread ( ) . setContextClassLoader ( originalClassLoader ) ; } boolean includeFromAar = getMojoConfigurationParameter ( project , INCLUDE_FROM_AAR_PARAM , INCLUDE_FROM_AAR_DEFAULT ) ; boolean includeFromApklib = getMojoConfigurationParameter ( project , INCLUDE_FROM_APKLIB_PARAM , INCLUDE_FROM_APKLIB_DEFAULT ) ; boolean disableConflictingDependenciesWarning = getMojoConfigurationParameter ( project , DISABLE_CONFLICTING_DEPENDENCIES_WARNING_PARAM , DISABLE_CONFLICTING_DEPENDENCIES_WARNING_DEFAULT ) ; log . debug ( "projects deps: : " + artifacts ) ; if ( ! disableConflictingDependenciesWarning ) { ProvidedDependencyChecker checker = new ProvidedDependencyChecker ( ) ; checker . checkProvidedDependencies ( artifacts , log ) ; } for ( Artifact artifact : artifacts ) { final String type = artifact . getType ( ) ; if ( type . equals ( AndroidExtension . AAR ) ) { addClassesToClasspath ( helper , project , artifact ) ; if ( includeFromAar ) { addLibsJarsToClassPath ( helper , project , artifact ) ; } } else if ( type . equals ( AndroidExtension . APK ) ) { addClassesToClasspath ( helper , project , artifact ) ; } else if ( type . equals ( AndroidExtension . APKLIB ) ) { if ( includeFromApklib ) { addLibsJarsToClassPath ( helper , project , artifact ) ; } } } } if ( addedJarFromLibs ) { log . warn ( "Transitive dependencies should really be provided by Maven dependency management.\n" + "          We suggest you to ask the above providers to package their component properly.\n" + "          Things may break at compile and/or runtime due to multiple copies of incompatible libraries." ) ; } log . debug ( "" ) ; log . debug ( "ClasspathModifierLifecycleParticipant#afterProjectsRead - finish" ) ; }
private String getMojoConfigurationParameter ( MavenProject project , String name , String defaultValue ) { String value = PomConfigurationHelper . getPluginConfigParameter ( project , name , defaultValue ) ; log . debug ( name + " set to " + value ) ; return value ; }
private boolean getMojoConfigurationParameter ( MavenProject project , String name , boolean defaultValue ) { return Boolean . valueOf ( getMojoConfigurationParameter ( project , name , Boolean . toString ( defaultValue ) ) ) ; }
private void addLibsJarsToClassPath ( UnpackedLibHelper helper , MavenProject project , Artifact artifact )        throws MavenExecutionException { try { final File unpackLibFolder = helper . getUnpackedLibFolder ( artifact ) ; final File artifactFile = helper . getArtifactToFile ( artifact ) ; ZipFile zipFile = new ZipFile ( artifactFile ) ; Enumeration enumeration = zipFile . entries ( ) ; while ( enumeration . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) enumeration . nextElement ( ) ; String entryName = entry . getName ( ) ; if ( Pattern . matches ( "^libs/.+\\.jar$" , entryName ) ) { final File libsJarFile = new File ( unpackLibFolder , entryName ) ; log . warn ( "Adding jar from libs folder to classpath: " + libsJarFile ) ; if ( ! libsJarFile . getParentFile ( ) . exists ( ) ) { libsJarFile . getParentFile ( ) . mkdirs ( ) ; } libsJarFile . createNewFile ( ) ; final Dependency dependency = createSystemScopeDependency ( artifact , libsJarFile , libsJarFile . getName ( ) ) ; project . getModel ( ) . addDependency ( dependency ) ; addedJarFromLibs = true ; } } } catch ( MojoExecutionException e ) { log . debug ( "Error extract jars" ) ; } catch ( ZipException e ) { log . debug ( "Error" ) ; } catch ( IOException e ) { log . debug ( "Error" ) ; } }
private void addClassesToClasspath ( UnpackedLibHelper helper , MavenProject project , Artifact artifact )        throws MavenExecutionException { final File classesJar = helper . getUnpackedClassesJar ( artifact ) ; log . debug ( "Adding to classpath : " + classesJar ) ; if ( ! classesJar . exists ( ) ) { classesJar . getParentFile ( ) . mkdirs ( ) ; try { final ZipOutputStream zipOutputStream = new ZipOutputStream ( new FileOutputStream ( classesJar ) ) ; zipOutputStream . putNextEntry ( new ZipEntry ( "dummy" ) ) ; zipOutputStream . close ( ) ; log . debug ( "Created dummy " + classesJar . getName ( ) + " exist=" + classesJar . exists ( ) ) ; } catch ( IOException e ) { throw new MavenExecutionException ( "Could not add " + classesJar . getName ( ) + " as dependency" , e ) ; } } final Dependency dependency = createSystemScopeDependency ( artifact , classesJar , null ) ; final Dependency providedJar = findProvidedDependencies ( dependency , project ) ; if ( providedJar != null ) { project . getModel ( ) . removeDependency ( providedJar ) ; } project . getModel ( ) . addDependency ( dependency ) ; }
private Dependency createSystemScopeDependency ( Artifact artifact , File location , String suffix ) { String artifactId = artifact . getArtifactId ( ) ; if ( suffix != null ) { artifactId += "_" + suffix ; } final Dependency dependency = new Dependency ( ) ; dependency . setGroupId ( artifact . getGroupId ( ) ) ; dependency . setArtifactId ( artifactId ) ; dependency . setVersion ( artifact . getBaseVersion ( ) ) ; dependency . setScope ( Artifact . SCOPE_SYSTEM ) ; dependency . setSystemPath ( location . getAbsolutePath ( ) ) ; return dependency ; }
private Dependency findProvidedDependencies ( Dependency dexDependency , MavenProject project ) { for ( Dependency dependency : project . getDependencies ( ) ) { if ( dependency . getScope ( ) . equals ( Artifact . SCOPE_PROVIDED ) ) { if ( dependency . getArtifactId ( ) . equals ( dexDependency . getArtifactId ( ) ) && dependency . getGroupId ( ) . equals ( dexDependency . getGroupId ( ) ) && dependency . getType ( ) . equals ( dexDependency . getType ( ) ) && dependency . getVersion ( ) . equals ( dexDependency . getVersion ( ) ) ) { return dependency ; } } } return null ; }
public LoaderAssert ( Loader actual ) { super( actual , LoaderAssert .class ); }
protected ObaTripDetailsRequest ( Uri uri ) { super( uri ); }
public Builder ( Context context , String tripId ) { super( context , getPathWithId ( "/trip-details/" , tripId ) ); }
public Builder setIncludeTrip ( boolean includeTrip ) { mBuilder . appendQueryParameter ( "includeTrip" , String . valueOf ( includeTrip ) ) ; return this ; }
public Builder setIncludeSchedule ( boolean includeSchedule ) { mBuilder . appendQueryParameter ( "includeSchedule" , String . valueOf ( includeSchedule ) ) ; return this ; }
public Builder setIncludeStatus ( boolean includeStatus ) { mBuilder . appendQueryParameter ( "includeStatus" , String . valueOf ( includeStatus ) ) ; return this ; }
public ObaTripDetailsRequest build ( ) { return new ObaTripDetailsRequest ( buildUri ( ) ) ; }
public static ObaTripDetailsRequest newRequest ( Context context , String tripId ) { return new Builder ( context , tripId ) . build ( ) ; }
@ Override public ObaTripDetailsResponse call ( ) { return call ( ObaTripDetailsResponse .class ) ; }
@ Override public String toString ( ) { return "ObaTripDetailsRequest [mUri=" + mUri + "]" ; }
protected ObaReportProblemWithTripRequest ( Uri uri ) { super( uri ); }
public Builder ( Context context , String tripId ) { super( context , BASE_PATH + "/report-problem-with-trip.json" ); mBuilder . appendQueryParameter ( "tripId" , tripId ) ; }
public Builder setStopId ( String stopId ) { mBuilder . appendQueryParameter ( "stopId" , stopId ) ; return this ; }
public Builder setServiceDate ( long serviceDate ) { mBuilder . appendQueryParameter ( "serviceDate" , String . valueOf ( serviceDate ) ) ; return this ; }
public Builder setVehicleId ( String vehicleId ) { mBuilder . appendQueryParameter ( "vehicleId" , vehicleId ) ; return this ; }
public Builder setCode ( String code ) { mBuilder . appendQueryParameter ( "code" , code ) ; String data = String . format ( "{\"code\":\"%s\"}" , code ) ; mBuilder . appendQueryParameter ( "data" , data ) ; return this ; }
public Builder setUserComment ( String comment ) { mBuilder . appendQueryParameter ( "userComment" , comment ) ; return this ; }
public Builder setUserLocation ( double lat , double lon ) { mBuilder . appendQueryParameter ( "userLat" , String . valueOf ( lat ) ) ; mBuilder . appendQueryParameter ( "userLon" , String . valueOf ( lon ) ) ; return this ; }
public Builder setUserLocationAccuracy ( int meters ) { mBuilder . appendQueryParameter ( "userLocationAccuracy" , String . valueOf ( meters ) ) ; return this ; }
public Builder setUserOnVehicle ( boolean onVehicle ) { mBuilder . appendQueryParameter ( "userOnVehicle" , String . valueOf ( onVehicle ) ) ; return this ; }
public Builder setUserVehicleNumber ( String vehicleNumber ) { mBuilder . appendQueryParameter ( "userVehicleNumber" , vehicleNumber ) ; return this ; }
public ObaReportProblemWithTripRequest build ( ) { return new ObaReportProblemWithTripRequest ( buildUri ( ) ) ; }
@ Override public ObaReportProblemWithTripResponse call ( ) { return call ( ObaReportProblemWithTripResponse .class ) ; }
@ Override public String toString ( ) { return "ObaReportProblemWithTripRequest [mUri=" + mUri + "]" ; }
@ Before public void setUp ( ) Exception { MockitoAnnotations . initMocks ( this ) ; }
@ Test public void testShouldFailForBrokenPass ( ) { try { final InputStream inputStream = InstrumentationRegistry . getInstrumentation ( ) . getContext ( ) . getResources ( ) . getAssets ( ) . open ( "passes/broken/fail.pkpass" ) ; final InputStreamWithSource inputStreamWithSource = new InputStreamWithSource ( "none" , inputStream ) ; final InputStreamUnzipControllerSpec spec = new InputStreamUnzipControllerSpec ( inputStreamWithSource , InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) , passStore , successCallback , failCallback ) ; UnzipPassController . INSTANCE . processInputStream ( spec ) ; verify ( successCallback , never ( ) ) . call ( any ( String .class ) ) ; verify ( failCallback ) . fail ( any ( String .class ) ) ; } catch ( Exception e ) { fail ( "should be able to load file" ) ; } }
protected ObaRegionsRequest ( Uri uri ) { super( uri ); }
public Builder ( Context context ) {        }
public Builder ( Context context , Uri uri ) { URI = uri ; }
public ObaRegionsRequest build ( ) { return new ObaRegionsRequest ( URI ) ; }
public static ObaRegionsRequest newRequest ( Context context ) { return new Builder ( context ) . build ( ) ; }
public static ObaRegionsRequest newRequest ( Context context , Uri uri ) { return new Builder ( context , uri ) . build ( ) ; }
@ Override public ObaRegionsResponse call ( ) { if ( mUri . getScheme ( ) . equals ( ContentResolver . SCHEME_ANDROID_RESOURCE ) ) { return getRegionFromResource ( ) ; } else { return call ( ObaRegionsResponse .class ) ; } }
@ Override public String toString ( ) { return "ObaRegionsRequest [mUri=" + mUri + "]" ; }
private ObaRegionsResponse getRegionFromResource ( ) { ObaRegionsResponse response = null ; InputStream is = Application . get ( ) . getApplicationContext ( ) . getResources ( ) . openRawResource ( R . raw . regions_v3 ) ; ObaApi . SerializationHandler handler = ObaApi . getSerializer ( ObaRegionsResponse .class ) ; response = handler . deserialize ( new InputStreamReader ( is ) , ObaRegionsResponse .class ) ; if ( response == null ) { response = handler . createFromError ( ObaRegionsResponse .class , ObaApi . OBA_INTERNAL_ERROR , "Json error" ) ; } return response ; }
public HelloAndroidActivityTest ( ) { super( HelloAndroidActivity .class ); }
public void testActivity_not_null ( ) { assertNotNull ( getActivity ( ) ) ; }
@ UiThreadTest public void testActivity_shouldUseCustomComputerUsingEasyMock ( ) Exception { final int EXPECTED_RESULT = 1 ; HelloAndroidActivity activityUnderTest = getActivity ( ) ; Computer mockComputer = EasyMock . createMock ( DummyComputer .class ) ; EasyMock . expect ( mockComputer . getResult ( ) ) . andReturn ( EXPECTED_RESULT ) ; activityUnderTest . setComputer ( mockComputer ) ; EasyMock . replay ( mockComputer ) ; Button button = ( Button ) activityUnderTest . findViewById ( R . id . button_main ) ; button . performClick ( ) ; EasyMock . verify ( mockComputer ) ; TextView textViewHello = ( TextView ) activityUnderTest . findViewById ( R . id . textview_hello ) ; String textViewHelloString = textViewHello . getText ( ) . toString ( ) ; assertEquals ( textViewHelloString , String . valueOf ( EXPECTED_RESULT ) ) ; }
@ UiThreadTest public void testActivity_shouldUseCustomComputerUsingMockito ( ) Exception { final int EXPECTED_RESULT = 1 ; HelloAndroidActivity activityUnderTest = getActivity ( ) ; Computer mockComputer = Mockito . mock ( Computer .class ) ; Mockito . when ( mockComputer . getResult ( ) ) . thenReturn ( EXPECTED_RESULT ) ; activityUnderTest . setComputer ( mockComputer ) ; Button button = ( Button ) activityUnderTest . findViewById ( R . id . button_main ) ; button . performClick ( ) ; Mockito . verify ( mockComputer , Mockito . times ( 1 ) ) . getResult ( ) ; TextView textViewHello = ( TextView ) activityUnderTest . findViewById ( R . id . textview_hello ) ; String textViewHelloString = textViewHello . getText ( ) . toString ( ) ; assertEquals ( textViewHelloString , String . valueOf ( EXPECTED_RESULT ) ) ; }
public Support4DemosSampleIT ( MavenRuntimeBuilder builder ) throws Exception { this . mavenRuntime = builder . build ( ) ; }
@ Test public void buildDeployAndRun ( ) Exception { File basedir = resources . getBasedir ( "support4demos" ) ; MavenExecutionResult result = mavenRuntime . forProject ( basedir ) . execute ( "clean" , PluginInfo . getQualifiedGoal ( "undeploy" ) , "install" , PluginInfo . getQualifiedGoal ( "deploy" ) , PluginInfo . getQualifiedGoal ( "run" ) ) ; result . assertErrorFreeLog ( ) ; result . assertLogText ( "Successfully installed" ) ; result . assertLogText ( "Attempting to start com.example.android.supportv4/com.example.android.supportv4.Support4Demos" ) ; }
@ Override protected void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_actionbarcontrollistview ) ; ObservableListView listView = ( ObservableListView ) findViewById ( R . id . list ) ; listView . setScrollViewCallbacks ( this ) ; setDummyData ( listView ) ; listView . setOnScrollListener ( new AbsListView . OnScrollListener ( ) { @ Override public void onScrollStateChanged ( AbsListView view , int scrollState ) { Log . v ( TAG , "onScrollStateChanged: " + scrollState ) ; } @ Override public void onScroll ( AbsListView view , int firstVisibleItem , int visibleItemCount , int totalItemCount ) { Log . v ( TAG , "onScroll: firstVisibleItem: " + firstVisibleItem + " visibleItemCount: " + visibleItemCount + " totalItemCount: " + totalItemCount ) ; } } ) ; }
@ Override public void onScrollStateChanged ( AbsListView view , int scrollState ) { Log . v ( TAG , "onScrollStateChanged: " + scrollState ) ; }
@ Override public void onScroll ( AbsListView view , int firstVisibleItem , int visibleItemCount , int totalItemCount ) { Log . v ( TAG , "onScroll: firstVisibleItem: " + firstVisibleItem + " visibleItemCount: " + visibleItemCount + " totalItemCount: " + totalItemCount ) ; }
@ Override public void onScrollChanged ( int scrollY , boolean firstScroll , boolean dragging ) {    }
@ Override public void onDownMotionEvent ( ) {    }
@ Override public void onUpOrCancelMotionEvent ( ScrollState scrollState ) { ActionBar ab = getSupportActionBar ( ) ; if ( ab == null ) { return; } if ( scrollState == ScrollState . UP ) { if ( ab . isShowing ( ) ) { ab . hide ( ) ; } } else if ( scrollState == ScrollState . DOWN ) { if ( ! ab . isShowing ( ) ) { ab . show ( ) ; } } }
public ListViewAssert ( ListView actual ) { super( actual , ListViewAssert .class ); }
@ Override public void onAttach ( Activity activity ) { super. onAttach ( activity ) ; GoogleApiAvailability api = GoogleApiAvailability . getInstance ( ) ; if ( api . isGooglePlayServicesAvailable ( getActivity ( ) ) == ConnectionResult . SUCCESS ) { mGoogleApiClient = LocationUtils . getGoogleApiClientWithCallbacks ( getActivity ( ) ) ; mGoogleApiClient . connect ( ) ; } try { mCallback = ( ReportProblemFragmentCallback ) activity ; } catch ( ClassCastException e ) { throw new ClassCastException ( "ReportProblemFragmentCallback should be implemented" + " in parent activity" ) ; } }
@ Override public void onActivityCreated ( Bundle savedInstanceState ) { super. onActivityCreated ( savedInstanceState ) ; setHasOptionsMenu ( true ) ; }
@ Override public View onCreateView ( LayoutInflater inflater , ViewGroup root , Bundle savedInstanceState ) { if ( root == null ) { return null ; } return inflater . inflate ( getLayoutId ( ) , null ) ; }
@ Override public void onStart ( ) { super. onStart ( ) ; if ( mGoogleApiClient != null && ! mGoogleApiClient . isConnected ( ) ) { mGoogleApiClient . connect ( ) ; } }
@ Override public void onStop ( ) { if ( mGoogleApiClient != null && mGoogleApiClient . isConnected ( ) ) { mGoogleApiClient . disconnect ( ) ; } super. onStop ( ) ; }
@ Override public void onCreateOptionsMenu ( Menu menu , MenuInflater inflater ) { inflater . inflate ( R . menu . report_problem_options , menu ) ; }
@ Override public boolean onOptionsItemSelected ( MenuItem item ) { final int id = item . getItemId ( ) ; if ( id == R . id . report_problem_send ) { sendReport ( ) ; } return false ; }
protected boolean isReportArgumentsValid ( ) { String code = SPINNER_TO_CODE [ mCodeView . getSelectedItemPosition ( ) ] ; return code != null ; }
protected void sendReport ( ) { UIUtils . showProgress ( this , true ) ; getLoaderManager ( ) . restartLoader ( REPORT_LOADER , getArguments ( ) , this ) ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . SUBMIT . toString ( ) , getString ( R . string . analytics_action_problem ) , getString ( R . string . analytics_label_report_problem ) ) ; if ( mCallback != null ) { mCallback . onSendReport ( ) ; } }
@ Override public Loader < ObaResponse > onCreateLoader ( int id , Bundle args ) { return createLoader ( args ) ; }
@ Override public void onLoadFinished ( Loader < ObaResponse > loader , ObaResponse response ) { UIUtils . showProgress ( this , false ) ; if ( ( response != null ) && ( response . getCode ( ) == ObaApi . OBA_OK ) ) { mGoBackHandler . postDelayed ( mGoBack , 100 ) ; } else { Toast . makeText ( getActivity ( ) , R . string . report_problem_error , Toast . LENGTH_LONG ) . show ( ) ; } }
@ Override public void onLoaderReset ( Loader < ObaResponse > loader ) { UIUtils . showProgress ( this , false ) ; }
public void run ( ) { getActivity ( ) . getSupportFragmentManager ( ) . popBackStack ( ) ; }
public ReportLoader ( Context context , Callable < ? extends ObaResponse > request ) { super( context ); mRequest = request ; }
@ Override public void onStartLoading ( ) { forceLoad ( ) ; }
@ Override public ObaResponse loadInBackground ( ) { try { return mRequest . call ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; }
protected abstract int getLayoutId ( )
protected abstract ReportLoader createLoader ( Bundle args );
protected AbstractListViewAssert ( A actual , Class < S > selfType ) { super( actual , selfType ); }
public S hasDivider ( Drawable divider ) { isNotNull ( ) ; Drawable actualDivider = actual . getDivider ( ) ; assertThat ( actualDivider ) . overridingErrorMessage ( "Expected divider <%s> but was <%s>." , divider , actualDivider ) . isSameAs ( divider ) ; return myself ; }
public S hasDividerHeight ( int height ) { isNotNull ( ) ; int actualHeight = actual . getDividerHeight ( ) ; assertThat ( actualHeight ) . overridingErrorMessage ( "Expected divider height <%s> but was <%s>." , height , actualHeight ) . isEqualTo ( height ) ; return myself ; }
public S hasFooterViewsCount ( int count ) { isNotNull ( ) ; int actualCount = actual . getFooterViewsCount ( ) ; assertThat ( actualCount ) . overridingErrorMessage ( "Expected footer views count <%s> but was <%s>." , count , actualCount ) . isEqualTo ( count ) ; return myself ; }
public S hasHeaderViewsCount ( int count ) { isNotNull ( ) ; int actualCount = actual . getHeaderViewsCount ( ) ; assertThat ( actualCount ) . overridingErrorMessage ( "Expected header views count <%s> but was <%s>." , count , actualCount ) . isEqualTo ( count ) ; return myself ; }
@ TargetApi ( GINGERBREAD ) public S hasOverscrollFooter ( Drawable footer ) { isNotNull ( ) ; Drawable actualFooter = actual . getOverscrollFooter ( ) ; assertThat ( actualFooter ) . overridingErrorMessage ( "Expected overscroll footer <%s> but was <%s>." , footer , actualFooter ) . isSameAs ( footer ) ; return myself ; }
@ TargetApi ( GINGERBREAD ) public S hasOverscrollHeader ( Drawable header ) { isNotNull ( ) ; Drawable actualHeader = actual . getOverscrollHeader ( ) ; assertThat ( actualHeader ) . overridingErrorMessage ( "Expected overscroll header <%s> but was <%s>." , header , actualHeader ) . isSameAs ( header ) ; return myself ; }
@ TargetApi ( KITKAT ) public S hasFooterDividersEnabled ( ) { isNotNull ( ) ; assertThat ( actual . areFooterDividersEnabled ( ) ) . overridingErrorMessage ( "Expected to have footer dividers enabled but were not." ) . isTrue ( ) ; return myself ; }
@ TargetApi ( KITKAT ) public S hasFooterDividersDisabled ( ) { isNotNull ( ) ; assertThat ( actual . areFooterDividersEnabled ( ) ) . overridingErrorMessage ( "Expected to have footer dividers disabled but were not." ) . isFalse ( ) ; return myself ; }
@ TargetApi ( KITKAT ) public S hasHeaderDividersEnabled ( ) { isNotNull ( ) ; assertThat ( actual . areHeaderDividersEnabled ( ) ) . overridingErrorMessage ( "Expected to have header dividers enabled but were not." ) . isTrue ( ) ; return myself ; }
@ TargetApi ( KITKAT ) public S hasHeaderDividersDisabled ( ) { isNotNull ( ) ; assertThat ( actual . areHeaderDividersEnabled ( ) ) . overridingErrorMessage ( "Expected to have header dividers disabled but were not." ) . isFalse ( ) ; return myself ; }
public SdkTestSupport ( ) { Assert . assertNotNull ( "For running the tests, you must have environment variable ANDROID_HOME set to a valid Android SDK 25 directory." , env_ANDROID_HOME ) ; sdk_with_platform_default = new AndroidSdk ( new File ( env_ANDROID_HOME ) , "25" , "25.0.2" ) ; }
public String getEnv_ANDROID_HOME ( ) { return env_ANDROID_HOME ; }
public AndroidSdk getSdk_with_platform_default ( ) { return sdk_with_platform_default ; }
public GPUImageSharpenFilter ( ) { this( 0.0f ); }
public GPUImageSharpenFilter ( final float sharpness ) { super( SHARPEN_VERTEX_SHADER , SHARPEN_FRAGMENT_SHADER ); mSharpness = sharpness ; }
@ Override public void onInit ( ) { super. onInit ( ) ; mSharpnessLocation = GLES20 . glGetUniformLocation ( getProgram ( ) , "sharpness" ) ; mImageWidthFactorLocation = GLES20 . glGetUniformLocation ( getProgram ( ) , "imageWidthFactor" ) ; mImageHeightFactorLocation = GLES20 . glGetUniformLocation ( getProgram ( ) , "imageHeightFactor" ) ; setSharpness ( mSharpness ) ; }
@ Override public void onOutputSizeChanged ( final int width , final int height ) { super. onOutputSizeChanged ( width , height ) ; setFloat ( mImageWidthFactorLocation , 1.0f / width ) ; setFloat ( mImageHeightFactorLocation , 1.0f / height ) ; }
public void setSharpness ( final float sharpness ) { mSharpness = sharpness ; setFloat ( mSharpnessLocation , mSharpness ) ; }
Text ( ) { value = "" ; }
public String getValue ( ) { return value ; }
AllAffectsElement ( ) { directionId = "" ; stopId = "" ; tripId = "" ; applicationId = "" ; routeId = "" ; agencyId = "" ; }
@ Override public String getDirectionId ( ) { return directionId ; }
@ Override public String getStopId ( ) { return stopId ; }
@ Override public String getTripId ( ) { return tripId ; }
@ Override public String getApplicationId ( ) { return applicationId ; }
@ Override public String getRouteId ( ) { return routeId ; }
@ Override public String getAgencyId ( ) { return agencyId ; }
ConditionDetailsElement ( ) { diversionStopIds = null ; diversionPath = null ; }
@ Override public ObaShape getDiversionPath ( ) { return diversionPath ; }
@ Override public List < String > getDiversionStopIds ( ) { return Arrays . asList ( diversionStopIds ) ; }
ConsequenceElement ( ) { condition = "" ; conditionDetails = null ; }
@ Override public String getCondition ( ) { return condition ; }
@ Override public ConditionDetails getDetails ( ) { return conditionDetails ; }
ActiveWindowElement ( ) { to = 0 ; from = 0 ; }
public long getTo ( ) { return to ; }
public long getFrom ( ) { return from ; }
ObaSituationElement ( ) { id = "" ; summary = null ; description = null ; advice = null ; reason = null ; creationTime = 0 ; allAffects = AllAffectsElement . EMPTY_ARRAY ; consequences = ConsequenceElement . EMPTY_ARRAY ; activeWindows = ActiveWindowElement . EMPTY_ARRAY ; severity = "" ; url = null ; }
@ Override public String getId ( ) { return id ; }
@ Override public String getSummary ( ) { return ( summary != null ) ? summary . getValue ( ) : null ; }
@ Override public String getDescription ( ) { return ( description != null ) ? description . getValue ( ) : null ; }
@ Override public String getAdvice ( ) { return ( advice != null ) ? advice . getValue ( ) : null ; }
@ Override public String getReason ( ) { return reason ; }
@ Override public long getCreationTime ( ) { return creationTime ; }
@ Override public AllAffects [] getAllAffects ( ) { return allAffects ; }
@ Override public Consequence [] getConsequences ( ) { return consequences ; }
@ Override public String getSeverity ( ) { return severity ; }
@ Override public ActiveWindow [] getActiveWindows ( ) { return activeWindows ; }
@ Override public String getUrl ( ) { return ( url != null ) ? url . getValue ( ) : null ; }
private AndroidUtils ( ) { throw new AssertionError ( ) ; }
public static void centerAndWrapTabsFor ( @ NotNull TabHost tabHost ) { if ( allowCenterAndWrappingTabs ( ) ) { int tabCount = tabHost . getTabWidget ( ) . getTabCount ( ) ; for ( int i = 0 ; i < tabCount ; i ++ ) { final View view = tabHost . getTabWidget ( ) . getChildTabViewAt ( i ) ; if ( view != null ) { if ( view . getLayoutParams ( ) . height > 0 ) { view . getLayoutParams ( ) . height *= 0.8 ; } final View textView = view . findViewById ( android . R . id . title ) ; if ( textView instanceof TextView ) { ( ( TextView ) textView ) . setGravity ( Gravity . CENTER ) ; ( ( TextView ) textView ) . setSingleLine ( false ) ; textView . getLayoutParams ( ) . height = ViewGroup . LayoutParams . FILL_PARENT ; textView . getLayoutParams ( ) . width = ViewGroup . LayoutParams . WRAP_CONTENT ; } } } } }
private static boolean allowCenterAndWrappingTabs ( ) { boolean result = true ; String deviceModel = Build . MODEL ; if ( deviceModel != null ) { deviceModel = deviceModel . toUpperCase ( ) ; if ( deviceModel . contains ( "M1" ) || deviceModel . contains ( "MIONE" ) || deviceModel . contains ( "MI-ONE" ) ) { result = false ; Log . i ( AndroidUtils .class . getName ( ) , "Device model doesn't support center and wrap of tabs: " + Build . MODEL ) ; } } if ( result ) { String buildId = Build . DISPLAY ; if ( buildId != null ) { buildId = buildId . toUpperCase ( ) ; if ( buildId . contains ( "MIUI" ) ) { result = false ; Log . i ( AndroidUtils .class . getName ( ) , "Device build doesn't support center and wrap of tabs: " + Build . DISPLAY ) ; } } } return result ; }
public static void addTab ( @ NotNull Context context , @ NotNull TabHost tabHost , @ NotNull String tabId , int tabCaptionId , @ NotNull Class < ? extends Activity > activityClass ) { final Intent intent = new Intent ( ) . setClass ( context , activityClass ) ; final TabHost . TabSpec tabSpec = tabHost . newTabSpec ( tabId ) . setIndicator ( context . getString ( tabCaptionId ) ) . setContent ( intent ) ; tabHost . addTab ( tabSpec ) ; }
public static int getAppVersionCode ( @ NotNull Context context , @ NotNull String appPackageName ) { try { return context . getPackageManager ( ) . getPackageInfo ( appPackageName , 0 ) . versionCode ; } catch ( PackageManager . NameNotFoundException e ) { } return - 1 ; }
public static < T > void processViewsOfType ( @ NotNull View view , @ NotNull Class < T > viewClass , @ NotNull ViewProcessor < T > viewProcessor ) { processViewsOfType0 ( view , viewClass , viewProcessor ) ; }
public static void processViews ( @ NotNull View view , @ NotNull ViewProcessor < View > viewProcessor ) { processViewsOfType0 ( view , null , viewProcessor ) ; }
private static < T > void processViewsOfType0 ( @ NotNull View view , @ Nullable Class < T > viewClass , @ NotNull ViewProcessor < T > viewProcessor ) { if ( view instanceof ViewGroup ) { final ViewGroup viewGroup = ( ViewGroup ) view ; if ( viewClass == null || ViewGroup .class . isAssignableFrom ( viewClass ) ) { viewProcessor . process ( ( T ) viewGroup ) ; } for ( int index = 0 ; index < viewGroup . getChildCount ( ) ; index ++ ) { processViewsOfType0 ( viewGroup . getChildAt ( index ) , viewClass , viewProcessor ) ; } } else if ( viewClass == null || view . getClass ( ) . isAssignableFrom ( viewClass ) ) { viewProcessor . process ( ( T ) view ) ; } }
void process ( @ NotNull V view );
public static void restartActivity ( @ NotNull Activity activity ) { final Intent intent = activity . getIntent ( ) ; Log . d ( activity . getClass ( ) . getName ( ) , "Finishing current activity!" ) ; activity . finish ( ) ; Log . d ( activity . getClass ( ) . getName ( ) , "Starting new activity!" ) ; activity . startActivity ( intent ) ; }
public PollerTask ( Context context , TaskContext taskContext , Uri uri ) { mContext = context ; mCR = mContext . getContentResolver ( ) ; mTaskContext = taskContext ; mUri = uri ; }
@ Override public void run ( ) { Cursor c = mCR . query ( mUri , ALERT_PROJECTION , null , null , null ) ; try { if ( c != null ) { while ( c . moveToNext ( ) ) { poll1 ( c ) ; } } } finally { if ( c != null ) { c . close ( ) ; } mTaskContext . taskComplete ( ) ; } }
private void poll1 ( Cursor c ) { final Uri alertUri = ObaContract . TripAlerts . buildUri ( c . getInt ( COL_ID ) ) ; final int state = c . getInt ( COL_STATE ) ; if ( state == ObaContract . TripAlerts . STATE_CANCELLED ) { return; } long now = System . currentTimeMillis ( ) ; final long startTime = c . getLong ( COL_START_TIME ) ; if ( startTime < ( now - ONE_MINUTE * 30 ) ) { ContentValues values = new ContentValues ( ) ; values . put ( ObaContract . TripAlerts . STATE , ObaContract . TripAlerts . STATE_CANCELLED ) ; mCR . update ( alertUri , values , null , null ) ; TripService . scheduleAll ( mContext ) ; return; } TripService . pollTrip ( mContext , alertUri , now + ONE_MINUTE ) ; if ( state == ObaContract . TripAlerts . STATE_SCHEDULED ) { ObaContract . TripAlerts . setState ( mContext , alertUri , ObaContract . TripAlerts . STATE_POLLING ) ; } final String tripId = c . getString ( COL_TRIP_ID ) ; final String stopId = c . getString ( COL_STOP_ID ) ; final long reminderMin = getReminderMin ( tripId , stopId ) ; ObaArrivalInfoResponse response = ObaArrivalInfoRequest . newRequest ( mContext , stopId ) . call ( ) ; ArrivalInfo arrivalInfo = null ; if ( response . getCode ( ) == ObaApi . OBA_OK ) { arrivalInfo = checkArrivals ( response , c . getString ( COL_TRIP_ID ) ) ; } if ( arrivalInfo != null ) { if ( arrivalInfo . getEta ( ) <= reminderMin ) { TripService . notifyTrip ( mContext , mUri , arrivalInfo . getNotifyText ( ) ) ; } } }
private long getReminderMin ( String tripId , String stopId ) { final Uri uri = ObaContract . Trips . buildUri ( tripId , stopId ) ; return ( long ) UIUtils . intForQuery ( mContext , uri , ObaContract . Trips . REMINDER ) ; }
private ArrivalInfo checkArrivals ( ObaArrivalInfoResponse response , String tripId ) { final ObaArrivalInfo [] arrivals = response . getArrivalInfo ( ) ; final int length = arrivals . length ; for ( int i = 0 ; i < length ; ++ i ) { ObaArrivalInfo info = arrivals [ i ] ; if ( tripId . equals ( info . getTripId ( ) ) ) { return new ArrivalInfo ( mContext , info , response . getCurrentTime ( ) , false ) ; } } return null ; }
protected AbstractLoaderAssert ( A actual , Class < S > selfType ) { super( actual , selfType ); }
public S hasId ( int id ) { isNotNull ( ) ; int actualId = actual . getId ( ) ; assertThat ( actualId ) . overridingErrorMessage ( "Expected ID <%s> but was <%s>." , id , actualId ) . isEqualTo ( id ) ; return myself ; }
public S isAbandoned ( ) { isNotNull ( ) ; assertThat ( actual . isAbandoned ( ) ) . overridingErrorMessage ( "Expected to be abandoned but was not abandoned." ) . isTrue ( ) ; return myself ; }
public S isNotAbandoned ( ) { isNotNull ( ) ; assertThat ( actual . isAbandoned ( ) ) . overridingErrorMessage ( "Expected to not be abandoned but was abandoned." ) . isFalse ( ) ; return myself ; }
public S isReset ( ) { isNotNull ( ) ; assertThat ( actual . isReset ( ) ) . overridingErrorMessage ( "Expected to be reset but was not reset." ) . isTrue ( ) ; return myself ; }
public S isNotReset ( ) { isNotNull ( ) ; assertThat ( actual . isReset ( ) ) . overridingErrorMessage ( "Expected to not be reset but was reset." ) . isFalse ( ) ; return myself ; }
public S isStarted ( ) { isNotNull ( ) ; assertThat ( actual . isStarted ( ) ) . overridingErrorMessage ( "Expected to be started but was not started." ) . isTrue ( ) ; return myself ; }
public S isNotStarted ( ) { isNotNull ( ) ; assertThat ( actual . isStarted ( ) ) . overridingErrorMessage ( "Expected to not be started but was started." ) . isFalse ( ) ; return myself ; }
@ Override protected int getLayoutResId ( ) { return R . layout . activity_toolbarcontrolscrollview ; }
@ Override protected ObservableScrollView createScrollable ( ) { return ( ObservableScrollView ) findViewById ( R . id . scrollable ) ; }
public MenuItemWrapper ( android . view . MenuItem nativeItem ) { if ( nativeItem == null ) { throw new IllegalStateException ( "Wrapped menu item cannot be null." ) ; } mNativeItem = nativeItem ; }
@ Override public int getItemId ( ) { return mNativeItem . getItemId ( ) ; }
@ Override public int getGroupId ( ) { return mNativeItem . getGroupId ( ) ; }
@ Override public int getOrder ( ) { return mNativeItem . getOrder ( ) ; }
@ Override public MenuItem setTitle ( CharSequence title ) { mNativeItem . setTitle ( title ) ; return this ; }
@ Override public MenuItem setTitle ( int title ) { mNativeItem . setTitle ( title ) ; return this ; }
@ Override public CharSequence getTitle ( ) { return mNativeItem . getTitle ( ) ; }
@ Override public MenuItem setTitleCondensed ( CharSequence title ) { mNativeItem . setTitleCondensed ( title ) ; return this ; }
@ Override public CharSequence getTitleCondensed ( ) { return mNativeItem . getTitleCondensed ( ) ; }
@ Override public MenuItem setIcon ( Drawable icon ) { mNativeItem . setIcon ( icon ) ; return this ; }
@ Override public MenuItem setIcon ( int iconRes ) { mNativeItem . setIcon ( iconRes ) ; return this ; }
@ Override public Drawable getIcon ( ) { return mNativeItem . getIcon ( ) ; }
@ Override public MenuItem setIntent ( Intent intent ) { mNativeItem . setIntent ( intent ) ; return this ; }
@ Override public Intent getIntent ( ) { return mNativeItem . getIntent ( ) ; }
@ Override public MenuItem setShortcut ( char numericChar , char alphaChar ) { mNativeItem . setShortcut ( numericChar , alphaChar ) ; return this ; }
@ Override public MenuItem setNumericShortcut ( char numericChar ) { mNativeItem . setNumericShortcut ( numericChar ) ; return this ; }
@ Override public char getNumericShortcut ( ) { return mNativeItem . getNumericShortcut ( ) ; }
@ Override public MenuItem setAlphabeticShortcut ( char alphaChar ) { mNativeItem . setAlphabeticShortcut ( alphaChar ) ; return this ; }
@ Override public char getAlphabeticShortcut ( ) { return mNativeItem . getAlphabeticShortcut ( ) ; }
@ Override public MenuItem setCheckable ( boolean checkable ) { mNativeItem . setCheckable ( checkable ) ; return this ; }
@ Override public boolean isCheckable ( ) { return mNativeItem . isCheckable ( ) ; }
@ Override public MenuItem setChecked ( boolean checked ) { mNativeItem . setChecked ( checked ) ; return this ; }
@ Override public boolean isChecked ( ) { return mNativeItem . isChecked ( ) ; }
@ Override public MenuItem setVisible ( boolean visible ) { mNativeItem . setVisible ( visible ) ; return this ; }
@ Override public boolean isVisible ( ) { return mNativeItem . isVisible ( ) ; }
@ Override public MenuItem setEnabled ( boolean enabled ) { mNativeItem . setEnabled ( enabled ) ; return this ; }
@ Override public boolean isEnabled ( ) { return mNativeItem . isEnabled ( ) ; }
@ Override public boolean hasSubMenu ( ) { return mNativeItem . hasSubMenu ( ) ; }
@ Override public SubMenu getSubMenu ( ) { if ( hasSubMenu ( ) && ( mSubMenu == null ) ) { mSubMenu = new SubMenuWrapper ( mNativeItem . getSubMenu ( ) ) ; } return mSubMenu ; }
@ Override public MenuItem setOnMenuItemClickListener ( OnMenuItemClickListener menuItemClickListener ) { mMenuItemClickListener = menuItemClickListener ; mNativeItem . setOnMenuItemClickListener ( this ) ; return this ; }
@ Override public boolean onMenuItemClick ( android . view . MenuItem item ) { if ( mMenuItemClickListener != null ) { return mMenuItemClickListener . onMenuItemClick ( this ) ; } return false ; }
@ Override public ContextMenuInfo getMenuInfo ( ) { return mNativeItem . getMenuInfo ( ) ; }
@ Override public void setShowAsAction ( int actionEnum ) { mNativeItem . setShowAsAction ( actionEnum ) ; }
@ Override public MenuItem setShowAsActionFlags ( int actionEnum ) { mNativeItem . setShowAsActionFlags ( actionEnum ) ; return this ; }
@ Override public MenuItem setActionView ( View view ) { mNativeItem . setActionView ( view ) ; return this ; }
@ Override public MenuItem setActionView ( int resId ) { mNativeItem . setActionView ( resId ) ; return this ; }
@ Override public View getActionView ( ) { return mNativeItem . getActionView ( ) ; }
@ Override public MenuItem setActionProvider ( ActionProvider actionProvider ) { mNativeItem . setActionProvider ( new ActionProviderWrapper ( actionProvider ) ) ; return this ; }
@ Override public ActionProvider getActionProvider ( ) { android . view . ActionProvider nativeProvider = mNativeItem . getActionProvider ( ) ; if ( nativeProvider != null && nativeProvider instanceof ActionProviderWrapper ) { return ( ( ActionProviderWrapper ) nativeProvider ) . unwrap ( ) ; } return null ; }
@ Override public boolean expandActionView ( ) { return mNativeItem . expandActionView ( ) ; }
@ Override public boolean collapseActionView ( ) { return mNativeItem . collapseActionView ( ) ; }
@ Override public boolean isActionViewExpanded ( ) { return mNativeItem . isActionViewExpanded ( ) ; }
@ Override public MenuItem setOnActionExpandListener ( OnActionExpandListener listener ) { mActionExpandListener = listener ; if ( mNativeActionExpandListener == null ) { mNativeActionExpandListener = new android . view . MenuItem . OnActionExpandListener ( ) { @ Override public boolean onMenuItemActionExpand ( android . view . MenuItem menuItem ) { if ( mActionExpandListener != null ) { return mActionExpandListener . onMenuItemActionExpand ( MenuItemWrapper .this ) ; } return false ; } @ Override public boolean onMenuItemActionCollapse ( android . view . MenuItem menuItem ) { if ( mActionExpandListener != null ) { return mActionExpandListener . onMenuItemActionCollapse ( MenuItemWrapper .this ) ; } return false ; } } ; mNativeItem . setOnActionExpandListener ( mNativeActionExpandListener ) ; } return this ; }
@ Override public boolean onMenuItemActionExpand ( android . view . MenuItem menuItem ) { if ( mActionExpandListener != null ) { return mActionExpandListener . onMenuItemActionExpand ( MenuItemWrapper .this ) ; } return false ; }
@ Override public boolean onMenuItemActionCollapse ( android . view . MenuItem menuItem ) { if ( mActionExpandListener != null ) { return mActionExpandListener . onMenuItemActionCollapse ( MenuItemWrapper .this ) ; } return false ; }
@ Override protected void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_actionbarcontrolwebview ) ; ObservableWebView webView = ( ObservableWebView ) findViewById ( R . id . web ) ; webView . setScrollViewCallbacks ( this ) ; webView . loadUrl ( "file: ) ; }
@ Override public void onScrollChanged ( int scrollY , boolean firstScroll , boolean dragging ) {    }
@ Override public void onDownMotionEvent ( ) {    }
@ Override public void onUpOrCancelMotionEvent ( ScrollState scrollState ) { ActionBar ab = getSupportActionBar ( ) ; if ( ab == null ) { return; } if ( scrollState == ScrollState . UP ) { if ( ab . isShowing ( ) ) { ab . hide ( ) ; } } else if ( scrollState == ScrollState . DOWN ) { if ( ! ab . isShowing ( ) ) { ab . show ( ) ; } } }
public StoryDetail ( ) {    }
public StoryDetail ( Long storyDetailId , String title , String url , String domain , Integer points , String user , String timeAgo , Integer commentsCount , String content , Object poll , String link , List < Comment > commentList , Long moreCommentsId , @ StoryType String type ) { mStoryDetailId = storyDetailId ; mTitle = title ; mUrl = url ; mDomain = domain ; mPoints = points ; mUser = user ; mTimeAgo = timeAgo ; mCommentsCount = commentsCount ; mContent = content ; mPoll = poll ; mLink = link ; mCommentList = commentList ; mMoreCommentsId = moreCommentsId ; mType = type ; }
public Long getStoryDetailId ( ) { return mStoryDetailId ; }
public String getTitle ( ) { return mTitle ; }
public String getUrl ( ) { return mUrl ; }
public String getDomain ( ) { return mDomain ; }
public Integer getPoints ( ) { return mPoints ; }
public String getUser ( ) { return mUser ; }
public String getTimeAgo ( ) { return mTimeAgo ; }
public int getCommentsCount ( ) { return mCommentsCount ; }
public String getContent ( ) { return mContent ; }
public Object getPoll ( ) { return mPoll ; }
public String getLink ( ) { return mLink ; }
public List < Comment > getCommentList ( ) { return mCommentList ; }
public void setCommentList ( List < Comment > commentList ) { mCommentList = commentList ; }
public Long getMoreCommentsId ( ) { return mMoreCommentsId ; }
@ StoryType public String getType ( ) { return mType ; }
public void setUrl ( String url ) { mUrl = url ; }
private Data ( ) { references = ObaReferencesElement . EMPTY_OBJECT ; list = ObaStopElement . EMPTY_ARRAY ; outOfRange = false ; limitExceeded = false ; }
private ObaStopsForLocationResponse ( ) { data = Data . EMPTY_OBJECT ; }
public ObaStop [] getStops ( ) { if ( data != null ) { if ( data . list != null ) { return data . list ; } } return new ObaStopElement [] {} ; }
public boolean getOutOfRange ( ) { return data . outOfRange ; }
public boolean getLimitExceeded ( ) { return data . limitExceeded ; }
@ Override protected ObaReferences getRefs ( ) { return data . references ; }
@ Override public void onActivityCreated ( Bundle savedInstanceState ) { super. onActivityCreated ( savedInstanceState ) ; setHasOptionsMenu ( true ) ; registerForContextMenu ( getListView ( ) ) ; setListShown ( false ) ; ExpandableListView list = ( ExpandableListView ) getListView ( ) ; list . setOnChildClickListener ( mChildClick ) ; Uri uri = ( Uri ) getArguments ( ) . getParcelable ( FragmentUtils . URI ) ; if ( uri == null ) { Log . e ( TAG , "No URI in arguments" ) ; return; } mRouteId = uri . getLastPathSegment ( ) ; getLoaderManager ( ) . initLoader ( ROUTE_INFO_LOADER , null , mRouteCallback ) ; getLoaderManager ( ) . initLoader ( ROUTE_STOPS_LOADER , null , mStopsCallback ) ; }
@ Override public View onCreateView ( LayoutInflater inflater , ViewGroup root , Bundle savedInstanceState ) { if ( root == null ) { return null ; } return inflater . inflate ( R . layout . route_info , null ) ; }
@ Override public void onCreateOptionsMenu ( Menu menu , MenuInflater inflater ) { inflater . inflate ( R . menu . route_info_options , menu ) ; }
@ Override public void onPrepareOptionsMenu ( Menu menu ) { boolean hasUrl = false ; if ( mRouteInfo != null ) { hasUrl = ! TextUtils . isEmpty ( mRouteInfo . getUrl ( ) ) ; } menu . findItem ( R . id . goto_url ) . setEnabled ( hasUrl ) . setVisible ( hasUrl ) ; }
@ Override public boolean onOptionsItemSelected ( MenuItem item ) { final int id = item . getItemId ( ) ; if ( id == R . id . show_on_map ) { HomeActivity . start ( getActivity ( ) , mRouteId ) ; return true ; } else if ( id == R . id . goto_url ) { UIUtils . goToUrl ( getActivity ( ) , mRouteInfo . getUrl ( ) ) ; return true ; } return false ; }
@ Override public boolean onChildClick ( ExpandableListView parent , View v , int groupPosition , int childPosition , long id ) { showArrivals ( v ) ; return true ; }
@ Override public void onCreateContextMenu ( ContextMenu menu , View v , ContextMenuInfo menuInfo ) { super. onCreateContextMenu ( menu , v , menuInfo ) ; ExpandableListView . ExpandableListContextMenuInfo info = ( ExpandableListView . ExpandableListContextMenuInfo ) menuInfo ; if ( ExpandableListView . getPackedPositionType ( info . packedPosition ) != ExpandableListView . PACKED_POSITION_TYPE_CHILD ) { return; } final TextView text = ( TextView ) info . targetView . findViewById ( R . id . name ) ; menu . setHeaderTitle ( text . getText ( ) ) ; menu . add ( 0 , CONTEXT_MENU_DEFAULT , 0 , R . string . route_info_context_get_stop_info ) ; menu . add ( 0 , CONTEXT_MENU_SHOWONMAP , 0 , R . string . route_info_context_showonmap ) ; }
@ Override public boolean onContextItemSelected ( android . view . MenuItem item ) { ExpandableListView . ExpandableListContextMenuInfo info = ( ExpandableListView . ExpandableListContextMenuInfo ) item . getMenuInfo ( ) ; switch ( item . getItemId ( ) ) { case CONTEXT_MENU_DEFAULT : showArrivals ( info . targetView ) ; return true ; case CONTEXT_MENU_SHOWONMAP : showOnMap ( info . targetView ) ; return true ; default: return super. onContextItemSelected ( item ) ; } }
@ Override public void onStart ( ) { super. onStart ( ) ; ObaAnalytics . reportFragmentStart ( this ) ; }
private void showArrivals ( View v ) { final TextView text = ( TextView ) v . findViewById ( R . id . stop_id ) ; final String stopId = ( String ) text . getText ( ) ; ObaStop stop = null ; if ( mStopsForRoute != null ) { stop = mStopsForRoute . getStopMap ( ) . get ( stopId ) ; } ArrivalsListActivity . Builder b = new ArrivalsListActivity . Builder ( getActivity ( ) , stopId ) ; if ( stop != null ) { b . setStopName ( stop . getName ( ) ) ; b . setStopDirection ( stop . getDirection ( ) ) ; } b . setUpMode ( NavHelp . UP_MODE_BACK ) ; b . start ( ) ; }
private void showOnMap ( View v ) { final TextView text = ( TextView ) v . findViewById ( R . id . stop_id ) ; final String stopId = ( String ) text . getText ( ) ; ObaStop stop = mStopsForRoute . getStopMap ( ) . get ( stopId ) ; if ( stop == null ) { return; } HomeActivity . start ( getActivity ( ) , stopId , stop . getLatitude ( ) , stop . getLongitude ( ) ) ; }
@ Override public Loader < ObaRouteResponse > onCreateLoader ( int id , Bundle args ) { return new RouteInfoLoader ( getActivity ( ) , mRouteId ) ; }
@ Override public void onLoadFinished ( Loader < ObaRouteResponse > loader , ObaRouteResponse data ) { setHeader ( data , true ) ; }
@ Override public void onLoaderReset ( Loader < ObaRouteResponse > loader ) { }
@ Override public Loader < StopsForRouteInfo > onCreateLoader ( int id , Bundle args ) { return new StopsForRouteLoader ( getActivity ( ) , mRouteId ) ; }
@ Override public void onLoadFinished ( Loader < StopsForRouteInfo > loader , StopsForRouteInfo data ) { setStopsForRoute ( data ) ; }
@ Override public void onLoaderReset ( Loader < StopsForRouteInfo > loader ) { }
RouteInfoLoader ( Context context , String routeId ) { super( context ); mRouteId = routeId ; }
@ Override public void onStartLoading ( ) { forceLoad ( ) ; }
@ Override public ObaRouteResponse loadInBackground ( ) { return ObaRouteRequest . newRequest ( getContext ( ) , mRouteId ) . call ( ) ; }
StopsForRouteLoader ( Context context , String routeId ) { super( context ); mRouteId = routeId ; }
@ Override public void onStartLoading ( ) { forceLoad ( ) ; }
@ Override public StopsForRouteInfo loadInBackground ( ) { final ObaStopsForRouteResponse response = new ObaStopsForRouteRequest . Builder ( getContext ( ) , mRouteId ) . setIncludeShapes ( false ) . build ( ) . call ( ) ; return new StopsForRouteInfo ( getContext ( ) , response ) ; }
public StopsForRouteInfo ( Context cxt , ObaStopsForRouteResponse response ) { mStopGroups = new ArrayList < HashMap < String , String > > ( ) ; mStops = new ArrayList < ArrayList < HashMap < String , String > > > ( ) ; mStopMap = new HashMap < String , ObaStop > ( ) ; mResultCode = response . getCode ( ) ; initMaps ( cxt , response ) ; }
private static Map < String , ObaStop > getStopMap ( List < ObaStop > stops ) { final int len = stops . size ( ) ; HashMap < String , ObaStop > result = new HashMap < String , ObaStop > ( len ) ; for ( int i = 0 ; i < len ; ++ i ) { ObaStop stop = stops . get ( i ) ; result . put ( stop . getId ( ) , stop ) ; } return result ; }
private void initMaps ( Context cxt , ObaStopsForRouteResponse response ) { if ( response . getCode ( ) == ObaApi . OBA_OK ) { final List < ObaStop > stops = response . getStops ( ) ; final Map < String , ObaStop > stopMap = getStopMap ( stops ) ; final ObaStopGrouping [] groupings = response . getStopGroupings ( ) ; final int groupingsLen = groupings . length ; for ( int groupingIndex = 0 ; groupingIndex < groupingsLen ; ++ groupingIndex ) { final ObaStopGrouping grouping = groupings [ groupingIndex ] ; final ObaStopGroup [] groups = grouping . getStopGroups ( ) ; final int groupsLen = groups . length ; for ( int i = 0 ; i < groupsLen ; ++ i ) { final HashMap < String , String > groupMap = new HashMap < String , String > ( 1 ) ; final ObaStopGroup group = groups [ i ] ; groupMap . put ( "name" , UIUtils . formatDisplayText ( group . getName ( ) ) ) ; final String [] stopIds = group . getStopIds ( ) ; final int stopIdLen = stopIds . length ; final ArrayList < HashMap < String , String > > childList = new ArrayList < HashMap < String , String > > ( stopIdLen ) ; for ( int j = 0 ; j < stopIdLen ; ++ j ) { final String stopId = stopIds [ j ] ; final ObaStop stop = stopMap . get ( stopId ) ; HashMap < String , String > groupStopMap = new HashMap < String , String > ( 2 ) ; if ( stop != null ) { groupStopMap . put ( "name" , UIUtils . formatDisplayText ( stop . getName ( ) ) ) ; String dir = cxt . getString ( UIUtils . getStopDirectionText ( stop . getDirection ( ) ) ) ; groupStopMap . put ( "direction" , dir ) ; groupStopMap . put ( "id" , stopId ) ; mStopMap . put ( stopId , stop ) ; } else { groupStopMap . put ( "name" , "" ) ; groupStopMap . put ( "direction" , "" ) ; groupStopMap . put ( "id" , stopId ) ; } childList . add ( groupStopMap ) ; } mStopGroups . add ( groupMap ) ; mStops . add ( childList ) ; } } } }
public int getResultCode ( ) { return mResultCode ; }
public ArrayList < HashMap < String , String > > getStopGroups ( ) { return mStopGroups ; }
public ArrayList < ArrayList < HashMap < String , String > > > getStops ( ) { return mStops ; }
public HashMap < String , ObaStop > getStopMap ( ) { return mStopMap ; }
private void setHeader ( ObaRouteResponse routeInfo , boolean addToDb ) { mRouteInfo = routeInfo ; View view = getView ( ) ; if ( routeInfo . getCode ( ) == ObaApi . OBA_OK ) { TextView shortNameText = ( TextView ) view . findViewById ( R . id . short_name ) ; TextView longNameText = ( TextView ) view . findViewById ( R . id . long_name ) ; TextView agencyText = ( TextView ) view . findViewById ( R . id . agency ) ; String url = mRouteInfo . getUrl ( ) ; String shortName = routeInfo . getShortName ( ) ; String longName = routeInfo . getLongName ( ) ; if ( TextUtils . isEmpty ( shortName ) ) { shortName = longName ; } if ( TextUtils . isEmpty ( longName ) || shortName . equals ( longName ) ) { longName = routeInfo . getDescription ( ) ; } shortNameText . setText ( UIUtils . formatDisplayText ( shortName ) ) ; longNameText . setText ( UIUtils . formatDisplayText ( longName ) ) ; agencyText . setText ( mRouteInfo . getAgency ( ) . getName ( ) ) ; if ( addToDb ) { ContentValues values = new ContentValues ( ) ; values . put ( ObaContract . Routes . SHORTNAME , shortName ) ; values . put ( ObaContract . Routes . LONGNAME , longName ) ; values . put ( ObaContract . Routes . URL , url ) ; if ( Application . get ( ) . getCurrentRegion ( ) != null ) { values . put ( ObaContract . Routes . REGION_ID , Application . get ( ) . getCurrentRegion ( ) . getId ( ) ) ; } ObaContract . Routes . insertOrUpdate ( getActivity ( ) , mRouteInfo . getId ( ) , values , true ) ; } } else { setEmptyText ( UIUtils . getRouteErrorString ( getActivity ( ) , routeInfo . getCode ( ) ) ) ; } }
private void setStopsForRoute ( StopsForRouteInfo result ) { mStopsForRoute = result ; final int code = mStopsForRoute . getResultCode ( ) ; if ( code == ObaApi . OBA_OK ) { setEmptyText ( "" ) ; } else { setEmptyText ( UIUtils . getRouteErrorString ( getActivity ( ) , code ) ) ; } mAdapter = new SimpleExpandableListAdapter ( getActivity ( ) , result . getStopGroups ( ) , android . R . layout . simple_expandable_list_item_1 , new String [] { "name" } , new int [] { android . R . id . text1 } , result . getStops ( ) , R . layout . route_info_listitem , new String [] { "name" , "direction" , "id" } , new int [] { R . id . name , R . id . direction , R . id . stop_id } ) ; setListAdapter ( mAdapter ) ; }
public void setListAdapter ( SimpleExpandableListAdapter adapter ) { ExpandableListView list = ( ExpandableListView ) getListView ( ) ; if ( list != null ) { list . setAdapter ( adapter ) ; setListShown ( true ) ; } }
public void testSerializeRouteDisplayNames ( ) { ObaStop stop = MockObaStop . getMockStop ( ) ; HashMap < String , ObaRoute > routes = MockObaStop . getMockRoutes ( ) ; String serializedRoutes = UIUtils . serializeRouteDisplayNames ( stop , routes ) ; assertEquals ( "1,5" , serializedRoutes ) ; }
public void testDeserializeRouteDisplayNames ( ) { String serializedRoutes = "1,5" ; List < String > routeList = UIUtils . deserializeRouteDisplayNames ( serializedRoutes ) ; assertEquals ( "1" , routeList . get ( 0 ) ) ; assertEquals ( "5" , routeList . get ( 1 ) ) ; }
public void testFormatRouteDisplayNames ( ) { String formattedString ; ArrayList < String > routes = new ArrayList < String > ( ) ; ArrayList < String > highlightedRoutes = new ArrayList < String > ( ) ; routes . add ( "1" ) ; routes . add ( "5" ) ; formattedString = UIUtils . formatRouteDisplayNames ( routes , highlightedRoutes ) ; assertEquals ( "1, 5" , formattedString ) ; routes . clear ( ) ; routes . add ( "5" ) ; routes . add ( "1" ) ; formattedString = UIUtils . formatRouteDisplayNames ( routes , highlightedRoutes ) ; assertEquals ( "1, 5" , formattedString ) ; routes . clear ( ) ; routes . add ( "5" ) ; routes . add ( "1" ) ; routes . add ( "15" ) ; routes . add ( "8b" ) ; routes . add ( "8a" ) ; formattedString = UIUtils . formatRouteDisplayNames ( routes , highlightedRoutes ) ; assertEquals ( "1, 5, 8a, 8b, 15" , formattedString ) ; routes . clear ( ) ; routes . add ( "5" ) ; routes . add ( "1" ) ; routes . add ( "15" ) ; routes . add ( "8b" ) ; routes . add ( "8a" ) ; highlightedRoutes . add ( "1" ) ; formattedString = UIUtils . formatRouteDisplayNames ( routes , highlightedRoutes ) ; assertEquals ( "1*, 5, 8a, 8b, 15" , formattedString ) ; routes . clear ( ) ; highlightedRoutes . clear ( ) ; routes . add ( "5" ) ; routes . add ( "1" ) ; routes . add ( "15" ) ; routes . add ( "8b" ) ; routes . add ( "8a" ) ; highlightedRoutes . add ( "1" ) ; highlightedRoutes . add ( "8b" ) ; highlightedRoutes . add ( "15" ) ; formattedString = UIUtils . formatRouteDisplayNames ( routes , highlightedRoutes ) ; assertEquals ( "1*, 5, 8a, 8b*, 15*" , formattedString ) ; }
public void testFormatDisplayText ( ) { assertEquals ( "SDSU Transit Center" , UIUtils . formatDisplayText ( "SDSU Transit Center" ) ) ; assertEquals ( "VA Hospital" , UIUtils . formatDisplayText ( "VA Hospital" ) ) ; assertEquals ( "SDSU" , UIUtils . formatDisplayText ( "SDSU" ) ) ; assertEquals ( "UTC Transit Center" , UIUtils . formatDisplayText ( "UTC Transit Center" ) ) ; assertEquals ( "North to University Area TC" , UIUtils . formatDisplayText ( "North to University Area TC" ) ) ; assertEquals ( "North To University Area Tc" , UIUtils . formatDisplayText ( "NORTH TO UNIVERSITY AREA TC" ) ) ; assertEquals ( "SDSU" , UIUtils . formatDisplayText ( "SDSU" ) ) ; assertEquals ( "Downtown San Diego - UTC via Old Town" , UIUtils . formatDisplayText ( "Downtown San Diego - UTC via Old Town" ) ) ; assertEquals ( "UTC/VA Med CTR Express" , UIUtils . formatDisplayText ( "UTC/VA Med CTR Express" ) ) ; }
public void testBuildTripOptions ( ) { ObaRegion tampa = MockRegion . getTampa ( getContext ( ) ) ; assertNotNull ( tampa ) ; Application . get ( ) . setCurrentRegion ( tampa ) ; ObaArrivalInfoResponse response = new ObaArrivalInfoRequest . Builder ( getContext ( ) , "Hillsborough Area Regional Transit_3105" ) . build ( ) . call ( ) ; assertOK ( response ) ; ObaStop stop = response . getStop ( ) ; assertNotNull ( stop ) ; assertEquals ( "Hillsborough Area Regional Transit_3105" , stop . getId ( ) ) ; List < ObaRoute > routes = response . getRoutes ( stop . getRouteIds ( ) ) ; assertTrue ( routes . size ( ) > 0 ) ; ObaAgency agency = response . getAgency ( routes . get ( 0 ) . getAgencyId ( ) ) ; assertEquals ( "Hillsborough Area Regional Transit" , agency . getId ( ) ) ; ObaArrivalInfo [] arrivals = response . getArrivalInfo ( ) ; assertNotNull ( arrivals ) ; ArrayList < ArrivalInfo > arrivalInfo = ArrivalInfoUtils . convertObaArrivalInfo ( getContext ( ) , arrivals , null , response . getCurrentTime ( ) , true ) ; ObaRoute route = response . getRoute ( arrivalInfo . get ( 0 ) . getInfo ( ) . getRouteId ( ) ) ; String url = route != null ? route . getUrl ( ) : null ; boolean hasUrl = ! TextUtils . isEmpty ( url ) ; boolean isReminderVisible = false ; boolean isRouteFavorite = false ; List < String > options = UIUtils . buildTripOptions ( getContext ( ) , isRouteFavorite , hasUrl , isReminderVisible ) ; assertEquals ( options . get ( 0 ) , "Add star to route" ) ; assertEquals ( options . get ( 1 ) , "Show route on map" ) ; assertEquals ( options . get ( 2 ) , "Show trip status" ) ; assertEquals ( options . get ( 3 ) , "Set a reminder" ) ; assertEquals ( options . get ( 4 ) , "Show only this route" ) ; assertEquals ( options . get ( 5 ) , "Show route schedule" ) ; assertEquals ( options . get ( 6 ) , "Report arrival time problem" ) ; isReminderVisible = true ; options = UIUtils . buildTripOptions ( getContext ( ) , isRouteFavorite , hasUrl , isReminderVisible ) ; assertEquals ( options . get ( 0 ) , "Add star to route" ) ; assertEquals ( options . get ( 1 ) , "Show route on map" ) ; assertEquals ( options . get ( 2 ) , "Show trip status" ) ; assertEquals ( options . get ( 3 ) , "Edit this reminder" ) ; assertEquals ( options . get ( 4 ) , "Show only this route" ) ; assertEquals ( options . get ( 5 ) , "Show route schedule" ) ; assertEquals ( options . get ( 6 ) , "Report arrival time problem" ) ; ObaArrivalInfoResponse response2 = new ObaArrivalInfoRequest . Builder ( getContext ( ) , "PSTA_4077" ) . build ( ) . call ( ) ; assertOK ( response2 ) ; stop = response2 . getStop ( ) ; assertNotNull ( stop ) ; assertEquals ( "PSTA_4077" , stop . getId ( ) ) ; routes = response2 . getRoutes ( stop . getRouteIds ( ) ) ; assertTrue ( routes . size ( ) > 0 ) ; agency = response2 . getAgency ( routes . get ( 0 ) . getAgencyId ( ) ) ; assertEquals ( "PSTA" , agency . getId ( ) ) ; arrivals = response2 . getArrivalInfo ( ) ; assertNotNull ( arrivals ) ; arrivalInfo = ArrivalInfoUtils . convertObaArrivalInfo ( getContext ( ) , arrivals , null , response2 . getCurrentTime ( ) , true ) ; route = response2 . getRoute ( arrivalInfo . get ( 0 ) . getInfo ( ) . getRouteId ( ) ) ; url = route != null ? route . getUrl ( ) : null ; boolean hasUrl2 = ! TextUtils . isEmpty ( url ) ; isReminderVisible = false ; options = UIUtils . buildTripOptions ( getContext ( ) , isRouteFavorite , hasUrl2 , isReminderVisible ) ; assertEquals ( options . get ( 0 ) , "Add star to route" ) ; assertEquals ( options . get ( 1 ) , "Show route on map" ) ; assertEquals ( options . get ( 2 ) , "Show trip status" ) ; assertEquals ( options . get ( 3 ) , "Set a reminder" ) ; assertEquals ( options . get ( 4 ) , "Show only this route" ) ; assertEquals ( options . get ( 5 ) , "Report arrival time problem" ) ; isReminderVisible = true ; options = UIUtils . buildTripOptions ( getContext ( ) , isRouteFavorite , hasUrl2 , isReminderVisible ) ; assertEquals ( options . get ( 0 ) , "Add star to route" ) ; assertEquals ( options . get ( 1 ) , "Show route on map" ) ; assertEquals ( options . get ( 2 ) , "Show trip status" ) ; assertEquals ( options . get ( 3 ) , "Edit this reminder" ) ; assertEquals ( options . get ( 4 ) , "Show only this route" ) ; assertEquals ( options . get ( 5 ) , "Report arrival time problem" ) ; isRouteFavorite = true ; isReminderVisible = false ; options = UIUtils . buildTripOptions ( getContext ( ) , isRouteFavorite , hasUrl , isReminderVisible ) ; assertEquals ( options . get ( 0 ) , "Remove star from route" ) ; assertEquals ( options . get ( 1 ) , "Show route on map" ) ; assertEquals ( options . get ( 2 ) , "Show trip status" ) ; assertEquals ( options . get ( 3 ) , "Set a reminder" ) ; assertEquals ( options . get ( 4 ) , "Show only this route" ) ; assertEquals ( options . get ( 5 ) , "Show route schedule" ) ; assertEquals ( options . get ( 6 ) , "Report arrival time problem" ) ; isReminderVisible = true ; options = UIUtils . buildTripOptions ( getContext ( ) , isRouteFavorite , hasUrl , isReminderVisible ) ; assertEquals ( options . get ( 0 ) , "Remove star from route" ) ; assertEquals ( options . get ( 1 ) , "Show route on map" ) ; assertEquals ( options . get ( 2 ) , "Show trip status" ) ; assertEquals ( options . get ( 3 ) , "Edit this reminder" ) ; assertEquals ( options . get ( 4 ) , "Show only this route" ) ; assertEquals ( options . get ( 5 ) , "Show route schedule" ) ; assertEquals ( options . get ( 6 ) , "Report arrival time problem" ) ; isReminderVisible = false ; options = UIUtils . buildTripOptions ( getContext ( ) , isRouteFavorite , hasUrl2 , isReminderVisible ) ; assertEquals ( options . get ( 0 ) , "Remove star from route" ) ; assertEquals ( options . get ( 1 ) , "Show route on map" ) ; assertEquals ( options . get ( 2 ) , "Show trip status" ) ; assertEquals ( options . get ( 3 ) , "Set a reminder" ) ; assertEquals ( options . get ( 4 ) , "Show only this route" ) ; assertEquals ( options . get ( 5 ) , "Report arrival time problem" ) ; isReminderVisible = true ; options = UIUtils . buildTripOptions ( getContext ( ) , isRouteFavorite , hasUrl2 , isReminderVisible ) ; assertEquals ( options . get ( 0 ) , "Remove star from route" ) ; assertEquals ( options . get ( 1 ) , "Show route on map" ) ; assertEquals ( options . get ( 2 ) , "Show trip status" ) ; assertEquals ( options . get ( 3 ) , "Edit this reminder" ) ; assertEquals ( options . get ( 4 ) , "Show only this route" ) ; assertEquals ( options . get ( 5 ) , "Report arrival time problem" ) ; }
public void testCreateStopDetailsDialogText ( ) { final String newLine = "\n" ; Pair stopDetails ; StringBuilder expectedMessage ; String stopName = "University Area Transit Center" ; String stopUserName = null ; String stopCode = "6497" ; String stopDirection = null ; List < String > routeDisplayNames = new ArrayList <> ( ) ; routeDisplayNames . add ( "5" ) ; stopDetails = UIUtils . createStopDetailsDialogText ( getContext ( ) , stopName , stopUserName , stopCode , stopDirection , routeDisplayNames ) ; assertEquals ( stopName , ( String ) stopDetails . first ) ; expectedMessage = new StringBuilder ( ) ; expectedMessage . append ( "Stop # " + stopCode ) ; expectedMessage . append ( newLine ) ; expectedMessage . append ( "Routes: " + routeDisplayNames . get ( 0 ) ) ; assertEquals ( expectedMessage . toString ( ) , ( String ) stopDetails . second ) ; stopUserName = "My stop nickname" ; stopDetails = UIUtils . createStopDetailsDialogText ( getContext ( ) , stopName , stopUserName , stopCode , stopDirection , routeDisplayNames ) ; assertEquals ( stopUserName , ( String ) stopDetails . first ) ; expectedMessage = new StringBuilder ( ) ; expectedMessage . append ( "Official name: " + stopName ) ; expectedMessage . append ( newLine ) ; expectedMessage . append ( "Stop # " + stopCode ) ; expectedMessage . append ( newLine ) ; expectedMessage . append ( "Routes: " + routeDisplayNames . get ( 0 ) ) ; assertEquals ( expectedMessage . toString ( ) , ( String ) stopDetails . second ) ; stopUserName = null ; stopDirection = "S" ; stopDetails = UIUtils . createStopDetailsDialogText ( getContext ( ) , stopName , stopUserName , stopCode , stopDirection , routeDisplayNames ) ; assertEquals ( stopName , ( String ) stopDetails . first ) ; expectedMessage = new StringBuilder ( ) ; expectedMessage . append ( "Stop # " + stopCode ) ; expectedMessage . append ( newLine ) ; expectedMessage . append ( "Routes: " + routeDisplayNames . get ( 0 ) ) ; expectedMessage . append ( newLine ) ; expectedMessage . append ( getContext ( ) . getString ( UIUtils . getStopDirectionText ( stopDirection ) ) ) ; assertEquals ( expectedMessage . toString ( ) , ( String ) stopDetails . second ) ; stopUserName = "My stop nickname" ; stopDirection = "S" ; stopDetails = UIUtils . createStopDetailsDialogText ( getContext ( ) , stopName , stopUserName , stopCode , stopDirection , routeDisplayNames ) ; assertEquals ( stopUserName , ( String ) stopDetails . first ) ; expectedMessage = new StringBuilder ( ) ; expectedMessage . append ( "Official name: " + stopName ) ; expectedMessage . append ( newLine ) ; expectedMessage . append ( "Stop # " + stopCode ) ; expectedMessage . append ( newLine ) ; expectedMessage . append ( "Routes: " + routeDisplayNames . get ( 0 ) ) ; expectedMessage . append ( newLine ) ; expectedMessage . append ( getContext ( ) . getString ( UIUtils . getStopDirectionText ( stopDirection ) ) ) ; assertEquals ( expectedMessage . toString ( ) , ( String ) stopDetails . second ) ; }
public void testArrivalTimeIndexSearch ( ) { ObaRegion tampa = MockRegion . getTampa ( getContext ( ) ) ; assertNotNull ( tampa ) ; Application . get ( ) . setCurrentRegion ( tampa ) ; ObaArrivalInfoResponse response = new ObaArrivalInfoRequest . Builder ( getContext ( ) , "Hillsborough Area Regional Transit_6497" ) . build ( ) . call ( ) ; assertOK ( response ) ; ObaStop stop = response . getStop ( ) ; assertNotNull ( stop ) ; assertEquals ( "Hillsborough Area Regional Transit_6497" , stop . getId ( ) ) ; List < ObaRoute > routes = response . getRoutes ( stop . getRouteIds ( ) ) ; assertTrue ( routes . size ( ) > 0 ) ; ObaAgency agency = response . getAgency ( routes . get ( 0 ) . getAgencyId ( ) ) ; assertEquals ( "Hillsborough Area Regional Transit" , agency . getId ( ) ) ; ObaContract . RouteHeadsignFavorites . markAsFavorite ( getContext ( ) , "Hillsborough Area Regional Transit_2" , "UATC to Downtown via Nebraska Ave" , stop . getId ( ) , false ) ; ObaContract . RouteHeadsignFavorites . markAsFavorite ( getContext ( ) , "Hillsborough Area Regional Transit_1" , "UATC to Downtown via Florida Ave" , stop . getId ( ) , false ) ; ObaContract . RouteHeadsignFavorites . markAsFavorite ( getContext ( ) , "Hillsborough Area Regional Transit_18" , "North to UATC/Livingston" , stop . getId ( ) , false ) ; ObaContract . RouteHeadsignFavorites . markAsFavorite ( getContext ( ) , "Hillsborough Area Regional Transit_5" , "South to Downtown/MTC" , stop . getId ( ) , false ) ; ObaContract . RouteHeadsignFavorites . markAsFavorite ( getContext ( ) , "Hillsborough Area Regional Transit_2" , "UATC to Downtown via Nebraska Ave" , stop . getId ( ) , false ) ; ObaContract . RouteHeadsignFavorites . markAsFavorite ( getContext ( ) , "Hillsborough Area Regional Transit_18" , "South to UATC/Downtown/MTC" , stop . getId ( ) , false ) ; ObaContract . RouteHeadsignFavorites . markAsFavorite ( getContext ( ) , "Hillsborough Area Regional Transit_12" , "North to University Area TC" , stop . getId ( ) , false ) ; ObaContract . RouteHeadsignFavorites . markAsFavorite ( getContext ( ) , "Hillsborough Area Regional Transit_9" , "UATC to Downtown via 15th St" , stop . getId ( ) , false ) ; ObaContract . RouteHeadsignFavorites . markAsFavorite ( getContext ( ) , "Hillsborough Area Regional Transit_12" , "South to Downtown/MTC" , stop . getId ( ) , false ) ; ObaContract . RouteHeadsignFavorites . markAsFavorite ( getContext ( ) , "Hillsborough Area Regional Transit_5" , "North to University Area TC" , stop . getId ( ) , false ) ; ObaContract . RouteHeadsignFavorites . markAsFavorite ( getContext ( ) , "Hillsborough Area Regional Transit_6" , "North to University Area TC" , stop . getId ( ) , true ) ; ObaContract . RouteHeadsignFavorites . markAsFavorite ( getContext ( ) , "Hillsborough Area Regional Transit_6" , "South to Downtown/MTC" , stop . getId ( ) , true ) ; ObaArrivalInfo [] arrivals = response . getArrivalInfo ( ) ; assertNotNull ( arrivals ) ; ArrayList < ArrivalInfo > arrivalInfo = ArrivalInfoUtils . convertObaArrivalInfo ( getContext ( ) , arrivals , null , response . getCurrentTime ( ) , true ) ; validateUatcArrivalInfo ( arrivalInfo ) ; int firstNonNegativeArrivalIndex = ArrivalInfoUtils . findFirstNonNegativeArrival ( arrivalInfo ) ; assertEquals ( 5 , firstNonNegativeArrivalIndex ) ; ArrayList < Integer > preferredArrivalIndexes = ArrivalInfoUtils . findPreferredArrivalIndexes ( arrivalInfo ) ; assertEquals ( 11 , preferredArrivalIndexes . get ( 0 ) . intValue ( ) ) ; assertEquals ( 13 , preferredArrivalIndexes . get ( 1 ) . intValue ( ) ) ; ObaContract . RouteHeadsignFavorites . markAsFavorite ( getContext ( ) , "Hillsborough Area Regional Transit_6" , "North to University Area TC" , stop . getId ( ) , false ) ; ObaContract . RouteHeadsignFavorites . markAsFavorite ( getContext ( ) , "Hillsborough Area Regional Transit_6" , "South to Downtown/MTC" , stop . getId ( ) , false ) ; arrivalInfo = ArrivalInfoUtils . convertObaArrivalInfo ( getContext ( ) , arrivals , null , response . getCurrentTime ( ) , true ) ; preferredArrivalIndexes = ArrivalInfoUtils . findPreferredArrivalIndexes ( arrivalInfo ) ; assertEquals ( 5 , preferredArrivalIndexes . get ( 0 ) . intValue ( ) ) ; assertEquals ( 6 , preferredArrivalIndexes . get ( 1 ) . intValue ( ) ) ; }
public void testArrivalInfoLabels ( ) { ObaRegion tampa = MockRegion . getTampa ( getContext ( ) ) ; assertNotNull ( tampa ) ; Application . get ( ) . setCurrentRegion ( tampa ) ; ObaArrivalInfoResponse response = new ObaArrivalInfoRequest . Builder ( getContext ( ) , "Hillsborough Area Regional Transit_6497" ) . build ( ) . call ( ) ; assertOK ( response ) ; ObaStop stop = response . getStop ( ) ; assertNotNull ( stop ) ; assertEquals ( "Hillsborough Area Regional Transit_6497" , stop . getId ( ) ) ; List < ObaRoute > routes = response . getRoutes ( stop . getRouteIds ( ) ) ; assertTrue ( routes . size ( ) > 0 ) ; ObaAgency agency = response . getAgency ( routes . get ( 0 ) . getAgencyId ( ) ) ; assertEquals ( "Hillsborough Area Regional Transit" , agency . getId ( ) ) ; ObaArrivalInfo [] arrivals = response . getArrivalInfo ( ) ; assertNotNull ( arrivals ) ; boolean includeArriveDepartLabels = true ; ArrayList < ArrivalInfo > arrivalInfo = ArrivalInfoUtils . convertObaArrivalInfo ( getContext ( ) , arrivals , null , response . getCurrentTime ( ) , includeArriveDepartLabels ) ; validateUatcArrivalInfo ( arrivalInfo ) ; assertEquals ( "Arrived on time" , arrivalInfo . get ( 0 ) . getStatusText ( ) ) ; assertEquals ( "Arrived at " + formatTime ( 1438804260000L ) , arrivalInfo . get ( 0 ) . getTimeText ( ) ) ; assertEquals ( "Departed 2 min late" , arrivalInfo . get ( 1 ) . getStatusText ( ) ) ; assertEquals ( "Departed at " + formatTime ( 1438804320000L ) , arrivalInfo . get ( 1 ) . getTimeText ( ) ) ; assertEquals ( "Departed 1 min early" , arrivalInfo . get ( 2 ) . getStatusText ( ) ) ; assertEquals ( "Departed at " + formatTime ( 1438804440000L ) , arrivalInfo . get ( 2 ) . getTimeText ( ) ) ; assertEquals ( "Arrived on time" , arrivalInfo . get ( 3 ) . getStatusText ( ) ) ; assertEquals ( "Arrived at " + formatTime ( 1438804440000L ) , arrivalInfo . get ( 3 ) . getTimeText ( ) ) ; assertEquals ( "Departed 6 min early" , arrivalInfo . get ( 4 ) . getStatusText ( ) ) ; assertEquals ( "Departed at " + formatTime ( 1438804440000L ) , arrivalInfo . get ( 4 ) . getTimeText ( ) ) ; assertEquals ( "On time" , arrivalInfo . get ( 5 ) . getStatusText ( ) ) ; assertEquals ( "Departing at " + formatTime ( 1438804500000L ) , arrivalInfo . get ( 5 ) . getTimeText ( ) ) ; assertEquals ( "On time" , arrivalInfo . get ( 6 ) . getStatusText ( ) ) ; assertEquals ( "Arriving at " + formatTime ( 1438804500000L ) , arrivalInfo . get ( 6 ) . getTimeText ( ) ) ; assertEquals ( "5 min delay" , arrivalInfo . get ( 7 ) . getStatusText ( ) ) ; assertEquals ( "Arriving at " + formatTime ( 1438804680000L ) , arrivalInfo . get ( 7 ) . getTimeText ( ) ) ; assertEquals ( "On time" , arrivalInfo . get ( 8 ) . getStatusText ( ) ) ; assertEquals ( "Departing at " + formatTime ( 1438804800000L ) , arrivalInfo . get ( 8 ) . getTimeText ( ) ) ; assertEquals ( "On time" , arrivalInfo . get ( 9 ) . getStatusText ( ) ) ; assertEquals ( "Departing at " + formatTime ( 1438804800000L ) , arrivalInfo . get ( 9 ) . getTimeText ( ) ) ; assertEquals ( "10 min delay" , arrivalInfo . get ( 10 ) . getStatusText ( ) ) ; assertEquals ( "Arriving at " + formatTime ( 1438804860000L ) , arrivalInfo . get ( 10 ) . getTimeText ( ) ) ; assertEquals ( "1 min early" , arrivalInfo . get ( 11 ) . getStatusText ( ) ) ; assertEquals ( "Arriving at " + formatTime ( 1438804920000L ) , arrivalInfo . get ( 11 ) . getTimeText ( ) ) ; assertEquals ( "On time" , arrivalInfo . get ( 12 ) . getStatusText ( ) ) ; assertEquals ( "Arriving at " + formatTime ( 1438805100000L ) , arrivalInfo . get ( 12 ) . getTimeText ( ) ) ; assertEquals ( "1 min early" , arrivalInfo . get ( 13 ) . getStatusText ( ) ) ; assertEquals ( "Departing at " + formatTime ( 1438805340000L ) , arrivalInfo . get ( 13 ) . getTimeText ( ) ) ; assertEquals ( "1 min delay" , arrivalInfo . get ( 14 ) . getStatusText ( ) ) ; assertEquals ( "Arriving at " + formatTime ( 1438805520000L ) , arrivalInfo . get ( 14 ) . getTimeText ( ) ) ; assertEquals ( "On time" , arrivalInfo . get ( 15 ) . getStatusText ( ) ) ; assertEquals ( "Arriving at " + formatTime ( 1438805700000L ) , arrivalInfo . get ( 15 ) . getTimeText ( ) ) ; assertEquals ( "On time" , arrivalInfo . get ( 16 ) . getStatusText ( ) ) ; assertEquals ( "Departing at " + formatTime ( 1438805700000L ) , arrivalInfo . get ( 16 ) . getTimeText ( ) ) ; assertEquals ( "4 min delay" , arrivalInfo . get ( 17 ) . getStatusText ( ) ) ; assertEquals ( "Arriving at " + formatTime ( 1438805880000L ) , arrivalInfo . get ( 17 ) . getTimeText ( ) ) ; assertEquals ( "On time" , arrivalInfo . get ( 18 ) . getStatusText ( ) ) ; assertEquals ( "Departing at " + formatTime ( 1438806000000L ) , arrivalInfo . get ( 18 ) . getTimeText ( ) ) ; assertEquals ( "8 min delay" , arrivalInfo . get ( 19 ) . getStatusText ( ) ) ; assertEquals ( "Arriving at " + formatTime ( 1438806060000L ) , arrivalInfo . get ( 19 ) . getTimeText ( ) ) ; assertEquals ( "2 min delay" , arrivalInfo . get ( 20 ) . getStatusText ( ) ) ; assertEquals ( "Departing at " + formatTime ( 1438806124000L ) , arrivalInfo . get ( 20 ) . getTimeText ( ) ) ; assertEquals ( "3 min delay" , arrivalInfo . get ( 21 ) . getStatusText ( ) ) ; assertEquals ( "Arriving at " + formatTime ( 1438806180000L ) , arrivalInfo . get ( 21 ) . getTimeText ( ) ) ; assertEquals ( "On time" , arrivalInfo . get ( 22 ) . getStatusText ( ) ) ; assertEquals ( "Arriving at " + formatTime ( 1438806300000L ) , arrivalInfo . get ( 22 ) . getTimeText ( ) ) ; assertEquals ( "On time" , arrivalInfo . get ( 23 ) . getStatusText ( ) ) ; assertEquals ( "Departing at " + formatTime ( 1438806300000L ) , arrivalInfo . get ( 23 ) . getTimeText ( ) ) ; assertEquals ( "6 min delay" , arrivalInfo . get ( 24 ) . getStatusText ( ) ) ; assertEquals ( "Arriving at " + formatTime ( 1438806420000L ) , arrivalInfo . get ( 24 ) . getTimeText ( ) ) ; assertEquals ( "3 min delay" , arrivalInfo . get ( 25 ) . getStatusText ( ) ) ; assertEquals ( "Arriving at " + formatTime ( 1438806420000L ) , arrivalInfo . get ( 25 ) . getTimeText ( ) ) ; assertEquals ( "6 min delay" , arrivalInfo . get ( 26 ) . getStatusText ( ) ) ; assertEquals ( "Arriving at " + formatTime ( 1438806540000L ) , arrivalInfo . get ( 26 ) . getTimeText ( ) ) ; assertEquals ( "On time" , arrivalInfo . get ( 27 ) . getStatusText ( ) ) ; assertEquals ( "Arriving at " + formatTime ( 1438806540000L ) , arrivalInfo . get ( 27 ) . getTimeText ( ) ) ; assertEquals ( "On time" , arrivalInfo . get ( 28 ) . getStatusText ( ) ) ; assertEquals ( "Departing at " + formatTime ( 1438806600000L ) , arrivalInfo . get ( 28 ) . getTimeText ( ) ) ; assertEquals ( "On time" , arrivalInfo . get ( 29 ) . getStatusText ( ) ) ; assertEquals ( "Departing at " + formatTime ( 1438806600000L ) , arrivalInfo . get ( 29 ) . getTimeText ( ) ) ; assertEquals ( "9 min delay" , arrivalInfo . get ( 30 ) . getStatusText ( ) ) ; assertEquals ( "Arriving at " + formatTime ( 1438806600000L ) , arrivalInfo . get ( 30 ) . getTimeText ( ) ) ; assertEquals ( "On time" , arrivalInfo . get ( 31 ) . getStatusText ( ) ) ; assertEquals ( "Departing at " + formatTime ( 1438806600000L ) , arrivalInfo . get ( 31 ) . getTimeText ( ) ) ; includeArriveDepartLabels = false ; arrivalInfo = ArrivalInfoUtils . convertObaArrivalInfo ( getContext ( ) , arrivals , null , response . getCurrentTime ( ) , includeArriveDepartLabels ) ; validateUatcArrivalInfo ( arrivalInfo ) ; assertEquals ( "On time" , arrivalInfo . get ( 0 ) . getStatusText ( ) ) ; assertEquals ( "2 min late" , arrivalInfo . get ( 1 ) . getStatusText ( ) ) ; assertEquals ( "1 min early" , arrivalInfo . get ( 2 ) . getStatusText ( ) ) ; assertEquals ( "On time" , arrivalInfo . get ( 3 ) . getStatusText ( ) ) ; assertEquals ( "6 min early" , arrivalInfo . get ( 4 ) . getStatusText ( ) ) ; assertEquals ( "On time" , arrivalInfo . get ( 5 ) . getStatusText ( ) ) ; assertEquals ( "On time" , arrivalInfo . get ( 6 ) . getStatusText ( ) ) ; assertEquals ( "5 min delay" , arrivalInfo . get ( 7 ) . getStatusText ( ) ) ; assertEquals ( "On time" , arrivalInfo . get ( 8 ) . getStatusText ( ) ) ; assertEquals ( "On time" , arrivalInfo . get ( 9 ) . getStatusText ( ) ) ; assertEquals ( "10 min delay" , arrivalInfo . get ( 10 ) . getStatusText ( ) ) ; assertEquals ( "1 min early" , arrivalInfo . get ( 11 ) . getStatusText ( ) ) ; assertEquals ( "On time" , arrivalInfo . get ( 12 ) . getStatusText ( ) ) ; assertEquals ( "1 min early" , arrivalInfo . get ( 13 ) . getStatusText ( ) ) ; assertEquals ( "1 min delay" , arrivalInfo . get ( 14 ) . getStatusText ( ) ) ; assertEquals ( "On time" , arrivalInfo . get ( 15 ) . getStatusText ( ) ) ; assertEquals ( "On time" , arrivalInfo . get ( 16 ) . getStatusText ( ) ) ; assertEquals ( "4 min delay" , arrivalInfo . get ( 17 ) . getStatusText ( ) ) ; assertEquals ( "On time" , arrivalInfo . get ( 18 ) . getStatusText ( ) ) ; assertEquals ( "8 min delay" , arrivalInfo . get ( 19 ) . getStatusText ( ) ) ; assertEquals ( "2 min delay" , arrivalInfo . get ( 20 ) . getStatusText ( ) ) ; assertEquals ( "3 min delay" , arrivalInfo . get ( 21 ) . getStatusText ( ) ) ; assertEquals ( "On time" , arrivalInfo . get ( 22 ) . getStatusText ( ) ) ; assertEquals ( "On time" , arrivalInfo . get ( 23 ) . getStatusText ( ) ) ; assertEquals ( "6 min delay" , arrivalInfo . get ( 24 ) . getStatusText ( ) ) ; assertEquals ( "3 min delay" , arrivalInfo . get ( 25 ) . getStatusText ( ) ) ; assertEquals ( "6 min delay" , arrivalInfo . get ( 26 ) . getStatusText ( ) ) ; assertEquals ( "On time" , arrivalInfo . get ( 27 ) . getStatusText ( ) ) ; assertEquals ( "On time" , arrivalInfo . get ( 28 ) . getStatusText ( ) ) ; assertEquals ( "On time" , arrivalInfo . get ( 29 ) . getStatusText ( ) ) ; assertEquals ( "9 min delay" , arrivalInfo . get ( 30 ) . getStatusText ( ) ) ; assertEquals ( "On time" , arrivalInfo . get ( 31 ) . getStatusText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 0 ) . getInfo ( ) ) + " has arrived." , arrivalInfo . get ( 0 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 1 ) . getInfo ( ) ) + " has departed." , arrivalInfo . get ( 1 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 2 ) . getInfo ( ) ) + " has departed." , arrivalInfo . get ( 2 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 3 ) . getInfo ( ) ) + " has arrived." , arrivalInfo . get ( 3 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 4 ) . getInfo ( ) ) + " has departed." , arrivalInfo . get ( 4 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 5 ) . getInfo ( ) ) + " is departing now!" , arrivalInfo . get ( 5 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 6 ) . getInfo ( ) ) + " is arriving now!" , arrivalInfo . get ( 6 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 7 ) . getInfo ( ) ) + " is arriving in 3 min!" , arrivalInfo . get ( 7 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 8 ) . getInfo ( ) ) + " is departing in 5 min!" , arrivalInfo . get ( 8 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 9 ) . getInfo ( ) ) + " is departing in 5 min!" , arrivalInfo . get ( 9 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 10 ) . getInfo ( ) ) + " is arriving in 6 min!" , arrivalInfo . get ( 10 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 11 ) . getInfo ( ) ) + " is arriving in 7 min!" , arrivalInfo . get ( 11 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 12 ) . getInfo ( ) ) + " is arriving in 10 min!" , arrivalInfo . get ( 12 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 13 ) . getInfo ( ) ) + " is departing in 14 min!" , arrivalInfo . get ( 13 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 14 ) . getInfo ( ) ) + " is arriving in 17 min!" , arrivalInfo . get ( 14 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 15 ) . getInfo ( ) ) + " is arriving in 20 min!" , arrivalInfo . get ( 15 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 16 ) . getInfo ( ) ) + " is departing in 20 min!" , arrivalInfo . get ( 16 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 17 ) . getInfo ( ) ) + " is arriving in 23 min!" , arrivalInfo . get ( 17 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 18 ) . getInfo ( ) ) + " is departing in 25 min!" , arrivalInfo . get ( 18 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 19 ) . getInfo ( ) ) + " is arriving in 26 min!" , arrivalInfo . get ( 19 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 20 ) . getInfo ( ) ) + " is departing in 27 min!" , arrivalInfo . get ( 20 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 21 ) . getInfo ( ) ) + " is arriving in 28 min!" , arrivalInfo . get ( 21 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 22 ) . getInfo ( ) ) + " is arriving in 30 min!" , arrivalInfo . get ( 22 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 23 ) . getInfo ( ) ) + " is departing in 30 min!" , arrivalInfo . get ( 23 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 24 ) . getInfo ( ) ) + " is arriving in 32 min!" , arrivalInfo . get ( 24 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 25 ) . getInfo ( ) ) + " is arriving in 32 min!" , arrivalInfo . get ( 25 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 26 ) . getInfo ( ) ) + " is arriving in 34 min!" , arrivalInfo . get ( 26 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 27 ) . getInfo ( ) ) + " is arriving in 34 min!" , arrivalInfo . get ( 27 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 28 ) . getInfo ( ) ) + " is departing in 35 min!" , arrivalInfo . get ( 28 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 29 ) . getInfo ( ) ) + " is departing in 35 min!" , arrivalInfo . get ( 29 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 30 ) . getInfo ( ) ) + " is arriving in 35 min!" , arrivalInfo . get ( 30 ) . getNotifyText ( ) ) ; assertEquals ( "Route " + UIUtils . getRouteDisplayName ( arrivalInfo . get ( 31 ) . getInfo ( ) ) + " is departing in 35 min!" , arrivalInfo . get ( 31 ) . getNotifyText ( ) ) ; }
public void testMaybeShrinkRouteName ( ) { TextView tv = new TextView ( getContext ( ) ) ; String routeShortName = "TST" ; float textSize = tv . getTextSize ( ) ; UIUtils . maybeShrinkRouteName ( getContext ( ) , tv , routeShortName ) ; assertEquals ( textSize , tv . getTextSize ( ) ) ; routeShortName = "Test" ; UIUtils . maybeShrinkRouteName ( getContext ( ) , tv , routeShortName ) ; assertEquals ( getContext ( ) . getResources ( ) . getDimension ( R . dimen . route_name_text_size_medium ) , tv . getTextSize ( ) ) ; routeShortName = "Test2" ; UIUtils . maybeShrinkRouteName ( getContext ( ) , tv , routeShortName ) ; assertEquals ( getContext ( ) . getResources ( ) . getDimension ( R . dimen . route_name_text_size_small ) , tv . getTextSize ( ) ) ; }
private void validateUatcArrivalInfo ( ArrayList < ArrivalInfo > arrivalInfo ) { assertEquals ( 32 , arrivalInfo . size ( ) ) ; assertEquals ( - 4 , arrivalInfo . get ( 0 ) . getEta ( ) ) ; assertEquals ( - 3 , arrivalInfo . get ( 1 ) . getEta ( ) ) ; assertEquals ( - 1 , arrivalInfo . get ( 2 ) . getEta ( ) ) ; assertEquals ( - 1 , arrivalInfo . get ( 3 ) . getEta ( ) ) ; assertEquals ( - 1 , arrivalInfo . get ( 4 ) . getEta ( ) ) ; assertEquals ( 0 , arrivalInfo . get ( 5 ) . getEta ( ) ) ; assertEquals ( 0 , arrivalInfo . get ( 6 ) . getEta ( ) ) ; assertEquals ( 3 , arrivalInfo . get ( 7 ) . getEta ( ) ) ; assertEquals ( 5 , arrivalInfo . get ( 8 ) . getEta ( ) ) ; assertEquals ( 5 , arrivalInfo . get ( 9 ) . getEta ( ) ) ; assertEquals ( 6 , arrivalInfo . get ( 10 ) . getEta ( ) ) ; assertEquals ( 7 , arrivalInfo . get ( 11 ) . getEta ( ) ) ; assertEquals ( 10 , arrivalInfo . get ( 12 ) . getEta ( ) ) ; assertEquals ( 14 , arrivalInfo . get ( 13 ) . getEta ( ) ) ; assertEquals ( 17 , arrivalInfo . get ( 14 ) . getEta ( ) ) ; assertEquals ( 20 , arrivalInfo . get ( 15 ) . getEta ( ) ) ; assertEquals ( 20 , arrivalInfo . get ( 16 ) . getEta ( ) ) ; assertEquals ( 23 , arrivalInfo . get ( 17 ) . getEta ( ) ) ; assertEquals ( 25 , arrivalInfo . get ( 18 ) . getEta ( ) ) ; assertEquals ( 26 , arrivalInfo . get ( 19 ) . getEta ( ) ) ; assertEquals ( 27 , arrivalInfo . get ( 20 ) . getEta ( ) ) ; assertEquals ( 28 , arrivalInfo . get ( 21 ) . getEta ( ) ) ; assertEquals ( 30 , arrivalInfo . get ( 22 ) . getEta ( ) ) ; assertEquals ( 30 , arrivalInfo . get ( 23 ) . getEta ( ) ) ; assertEquals ( 32 , arrivalInfo . get ( 24 ) . getEta ( ) ) ; assertEquals ( 32 , arrivalInfo . get ( 25 ) . getEta ( ) ) ; assertEquals ( 34 , arrivalInfo . get ( 26 ) . getEta ( ) ) ; assertEquals ( 34 , arrivalInfo . get ( 27 ) . getEta ( ) ) ; assertEquals ( 35 , arrivalInfo . get ( 28 ) . getEta ( ) ) ; assertEquals ( 35 , arrivalInfo . get ( 29 ) . getEta ( ) ) ; assertEquals ( 35 , arrivalInfo . get ( 30 ) . getEta ( ) ) ; assertEquals ( 35 , arrivalInfo . get ( 31 ) . getEta ( ) ) ; }
public void testGetTransparentColor ( ) { String colorString = "#777777" ; int alpha = 127 ; int color = Color . parseColor ( colorString ) ; int newColor = UIUtils . getTransparentColor ( color , alpha ) ; int r = Color . red ( color ) ; int g = Color . green ( color ) ; int b = Color . blue ( color ) ; int newR = Color . red ( newColor ) ; int newG = Color . green ( newColor ) ; int newB = Color . blue ( newColor ) ; int newAlpha = Color . alpha ( newColor ) ; assertEquals ( r , newR ) ; assertEquals ( g , newG ) ; assertEquals ( b , newB ) ; assertEquals ( alpha , newAlpha ) ; }
private String formatTime ( long time ) { return UIUtils . formatTime ( getContext ( ) , time ) ; }
public void testGetMapCenter ( ) { Bundle b = null ; assertNull ( UIUtils . getMapCenter ( b ) ) ; b = new Bundle ( ) ; assertNull ( UIUtils . getMapCenter ( b ) ) ; b . putDouble ( MapParams . CENTER_LAT , 0.0 ) ; assertNull ( UIUtils . getMapCenter ( b ) ) ; b = new Bundle ( ) ; b . putDouble ( MapParams . CENTER_LON , 0.0 ) ; assertNull ( UIUtils . getMapCenter ( b ) ) ; b = new Bundle ( ) ; b . putDouble ( MapParams . CENTER_LAT , 0.0 ) ; b . putDouble ( MapParams . CENTER_LON , 0.0 ) ; assertNull ( UIUtils . getMapCenter ( b ) ) ; final double lat = 28.343243 ; final double lon = - 87.234234 ; b = new Bundle ( ) ; b . putDouble ( MapParams . CENTER_LAT , lat ) ; b . putDouble ( MapParams . CENTER_LON , lon ) ; Location l = UIUtils . getMapCenter ( b ) ; assertNotNull ( l ) ; assertEquals ( lat , l . getLatitude ( ) ) ; assertEquals ( lon , l . getLongitude ( ) ) ; }
public void testGetAllSituations ( ) { Application . get ( ) . setCustomApiUrl ( "sdmts.onebusway.org/api" ) ; ObaArrivalInfoResponse response = new ObaArrivalInfoRequest . Builder ( getContext ( ) , "MTS_11670" ) . build ( ) . call ( ) ; assertOK ( response ) ; List < ObaSituation > situations = response . getSituations ( ) ; assertNotNull ( situations ) ; assertEquals ( 0 , situations . size ( ) ) ; List < ObaSituation > allSituations = UIUtils . getAllSituations ( response ) ; HashSet < String > situationIds = new HashSet <> ( ) ; for ( ObaSituation situation : allSituations ) { situationIds . add ( situation . getId ( ) ) ; } assertEquals ( 7 , allSituations . size ( ) ) ; assertEquals ( 7 , situationIds . size ( ) ) ; assertTrue ( situationIds . contains ( "MTS_38" ) ) ; assertTrue ( situationIds . contains ( "MTS_37" ) ) ; assertTrue ( situationIds . contains ( "MTS_28" ) ) ; assertTrue ( situationIds . contains ( "MTS_34" ) ) ; assertTrue ( situationIds . contains ( "MTS_11" ) ) ; assertTrue ( situationIds . contains ( "MTS_33" ) ) ; assertTrue ( situationIds . contains ( "MTS_3" ) ) ; assertTrue ( allSituations . contains ( response . getSituation ( "MTS_38" ) ) ) ; assertTrue ( allSituations . contains ( response . getSituation ( "MTS_37" ) ) ) ; assertTrue ( allSituations . contains ( response . getSituation ( "MTS_28" ) ) ) ; assertTrue ( allSituations . contains ( response . getSituation ( "MTS_34" ) ) ) ; assertTrue ( allSituations . contains ( response . getSituation ( "MTS_11" ) ) ) ; assertTrue ( allSituations . contains ( response . getSituation ( "MTS_33" ) ) ) ; assertTrue ( allSituations . contains ( response . getSituation ( "MTS_3" ) ) ) ; response = new ObaArrivalInfoRequest . Builder ( getContext ( ) , "MTS_13353" ) . build ( ) . call ( ) ; assertOK ( response ) ; situations = response . getSituations ( ) ; assertNotNull ( situations ) ; assertEquals ( 1 , situations . size ( ) ) ; allSituations = UIUtils . getAllSituations ( response ) ; situationIds = new HashSet <> ( ) ; for ( ObaSituation situation : allSituations ) { situationIds . add ( situation . getId ( ) ) ; } assertEquals ( 5 , allSituations . size ( ) ) ; assertEquals ( 5 , situationIds . size ( ) ) ; assertTrue ( situationIds . contains ( "MTS_32" ) ) ; assertTrue ( situationIds . contains ( "MTS_34" ) ) ; assertTrue ( situationIds . contains ( "MTS_14" ) ) ; assertTrue ( situationIds . contains ( "MTS_13" ) ) ; assertTrue ( situationIds . contains ( "MTS_9c943ee8-d566-4cd8-8a89-a2a535ebe4fe" ) ) ; assertTrue ( allSituations . contains ( response . getSituation ( "MTS_32" ) ) ) ; assertTrue ( allSituations . contains ( response . getSituation ( "MTS_34" ) ) ) ; assertTrue ( allSituations . contains ( response . getSituation ( "MTS_14" ) ) ) ; assertTrue ( allSituations . contains ( response . getSituation ( "MTS_13" ) ) ) ; assertTrue ( allSituations . contains ( response . getSituations ( ) . get ( 0 ) ) ) ; }
public double getLat ( ) { return lat ; }
public double getLon ( ) { return lon ; }
public Location getLocation ( ) { return LocationUtils . makeLocation ( lat , lon ) ; }
public long getServiceDate ( )
public boolean isPredicted ( )
public long getScheduleDeviation ( )
public String getVehicleId ( )
public String getClosestStop ( )
public long getClosestStopTimeOffset ( )
public Location getPosition ( )
public String getActiveTripId ( )
public Double getDistanceAlongTrip ( )
public Double getScheduledDistanceAlongTrip ( )
public Double getTotalDistanceAlongTrip ( )
public Double getOrientation ( )
public String getNextStop ( )
public Long getNextStopTimeOffset ( )
public String getPhase ( )
public String getStatus ( )
public long getLastUpdateTime ( )
public Location getLastKnownLocation ( )
public long getLastLocationUpdateTime ( )
public Double getLastKnownOrientation ( )
public int getBlockTripSequence ( )
@ Override protected void onCreate ( Bundle savedInstanceState ) { settings = PreferenceManager . getDefaultSharedPreferences ( this . getApplicationContext ( ) ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . N_MR1 ) shortcutManager = getSystemService ( ShortcutManager .class ) ; activity = this ; PRNGFixes . apply ( ) ; if ( savedInstanceState != null && ( ! settings . getBoolean ( "git_external" , false ) || ContextCompat . checkSelfPermission ( activity , Manifest . permission . READ_EXTERNAL_STORAGE ) != PackageManager . PERMISSION_GRANTED ) ) { savedInstanceState = null ; } super. onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_pwdstore ) ; }
@ Override public void onResume ( ) { super. onResume ( ) ; if ( settings . getBoolean ( "git_external" , false ) ) { if ( ContextCompat . checkSelfPermission ( activity , Manifest . permission . READ_EXTERNAL_STORAGE ) != PackageManager . PERMISSION_GRANTED ) { if ( ActivityCompat . shouldShowRequestPermissionRationale ( activity , Manifest . permission . READ_EXTERNAL_STORAGE ) ) { Snackbar snack = Snackbar . make ( findViewById ( R . id . main_layout ) , "The store is on the sdcard but the app does not have permission to access it. Please give permission." , Snackbar . LENGTH_INDEFINITE ) . setAction ( R . string . dialog_ok , new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { ActivityCompat . requestPermissions ( activity , new String [] { Manifest . permission . READ_EXTERNAL_STORAGE } , REQUEST_EXTERNAL_STORAGE ) ; } } ) ; snack . show ( ) ; View view = snack . getView ( ) ; TextView tv = ( TextView ) view . findViewById ( android . support . design . R . id . snackbar_text ) ; tv . setTextColor ( Color . WHITE ) ; tv . setMaxLines ( 10 ) ; } else { ActivityCompat . requestPermissions ( activity , new String [] { Manifest . permission . READ_EXTERNAL_STORAGE } , REQUEST_EXTERNAL_STORAGE ) ; } } else { checkLocalRepository ( ) ; } } else { checkLocalRepository ( ) ; } }
@ Override public void onClick ( View view ) { ActivityCompat . requestPermissions ( activity , new String [] { Manifest . permission . READ_EXTERNAL_STORAGE } , REQUEST_EXTERNAL_STORAGE ) ; }
@ Override public void onRequestPermissionsResult ( int requestCode , String permissions [] , int [] grantResults ) { switch ( requestCode ) { case REQUEST_EXTERNAL_STORAGE : { if ( grantResults . length > 0 && grantResults [ 0 ] == PackageManager . PERMISSION_GRANTED ) { checkLocalRepository ( ) ; } } } }
@ Override public void onPause ( ) { super. onPause ( ) ; }
@ Override public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . main_menu , menu ) ; MenuItem searchItem = menu . findItem ( R . id . action_search ) ; SearchView searchView = ( SearchView ) MenuItemCompat . getActionView ( searchItem ) ; searchView . setOnQueryTextListener ( new SearchView . OnQueryTextListener ( ) { @ Override public boolean onQueryTextSubmit ( String s ) { return true ; } @ Override public boolean onQueryTextChange ( String s ) { filterListAdapter ( s ) ; return true ; } } ) ; MenuItemCompat . setOnActionExpandListener ( searchItem , new MenuItemCompat . OnActionExpandListener ( ) { @ Override public boolean onMenuItemActionCollapse ( MenuItem item ) { refreshListAdapter ( ) ; return true ; } @ Override public boolean onMenuItemActionExpand ( MenuItem item ) { return true ; } } ) ; return super. onCreateOptionsMenu ( menu ) ; }
@ Override public boolean onQueryTextSubmit ( String s ) { return true ; }
@ Override public boolean onQueryTextChange ( String s ) { filterListAdapter ( s ) ; return true ; }
@ Override public boolean onMenuItemActionCollapse ( MenuItem item ) { refreshListAdapter ( ) ; return true ; }
@ Override public boolean onMenuItemActionExpand ( MenuItem item ) { return true ; }
@ Override public boolean onOptionsItemSelected ( MenuItem item ) { int id = item . getItemId ( ) ; Intent intent ; Log . d ( "PASS" , "Menu item " + id + " pressed" ) ; AlertDialog . Builder initBefore = new AlertDialog . Builder ( this ) . setMessage ( this . getResources ( ) . getString ( R . string . creation_dialog_text ) ) . setPositiveButton ( this . getResources ( ) . getString ( R . string . dialog_ok ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialogInterface , int i ) {                    } } ) ; switch ( id ) { case R . id . user_pref : try { intent = new Intent ( this , UserPreference .class ) ; startActivity ( intent ) ; } catch ( Exception e ) { System . out . println ( "Exception caught :(" ) ; e . printStackTrace ( ) ; } return true ; case R . id . git_push : if ( ! PasswordRepository . isInitialized ( ) ) { initBefore . show ( ) ; break; } intent = new Intent ( this , GitActivity .class ) ; intent . putExtra ( "Operation" , GitActivity . REQUEST_PUSH ) ; startActivityForResult ( intent , GitActivity . REQUEST_PUSH ) ; return true ; case R . id . git_pull : if ( ! PasswordRepository . isInitialized ( ) ) { initBefore . show ( ) ; break; } intent = new Intent ( this , GitActivity .class ) ; intent . putExtra ( "Operation" , GitActivity . REQUEST_PULL ) ; startActivityForResult ( intent , GitActivity . REQUEST_PULL ) ; return true ; case R . id . git_sync : if ( ! PasswordRepository . isInitialized ( ) ) { initBefore . show ( ) ; break; } intent = new Intent ( this , GitActivity .class ) ; intent . putExtra ( "Operation" , GitActivity . REQUEST_SYNC ) ; startActivityForResult ( intent , GitActivity . REQUEST_SYNC ) ; return true ; case R . id . refresh : updateListAdapter ( ) ; return true ; case android . R . id . home : Log . d ( "PASS" , "Home pressed" ) ; this . onBackPressed ( ) ; break; default: break; } return super. onOptionsItemSelected ( item ) ; }
@ Override public void onClick ( DialogInterface dialogInterface , int i ) {                    }
public void openSettings ( View view ) { Intent intent ; try { intent = new Intent ( this , UserPreference .class ) ; startActivity ( intent ) ; } catch ( Exception e ) { System . out . println ( "Exception caught :(" ) ; e . printStackTrace ( ) ; } }
public void cloneExistingRepository ( View view ) { initRepository ( CLONE_REPO_BUTTON ) ; }
public void createNewRepository ( View view ) { initRepository ( NEW_REPO_BUTTON ) ; }
private void createRepository ( ) { if ( ! PasswordRepository . isInitialized ( ) ) { PasswordRepository . initialize ( this ) ; } File localDir = PasswordRepository . getRepositoryDirectory ( getApplicationContext ( ) ) ; localDir . mkdir ( ) ; try { PasswordRepository . createRepository ( localDir ) ; new File ( localDir . getAbsolutePath ( ) + "/.gpg-id" ) . createNewFile ( ) ; settings . edit ( ) . putBoolean ( "repository_initialized" , true ) . apply ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; localDir . delete ( ) ; return; } checkLocalRepository ( ) ; }
public void initializeRepositoryInfo ( ) { if ( settings . getBoolean ( "git_external" , false ) && settings . getString ( "git_external_repo" , null ) != null ) { File dir = new File ( settings . getString ( "git_external_repo" , null ) ) ; if ( dir . exists ( ) && dir . isDirectory ( ) && ! FileUtils . listFiles ( dir , null , true ) . isEmpty ( ) && ! PasswordRepository . getPasswords ( dir , PasswordRepository . getRepositoryDirectory ( this ) ) . isEmpty ( ) ) { PasswordRepository . closeRepository ( ) ; checkLocalRepository ( ) ; return; } } final Set < String > keyIds = settings . getStringSet ( "openpgp_key_ids_set" , new HashSet < String > ( ) ) ; if ( keyIds . isEmpty ( ) ) new AlertDialog . Builder ( this ) . setMessage ( this . getResources ( ) . getString ( R . string . key_dialog_text ) ) . setPositiveButton ( this . getResources ( ) . getString ( R . string . dialog_positive ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialogInterface , int i ) { Intent intent = new Intent ( activity , UserPreference .class ) ; startActivityForResult ( intent , GitActivity . REQUEST_INIT ) ; } } ) . setNegativeButton ( this . getResources ( ) . getString ( R . string . dialog_negative ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialogInterface , int i ) { } } ) . show ( ) ; createRepository ( ) ; }
@ Override public void onClick ( DialogInterface dialogInterface , int i ) { Intent intent = new Intent ( activity , UserPreference .class ) ; startActivityForResult ( intent , GitActivity . REQUEST_INIT ) ; }
@ Override public void onClick ( DialogInterface dialogInterface , int i ) { }
private void checkLocalRepository ( ) { Repository repo = PasswordRepository . initialize ( this ) ; if ( repo == null ) { Intent intent = new Intent ( activity , UserPreference .class ) ; intent . putExtra ( "operation" , "git_external" ) ; startActivityForResult ( intent , HOME ) ; } else { checkLocalRepository ( PasswordRepository . getRepositoryDirectory ( getApplicationContext ( ) ) ) ; } }
private void checkLocalRepository ( File localDir ) { FragmentManager fragmentManager = getSupportFragmentManager ( ) ; FragmentTransaction fragmentTransaction = fragmentManager . beginTransaction ( ) ; if ( localDir != null && settings . getBoolean ( "repository_initialized" , false ) ) { Log . d ( "PASS" , "Check, dir: " + localDir . getAbsolutePath ( ) ) ; if ( fragmentManager . findFragmentByTag ( "PasswordsList" ) == null || settings . getBoolean ( "repo_changed" , false ) ) { settings . edit ( ) . putBoolean ( "repo_changed" , false ) . apply ( ) ; plist = new PasswordFragment ( ) ; Bundle args = new Bundle ( ) ; args . putString ( "Path" , PasswordRepository . getRepositoryDirectory ( getApplicationContext ( ) ) . getAbsolutePath ( ) ) ; if ( getIntent ( ) . getBooleanExtra ( "matchWith" , false ) ) { args . putBoolean ( "matchWith" , true ) ; } plist . setArguments ( args ) ; getSupportActionBar ( ) . show ( ) ; getSupportActionBar ( ) . setDisplayHomeAsUpEnabled ( false ) ; fragmentManager . popBackStack ( null , FragmentManager . POP_BACK_STACK_INCLUSIVE ) ; fragmentTransaction . replace ( R . id . main_layout , plist , "PasswordsList" ) ; fragmentTransaction . commit ( ) ; } } else { getSupportActionBar ( ) . hide ( ) ; fragmentManager . popBackStack ( null , FragmentManager . POP_BACK_STACK_INCLUSIVE ) ; ToCloneOrNot cloneFrag = new ToCloneOrNot ( ) ; fragmentTransaction . replace ( R . id . main_layout , cloneFrag , "ToCloneOrNot" ) ; fragmentTransaction . commit ( ) ; } }
@ Override public void onBackPressed ( ) { if ( ( null != plist ) && plist . isNotEmpty ( ) ) { plist . popBack ( ) ; } else { super. onBackPressed ( ) ; } if ( null != plist && ! plist . isNotEmpty ( ) ) { getSupportActionBar ( ) . setDisplayHomeAsUpEnabled ( false ) ; } }
public void decryptPassword ( PasswordItem item ) { Intent intent = new Intent ( this , PgpHandler .class ) ; intent . putExtra ( "NAME" , item . toString ( ) ) ; intent . putExtra ( "FILE_PATH" , item . getFile ( ) . getAbsolutePath ( ) ) ; intent . putExtra ( "Operation" , "DECRYPT" ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . N_MR1 ) { ShortcutInfo shortcut = new ShortcutInfo . Builder ( this , item . getFullPathName ( ) ) . setShortLabel ( item . toString ( ) ) . setLongLabel ( item . getFullPathName ( ) + item . toString ( ) ) . setIcon ( Icon . createWithResource ( this , R . drawable . ic_launcher ) ) . setIntent ( intent . setAction ( "DECRYPT_PASS" ) ) . build ( ) ; shortcutManager . addDynamicShortcuts ( Arrays . asList ( shortcut ) ) ; } startActivityForResult ( intent , PgpHandler . REQUEST_CODE_DECRYPT_AND_VERIFY ) ; }
public void editPassword ( PasswordItem item ) { Intent intent = new Intent ( this , PgpHandler .class ) ; intent . putExtra ( "NAME" , item . toString ( ) ) ; intent . putExtra ( "FILE_PATH" , item . getFile ( ) . getAbsolutePath ( ) ) ; intent . putExtra ( "Operation" , "EDIT" ) ; startActivityForResult ( intent , PgpHandler . REQUEST_CODE_EDIT ) ; }
public void createPassword ( ) { if ( ! PasswordRepository . isInitialized ( ) ) { new AlertDialog . Builder ( this ) . setMessage ( this . getResources ( ) . getString ( R . string . creation_dialog_text ) ) . setPositiveButton ( this . getResources ( ) . getString ( R . string . dialog_ok ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialogInterface , int i ) {                        } } ) . show ( ) ; return; } if ( settings . getStringSet ( "openpgp_key_ids_set" , new HashSet < String > ( ) ) . isEmpty ( ) ) { new AlertDialog . Builder ( this ) . setTitle ( "OpenPGP key not selected" ) . setMessage ( "We will redirect you to settings. Please select your OpenPGP Key." ) . setPositiveButton ( this . getResources ( ) . getString ( R . string . dialog_ok ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialogInterface , int i ) { Intent intent = new Intent ( activity , UserPreference .class ) ; startActivity ( intent ) ; } } ) . show ( ) ; return; } this . currentDir = getCurrentDir ( ) ; Log . i ( "PWDSTR" , "Adding file to : " + this . currentDir . getAbsolutePath ( ) ) ; Intent intent = new Intent ( this , PgpHandler .class ) ; intent . putExtra ( "FILE_PATH" , getCurrentDir ( ) . getAbsolutePath ( ) ) ; intent . putExtra ( "Operation" , "ENCRYPT" ) ; startActivityForResult ( intent , PgpHandler . REQUEST_CODE_ENCRYPT ) ; }
@ Override public void onClick ( DialogInterface dialogInterface , int i ) {                        }
@ Override public void onClick ( DialogInterface dialogInterface , int i ) { Intent intent = new Intent ( activity , UserPreference .class ) ; startActivity ( intent ) ; }
public void deletePasswords ( final PasswordRecyclerAdapter adapter , final Set < Integer > selectedItems ) { final Iterator it = selectedItems . iterator ( ) ; if ( ! it . hasNext ( ) ) { return; } final int position = ( int ) it . next ( ) ; final PasswordItem item = adapter . getValues ( ) . get ( position ) ; new AlertDialog . Builder ( this ) . setMessage ( this . getResources ( ) . getString ( R . string . delete_dialog_text ) + item + "\"" ) . setPositiveButton ( this . getResources ( ) . getString ( R . string . dialog_yes ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialogInterface , int i ) { item . getFile ( ) . delete ( ) ; adapter . remove ( position ) ; it . remove ( ) ; adapter . updateSelectedItems ( position , selectedItems ) ; commit ( "[ANDROID PwdStore] Remove " + item + " from store." ) ; deletePasswords ( adapter , selectedItems ) ; } } ) . setNegativeButton ( this . getResources ( ) . getString ( R . string . dialog_no ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialogInterface , int i ) { it . remove ( ) ; deletePasswords ( adapter , selectedItems ) ; } } ) . show ( ) ; }
@ Override public void onClick ( DialogInterface dialogInterface , int i ) { item . getFile ( ) . delete ( ) ; adapter . remove ( position ) ; it . remove ( ) ; adapter . updateSelectedItems ( position , selectedItems ) ; commit ( "[ANDROID PwdStore] Remove " + item + " from store." ) ; deletePasswords ( adapter , selectedItems ) ; }
@ Override public void onClick ( DialogInterface dialogInterface , int i ) { it . remove ( ) ; deletePasswords ( adapter , selectedItems ) ; }
public void movePasswords ( ArrayList < PasswordItem > values ) { Intent intent = new Intent ( this , PgpHandler .class ) ; ArrayList < String > fileLocations = new ArrayList <> ( ) ; for ( PasswordItem passwordItem : values ) { fileLocations . add ( passwordItem . getFile ( ) . getAbsolutePath ( ) ) ; } intent . putExtra ( "Files" , fileLocations ) ; intent . putExtra ( "Operation" , "SELECTFOLDER" ) ; startActivityForResult ( intent , PgpHandler . REQUEST_CODE_SELECT_FOLDER ) ; }
public void updateListAdapter ( ) { if ( ( null != plist ) ) { plist . updateAdapter ( ) ; } }
public void refreshListAdapter ( ) { if ( ( null != plist ) ) { plist . refreshAdapter ( ) ; } }
public void filterListAdapter ( String filter ) { if ( ( null != plist ) ) { plist . filterAdapter ( filter ) ; } }
private File getCurrentDir ( ) { if ( ( null != plist ) ) { return plist . getCurrentDir ( ) ; } return PasswordRepository . getRepositoryDirectory ( getApplicationContext ( ) ) ; }
private void commit ( final String message ) { new GitOperation ( PasswordRepository . getRepositoryDirectory ( activity ) , activity ) { @ Override public void execute ( ) { Log . d ( TAG , "Commiting with message " + message ) ; Git git = new Git ( this . repository ) ; GitAsyncTask tasks = new GitAsyncTask ( activity , false , true , this ) ; tasks . execute ( git . add ( ) . addFilepattern ( "." ) , git . commit ( ) . setMessage ( message ) ) ; } } . execute ( ) ; }
@ Override public void execute ( ) { Log . d ( TAG , "Commiting with message " + message ) ; Git git = new Git ( this . repository ) ; GitAsyncTask tasks = new GitAsyncTask ( activity , false , true , this ) ; tasks . execute ( git . add ( ) . addFilepattern ( "." ) , git . commit ( ) . setMessage ( message ) ) ; }
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { if ( resultCode == RESULT_OK ) { switch ( requestCode ) { case GitActivity . REQUEST_CLONE : settings . edit ( ) . putBoolean ( "repository_initialized" , true ) . apply ( ) ; break; case PgpHandler . REQUEST_CODE_DECRYPT_AND_VERIFY : if ( data . getBooleanExtra ( "needCommit" , false ) ) { commit ( this . getResources ( ) . getString ( R . string . edit_commit_text ) + data . getExtras ( ) . getString ( "NAME" ) ) ; refreshListAdapter ( ) ; } break; case PgpHandler . REQUEST_CODE_ENCRYPT : commit ( this . getResources ( ) . getString ( R . string . add_commit_text ) + data . getExtras ( ) . getString ( "NAME" ) + this . getResources ( ) . getString ( R . string . from_store ) ) ; refreshListAdapter ( ) ; break; case PgpHandler . REQUEST_CODE_EDIT : commit ( this . getResources ( ) . getString ( R . string . edit_commit_text ) + data . getExtras ( ) . getString ( "NAME" ) ) ; refreshListAdapter ( ) ; break; case GitActivity . REQUEST_INIT : initializeRepositoryInfo ( ) ; break; case GitActivity . REQUEST_SYNC : case GitActivity . REQUEST_PULL : updateListAdapter ( ) ; break; case HOME : checkLocalRepository ( ) ; break; case NEW_REPO_BUTTON : initializeRepositoryInfo ( ) ; break; case CLONE_REPO_BUTTON : if ( settings . getBoolean ( "git_external" , false ) && settings . getString ( "git_external_repo" , null ) != null ) { String externalRepoPath = settings . getString ( "git_external_repo" , null ) ; File dir = externalRepoPath != null ? new File ( externalRepoPath ) : null ; if ( dir != null && dir . exists ( ) && dir . isDirectory ( ) && ! FileUtils . listFiles ( dir , null , true ) . isEmpty ( ) && ! PasswordRepository . getPasswords ( dir , PasswordRepository . getRepositoryDirectory ( this ) ) . isEmpty ( ) ) { PasswordRepository . closeRepository ( ) ; checkLocalRepository ( ) ; return; } } Intent intent = new Intent ( activity , GitActivity .class ) ; intent . putExtra ( "Operation" , GitActivity . REQUEST_CLONE ) ; startActivityForResult ( intent , GitActivity . REQUEST_CLONE ) ; break; case PgpHandler . REQUEST_CODE_SELECT_FOLDER : Log . d ( "Moving" , "Moving passwords to " + data . getStringExtra ( "SELECTED_FOLDER_PATH" ) ) ; Log . d ( "Moving" , TextUtils . join ( ", " , data . getStringArrayListExtra ( "Files" ) ) ) ; File target = new File ( data . getStringExtra ( "SELECTED_FOLDER_PATH" ) ) ; if ( ! target . isDirectory ( ) ) { Log . e ( "Moving" , "Tried moving passwords to a non-existing folder." ) ; break; } for ( String string : data . getStringArrayListExtra ( "Files" ) ) { File source = new File ( string ) ; if ( ! source . exists ( ) ) { Log . e ( "Moving" , "Tried moving something that appears non-existent." ) ; continue; } if ( ! source . renameTo ( new File ( target . getAbsolutePath ( ) + "/" + source . getName ( ) ) ) ) { Log . e ( "Moving" , "Something went wrong while moving." ) ; } else { commit ( "[ANDROID PwdStore] Moved " + string . replace ( PasswordRepository . getRepositoryDirectory ( getApplicationContext ( ) ) + "/" , "" ) + " to " + target . getAbsolutePath ( ) . replace ( PasswordRepository . getRepositoryDirectory ( getApplicationContext ( ) ) + "/" , "" ) + target . getAbsolutePath ( ) + "/" + source . getName ( ) + "." ) ; } } updateListAdapter ( ) ; break; } } }
protected void initRepository ( final int operation ) { PasswordRepository . closeRepository ( ) ; new AlertDialog . Builder ( this ) . setTitle ( "Repository location" ) . setMessage ( "Select where to create or clone your password repository." ) . setPositiveButton ( "Hidden (preferred)" , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int whichButton ) { settings . edit ( ) . putBoolean ( "git_external" , false ) . apply ( ) ; switch ( operation ) { case NEW_REPO_BUTTON : initializeRepositoryInfo ( ) ; break; case CLONE_REPO_BUTTON : PasswordRepository . initialize ( PasswordStore .this ) ; Intent intent = new Intent ( activity , GitActivity .class ) ; intent . putExtra ( "Operation" , GitActivity . REQUEST_CLONE ) ; startActivityForResult ( intent , GitActivity . REQUEST_CLONE ) ; break; } } } ) . setNegativeButton ( "SD-Card" , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int whichButton ) { settings . edit ( ) . putBoolean ( "git_external" , true ) . apply ( ) ; if ( settings . getString ( "git_external_repo" , null ) == null ) { Intent intent = new Intent ( activity , UserPreference .class ) ; intent . putExtra ( "operation" , "git_external" ) ; startActivityForResult ( intent , operation ) ; } else { new AlertDialog . Builder ( activity ) . setTitle ( "Directory already selected" ) . setMessage ( "Do you want to use \"" + settings . getString ( "git_external_repo" , null ) + "\"?" ) . setPositiveButton ( "Use" , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { switch ( operation ) { case NEW_REPO_BUTTON : initializeRepositoryInfo ( ) ; break; case CLONE_REPO_BUTTON : PasswordRepository . initialize ( PasswordStore .this ) ; Intent intent = new Intent ( activity , GitActivity .class ) ; intent . putExtra ( "Operation" , GitActivity . REQUEST_CLONE ) ; startActivityForResult ( intent , GitActivity . REQUEST_CLONE ) ; break; } } } ) . setNegativeButton ( "Change" , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { Intent intent = new Intent ( activity , UserPreference .class ) ; intent . putExtra ( "operation" , "git_external" ) ; startActivityForResult ( intent , operation ) ; } } ) . show ( ) ; } } } ) . show ( ) ; }
public void onClick ( DialogInterface dialog , int whichButton ) { settings . edit ( ) . putBoolean ( "git_external" , false ) . apply ( ) ; switch ( operation ) { case NEW_REPO_BUTTON : initializeRepositoryInfo ( ) ; break; case CLONE_REPO_BUTTON : PasswordRepository . initialize ( PasswordStore .this ) ; Intent intent = new Intent ( activity , GitActivity .class ) ; intent . putExtra ( "Operation" , GitActivity . REQUEST_CLONE ) ; startActivityForResult ( intent , GitActivity . REQUEST_CLONE ) ; break; } }
public void onClick ( DialogInterface dialog , int whichButton ) { settings . edit ( ) . putBoolean ( "git_external" , true ) . apply ( ) ; if ( settings . getString ( "git_external_repo" , null ) == null ) { Intent intent = new Intent ( activity , UserPreference .class ) ; intent . putExtra ( "operation" , "git_external" ) ; startActivityForResult ( intent , operation ) ; } else { new AlertDialog . Builder ( activity ) . setTitle ( "Directory already selected" ) . setMessage ( "Do you want to use \"" + settings . getString ( "git_external_repo" , null ) + "\"?" ) . setPositiveButton ( "Use" , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { switch ( operation ) { case NEW_REPO_BUTTON : initializeRepositoryInfo ( ) ; break; case CLONE_REPO_BUTTON : PasswordRepository . initialize ( PasswordStore .this ) ; Intent intent = new Intent ( activity , GitActivity .class ) ; intent . putExtra ( "Operation" , GitActivity . REQUEST_CLONE ) ; startActivityForResult ( intent , GitActivity . REQUEST_CLONE ) ; break; } } } ) . setNegativeButton ( "Change" , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { Intent intent = new Intent ( activity , UserPreference .class ) ; intent . putExtra ( "operation" , "git_external" ) ; startActivityForResult ( intent , operation ) ; } } ) . show ( ) ; } }
@ Override public void onClick ( DialogInterface dialog , int which ) { switch ( operation ) { case NEW_REPO_BUTTON : initializeRepositoryInfo ( ) ; break; case CLONE_REPO_BUTTON : PasswordRepository . initialize ( PasswordStore .this ) ; Intent intent = new Intent ( activity , GitActivity .class ) ; intent . putExtra ( "Operation" , GitActivity . REQUEST_CLONE ) ; startActivityForResult ( intent , GitActivity . REQUEST_CLONE ) ; break; } }
@ Override public void onClick ( DialogInterface dialog , int which ) { Intent intent = new Intent ( activity , UserPreference .class ) ; intent . putExtra ( "operation" , "git_external" ) ; startActivityForResult ( intent , operation ) ; }
public void matchPasswordWithApp ( PasswordItem item ) { String path = item . getFile ( ) . getAbsolutePath ( ) ; path = path . replace ( PasswordRepository . getRepositoryDirectory ( getApplicationContext ( ) ) + "/" , "" ) . replace ( ".gpg" , "" ) ; Intent data = new Intent ( ) ; data . putExtra ( "path" , path ) ; setResult ( RESULT_OK , data ) ; finish ( ) ; }
@ Override public Cursor onQuery ( T helper , SQLiteDatabase db , MatcherPattern target , QueryParameters parameter ) { Cursor result = null ; SQLiteQueryBuilder builder = new SQLiteQueryBuilder ( ) ; builder . setTables ( target . getTableInfo ( ) . getName ( ) ) ; builder . setProjectionMap ( target . getTableInfo ( ) . getProjectionMap ( ) ) ; switch ( target . getMimeTypeVnd ( ) . getSubType ( ) ) { case ITEM : builder . appendWhere ( target . getTableInfo ( ) . getIdColumnInfo ( ) . getColumnName ( ) ) ; builder . appendWhere ( "=" ) ; builder . appendWhere ( parameter . getUri ( ) . getPathSegments ( ) . get ( 1 ) ) ; break; case DIRECTORY : default: break; } String orderBy = getSortOrderStringForQuery ( target , parameter ) ; result = builder . query ( db , parameter . getProjection ( ) , parameter . getSelection ( ) , parameter . getSelectionArgs ( ) , null , null , orderBy ) ; return result ; }
@ Override public Uri onInsert ( T helper , SQLiteDatabase db , MatcherPattern target , InsertParameters parameter ) { Uri result = null ; long id = db . insert ( target . getTableInfo ( ) . getName ( ) , null , parameter . getValues ( ) ) ; if ( id >= 0 ) { result = ContentUris . withAppendedId ( target . getContentUriPattern ( ) , id ) ; } else { throw new SQLException ( "Failed to insert row into : " + parameter . getUri ( ) . toString ( ) ) ; } return result ; }
@ Override public int onDelete ( T helper , SQLiteDatabase db , MatcherPattern target , DeleteParameters parameter ) { int result = - 1 ; switch ( target . getMimeTypeVnd ( ) . getSubType ( ) ) { case DIRECTORY : result = db . delete ( target . getTableInfo ( ) . getName ( ) , parameter . getSelection ( ) , parameter . getSelectionArgs ( ) ) ; break; case ITEM : String where = target . getTableInfo ( ) . getIdColumnInfo ( ) . getColumnName ( ) + "=" + parameter . getUri ( ) . getPathSegments ( ) . get ( 1 ) ; if ( parameter . getSelection ( ) != null && parameter . getSelection ( ) . length ( ) >= 1 ) { where += " AND ( " + parameter . getSelection ( ) + " ) " ; } result = db . delete ( target . getTableInfo ( ) . getName ( ) , where , parameter . getSelectionArgs ( ) ) ; break; default: break; } return result ; }
@ Override public int onUpdate ( T helper , SQLiteDatabase db , MatcherPattern target , UpdateParameters parameter ) { int result = - 1 ; switch ( target . getMimeTypeVnd ( ) . getSubType ( ) ) { case DIRECTORY : result = db . update ( target . getTableInfo ( ) . getName ( ) , parameter . getValues ( ) , parameter . getSelection ( ) , parameter . getSelectionArgs ( ) ) ; break; case ITEM : String where = target . getTableInfo ( ) . getIdColumnInfo ( ) . getColumnName ( ) + "=" + parameter . getUri ( ) . getPathSegments ( ) . get ( 1 ) ; if ( parameter . getSelection ( ) != null && parameter . getSelection ( ) . length ( ) >= 1 ) { where += " AND ( " + parameter . getSelection ( ) + " ) " ; } result = db . update ( target . getTableInfo ( ) . getName ( ) , parameter . getValues ( ) , where , parameter . getSelectionArgs ( ) ) ; break; default: break; } return result ; }
protected String getSortOrderStringForQuery ( MatcherPattern target , QueryParameters parameter ) { String result = "" ; if ( parameter . getSortOrder ( ) != null && parameter . getSortOrder ( ) . length ( ) >= 1 ) { result = parameter . getSortOrder ( ) ; } else { result = target . getTableInfo ( ) . getDefaultSortOrderString ( ) ; } return result ; }
public static void setInitMainThreadSchedulerHandler ( Function < Callable < Scheduler > , Scheduler > handler ) { onInitMainThreadHandler = handler ; }
public static Scheduler initMainThreadScheduler ( Callable < Scheduler > scheduler ) { if ( scheduler == null ) { throw new NullPointerException ( "scheduler == null" ) ; } Function < Callable < Scheduler > , Scheduler > f = onInitMainThreadHandler ; if ( f == null ) { return callRequireNonNull ( scheduler ) ; } return applyRequireNonNull ( f , scheduler ) ; }
public static void setMainThreadSchedulerHandler ( Function < Scheduler , Scheduler > handler ) { onMainThreadHandler = handler ; }
public static Scheduler onMainThreadScheduler ( Scheduler scheduler ) { if ( scheduler == null ) { throw new NullPointerException ( "scheduler == null" ) ; } Function < Scheduler , Scheduler > f = onMainThreadHandler ; if ( f == null ) { return scheduler ; } return apply ( f , scheduler ) ; }
public static Function < Callable < Scheduler > , Scheduler > getInitMainThreadSchedulerHandler ( ) { return onInitMainThreadHandler ; }
public static Function < Scheduler , Scheduler > getOnMainThreadSchedulerHandler ( ) { return onMainThreadHandler ; }
public static void reset ( ) { setInitMainThreadSchedulerHandler ( null ) ; setMainThreadSchedulerHandler ( null ) ; }
static Scheduler callRequireNonNull ( Callable < Scheduler > s ) { try { Scheduler scheduler = s . call ( ) ; if ( scheduler == null ) { throw new NullPointerException ( "Scheduler Callable returned null" ) ; } return scheduler ; } catch ( Throwable ex ) { throw Exceptions . propagate ( ex ) ; } }
static Scheduler applyRequireNonNull ( Function < Callable < Scheduler > , Scheduler > f , Callable < Scheduler > s ) { Scheduler scheduler = apply ( f , s ) ; if ( scheduler == null ) { throw new NullPointerException ( "Scheduler Callable returned null" ) ; } return scheduler ; }
static < T , R > R apply ( Function < T , R > f , T t ) { try { return f . apply ( t ) ; } catch ( Throwable ex ) { throw Exceptions . propagate ( ex ) ; } }
private RxAndroidPlugins ( ) { throw new AssertionError ( "No instances." ) ; }
public ToastAssert ( Toast actual ) { super( actual , ToastAssert .class ); }
public ToastAssert hasDuration ( int duration ) { isNotNull ( ) ; int actualDuration = actual . getDuration ( ) ; assertThat ( actualDuration ) . overridingErrorMessage ( "Expected duration <%s> but was <%s>." , duration , actualDuration ) . isEqualTo ( duration ) ; return this ; }
public ToastAssert hasGravity ( int gravity ) { isNotNull ( ) ; int actualGravity = actual . getGravity ( ) ; assertThat ( actualGravity ) . overridingErrorMessage ( "Expected gravity <%s> but was <%s>." , gravity , actualGravity ) . isEqualTo ( gravity ) ; return this ; }
public ToastAssert hasHorizontalMargin ( float margin ) { isNotNull ( ) ; float actualMargin = actual . getHorizontalMargin ( ) ; assertThat ( actualMargin ) . overridingErrorMessage ( "Expected horizontal margin <%s> but was <%s>." , margin , actualMargin ) . isEqualTo ( margin ) ; return this ; }
public ToastAssert hasVerticalMargin ( float margin ) { isNotNull ( ) ; float actualMargin = actual . getVerticalMargin ( ) ; assertThat ( actualMargin ) . overridingErrorMessage ( "Expected vertical margin <%s> but was <%s>." , margin , actualMargin ) . isEqualTo ( margin ) ; return this ; }
public ToastAssert hasView ( View view ) { isNotNull ( ) ; View actualView = actual . getView ( ) ; assertThat ( actualView ) . overridingErrorMessage ( "Expected view <%s> but was <%s>." , view , actualView ) . isSameAs ( view ) ; return this ; }
public ToastAssert hasXOffset ( int offset ) { isNotNull ( ) ; int actualOffset = actual . getXOffset ( ) ; assertThat ( actualOffset ) . overridingErrorMessage ( "Expected X offset <%s> but was <%s>." , offset , actualOffset ) . isEqualTo ( offset ) ; return this ; }
public ToastAssert hasYOffset ( int offset ) { isNotNull ( ) ; int actualOffset = actual . getYOffset ( ) ; assertThat ( actualOffset ) . overridingErrorMessage ( "Expected Y offset <%s> but was <%s>." , offset , actualOffset ) . isEqualTo ( offset ) ; return this ; }
protected ObaRoutesForLocationRequest ( Uri uri ) { super( uri ); }
public Builder ( Context context , Location location ) { super( context , BASE_PATH + "/routes-for-location.json" ); mBuilder . appendQueryParameter ( "lat" , String . valueOf ( location . getLatitude ( ) ) ) ; mBuilder . appendQueryParameter ( "lon" , String . valueOf ( location . getLongitude ( ) ) ) ; }
public Builder setRadius ( int radius ) { mBuilder . appendQueryParameter ( "radius" , String . valueOf ( radius ) ) ; return this ; }
public Builder setSpan ( double latSpan , double lonSpan ) { mBuilder . appendQueryParameter ( "latSpan" , String . valueOf ( latSpan ) ) ; mBuilder . appendQueryParameter ( "lonSpan" , String . valueOf ( lonSpan ) ) ; return this ; }
public Builder setSpan ( int latSpan , int lonSpan ) { mBuilder . appendQueryParameter ( "latSpan" , String . valueOf ( latSpan / 1E6 ) ) ; mBuilder . appendQueryParameter ( "lonSpan" , String . valueOf ( lonSpan / 1E6 ) ) ; return this ; }
public Builder setQuery ( String query ) { mBuilder . appendQueryParameter ( "query" , query ) ; return this ; }
public ObaRoutesForLocationRequest build ( ) { return new ObaRoutesForLocationRequest ( buildUri ( ) ) ; }
@ Override public ObaRoutesForLocationResponse call ( ) { return call ( ObaRoutesForLocationResponse .class ) ; }
@ Override public String toString ( ) { return "ObaRoutesForLocationRequest [mUri=" + mUri + "]" ; }
public static void show ( AppCompatActivity activity , ObaStop stop , Integer containerViewId ) { FragmentManager fm = activity . getSupportFragmentManager ( ) ; Bundle args = new Bundle ( ) ; args . putString ( STOP_ID , stop . getId ( ) ) ; args . putString ( STOP_NAME , stop . getName ( ) ) ; ReportStopProblemFragment content = new ReportStopProblemFragment ( ) ; content . setArguments ( args ) ; FragmentTransaction ft = fm . beginTransaction ( ) ; if ( containerViewId == null ) { ft . replace ( android . R . id . content , content , TAG ) ; } else { ft . replace ( containerViewId , content , TAG ) ; } ft . addToBackStack ( null ) ; try { ft . commit ( ) ; } catch ( IllegalStateException e ) { Log . e ( TAG , "Cannot show ReportStopProblemFragment after onSaveInstanceState has been called" ) ; } }
@ Override protected int getLayoutId ( ) { return R . layout . report_stop_problem ; }
@ Override public void onViewCreated ( View view , Bundle savedInstanceState ) { mCodeView = ( Spinner ) view . findViewById ( R . id . report_problem_code ) ; ArrayAdapter < ? > adapter = ArrayAdapter . createFromResource ( getActivity ( ) , R . array . report_stop_problem_code , android . R . layout . simple_spinner_item ) ; adapter . setDropDownViewResource ( android . R . layout . simple_spinner_dropdown_item ) ; mCodeView . setAdapter ( adapter ) ; mUserComment = ( TextView ) view . findViewById ( R . id . report_problem_comment ) ; if ( savedInstanceState != null ) { int position = savedInstanceState . getInt ( CODE ) ; mCodeView . setSelection ( position ) ; CharSequence comment = savedInstanceState . getCharSequence ( USER_COMMENT ) ; mUserComment . setText ( comment ) ; } SPINNER_TO_CODE = new String [] { null , ObaReportProblemWithStopRequest . NAME_WRONG , ObaReportProblemWithStopRequest . NUMBER_WRONG , ObaReportProblemWithStopRequest . LOCATION_WRONG , ObaReportProblemWithStopRequest . ROUTE_OR_TRIP_MISSING , ObaReportProblemWithStopRequest . OTHER } ; setupIconColors ( ) ; }
private void setupIconColors ( ) { ( ( ImageView ) getActivity ( ) . findViewById ( R . id . ic_category ) ) . setColorFilter ( getResources ( ) . getColor ( R . color . material_gray ) ) ; ( ( ImageView ) getActivity ( ) . findViewById ( R . id . ic_action_info ) ) . setColorFilter ( getResources ( ) . getColor ( R . color . material_gray ) ) ; }
@ Override public void onSaveInstanceState ( Bundle outState ) { super. onSaveInstanceState ( outState ) ; outState . putInt ( CODE , mCodeView . getSelectedItemPosition ( ) ) ; outState . putCharSequence ( USER_COMMENT , mUserComment . getText ( ) ) ; }
@ Override protected void sendReport ( ) { InputMethodManager imm = ( InputMethodManager ) getActivity ( ) . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; imm . hideSoftInputFromWindow ( mUserComment . getWindowToken ( ) , 0 ) ; if ( isReportArgumentsValid ( ) ) { ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . SUBMIT . toString ( ) , getString ( R . string . analytics_action_problem ) , getString ( R . string . analytics_label_report_stop_problem ) ) ; super. sendReport ( ) ; } else { Toast . makeText ( getActivity ( ) , getString ( R . string . report_problem_invalid_argument ) , Toast . LENGTH_LONG ) . show ( ) ; } }
@ Override protected ReportLoader createLoader ( Bundle args ) { String stopId = args . getString ( STOP_ID ) ; ObaReportProblemWithStopRequest . Builder builder = new ObaReportProblemWithStopRequest . Builder ( getActivity ( ) , stopId ) ; String code = SPINNER_TO_CODE [ mCodeView . getSelectedItemPosition ( ) ] ; if ( code != null ) { builder . setCode ( code ) ; } CharSequence comment = mUserComment . getText ( ) ; if ( ! TextUtils . isEmpty ( comment ) ) { builder . setUserComment ( comment . toString ( ) ) ; } Location location = Application . getLastKnownLocation ( getActivity ( ) , mGoogleApiClient ) ; if ( location != null ) { builder . setUserLocation ( location . getLatitude ( ) , location . getLongitude ( ) ) ; if ( location . hasAccuracy ( ) ) { builder . setUserLocationAccuracy ( ( int ) location . getAccuracy ( ) ) ; } } return new ReportLoader ( getActivity ( ) , builder . build ( ) ) ; }
public MavenErrorReporter ( ILogger logger , @ NonNull EvaluationMode mode ) { super( mode ); this . logger = logger ; }
@ Override public SyncIssue handleIssue ( String data , int type , int i1 , String msg ) { logger . info ( "Sync Error.  Data: " + data + "\tmsg: " + msg ) ; return new SyncIssueImpl ( 0 , type , data , msg ) ; }
@ Override public void receiveMessage ( Message message ) { logger . info ( message . toString ( ) ) ; }
SyncIssueImpl ( int severity , int type , String data , String message ) { this . severity = severity ; this . type = type ; this . data = data ; this . message = message ; }
@ Override public int getSeverity ( ) { return severity ; }
@ Override public int getType ( ) { return type ; }
@ Override public String getData ( ) { return data ; }
@ Override public String getMessage ( ) { return message ; }
@ Override public void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; UIUtils . setupActionBar ( this ) ; FragmentManager fm = getSupportFragmentManager ( ) ; if ( fm . findFragmentById ( android . R . id . content ) == null ) { MyRemindersFragment list = new MyRemindersFragment ( ) ; fm . beginTransaction ( ) . add ( android . R . id . content , list ) . commit ( ) ; } }
@ Override public boolean onOptionsItemSelected ( MenuItem item ) { if ( item . getItemId ( ) == android . R . id . home ) { NavHelp . goHome ( this , false ) ; return true ; } return false ; }
public static final void start ( Context context , String focusId , double lat , double lon ) { context . startActivity ( makeIntent ( context , focusId , lat , lon ) ) ; }
public static final void start ( Context context , String routeId ) { context . startActivity ( makeIntent ( context , routeId ) ) ; }
public static final Intent makeIntent ( Context context , String focusId , double lat , double lon ) { Intent myIntent = new Intent ( context , MapViewActivity .class ) ; myIntent . putExtra ( FOCUS_STOP_ID , focusId ) ; myIntent . putExtra ( CENTER_LAT , lat ) ; myIntent . putExtra ( CENTER_LON , lon ) ; return myIntent ; }
public static final Intent makeIntent ( Context context , String routeId ) { Intent myIntent = new Intent ( context , MapViewActivity .class ) ; myIntent . putExtra ( ROUTE_ID , routeId ) ; return myIntent ; }
@ Override public void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; requestWindowFeature ( Window . FEATURE_INDETERMINATE_PROGRESS ) ; setContentView ( R . layout . main ) ; mMapView = ( MapView ) findViewById ( R . id . mapview ) ; mMapView . setBuiltInZoomControls ( false ) ; mZoomControls = ( ZoomControls ) findViewById ( R . id . zoom_controls ) ; mZoomControls . setOnZoomInClickListener ( mOnZoomIn ) ; mZoomControls . setOnZoomOutClickListener ( mOnZoomOut ) ; mStopsController = new StopsController ( this , this ) ; UIHelp . setChildClickable ( this , R . id . show_arrival_info , mOnShowArrivals ) ; UIHelp . setChildClickable ( this , R . id . show_routes , mOnShowRoutes ) ; Bundle bundle = getIntent ( ) . getExtras ( ) ; if ( bundle != null ) { mRouteId = bundle . getString ( ROUTE_ID ) ; mFocusStopId = bundle . getString ( FOCUS_STOP_ID ) ; mapValuesFromBundle ( bundle ) ; } if ( savedInstanceState != null ) { mFocusStopId = savedInstanceState . getString ( FOCUS_STOP_ID ) ; mShowRoutes = savedInstanceState . getBoolean ( SHOW_ROUTES ) ; mapValuesFromBundle ( savedInstanceState ) ; } mStopsController . setNonConfigurationInstance ( getLastNonConfigurationInstance ( ) ) ; autoShowWhatsNew ( ) ; UIHelp . checkAirplaneMode ( this ) ; }
@ Override public void onDestroy ( ) { mStopUserMap . close ( ) ; mStopUserMap = null ; mStopsController . cancel ( ) ; mStopsController = null ; super. onDestroy ( ) ; }
@ Override public boolean onCreateOptionsMenu ( Menu menu ) { MenuInflater inflater = getMenuInflater ( ) ; inflater . inflate ( R . menu . main_options , menu ) ; return true ; }
@ Override public boolean onOptionsItemSelected ( MenuItem item ) { final int id = item . getItemId ( ) ; if ( id == R . id . my_location ) { setMyLocation ( ) ; return true ; } else if ( id == R . id . find_route ) { Intent myIntent = new Intent ( this , MyRoutesActivity .class ) ; startActivity ( myIntent ) ; return true ; } else if ( id == R . id . find_stop ) { Intent myIntent = new Intent ( this , MyStopsActivity .class ) ; startActivity ( myIntent ) ; return true ; } else if ( id == R . id . view_trips ) { Intent myIntent = new Intent ( this , TripListActivity .class ) ; startActivity ( myIntent ) ; return true ; } else if ( id == R . id . help ) { showDialog ( HELP_DIALOG ) ; return true ; } return false ; }
@ Override public void onResume ( ) { mLocationOverlay = new MyFixedLocationOverlay ( this , mMapView ) ; List < Overlay > mapOverlays = mMapView . getOverlays ( ) ; mapOverlays . add ( mLocationOverlay ) ; mLocationOverlay . enableMyLocation ( ) ; if ( mStopUserMap == null ) { mStopUserMap = new UIHelp . StopUserInfoMap ( this ) ; } else { mStopUserMap . requery ( ) ; } MapController mapCtrl = mMapView . getController ( ) ; GeoPoint prevCenter = mMapCenter ; if ( prevCenter != null ) { mapCtrl . setCenter ( prevCenter ) ; } if ( mMapZoom != mMapView . getZoomLevel ( ) ) { mapCtrl . setZoom ( mMapZoom ) ; } ObaResponse response = mStopsController . getResponse ( ) ; if ( response != null ) { setOverlays ( response ) ; if ( mStopOverlay != null ) { showRoutes ( null , mShowRoutes ) ; } } else if ( isRouteMode ( ) ) { getStops ( ) ; } if ( ! isRouteMode ( ) ) { if ( prevCenter == null ) { setMyLocation ( ) ; } else { getStops ( ) ; } mMapWatcher = new MapWatcher ( mMapView , this ) ; mMapWatcher . start ( ) ; } super. onResume ( ) ; }
@ Override public void onPause ( ) { mLocationOverlay . disableMyLocation ( ) ; mStopsController . cancel ( ) ; if ( mMapWatcher != null ) { mMapWatcher . stop ( ) ; mMapWatcher = null ; } mMapCenter = mMapView . getMapCenter ( ) ; mMapZoom = mMapView . getZoomLevel ( ) ; Log . d ( TAG , "PAUSE: Saving center: " + mMapCenter ) ; List < Overlay > mapOverlays = mMapView . getOverlays ( ) ; mapOverlays . clear ( ) ; mStopOverlay = null ; mLocationOverlay = null ; super. onPause ( ) ; }
@ Override protected void onSaveInstanceState ( Bundle outState ) { outState . putString ( FOCUS_STOP_ID , mFocusStopId ) ; outState . putBoolean ( SHOW_ROUTES , mShowRoutes ) ; GeoPoint center = mMapView . getMapCenter ( ) ; outState . putDouble ( CENTER_LAT , center . getLatitudeE6 ( ) / 1E6 ) ; outState . putDouble ( CENTER_LON , center . getLongitudeE6 ( ) / 1E6 ) ; outState . putInt ( MAP_ZOOM , mMapView . getZoomLevel ( ) ) ; }
@ Override public Object onRetainNonConfigurationInstance ( ) { return mStopsController . onRetainNonConfigurationInstance ( ) ; }
@ Override protected boolean isRouteDisplayed ( ) { return false ; }
@ Override protected Dialog onCreateDialog ( int id ) { switch ( id ) { case HELP_DIALOG : return createHelpDialog ( ) ; case WHATSNEW_DIALOG : return createWhatsNewDialog ( ) ; case NOLOCATION_DIALOG : return createNoLocationDialog ( ) ; case OUTOFRANGE_DIALOG : return createOutOfRangeDialog ( ) ; } return null ; }
@ Override public void onLowMemory ( ) { super. onLowMemory ( ) ; Log . d ( TAG , "******** LOW MEMORY ******** " ) ; ObaApi . clearCache ( ) ; }
@ Override public void onActivityResult ( int requestCode , int resultCode , Intent data ) { super. onActivityResult ( requestCode , resultCode , data ) ; mMapCenter = null ; }
@ Override public void onMapZoomChanging ( ) { Log . d ( TAG , "Map zoom changing" ) ; }
@ Override public void onMapZoomChanged ( ) { Log . d ( TAG , "Map zoom changed" ) ; getStops ( ) ; }
@ Override public void onMapCenterChanging ( ) { Log . d ( TAG , "Map center changing" ) ; }
@ Override public void onMapCenterChanged ( ) { mMapCenter = mMapView . getMapCenter ( ) ; Log . d ( TAG , "Map center changed: " + mMapCenter ) ; getStops ( ) ; }
public void setStopWait ( Object obj ) { mStopWait = obj ; }
public StopsController getStopsController ( ) { return mStopsController ; }
@ Override public void onRequestFulfilled ( ObaResponse response ) { setOverlays ( response ) ; if ( mStopWait != null ) { synchronized ( mStopWait ) { mStopWait . notifyAll ( ) ; } } }
private void getStops ( ) { mStopsController . setCurrentRequest ( StopsController . requestFromView ( mMapView , mRouteId ) ) ; }
public void run ( ) { if ( mLocationOverlay != null ) { setMyLocation ( mLocationOverlay . getMyLocation ( ) ) ; } }
public void run ( ) { if ( mLocationOverlay != null && mLocationOverlay . getMyLocation ( ) == null ) { Toast . makeText ( MapViewActivity .this , R . string . main_waiting_for_location , Toast . LENGTH_LONG ) . show ( ) ; mWaitingForLocationHandler . postDelayed ( mUnableToGetLocation , 2 * WAIT_FOR_LOCATION_TIMEOUT ) ; } }
public void run ( ) { if ( mLocationOverlay != null && mLocationOverlay . getMyLocation ( ) == null ) { Toast . makeText ( MapViewActivity .this , R . string . main_location_unavailable , Toast . LENGTH_LONG ) . show ( ) ; if ( ! isRouteMode ( ) ) { getStops ( ) ; } } }
private void setMyLocation ( ) { if ( mLocationOverlay == null ) { return; } if ( ! mLocationOverlay . isMyLocationEnabled ( ) ) { showDialog ( NOLOCATION_DIALOG ) ; return; } GeoPoint point = mLocationOverlay . getMyLocation ( ) ; if ( point == null ) { mWaitingForLocationHandler . postDelayed ( mWaitingForLocation , WAIT_FOR_LOCATION_TIMEOUT ) ; mLocationOverlay . runOnFirstFix ( new Runnable ( ) { public void run ( ) { mGetStopsHandler . post ( mGetStops ) ; } } ) ; } else { setMyLocation ( point ) ; } }
public void run ( ) { mGetStopsHandler . post ( mGetStops ) ; }
private void setMyLocation ( GeoPoint point ) { MapController mapCtrl = mMapView . getController ( ) ; mapCtrl . animateTo ( point ) ; mapCtrl . setZoom ( 16 ) ; mMapZoom = 16 ; if ( ! isRouteMode ( ) ) { getStops ( ) ; } }
public RouteArrayAdapter ( List < ObaRoute > routes ) { super( MapViewActivity .this , routes , R . layout . main_popup_route_item ); }
@ Override protected void setData ( View view , int position ) { TextView shortName = ( TextView ) view . findViewById ( R . id . short_name ) ; final ObaRoute route = mArray . get ( position ) ; shortName . setText ( UIHelp . getRouteDisplayName ( route ) ) ; view . setOnClickListener ( new OnClickListener ( ) { @ Override public void onClick ( View view ) { RouteInfoActivity . start ( MapViewActivity .this , route . getId ( ) ) ; } } ) ; }
@ Override public void onClick ( View view ) { RouteInfoActivity . start ( MapViewActivity .this , route . getId ( ) ) ; }
void populateRoutes ( ObaStop stop , boolean force ) { GridView grid = ( GridView ) findViewById ( R . id . route_list ) ; if ( grid . getVisibility ( ) != View . GONE || force ) { ObaResponseWithRefs response = ( ObaResponseWithRefs ) mStopsController . getResponse ( ) ; grid . setAdapter ( new RouteArrayAdapter ( response . getRoutes ( stop . getRouteIds ( ) ) ) ) ; } }
public void onFocusChanged ( @ SuppressWarnings ( "rawtypes" ) ItemizedOverlay overlay , final OverlayItem newFocus ) { mStopChangedHandler . post ( new Runnable ( ) { public void run ( ) { if ( mStopUserMap == null ) { mFocusStopId = null ; return; } final View popup = findViewById ( R . id . map_popup ) ; if ( newFocus == null ) { mFocusStopId = null ; popup . setVisibility ( View . GONE ) ; return; } final StopOverlay . StopOverlayItem item = ( StopOverlayItem ) newFocus ; final ObaStop stop = item . getStop ( ) ; mFocusStopId = stop . getId ( ) ; TextView stopName = ( TextView ) popup . findViewById ( R . id . stop_name ) ; mStopUserMap . setView2 ( stopName , stop . getId ( ) , stop . getName ( ) ) ; UIHelp . setStopDirection ( popup . findViewById ( R . id . direction ) , stop . getDirection ( ) , false ) ; populateRoutes ( stop , false ) ; popup . setVisibility ( View . VISIBLE ) ; } } ) ; }
public void run ( ) { if ( mStopUserMap == null ) { mFocusStopId = null ; return; } final View popup = findViewById ( R . id . map_popup ) ; if ( newFocus == null ) { mFocusStopId = null ; popup . setVisibility ( View . GONE ) ; return; } final StopOverlay . StopOverlayItem item = ( StopOverlayItem ) newFocus ; final ObaStop stop = item . getStop ( ) ; mFocusStopId = stop . getId ( ) ; TextView stopName = ( TextView ) popup . findViewById ( R . id . stop_name ) ; mStopUserMap . setView2 ( stopName , stop . getId ( ) , stop . getName ( ) ) ; UIHelp . setStopDirection ( popup . findViewById ( R . id . direction ) , stop . getDirection ( ) , false ) ; populateRoutes ( stop , false ) ; popup . setVisibility ( View . VISIBLE ) ; }
public void onClick ( View v ) { if ( mStopOverlay == null ) { return; } StopOverlayItem item = ( StopOverlayItem ) mStopOverlay . getFocus ( ) ; if ( item != null ) { goToStop ( MapViewActivity .this , item . getStop ( ) ) ; } }
public void onClick ( View v ) { showRoutes ( ( TextView ) v , ! mShowRoutes ) ; }
void enableZoom ( ) { mZoomControls . setIsZoomInEnabled ( mMapView . getZoomLevel ( ) != MAX_ZOOM ) ; mZoomControls . setIsZoomOutEnabled ( mMapView . getZoomLevel ( ) != MIN_ZOOM ) ; }
@ Override public void onClick ( View v ) { if ( ! mMapView . getController ( ) . zoomIn ( ) ) { mZoomControls . setIsZoomInEnabled ( false ) ; mZoomControls . setIsZoomOutEnabled ( true ) ; } else { enableZoom ( ) ; } }
public void onClick ( View v ) { if ( ! mMapView . getController ( ) . zoomOut ( ) ) { mZoomControls . setIsZoomInEnabled ( true ) ; mZoomControls . setIsZoomOutEnabled ( false ) ; } else { enableZoom ( ) ; } }
private void showRoutes ( TextView text , boolean show ) { final GridView grid = ( GridView ) findViewById ( R . id . route_list ) ; if ( text == null ) { text = ( TextView ) findViewById ( R . id . show_routes ) ; } if ( show ) { final StopOverlayItem item = ( StopOverlayItem ) mStopOverlay . getFocus ( ) ; if ( item != null ) { populateRoutes ( item . getStop ( ) , true ) ; } grid . setVisibility ( View . VISIBLE ) ; text . setText ( R . string . main_hide_routes ) ; } else { grid . setVisibility ( View . GONE ) ; text . setText ( R . string . main_show_routes ) ; } mShowRoutes = show ; Spannable span = ( Spannable ) text . getText ( ) ; span . setSpan ( mOnShowRoutes , 0 , span . length ( ) , 0 ) ; }
private void setOverlays ( ObaResponse response ) { if ( response . getCode ( ) != ObaApi . OBA_OK ) { return; } List < ObaStop > stops ; if ( response instanceof ObaStopsForRouteResponse ) { stops = ( ( ObaStopsForRouteResponse ) response ) . getStops ( ) ; } else { assert ( response instanceof ObaStopsForLocationResponse ) ; ObaStopsForLocationResponse stopsResponse = ( ObaStopsForLocationResponse ) response ; if ( stopsResponse . getOutOfRange ( ) && mWarnOutOfRange ) { showDialog ( OUTOFRANGE_DIALOG ) ; return; } stops = Arrays . asList ( stopsResponse . getStops ( ) ) ; } List < Overlay > mapOverlays = mMapView . getOverlays ( ) ; if ( mFocusStopId == null ) { final View popup = findViewById ( R . id . map_popup ) ; popup . setVisibility ( View . GONE ) ; } if ( mStopOverlay != null ) { mapOverlays . remove ( mStopOverlay ) ; mStopOverlay = null ; } mStopOverlay = new StopOverlay ( stops , this ) ; mStopOverlay . setOnFocusChangeListener ( mFocusChangeListener ) ; if ( mFocusStopId != null ) { if ( ! mStopOverlay . setFocusById ( mFocusStopId ) ) { final View popup = findViewById ( R . id . map_popup ) ; popup . setVisibility ( View . GONE ) ; } } if ( isRouteMode ( ) ) { } mapOverlays . add ( mStopOverlay ) ; mMapView . postInvalidate ( ) ; }
static void goToStop ( Context context , ObaStop stop ) { StopInfoActivity . start ( context , stop ) ; }
private Dialog createHelpDialog ( ) { AlertDialog . Builder builder = new AlertDialog . Builder ( this ) ; builder . setTitle ( R . string . main_help_title ) ; builder . setItems ( R . array . main_help_options , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int which ) { switch ( which ) { case 0 : UIHelp . goToUrl ( MapViewActivity .this , HELP_URL ) ; break; case 1 : UIHelp . goToUrl ( MapViewActivity .this , TWITTER_URL ) ; break; case 2 : showDialog ( WHATSNEW_DIALOG ) ; break; case 3 : goToBugReport ( ) ; break; case 4 : Intent preferences = new Intent ( MapViewActivity .this , EditPreferencesActivity .class ) ; startActivity ( preferences ) ; break; } } } ) ; return builder . create ( ) ; }
public void onClick ( DialogInterface dialog , int which ) { switch ( which ) { case 0 : UIHelp . goToUrl ( MapViewActivity .this , HELP_URL ) ; break; case 1 : UIHelp . goToUrl ( MapViewActivity .this , TWITTER_URL ) ; break; case 2 : showDialog ( WHATSNEW_DIALOG ) ; break; case 3 : goToBugReport ( ) ; break; case 4 : Intent preferences = new Intent ( MapViewActivity .this , EditPreferencesActivity .class ) ; startActivity ( preferences ) ; break; } }
private Dialog createWhatsNewDialog ( ) { AlertDialog . Builder builder = new AlertDialog . Builder ( this ) ; builder . setTitle ( R . string . main_help_whatsnew_title ) ; builder . setIcon ( R . drawable . icon ) ; builder . setMessage ( R . string . main_help_whatsnew ) ; builder . setNeutralButton ( R . string . main_help_close , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int which ) { dismissDialog ( WHATSNEW_DIALOG ) ; } } ) ; return builder . create ( ) ; final Dialog dialog = new Dialog(this);        dialog.setContentView(R.layout.whats_new); Button button = (Button)dialog.findViewById(android.R.id.closeButton);        button.setOnClickListener(new View.OnClickListener() {            public void onClick(View v) {                dismissDialog(WHATSNEW_DIALOG);            }        });        return dialog;        */    }
public void onClick ( DialogInterface dialog , int which ) { dismissDialog ( WHATSNEW_DIALOG ) ; }
private Dialog createNoLocationDialog ( ) { AlertDialog . Builder builder = new AlertDialog . Builder ( this ) ; builder . setTitle ( R . string . main_nolocation_title ) ; builder . setIcon ( android . R . drawable . ic_dialog_map ) ; builder . setMessage ( R . string . main_nolocation ) ; builder . setPositiveButton ( android . R . string . yes , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { startActivityForResult ( new Intent ( Settings . ACTION_LOCATION_SOURCE_SETTINGS ) , 0 ) ; dismissDialog ( NOLOCATION_DIALOG ) ; } } ) ; builder . setNegativeButton ( android . R . string . no , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { if ( ! isRouteMode ( ) ) { getStops ( ) ; } dismissDialog ( NOLOCATION_DIALOG ) ; } } ) ; return builder . create ( ) ; }
@ Override public void onClick ( DialogInterface dialog , int which ) { startActivityForResult ( new Intent ( Settings . ACTION_LOCATION_SOURCE_SETTINGS ) , 0 ) ; dismissDialog ( NOLOCATION_DIALOG ) ; }
@ Override public void onClick ( DialogInterface dialog , int which ) { if ( ! isRouteMode ( ) ) { getStops ( ) ; } dismissDialog ( NOLOCATION_DIALOG ) ; }
private Dialog createOutOfRangeDialog ( ) { AlertDialog . Builder builder = new AlertDialog . Builder ( this ) ; LayoutInflater inflater = getLayoutInflater ( ) ; builder . setCustomTitle ( inflater . inflate ( R . layout . main_outofrange_title , null ) ) ; builder . setItems ( R . array . agency_locations , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { if ( which >= 0 && which < AGENCY_LOCATIONS . length ) { setMyLocation ( AGENCY_LOCATIONS [ which ] ) ; } dismissDialog ( OUTOFRANGE_DIALOG ) ; mWarnOutOfRange = false ; } } ) ; return builder . create ( ) ; }
@ Override public void onClick ( DialogInterface dialog , int which ) { if ( which >= 0 && which < AGENCY_LOCATIONS . length ) { setMyLocation ( AGENCY_LOCATIONS [ which ] ) ; } dismissDialog ( OUTOFRANGE_DIALOG ) ; mWarnOutOfRange = false ; }
private void autoShowWhatsNew ( ) { SharedPreferences settings = getSharedPreferences ( UIHelp . PREFS_NAME , 0 ) ; PackageManager pm = getPackageManager ( ) ; PackageInfo appInfo = null ; try { appInfo = pm . getPackageInfo ( getPackageName ( ) , PackageManager . GET_META_DATA ) ; } catch ( NameNotFoundException e ) { return; } final int oldVer = settings . getInt ( WHATS_NEW_VER , 0 ) ; final int newVer = appInfo . versionCode ; if ( oldVer != newVer ) { if ( oldVer == 0 && newVer == 7 ) { Integer count = UIHelp . intForQuery ( this , ObaContract . Stops . CONTENT_URI , ObaContract . Stops . _COUNT ) ; if ( count != null && count != 0 ) { showDialog ( WHATSNEW_DIALOG ) ; } } else if ( ( oldVer > 0 ) && ( oldVer < newVer ) ) { showDialog ( WHATSNEW_DIALOG ) ; } TripService . scheduleAll ( this ) ; SharedPreferences . Editor edit = settings . edit ( ) ; edit . putInt ( WHATS_NEW_VER , appInfo . versionCode ) ; edit . commit ( ) ; } }
private void goToBugReport ( ) { PackageManager pm = getPackageManager ( ) ; PackageInfo appInfo = null ; try { appInfo = pm . getPackageInfo ( getPackageName ( ) , PackageManager . GET_META_DATA ) ; } catch ( NameNotFoundException e ) { return; } final String body = getString ( R . string . bug_report_body , appInfo . versionName , Build . MODEL , Build . VERSION . RELEASE , Build . VERSION . SDK ) ; Intent send = new Intent ( Intent . ACTION_SEND ) ; send . putExtra ( Intent . EXTRA_EMAIL , new String [] { getString ( R . string . bug_report_dest ) } ) ; send . putExtra ( Intent . EXTRA_SUBJECT , getString ( R . string . bug_report_subject ) ) ; send . putExtra ( Intent . EXTRA_TEXT , body ) ; send . setType ( "message/rfc822" ) ; try { startActivity ( Intent . createChooser ( send , getString ( R . string . bug_report_subject ) ) ) ; } catch ( ActivityNotFoundException e ) { Toast . makeText ( this , R . string . bug_report_error , Toast . LENGTH_LONG ) . show ( ) ; } }
private void mapValuesFromBundle ( Bundle bundle ) { double lat = bundle . getDouble ( CENTER_LAT ) ; double lon = bundle . getDouble ( CENTER_LON ) ; if ( lat != 0.0 && lon != 0.0 ) { mMapCenter = ObaApi . makeGeoPoint ( lat , lon ) ; } mMapZoom = bundle . getInt ( MAP_ZOOM , mMapZoom ) ; }
private boolean isRouteMode ( ) { return mRouteId != null ; }
@ Override public boolean onSearchRequested ( ) { Intent intent = new Intent ( this , MyRoutesActivity .class ) ; intent . setData ( MyTabActivityBase . getDefaultTabUri ( MySearchRoutesActivity . TAB_NAME ) ) ; startActivity ( intent ) ; return true ; }
private ObaShapeElement ( ) { points = "" ; length = 0 ; levels = "" ; }
@ Override public int getLength ( ) { return length ; }
@ Override public String getRawLevels ( ) { return levels ; }
@ Override public List < Integer > getLevels ( ) { return decodeLevels ( levels , length ) ; }
@ Override public List < Location > getPoints ( ) { return decodeLine ( points , length ) ; }
@ Override public String getRawPoints ( ) { return points ; }
public static List < Location > decodeLine ( String encoded , int numPoints ) { if ( numPoints < 0 ) { throw new IllegalArgumentException ( "numPoints must be >= 0" ) ; } ArrayList < Location > array = new ArrayList < Location > ( numPoints ) ; final int len = encoded . length ( ) ; int i = 0 ; int lat = 0 , lon = 0 ; while ( i < len ) { int shift = 0 ; int result = 0 ; int a , b ; do { a = encoded . charAt ( i ) ; b = a - 63 ; result |= ( b & 0x1f ) << shift ; shift += 5 ; ++ i ; } while ( b >= 0x20 ); final int dlat = ( ( result & 1 ) == 1 ? ~ ( result >> 1 ) : ( result >> 1 ) ) ; lat += dlat ; shift = 0 ; result = 0 ; do { a = encoded . charAt ( i ) ; b = a - 63 ; result |= ( b & 0x1f ) << shift ; shift += 5 ; ++ i ; } while ( b >= 0x20 ); final int dlon = ( ( result & 1 ) == 1 ? ~ ( result >> 1 ) : ( result >> 1 ) ) ; lon += dlon ; array . add ( LocationUtils . makeLocation ( lat / 1E5 , lon / 1E5 ) ) ; } return array ; }
public static List < Integer > decodeLevels ( String encoded , int numPoints ) { if ( numPoints < 0 ) { throw new IllegalArgumentException ( "numPoints must be >= 0" ) ; } ArrayList < Integer > array = new ArrayList < Integer > ( numPoints ) ; final int len = encoded . length ( ) ; int i = 0 ; while ( i < len ) { int shift = 0 ; int result = 0 ; int a , b ; do { a = encoded . charAt ( i ) ; b = a - 63 ; result |= ( b & 0x1f ) << shift ; shift += 5 ; ++ i ; } while ( b >= 0x20 ); array . add ( result ) ; } return array ; }
public static void setupActionBar ( AppCompatActivity activity ) { ActionBar bar = activity . getSupportActionBar ( ) ; bar . setIcon ( android . R . color . transparent ) ; bar . setDisplayShowTitleEnabled ( true ) ; if ( ! ( activity instanceof HomeActivity ) ) { bar . setDisplayHomeAsUpEnabled ( true ) ; } }
public static void setupSearch ( Activity activity , Menu menu ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . HONEYCOMB ) { SearchManager searchManager = ( SearchManager ) activity . getSystemService ( Context . SEARCH_SERVICE ) ; final MenuItem searchMenu = menu . findItem ( R . id . action_search ) ; SearchView searchView = ( SearchView ) MenuItemCompat . getActionView ( searchMenu ) ; searchView . setSearchableInfo ( searchManager . getSearchableInfo ( activity . getComponentName ( ) ) ) ; searchView . setOnQueryTextFocusChangeListener ( new View . OnFocusChangeListener ( ) { @ Override public void onFocusChange ( View view , boolean queryTextFocused ) { if ( ! queryTextFocused ) { MenuItemCompat . collapseActionView ( searchMenu ) ; } } } ) ; } }
@ Override public void onFocusChange ( View view , boolean queryTextFocused ) { if ( ! queryTextFocused ) { MenuItemCompat . collapseActionView ( searchMenu ) ; } }
public static void showProgress ( Fragment fragment , boolean visible ) { AppCompatActivity act = ( AppCompatActivity ) fragment . getActivity ( ) ; if ( act != null ) { act . setSupportProgressBarIndeterminateVisibility ( visible ) ; } }
public static void setClickableSpan ( TextView v , ClickableSpan span ) { Spannable text = ( Spannable ) v . getText ( ) ; text . setSpan ( span , 0 , text . length ( ) , 0 ) ; v . setMovementMethod ( LinkMovementMethod . getInstance ( ) ) ; }
public static void removeAllClickableSpans ( TextView v ) { Spannable text = ( Spannable ) v . getText ( ) ; ClickableSpan [] spans = text . getSpans ( 0 , text . length ( ) , ClickableSpan .class ) ; for ( ClickableSpan cs : spans ) { text . removeSpan ( cs ) ; } }
public static int getStopDirectionText ( String direction ) { if ( direction . equals ( "N" ) ) { return R . string . direction_n ; } else if ( direction . equals ( "NW" ) ) { return R . string . direction_nw ; } else if ( direction . equals ( "W" ) ) { return R . string . direction_w ; } else if ( direction . equals ( "SW" ) ) { return R . string . direction_sw ; } else if ( direction . equals ( "S" ) ) { return R . string . direction_s ; } else if ( direction . equals ( "SE" ) ) { return R . string . direction_se ; } else if ( direction . equals ( "E" ) ) { return R . string . direction_e ; } else if ( direction . equals ( "NE" ) ) { return R . string . direction_ne ; } else { return R . string . direction_none ; } }
public static String getRouteDisplayName ( String routeShortName , String routeLongName ) { if ( ! TextUtils . isEmpty ( routeShortName ) ) { return routeShortName ; } if ( ! TextUtils . isEmpty ( routeLongName ) ) { return routeLongName ; } return "" ; }
public static String getRouteDisplayName ( ObaRoute route ) { return getRouteDisplayName ( route . getShortName ( ) , route . getLongName ( ) ) ; }
public static String getRouteDisplayName ( ObaArrivalInfo arrivalInfo ) { return getRouteDisplayName ( arrivalInfo . getShortName ( ) , arrivalInfo . getRouteLongName ( ) ) ; }
public static String getRouteDescription ( ObaRoute route ) { String shortName = route . getShortName ( ) ; String longName = route . getLongName ( ) ; if ( TextUtils . isEmpty ( shortName ) ) { shortName = longName ; } if ( TextUtils . isEmpty ( longName ) || shortName . equals ( longName ) ) { longName = route . getDescription ( ) ; } return UIUtils . formatDisplayText ( longName ) ; }
public static String formatDisplayText ( String displayText ) { if ( displayText == null ) { return null ; } if ( MyTextUtils . isAllCaps ( displayText ) && displayText . contains ( " " ) ) { return MyTextUtils . toTitleCase ( displayText ) ; } else { return displayText ; } }
public static void setStopDirection ( View v , String direction , boolean show ) { final TextView text = ( TextView ) v ; final int directionText = UIUtils . getStopDirectionText ( direction ) ; if ( ( directionText != R . string . direction_none ) || show ) { text . setText ( directionText ) ; text . setVisibility ( View . VISIBLE ) ; } else { text . setVisibility ( View . GONE ) ; } }
public static void setRouteView ( View view , ObaRoute route ) { TextView shortNameText = ( TextView ) view . findViewById ( R . id . short_name ) ; TextView longNameText = ( TextView ) view . findViewById ( R . id . long_name ) ; String shortName = route . getShortName ( ) ; String longName = UIUtils . formatDisplayText ( route . getLongName ( ) ) ; if ( TextUtils . isEmpty ( shortName ) ) { shortName = longName ; } if ( TextUtils . isEmpty ( longName ) || shortName . equals ( longName ) ) { longName = UIUtils . formatDisplayText ( route . getDescription ( ) ) ; } shortNameText . setText ( shortName ) ; longNameText . setText ( longName ) ; }
public StopUserInfoMap ( Context context ) { ContentResolver cr = context . getContentResolver ( ) ; Cursor c = cr . query ( ObaContract . Stops . CONTENT_URI , STOP_USER_PROJECTION , "(" + ObaContract . Stops . USER_NAME + " IS NOT NULL)" + "OR (" + ObaContract . Stops . FAVORITE + "=1)" , null , null ) ; mMap = new ContentQueryMap ( c , ObaContract . Stops . _ID , true , null ) ; }
public void close ( ) { mMap . close ( ) ; }
public void requery ( ) { mMap . requery ( ) ; }
public void setView ( View stopRoot , String stopId , String stopName ) { TextView nameView = ( TextView ) stopRoot . findViewById ( R . id . stop_name ) ; setView2 ( nameView , stopId , stopName , true ) ; }
public void setView2 ( TextView nameView , String stopId , String stopName , boolean showIcon ) { ContentValues values = mMap . getValues ( stopId ) ; int icon = 0 ; if ( values != null ) { Integer i = values . getAsInteger ( ObaContract . Stops . FAVORITE ) ; final boolean favorite = ( i != null ) && ( i == 1 ) ; final String userName = values . getAsString ( ObaContract . Stops . USER_NAME ) ; nameView . setText ( TextUtils . isEmpty ( userName ) ? UIUtils . formatDisplayText ( stopName ) : userName ) ; icon = favorite && showIcon ? R . drawable . ic_toggle_star : 0 ; } else { nameView . setText ( UIUtils . formatDisplayText ( stopName ) ) ; } nameView . setCompoundDrawablesWithIntrinsicBounds ( icon , 0 , 0 , 0 ) ; }
public static String serializeRouteDisplayNames ( ObaStop stop , HashMap < String , ObaRoute > routes ) { StringBuffer sb = new StringBuffer ( ) ; String [] routeIds = stop . getRouteIds ( ) ; for ( int i = 0 ; i < routeIds . length ; i ++ ) { if ( routes != null ) { ObaRoute route = routes . get ( routeIds [ i ] ) ; sb . append ( getRouteDisplayName ( route ) ) ; } else { sb . append ( routeIds [ i ] ) ; } if ( i != routeIds . length - 1 ) { sb . append ( "," ) ; } } return sb . toString ( ) ; }
public static List < String > deserializeRouteDisplayNames ( String serializedRouteDisplayNames ) { String routes [] = serializedRouteDisplayNames . split ( "," ) ; return Arrays . asList ( routes ) ; }
public static String formatRouteDisplayNames ( List < String > routeDisplayNames , List < String > nextArrivalRouteShortNames ) { Collections . sort ( routeDisplayNames , new AlphanumComparator ( ) ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < routeDisplayNames . size ( ) ; i ++ ) { boolean match = false ; for ( String nextArrivalRouteShortName : nextArrivalRouteShortNames ) { if ( routeDisplayNames . get ( i ) . equalsIgnoreCase ( nextArrivalRouteShortName ) ) { match = true ; break; } } if ( match ) { sb . append ( routeDisplayNames . get ( i ) + "*" ) ; } else { sb . append ( routeDisplayNames . get ( i ) ) ; } if ( i != routeDisplayNames . size ( ) - 1 ) { sb . append ( ", " ) ; } } return sb . toString ( ) ; }
public static Pair < String , String > createStopDetailsDialogText ( Context context , String stopName , String stopUserName , String stopCode , String stopDirection , List < String > routeDisplayNames ) { final String newLine = "\n" ; String title = "" ; StringBuilder message = new StringBuilder ( ) ; if ( ! TextUtils . isEmpty ( stopUserName ) ) { title = stopUserName ; if ( stopName != null ) { message . append ( context . getString ( R . string . stop_info_official_stop_name_label , stopName ) ) . append ( newLine ) ; } } else if ( stopName != null ) { title = stopName ; } if ( stopCode != null ) { message . append ( context . getString ( R . string . stop_details_code , stopCode ) + newLine ) ; } if ( routeDisplayNames != null ) { String routes = context . getString ( R . string . stop_info_route_ids_label ) + " " + UIUtils . formatRouteDisplayNames ( routeDisplayNames , new ArrayList < String > ( ) ) ; message . append ( routes ) ; } if ( ! TextUtils . isEmpty ( stopDirection ) ) { message . append ( newLine ) . append ( context . getString ( UIUtils . getStopDirectionText ( stopDirection ) ) ) ; } return new Pair ( title , message . toString ( ) ) ; }
public static AlertDialog buildAlertDialog ( Context context , String title , String message ) { AlertDialog . Builder builder = new AlertDialog . Builder ( context ) ; builder . setTitle ( title ) ; builder . setMessage ( message ) ; return builder . create ( ) ; }
public static Intent makeShortcut ( Context context , String name , Intent destIntent ) { destIntent . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_TOP ) ; Intent intent = new Intent ( ) ; intent . putExtra ( Intent . EXTRA_SHORTCUT_INTENT , destIntent ) ; intent . putExtra ( Intent . EXTRA_SHORTCUT_NAME , name ) ; Parcelable iconResource = Intent . ShortcutIconResource . fromContext ( context , R . mipmap . ic_launcher ) ; intent . putExtra ( Intent . EXTRA_SHORTCUT_ICON_RESOURCE , iconResource ) ; return intent ; }
public static void goToUrl ( Context context , String url ) { Intent intent = new Intent ( Intent . ACTION_VIEW , Uri . parse ( url ) ) ; try { context . startActivity ( intent ) ; } catch ( ActivityNotFoundException e ) { Toast . makeText ( context , context . getString ( R . string . browser_error ) , Toast . LENGTH_SHORT ) . show ( ) ; } }
public static void goToPhoneDialer ( Context context , String url ) { Intent intent = new Intent ( Intent . ACTION_DIAL ) ; intent . setData ( Uri . parse ( url ) ) ; context . startActivity ( intent ) ; }
public static void sendEmail ( Context context , String email , String location ) { sendEmail ( context , email , location , null , false ) ; }
public static void sendEmail ( Context context , String email , String location , String tripPlanUrl , boolean tripPlanFail ) { String obaRegionName = RegionUtils . getObaRegionName ( ) ; boolean autoRegion = Application . getPrefs ( ) . getBoolean ( context . getString ( R . string . preference_key_auto_select_region ) , true ) ; String regionSelectionMethod ; if ( autoRegion ) { regionSelectionMethod = context . getString ( R . string . region_selected_auto ) ; } else { regionSelectionMethod = context . getString ( R . string . region_selected_manually ) ; } UIUtils . sendEmail ( context , email , location , obaRegionName , regionSelectionMethod , tripPlanUrl , tripPlanFail ) ; }
private static void sendEmail ( Context context , String email , String location , String regionName , String regionSelectionMethod , String tripPlanUrl , boolean tripPlanFail ) { PackageManager pm = context . getPackageManager ( ) ; PackageInfo appInfoOba ; PackageInfo appInfoGps ; String obaVersion = "" ; String googlePlayServicesAppVersion = "" ; try { appInfoOba = pm . getPackageInfo ( context . getPackageName ( ) , PackageManager . GET_META_DATA ) ; obaVersion = appInfoOba . versionName ; } catch ( PackageManager . NameNotFoundException e ) { } try { appInfoGps = pm . getPackageInfo ( GoogleApiAvailability . GOOGLE_PLAY_SERVICES_PACKAGE , 0 ) ; googlePlayServicesAppVersion = appInfoGps . versionName ; } catch ( PackageManager . NameNotFoundException e ) { } String body ; if ( location != null ) { if ( tripPlanUrl == null ) { body = context . getString ( R . string . bug_report_body , obaVersion , Build . MODEL , Build . VERSION . RELEASE , Build . VERSION . SDK_INT , googlePlayServicesAppVersion , GoogleApiAvailability . GOOGLE_PLAY_SERVICES_VERSION_CODE , regionName , regionSelectionMethod , location ) ; } else { if ( tripPlanFail ) { body = context . getString ( R . string . bug_report_body_trip_plan_fail , obaVersion , Build . MODEL , Build . VERSION . RELEASE , Build . VERSION . SDK_INT , googlePlayServicesAppVersion , GoogleApiAvailability . GOOGLE_PLAY_SERVICES_VERSION_CODE , regionName , regionSelectionMethod , location , tripPlanUrl ) ; } else { body = context . getString ( R . string . bug_report_body_trip_plan , obaVersion , Build . MODEL , Build . VERSION . RELEASE , Build . VERSION . SDK_INT , googlePlayServicesAppVersion , GoogleApiAvailability . GOOGLE_PLAY_SERVICES_VERSION_CODE , regionName , regionSelectionMethod , location , tripPlanUrl ) ; } } } else { if ( tripPlanUrl == null ) { body = context . getString ( R . string . bug_report_body_without_location , obaVersion , Build . MODEL , Build . VERSION . RELEASE , Build . VERSION . SDK_INT ) ; } else { if ( tripPlanFail ) { body = context . getString ( R . string . bug_report_body_trip_plan_without_location_fail , obaVersion , Build . MODEL , Build . VERSION . RELEASE , Build . VERSION . SDK_INT , tripPlanUrl ) ; } else { body = context . getString ( R . string . bug_report_body_trip_plan_without_location , obaVersion , Build . MODEL , Build . VERSION . RELEASE , Build . VERSION . SDK_INT , tripPlanUrl ) ; } } } Intent send = new Intent ( Intent . ACTION_SEND ) ; send . putExtra ( Intent . EXTRA_EMAIL , new String [] { email } ) ; String subject ; if ( tripPlanUrl == null ) { if ( tripPlanFail ) { subject = context . getString ( R . string . bug_report_subject_trip_plan ) ; } else { subject = context . getString ( R . string . bug_report_subject ) ; } } else { if ( tripPlanFail ) { subject = context . getString ( R . string . bug_report_subject_trip_plan_fail ) ; } else { subject = context . getString ( R . string . bug_report_subject_trip_plan ) ; } } send . putExtra ( Intent . EXTRA_SUBJECT , subject ) ; send . putExtra ( Intent . EXTRA_TEXT , body ) ; send . setType ( "message/rfc822" ) ; try { context . startActivity ( Intent . createChooser ( send , subject ) ) ; } catch ( ActivityNotFoundException e ) { Toast . makeText ( context , R . string . bug_report_error , Toast . LENGTH_LONG ) . show ( ) ; } }
public static String getRouteErrorString ( Context context , int code ) { if ( ! isConnected ( context ) ) { if ( isAirplaneMode ( context ) ) { return context . getString ( R . string . airplane_mode_error ) ; } else { return context . getString ( R . string . no_network_error ) ; } } switch ( code ) { case ObaApi . OBA_INTERNAL_ERROR : return context . getString ( R . string . internal_error ) ; case ObaApi . OBA_NOT_FOUND : ObaRegion r = Application . get ( ) . getCurrentRegion ( ) ; if ( r != null ) { return context . getString ( R . string . route_not_found_error_with_region_name , r . getName ( ) ) ; } else { return context . getString ( R . string . route_not_found_error_no_region ) ; } case ObaApi . OBA_BAD_GATEWAY : return context . getString ( R . string . bad_gateway_error ) ; case ObaApi . OBA_OUT_OF_MEMORY : return context . getString ( R . string . out_of_memory_error ) ; default: return context . getString ( R . string . generic_comm_error ) ; } }
public static String getStopErrorString ( Context context , int code ) { if ( ! isConnected ( context ) ) { if ( isAirplaneMode ( context ) ) { return context . getString ( R . string . airplane_mode_error ) ; } else { return context . getString ( R . string . no_network_error ) ; } } switch ( code ) { case ObaApi . OBA_INTERNAL_ERROR : return context . getString ( R . string . internal_error ) ; case ObaApi . OBA_NOT_FOUND : ObaRegion r = Application . get ( ) . getCurrentRegion ( ) ; if ( r != null ) { return context . getString ( R . string . stop_not_found_error_with_region_name , r . getName ( ) ) ; } else { return context . getString ( R . string . stop_not_found_error_no_region ) ; } case ObaApi . OBA_BAD_GATEWAY : return context . getString ( R . string . bad_gateway_error ) ; case ObaApi . OBA_OUT_OF_MEMORY : return context . getString ( R . string . out_of_memory_error ) ; default: return context . getString ( R . string . generic_comm_error ) ; } }
public static int getMapErrorString ( Context context , int code ) { if ( ! isConnected ( context ) ) { if ( isAirplaneMode ( context ) ) { return R . string . airplane_mode_error ; } else { return R . string . no_network_error ; } } switch ( code ) { case ObaApi . OBA_INTERNAL_ERROR : return R . string . internal_error ; case ObaApi . OBA_BAD_GATEWAY : return R . string . bad_gateway_error ; case ObaApi . OBA_OUT_OF_MEMORY : return R . string . out_of_memory_error ; default: return R . string . map_generic_error ; } }
public static boolean isAirplaneMode ( Context context ) { if ( context == null ) { return false ; } ContentResolver cr = context . getContentResolver ( ) ; return Settings . System . getInt ( cr , Settings . System . AIRPLANE_MODE_ON , 0 ) != 0 ; }
public static boolean isConnected ( Context context ) { if ( context == null ) { return true ; } ConnectivityManager cm = ( ConnectivityManager ) context . getSystemService ( Context . CONNECTIVITY_SERVICE ) ; NetworkInfo activeNetwork = cm . getActiveNetworkInfo ( ) ; return ( activeNetwork != null ) && activeNetwork . isConnectedOrConnecting ( ) ; }
public static String stringForQuery ( Context context , Uri uri , String column ) { ContentResolver cr = context . getContentResolver ( ) ; Cursor c = cr . query ( uri , new String [] { column } , null , null , null ) ; if ( c != null ) { try { if ( c . moveToFirst ( ) ) { return c . getString ( 0 ) ; } } finally { c . close ( ) ; } } return "" ; }
public static Integer intForQuery ( Context context , Uri uri , String column ) { ContentResolver cr = context . getContentResolver ( ) ; Cursor c = cr . query ( uri , new String [] { column } , null , null , null ) ; if ( c != null ) { try { if ( c . moveToFirst ( ) ) { return c . getInt ( 0 ) ; } } finally { c . close ( ) ; } } return null ; }
public static String getNoArrivalsMessage ( Context context , int minutes , boolean additionalArrivals , boolean shortFormat ) { if ( minutes <= MINUTES_IN_HOUR ) { if ( additionalArrivals ) { if ( shortFormat ) { return context . getString ( R . string . stop_info_no_additional_data_minutes_short_format , minutes ) ; } else { return context . getString ( R . string . stop_info_no_additional_data_minutes , minutes ) ; } } else { if ( shortFormat ) { return context . getString ( R . string . stop_info_nodata_minutes_short_format , minutes ) ; } else { return context . getString ( R . string . stop_info_nodata_minutes , minutes ) ; } } } else { if ( additionalArrivals ) { if ( shortFormat ) { return context . getResources ( ) . getQuantityString ( R . plurals . stop_info_no_additional_data_hours_minutes_short_format , minutes / 60 , minutes % 60 , minutes / 60 ) ; } else { return context . getResources ( ) . getQuantityString ( R . plurals . stop_info_no_additional_data_hours_minutes , minutes / 60 , minutes % 60 , minutes / 60 ) ; } } else { if ( shortFormat ) { return context . getResources ( ) . getQuantityString ( R . plurals . stop_info_nodata_hours_minutes_short_format , minutes / 60 , minutes % 60 , minutes / 60 ) ; } else { return context . getResources ( ) . getQuantityString ( R . plurals . stop_info_nodata_hours_minutes , minutes / 60 , minutes % 60 , minutes / 60 ) ; } } } }
public static boolean canManageDialog ( Activity activity ) { if ( activity == null ) { return false ; } if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . JELLY_BEAN_MR1 ) { return ! activity . isFinishing ( ) && ! activity . isDestroyed ( ) ; } else { return ! activity . isFinishing ( ) ; } }
public static boolean canManageDialog ( Context context ) { if ( context == null ) { return false ; } if ( context instanceof Activity ) { return canManageDialog ( ( Activity ) context ) ; } else { return true ; } }
public static boolean canAnimateViewModern ( ) { return Build . VERSION . SDK_INT >= Build . VERSION_CODES . HONEYCOMB_MR1 ; }
public static boolean canCancelAnimation ( ) { return Build . VERSION . SDK_INT >= Build . VERSION_CODES . ICE_CREAM_SANDWICH ; }
public static boolean canSupportArrivalInfoStyleB ( ) { return Build . VERSION . SDK_INT >= Build . VERSION_CODES . ICE_CREAM_SANDWICH ; }
@ TargetApi ( 14 ) public static void showViewWithAnimation ( final View v , int animationDuration ) { if ( ! canAnimateViewModern ( ) ) { showViewWithoutAnimation ( v ) ; return; } if ( v . getVisibility ( ) == View . VISIBLE && v . getAlpha ( ) == 1 ) { return; } v . clearAnimation ( ) ; if ( canCancelAnimation ( ) ) { v . animate ( ) . cancel ( ) ; } if ( v . getVisibility ( ) != View . VISIBLE ) { v . setAlpha ( 0f ) ; v . setVisibility ( View . VISIBLE ) ; } v . animate ( ) . alpha ( 1f ) . setDuration ( animationDuration ) . setListener ( null ) ; }
public static void showViewWithoutAnimation ( final View v ) { if ( v . getVisibility ( ) == View . VISIBLE ) { return; } v . setVisibility ( View . VISIBLE ) ; }
@ TargetApi ( 14 ) public static void hideViewWithAnimation ( final View v , int animationDuration ) { if ( ! canAnimateViewModern ( ) ) { hideViewWithoutAnimation ( v ) ; return; } if ( v . getVisibility ( ) == View . GONE ) { return; } v . clearAnimation ( ) ; if ( canCancelAnimation ( ) ) { v . animate ( ) . cancel ( ) ; } v . animate ( ) . alpha ( 0f ) . setDuration ( animationDuration ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationEnd ( Animator animation ) { v . setVisibility ( View . GONE ) ; } } ) ; }
@ Override public void onAnimationEnd ( Animator animation ) { v . setVisibility ( View . GONE ) ; }
public static void hideViewWithoutAnimation ( final View v ) { if ( v . getVisibility ( ) == View . GONE ) { return; } v . setVisibility ( View . GONE ) ; }
@ TargetApi ( 12 ) public static void logViewVisibility ( View v ) { if ( v != null ) { if ( v . getVisibility ( ) == View . VISIBLE ) { Log . d ( TAG , v . getContext ( ) . getResources ( ) . getResourceEntryName ( v . getId ( ) ) + " is visible" ) ; if ( UIUtils . canAnimateViewModern ( ) ) { Log . d ( TAG , v . getContext ( ) . getResources ( ) . getResourceEntryName ( v . getId ( ) ) + " alpha - " + v . getAlpha ( ) ) ; } } else if ( v . getVisibility ( ) == View . INVISIBLE ) { Log . d ( TAG , v . getContext ( ) . getResources ( ) . getResourceEntryName ( v . getId ( ) ) + " is INVISIBLE" ) ; } else if ( v . getVisibility ( ) == View . GONE ) { Log . d ( TAG , v . getContext ( ) . getResources ( ) . getResourceEntryName ( v . getId ( ) ) + " is GONE" ) ; } else { Log . d ( TAG , v . getContext ( ) . getResources ( ) . getResourceEntryName ( v . getId ( ) ) + ".getVisibility() - " + v . getVisibility ( ) ) ; } } }
public static int dpToPixels ( Context context , float dp ) { final float scale = context . getResources ( ) . getDisplayMetrics ( ) . density ; return ( int ) ( dp * scale + 0.5f ) ; }
public static void setMargins ( View v , int l , int t , int r , int b ) { ViewGroup . MarginLayoutParams p = ( ViewGroup . MarginLayoutParams ) v . getLayoutParams ( ) ; p . setMargins ( l , t , r , b ) ; v . setLayoutParams ( p ) ; }
public static void setAccessibilityIgnore ( View view ) { view . setClickable ( false ) ; view . setFocusable ( false ) ; view . setContentDescription ( "" ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . JELLY_BEAN ) { view . setImportantForAccessibility ( View . IMPORTANT_FOR_ACCESSIBILITY_NO ) ; } }
public static List < String > buildTripOptions ( Context c , boolean isRouteFavorite , boolean hasUrl , boolean isReminderVisible ) { ArrayList < String > list = new ArrayList <> ( ) ; if ( ! isRouteFavorite ) { list . add ( c . getString ( R . string . bus_options_menu_add_star ) ) ; } else { list . add ( c . getString ( R . string . bus_options_menu_remove_star ) ) ; } list . add ( c . getString ( R . string . bus_options_menu_show_route_on_map ) ) ; list . add ( c . getString ( R . string . bus_options_menu_show_trip_details ) ) ; if ( ! isReminderVisible ) { list . add ( c . getString ( R . string . bus_options_menu_set_reminder ) ) ; } else { list . add ( c . getString ( R . string . bus_options_menu_edit_reminder ) ) ; } list . add ( c . getString ( R . string . bus_options_menu_show_only_this_route ) ) ; if ( hasUrl ) { list . add ( c . getString ( R . string . bus_options_menu_show_route_schedule ) ) ; } list . add ( c . getString ( R . string . bus_options_menu_report_trip_problem ) ) ; return list ; }
public static List < Integer > buildTripOptionsIcons ( boolean isRouteFavorite , boolean hasUrl ) { ArrayList < Integer > list = new ArrayList <> ( ) ; if ( ! isRouteFavorite ) { list . add ( R . drawable . focus_star_on ) ; } else { list . add ( R . drawable . focus_star_off ) ; } list . add ( R . drawable . ic_arrivals_styleb_action_map ) ; list . add ( R . drawable . ic_trip_details ) ; list . add ( R . drawable . ic_drawer_alarm ) ; list . add ( R . drawable . ic_content_filter_list ) ; if ( hasUrl ) { list . add ( R . drawable . ic_notification_event_note ) ; } list . add ( R . drawable . ic_alert_warning ) ; return list ; }
public static void setRealtimeIndicatorColorByResourceCode ( ViewGroup vg , Integer lineColor , Integer fillColor ) { Resources r = vg . getResources ( ) ; setRealtimeIndicatorColor ( vg , r . getColor ( lineColor ) , r . getColor ( fillColor ) ) ; }
public static void setRealtimeIndicatorColor ( ViewGroup vg , Integer lineColor , Integer fillColor ) { for ( int i = 0 ; i < vg . getChildCount ( ) ; i ++ ) { View v = vg . getChildAt ( i ) ; if ( v instanceof RealtimeIndicatorView ) { if ( lineColor != null ) { ( ( RealtimeIndicatorView ) v ) . setLineColor ( lineColor ) ; } else { ( ( RealtimeIndicatorView ) v ) . setLineColor ( R . color . realtime_indicator_line ) ; } if ( fillColor != null ) { ( ( RealtimeIndicatorView ) v ) . setFillColor ( fillColor ) ; } else { ( ( RealtimeIndicatorView ) v ) . setLineColor ( R . color . realtime_indicator_fill ) ; } } } }
public static Bitmap colorBitmap ( Bitmap source , int color ) { int width = source . getWidth ( ) ; int height = source . getHeight ( ) ; int [] pixels = new int [ width * height ] ; source . getPixels ( pixels , 0 , width , 0 , 0 , width , height ) ; for ( int x = 0 ; x < pixels . length ; ++ x ) { pixels [ x ] = ( pixels [ x ] == Color . BLACK ) ? color : pixels [ x ] ; } Bitmap out = Bitmap . createBitmap ( width , height , source . getConfig ( ) ) ; out . setPixels ( pixels , 0 , width , 0 , 0 , width , height ) ; return out ; }
public static boolean isTouchInView ( View view , MotionEvent event ) { Rect rect = new Rect ( ) ; view . getGlobalVisibleRect ( rect ) ; return rect . contains ( ( int ) event . getRawX ( ) , ( int ) event . getRawY ( ) ) ; }
public static long getCurrentTimeForComparison ( ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . JELLY_BEAN_MR1 ) { return SystemClock . elapsedRealtimeNanos ( ) ; } else { return TimeUnit . MILLISECONDS . toNanos ( System . currentTimeMillis ( ) ) ; } }
public static void openKeyboard ( Context context ) { InputMethodManager inputMethodManager = ( InputMethodManager ) context . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; inputMethodManager . toggleSoftInput ( InputMethodManager . SHOW_FORCED , InputMethodManager . HIDE_NOT_ALWAYS ) ; }
public static void closeKeyboard ( Context context , View v ) { InputMethodManager imm = ( InputMethodManager ) context . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; imm . hideSoftInputFromWindow ( v . getWindowToken ( ) , 0 ) ; }
public static List < ObaSituation > getAllSituations ( final ObaArrivalInfoResponse response ) { List < ObaSituation > allSituations = new ArrayList <> ( ) ; allSituations . addAll ( response . getSituations ( ) ) ; HashSet < String > allIds = new HashSet <> ( ) ; for ( ObaSituation s : allSituations ) { allIds . add ( s . getId ( ) ) ; } ObaArrivalInfo [] info = response . getArrivalInfo ( ) ; for ( ObaArrivalInfo i : info ) { for ( String situationId : i . getSituationIds ( ) ) { if ( ! allIds . contains ( situationId ) ) { allIds . add ( situationId ) ; allSituations . add ( response . getSituation ( situationId ) ) ; } } } return allSituations ; }
public static boolean isActiveWindowForSituation ( ObaSituation situation , long currentTime ) { if ( situation . getActiveWindows ( ) . length == 0 ) { return true ; } long currentTimeSeconds = TimeUnit . MILLISECONDS . toSeconds ( currentTime ) ; boolean isActiveWindowForSituation = false ; for ( ObaSituation . ActiveWindow activeWindow : situation . getActiveWindows ( ) ) { long from = activeWindow . getFrom ( ) ; long to = activeWindow . getTo ( ) ; if ( from <= currentTimeSeconds && currentTimeSeconds <= to ) { isActiveWindowForSituation = true ; break; } } return isActiveWindowForSituation ; }
public static String formatTime ( Context context , long time ) { return DateUtils . formatDateTime ( context , time , DateUtils . FORMAT_SHOW_TIME | DateUtils . FORMAT_NO_NOON | DateUtils . FORMAT_NO_MIDNIGHT ) ; }
public static void maybeShrinkRouteName ( Context context , TextView view , String routeShortName ) { if ( routeShortName . length ( ) < 4 ) { return; } else if ( routeShortName . length ( ) == 4 ) { view . setTextSize ( TypedValue . COMPLEX_UNIT_PX , context . getResources ( ) . getDimension ( R . dimen . route_name_text_size_medium ) ) ; } else if ( routeShortName . length ( ) > 4 ) { view . setTextSize ( TypedValue . COMPLEX_UNIT_PX , context . getResources ( ) . getDimension ( R . dimen . route_name_text_size_small ) ) ; } }
public static int getTransparentColor ( int solidColor , int alpha ) { int r = Color . red ( solidColor ) ; int g = Color . green ( solidColor ) ; int b = Color . blue ( solidColor ) ; return Color . argb ( alpha , r , g , b ) ; }
public static Location getMapCenter ( Bundle b ) { if ( b == null ) { return null ; } Location center = null ; double lat = b . getDouble ( MapParams . CENTER_LAT ) ; double lon = b . getDouble ( MapParams . CENTER_LON ) ; if ( lat != 0.0 && lon != 0.0 ) { center = LocationUtils . makeLocation ( lat , lon ) ; } return center ; }
public static File createImageFile ( Context context , String nameSuffix ) throws IOException { String timeStamp = new SimpleDateFormat ( "yyyyMMdd_HHmmss" ) . format ( new Date ( ) ) ; StringBuilder imageFileName = new StringBuilder ( ) ; imageFileName . append ( "JPEG_" ) ; imageFileName . append ( timeStamp ) ; imageFileName . append ( "_" ) ; if ( nameSuffix != null ) { imageFileName . append ( nameSuffix ) ; } File storageDir = context . getExternalFilesDir ( Environment . DIRECTORY_PICTURES ) ; return File . createTempFile ( imageFileName . toString ( ) , ".jpg" , storageDir ) ; }
public static Bitmap decodeSampledBitmapFromFile ( String pathName , int reqWidth , int reqHeight )            throws IOException { final BitmapFactory . Options options = new BitmapFactory . Options ( ) ; options . inJustDecodeBounds = true ; BitmapFactory . decodeFile ( pathName , options ) ; options . inSampleSize = calculateInSampleSize ( options , reqWidth , reqHeight ) ; options . inJustDecodeBounds = false ; Bitmap b = BitmapFactory . decodeFile ( pathName , options ) ; return rotateImageIfRequired ( b , pathName ) ; }
private static int calculateInSampleSize ( BitmapFactory . Options options , int reqWidth , int reqHeight ) { final int height = options . outHeight ; final int width = options . outWidth ; int inSampleSize = 1 ; if ( height > reqHeight || width > reqWidth ) { final int heightRatio = Math . round ( ( float ) height / ( float ) reqHeight ) ; final int widthRatio = Math . round ( ( float ) width / ( float ) reqWidth ) ; inSampleSize = heightRatio < widthRatio ? heightRatio : widthRatio ; final float totalPixels = width * height ; final float totalReqPixelsCap = reqWidth * reqHeight * 2 ; while ( totalPixels / ( inSampleSize * inSampleSize ) > totalReqPixelsCap ) { inSampleSize ++ ; } } return inSampleSize ; }
private static Bitmap rotateImageIfRequired ( Bitmap img , String imagePath ) throws IOException { ExifInterface ei = new ExifInterface ( imagePath ) ; int orientation = ei . getAttributeInt ( ExifInterface . TAG_ORIENTATION , ExifInterface . ORIENTATION_NORMAL ) ; switch ( orientation ) { case ExifInterface . ORIENTATION_ROTATE_90 : return rotateImage ( img , 90 ) ; case ExifInterface . ORIENTATION_ROTATE_180 : return rotateImage ( img , 180 ) ; case ExifInterface . ORIENTATION_ROTATE_270 : return rotateImage ( img , 270 ) ; default: return img ; } }
private static Bitmap rotateImage ( Bitmap img , int degree ) { Matrix matrix = new Matrix ( ) ; matrix . postRotate ( degree ) ; Bitmap rotatedImg = Bitmap . createBitmap ( img , 0 , 0 , img . getWidth ( ) , img . getHeight ( ) , matrix , true ) ; img . recycle ( ) ; return rotatedImg ; }
@ Override public void onAttach ( Activity activity ) { super. onAttach ( activity ) ; GoogleApiAvailability api = GoogleApiAvailability . getInstance ( ) ; if ( api . isGooglePlayServicesAvailable ( getActivity ( ) ) == ConnectionResult . SUCCESS ) { mGoogleApiClient = LocationUtils . getGoogleApiClientWithCallbacks ( getActivity ( ) ) ; mGoogleApiClient . connect ( ) ; } }
@ Override public void onActivityCreated ( Bundle savedInstanceState ) { super. onActivityCreated ( savedInstanceState ) ; registerForContextMenu ( getListView ( ) ) ; TextView empty = ( TextView ) getView ( ) . findViewById ( android . R . id . empty ) ; empty . setMovementMethod ( LinkMovementMethod . getInstance ( ) ) ; setEmptyText ( getHintText ( ) ) ; mSearchViewV1 . setQueryHint ( getString ( getEditBoxHintText ( ) ) ) ; mSearchViewV1 . setOnQueryTextListener ( this ) ; mSearchViewV1 . setOnQueryTextFocusChangeListener ( mOnQueryTextFocusChangeListener ) ; }
@ Override public void onViewCreated ( View view , Bundle savedInstanceState ) { super. onViewCreated ( view , savedInstanceState ) ; mSearchViewV1 = ( SearchViewV1 ) getView ( ) . findViewById ( R . id . search ) ; }
@ Override public void onStart ( ) { super. onStart ( ) ; if ( mGoogleApiClient != null && ! mGoogleApiClient . isConnected ( ) ) { mGoogleApiClient . connect ( ) ; } }
@ Override public void onStop ( ) { if ( mGoogleApiClient != null && mGoogleApiClient . isConnected ( ) ) { mGoogleApiClient . disconnect ( ) ; } UIUtils . closeKeyboard ( getActivity ( ) , mSearchViewV1 ) ; super. onStop ( ) ; }
@ Override public void onDestroy ( ) { cancelDelayedSearch ( ) ; super. onDestroy ( ) ; }
@ Override public void setEmptyText ( CharSequence seq ) { TextView empty = ( TextView ) getView ( ) . findViewById ( R . id . internalEmpty ) ; if ( empty != null ) { empty . setText ( seq , BufferType . SPANNABLE ) ; } empty = ( TextView ) getView ( ) . findViewById ( android . R . id . empty ) ; if ( empty != null ) { empty . setText ( seq , BufferType . SPANNABLE ) ; } }
@ Override public boolean onQueryTextChange ( String newText ) { cancelDelayedSearch ( ) ; if ( newText . length ( ) == 0 ) { return true ; } final String query = newText ; final Runnable doSearch = new Runnable ( ) { public void run ( ) { doSearch ( query ) ; } } ; mSearchTimer = new Timer ( ) ; mSearchTimer . schedule ( new TimerTask ( ) { @ Override public void run ( ) { mSearchHandler . post ( doSearch ) ; } } , DELAYED_SEARCH_TIMEOUT ) ; return true ; }
public void run ( ) { doSearch ( query ) ; }
@ Override public void run ( ) { mSearchHandler . post ( doSearch ) ; }
@ Override public boolean onQueryTextSubmit ( String query ) { return true ; }
protected void cancelDelayedSearch ( ) { if ( mSearchTimer != null ) { mSearchTimer . cancel ( ) ; mSearchTimer = null ; } }
protected SearchViewV1 getSearchViewV1 ( ) { return mSearchViewV1 ; }
protected final void makeShortcut ( String name , Intent destIntent ) { final Intent shortcut = UIUtils . makeShortcut ( getActivity ( ) , name , destIntent ) ; Activity activity = getActivity ( ) ; activity . setResult ( Activity . RESULT_OK , shortcut ) ; activity . finish ( ) ; }
protected boolean isShortcutMode ( ) { Activity act = getActivity ( ) ; if ( act instanceof MyTabActivityBase ) { MyTabActivityBase base = ( MyTabActivityBase ) act ; return base . isShortcutMode ( ) ; } return false ; }
protected final Location getSearchCenter ( ) { Activity act = getActivity ( ) ; Location location = Application . getLastKnownLocation ( act , mGoogleApiClient ) ; if ( location == null ) { location = LocationUtils . getDefaultSearchCenter ( ) ; } return location ; }
@ Override public void onFocusChange ( View view , boolean hasFocus ) { if ( hasFocus ) { getActivity ( ) . getWindow ( ) . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_STATE_ALWAYS_VISIBLE ) ; } }
abstract protected void doSearch ( String text );
abstract protected int getEditBoxHintText ( )
abstract protected int getMinSearchLength ( )
abstract protected CharSequence getHintText ( )
private Entry ( ) { stopId = "" ; arrivalsAndDepartures = ObaArrivalInfo . EMPTY_ARRAY ; nearbyStopIds = new String [] {} ; situationIds = new String [] {} ; }
ObaArrivalInfoResponse ( ) { data = Data . EMPTY_OBJECT ; }
public ObaStop getStop ( ) { if ( data == null || data . references == null || data . entry == null ) { return null ; } else { return data . references . getStop ( data . entry . stopId ) ; } }
public List < ObaStop > getNearbyStops ( ) { return data . references . getStops ( data . entry . nearbyStopIds ) ; }
public ObaArrivalInfo [] getArrivalInfo ( ) { return data . entry . arrivalsAndDepartures ; }
public List < ObaSituation > getSituations ( ) { return data . references . getSituations ( data . entry . situationIds ) ; }
@ Override public ObaReferences getRefs ( ) { return data . references ; }
public void testKCMStopRequestUsingCustomUrl ( ) { Application . get ( ) . setCustomApiUrl ( "api.pugetsound.onebusaway.org" ) ; _assertKCMStopRequest ( ) ; }
public void testKCMStopRequestUsingRegion ( ) { ObaRegion ps = MockRegion . getPugetSound ( getContext ( ) ) ; assertNotNull ( ps ) ; Application . get ( ) . setCurrentRegion ( ps ) ; _assertKCMStopRequest ( ) ; }
private void _assertKCMStopRequest ( ) { ObaArrivalInfoRequest . Builder builder = new ObaArrivalInfoRequest . Builder ( getContext ( ) , "1_29261" ) ; ObaArrivalInfoRequest request = builder . build ( ) ; UriAssert . assertUriMatch ( "http: , new HashMap < String , String > ( ) { { put ( "key" , "*" ) ; put ( "version" , "2" ) ; } } , request ) ; }
public void testHARTStopRequestUsingCustomUrl ( ) { Application . get ( ) . setCustomApiUrl ( "api.tampa.onebusaway.org/api" ) ; _assertHARTStopRequest ( ) ; }
public void testHARTStopRequestUsingRegion ( ) { ObaRegion tampa = MockRegion . getTampa ( getContext ( ) ) ; assertNotNull ( tampa ) ; Application . get ( ) . setCurrentRegion ( tampa ) ; _assertHARTStopRequest ( ) ; }
private void _assertHARTStopRequest ( ) { ObaArrivalInfoRequest . Builder builder = new ObaArrivalInfoRequest . Builder ( getContext ( ) , "Hillsborough Area Regional Transit_3105" ) ; ObaArrivalInfoRequest request = builder . build ( ) ; UriAssert . assertUriMatch ( "http: , new HashMap < String , String > ( ) { { put ( "key" , "*" ) ; put ( "version" , "2" ) ; } } , request ) ; }
public void testKCMStopResponseUsingCustomUrl ( ) Exception { Application . get ( ) . setCustomApiUrl ( "api.pugetsound.onebusaway.org" ) ; _assertKCMStopResponse ( ) ; }
public void testKCMStopResponseUsingRegion ( ) Exception { ObaRegion ps = MockRegion . getPugetSound ( getContext ( ) ) ; assertNotNull ( ps ) ; Application . get ( ) . setCurrentRegion ( ps ) ; _assertKCMStopResponse ( ) ; }
private void _assertKCMStopResponse ( ) { ObaArrivalInfoResponse response = new ObaArrivalInfoRequest . Builder ( getContext ( ) , "1_29261" ) . build ( ) . call ( ) ; assertOK ( response ) ; ObaStop stop = response . getStop ( ) ; assertNotNull ( stop ) ; assertEquals ( "1_29261" , stop . getId ( ) ) ; final List < ObaRoute > routes = response . getRoutes ( stop . getRouteIds ( ) ) ; assertTrue ( routes . size ( ) > 0 ) ; ObaAgency agency = response . getAgency ( routes . get ( 0 ) . getAgencyId ( ) ) ; assertEquals ( "1" , agency . getId ( ) ) ; final ObaArrivalInfo [] arrivals = response . getArrivalInfo ( ) ; assertNotNull ( arrivals ) ; final List < ObaStop > nearbyStops = response . getNearbyStops ( ) ; assertTrue ( nearbyStops . size ( ) > 0 ) ; }
public void testHARTStopResponseUsingCustomUrl ( ) Exception { Application . get ( ) . setCustomApiUrl ( "api.tampa.onebusaway.org/api" ) ; _assertHARTStopResponse ( ) ; }
public void testHARTStopResponseUsingRegion ( ) Exception { ObaRegion tampa = MockRegion . getTampa ( getContext ( ) ) ; assertNotNull ( tampa ) ; Application . get ( ) . setCurrentRegion ( tampa ) ; _assertHARTStopResponse ( ) ; }
private void _assertHARTStopResponse ( ) { ObaArrivalInfoResponse response = new ObaArrivalInfoRequest . Builder ( getContext ( ) , "Hillsborough Area Regional Transit_3105" ) . build ( ) . call ( ) ; assertOK ( response ) ; ObaStop stop = response . getStop ( ) ; assertNotNull ( stop ) ; assertEquals ( "Hillsborough Area Regional Transit_3105" , stop . getId ( ) ) ; final List < ObaRoute > routes = response . getRoutes ( stop . getRouteIds ( ) ) ; assertTrue ( routes . size ( ) > 0 ) ; ObaAgency agency = response . getAgency ( routes . get ( 0 ) . getAgencyId ( ) ) ; assertEquals ( "Hillsborough Area Regional Transit" , agency . getId ( ) ) ; ObaTrip trip = response . getTrip ( "Hillsborough Area Regional Transit_909841" ) ; assertEquals ( "Hillsborough Area Regional Transit_266684" , trip . getBlockId ( ) ) ; final ObaArrivalInfo [] arrivals = response . getArrivalInfo ( ) ; assertNotNull ( arrivals ) ; assertEquals ( 27.982215585882088 , arrivals [ 0 ] . getTripStatus ( ) . getPosition ( ) . getLatitude ( ) ) ; assertEquals ( - 82.4224 , arrivals [ 0 ] . getTripStatus ( ) . getPosition ( ) . getLongitude ( ) ) ; final List < ObaStop > nearbyStops = response . getNearbyStops ( ) ; assertTrue ( nearbyStops . size ( ) > 0 ) ; }
public void testTotalStopsInTrip ( ) Exception { Application . get ( ) . setCustomApiUrl ( "api.tampa.onebusaway.org/api" ) ; ObaArrivalInfoResponse response = new ObaArrivalInfoRequest . Builder ( getContext ( ) , "Hillsborough Area Regional Transit_10000" ) . build ( ) . call ( ) ; assertOK ( response ) ; ObaArrivalInfo [] arrivals = response . getArrivalInfo ( ) ; assertNotNull ( arrivals ) ; assertEquals ( 34 , arrivals [ 0 ] . getTotalStopsInTrip ( ) ) ; assertEquals ( 34 , arrivals [ 1 ] . getTotalStopsInTrip ( ) ) ; assertEquals ( 142 , arrivals [ 2 ] . getTotalStopsInTrip ( ) ) ; assertEquals ( 71 , arrivals [ 3 ] . getTotalStopsInTrip ( ) ) ; assertEquals ( 142 , arrivals [ 4 ] . getTotalStopsInTrip ( ) ) ; assertEquals ( 34 , arrivals [ 5 ] . getTotalStopsInTrip ( ) ) ; assertEquals ( 34 , arrivals [ 6 ] . getTotalStopsInTrip ( ) ) ; assertEquals ( 142 , arrivals [ 7 ] . getTotalStopsInTrip ( ) ) ; response = new ObaArrivalInfoRequest . Builder ( getContext ( ) , "Hillsborough Area Regional Transit_6497" ) . build ( ) . call ( ) ; assertOK ( response ) ; arrivals = response . getArrivalInfo ( ) ; assertEquals ( 0 , arrivals [ 0 ] . getTotalStopsInTrip ( ) ) ; assertEquals ( 0 , arrivals [ 1 ] . getTotalStopsInTrip ( ) ) ; assertEquals ( 0 , arrivals [ 2 ] . getTotalStopsInTrip ( ) ) ; }
public void testNewRequestUsingCustomUrl ( ) Exception { Application . get ( ) . setCustomApiUrl ( "api.pugetsound.onebusaway.org" ) ; _assertNewRequest ( ) ; }
public void testNewRequestUsingRegion ( ) Exception { ObaRegion ps = MockRegion . getPugetSound ( getContext ( ) ) ; assertNotNull ( ps ) ; Application . get ( ) . setCurrentRegion ( ps ) ; _assertNewRequest ( ) ; }
private void _assertNewRequest ( ) { ObaArrivalInfoRequest request = ObaArrivalInfoRequest . newRequest ( getContext ( ) , "1_10" ) ; assertNotNull ( request ) ; UriAssert . assertUriMatch ( "http: , new HashMap < String , String > ( ) { { put ( "key" , "*" ) ; put ( "version" , "2" ) ; } } , request ) ; }
public void testStopSituationPsta ( ) Exception { Application . get ( ) . setCustomApiUrl ( "api.tampa.onebusaway.org/api" ) ; ObaArrivalInfoResponse response = new ObaArrivalInfoRequest . Builder ( getContext ( ) , "PSTA_4077" ) . build ( ) . call ( ) ; assertOK ( response ) ; List < ObaSituation > situations = response . getSituations ( ) ; assertNotNull ( situations ) ; ObaSituation situation = situations . get ( 0 ) ; assertEquals ( "PSTA_1" , situation . getId ( ) ) ; assertEquals ( "new 29: 29" , situation . getSummary ( ) ) ; assertEquals ( "[Low] : 29 updated" , situation . getDescription ( ) ) ; assertEquals ( "" , situation . getReason ( ) ) ; assertEquals ( 1424788240588l , situation . getCreationTime ( ) ) ; assertEquals ( "" , situation . getSeverity ( ) ) ; assertEquals ( "PSTA" , situation . getAllAffects ( ) [ 0 ] . getAgencyId ( ) ) ; assertEquals ( "" , situation . getAllAffects ( ) [ 0 ] . getApplicationId ( ) ) ; assertEquals ( "" , situation . getAllAffects ( ) [ 0 ] . getDirectionId ( ) ) ; assertEquals ( "" , situation . getAllAffects ( ) [ 0 ] . getRouteId ( ) ) ; assertEquals ( "" , situation . getAllAffects ( ) [ 0 ] . getStopId ( ) ) ; assertEquals ( "" , situation . getAllAffects ( ) [ 0 ] . getTripId ( ) ) ; assertNull ( situation . getUrl ( ) ) ; ObaSituation . ActiveWindow [] windows = situation . getActiveWindows ( ) ; assertEquals ( 0 , windows . length ) ; boolean result = UIUtils . isActiveWindowForSituation ( situation , response . getCurrentTime ( ) ) ; assertEquals ( true , result ) ; }
public void testStopSituationDart ( ) Exception { Application . get ( ) . setCustomApiUrl ( "dart.onebusaway.org/api" ) ; ObaArrivalInfoResponse response = new ObaArrivalInfoRequest . Builder ( getContext ( ) , "DART_4041" ) . build ( ) . call ( ) ; assertOK ( response ) ; List < ObaSituation > situations = response . getSituations ( ) ; assertNotNull ( situations ) ; ObaSituation situation = situations . get ( 0 ) ; assertEquals ( "DART_54" , situation . getId ( ) ) ; assertEquals ( "No DART bus service on Saturday, July 4, 2015" , situation . getSummary ( ) ) ; assertEquals ( "DART will not operate bus service on Saturday, July 4, 2015 in observation of Independence Day.\n\nDART will operate Saturday service on Friday, July 3, 2015 for the day before the holiday. Hours for the customer service window and phones are 8 a.m. to 4 p.m. and Administrative offices are also closed on Friday, July 3, 2015.\n\nThe following routes will not operate on Friday, July 3, 2015:\n\n· Local Routes 5, 8, 11, 13, 51\n\n· Express Routes\n\n· Flex Routes 73, 74\n\n· D-Line Downtown Shuttle\n\n· The LINK Shuttle\n\n· On Call Services\n\nFor more information, contact DART Customer Service at 515-283-8100 or by email at dart@ridedart.com.." , situation . getDescription ( ) ) ; assertEquals ( "" , situation . getReason ( ) ) ; assertEquals ( 1436072383004L , situation . getCreationTime ( ) ) ; assertEquals ( "" , situation . getSeverity ( ) ) ; assertEquals ( "DART" , situation . getAllAffects ( ) [ 0 ] . getAgencyId ( ) ) ; assertEquals ( "" , situation . getAllAffects ( ) [ 0 ] . getApplicationId ( ) ) ; assertEquals ( "" , situation . getAllAffects ( ) [ 0 ] . getDirectionId ( ) ) ; assertEquals ( "" , situation . getAllAffects ( ) [ 0 ] . getRouteId ( ) ) ; assertEquals ( "" , situation . getAllAffects ( ) [ 0 ] . getStopId ( ) ) ; assertEquals ( "" , situation . getAllAffects ( ) [ 0 ] . getTripId ( ) ) ; assertNull ( situation . getUrl ( ) ) ; ObaSituation . ActiveWindow [] windows = situation . getActiveWindows ( ) ; assertEquals ( 1435005045 , windows [ 0 ] . getFrom ( ) ) ; assertEquals ( 1436072372 , windows [ 0 ] . getTo ( ) ) ; assertEquals ( 1436072374 , windows [ 1 ] . getFrom ( ) ) ; assertEquals ( 1436073000 , windows [ 1 ] . getTo ( ) ) ; long timeBeforeWindow0 = 0 ; boolean result = UIUtils . isActiveWindowForSituation ( situation , timeBeforeWindow0 ) ; assertEquals ( false , result ) ; long timeWithinWindow0 = 1435005046000L ; result = UIUtils . isActiveWindowForSituation ( situation , timeWithinWindow0 ) ; assertEquals ( true , result ) ; long timeAfterWindow0 = 1436072373000L ; result = UIUtils . isActiveWindowForSituation ( situation , timeAfterWindow0 ) ; assertEquals ( false , result ) ; long timeBeforeWindow1 = 1436072373000L ; result = UIUtils . isActiveWindowForSituation ( situation , timeBeforeWindow1 ) ; assertEquals ( false , result ) ; long timeWithinWindow1 = 1436072375000L ; result = UIUtils . isActiveWindowForSituation ( situation , timeWithinWindow1 ) ; assertEquals ( true , result ) ; long timeAfterWindow1 = 1436073001000L ; result = UIUtils . isActiveWindowForSituation ( situation , timeAfterWindow1 ) ; assertEquals ( false , result ) ; }
public void testRouteSituationSdmts ( ) Exception { Application . get ( ) . setCustomApiUrl ( "sdmts.onebusway.org/api" ) ; ObaArrivalInfoResponse response = new ObaArrivalInfoRequest . Builder ( getContext ( ) , "MTS_11670" ) . build ( ) . call ( ) ; assertOK ( response ) ; List < ObaSituation > situations = response . getSituations ( ) ; assertNotNull ( situations ) ; assertEquals ( 0 , situations . size ( ) ) ; ObaArrivalInfo [] info = response . getArrivalInfo ( ) ; for ( ObaArrivalInfo i : info ) { for ( String situationId : i . getSituationIds ( ) ) { assertNotNull ( response . getSituation ( situationId ) ) ; } } String [] ids = info [ 0 ] . getSituationIds ( ) ; ObaSituation situation = response . getSituation ( ids [ 0 ] ) ; assertEquals ( "MTS_38" , situation . getId ( ) ) ; assertEquals ( "Concrete Pour Impacting N/B RTS 11, 901 & 929" , situation . getSummary ( ) ) ; assertEquals ( "Due to a three day concrete pour, northbound Park Blvd. will be closed from Imperial to 11th Ave. 9/21 - 9/23, from 5am - 4pm. Northbound routes 11, 901 and 929 will detour during construction hours. The northbound bus stop i.d 99010 on 11th at K (Library) will be temporarily discontinued. Connections can be made at 12th & Imperial." , situation . getDescription ( ) ) ; assertEquals ( "CONSTRUCTION" , situation . getReason ( ) ) ; assertEquals ( 1474527588415L , situation . getCreationTime ( ) ) ; assertEquals ( "" , situation . getSeverity ( ) ) ; assertEquals ( "" , situation . getAllAffects ( ) [ 0 ] . getAgencyId ( ) ) ; assertEquals ( "" , situation . getAllAffects ( ) [ 0 ] . getApplicationId ( ) ) ; assertEquals ( "" , situation . getAllAffects ( ) [ 0 ] . getDirectionId ( ) ) ; assertEquals ( "MTS_11" , situation . getAllAffects ( ) [ 0 ] . getRouteId ( ) ) ; assertEquals ( "" , situation . getAllAffects ( ) [ 0 ] . getStopId ( ) ) ; assertEquals ( "" , situation . getAllAffects ( ) [ 0 ] . getTripId ( ) ) ; ObaSituation . ActiveWindow [] windows = situation . getActiveWindows ( ) ; assertEquals ( 1474434000 , windows [ 0 ] . getFrom ( ) ) ; assertEquals ( 1474646400 , windows [ 0 ] . getTo ( ) ) ; ObaSituation . Consequence [] consequences = situation . getConsequences ( ) ; assertNotNull ( consequences ) ; assertEquals ( 1 , consequences . length ) ; ObaSituation . Consequence c = consequences [ 0 ] ; assertEquals ( ObaSituation . Consequence . CONDITION_DETOUR , c . getCondition ( ) ) ; ObaSituation . ConditionDetails details = c . getDetails ( ) ; assertNull ( details ) ; assertEquals ( "http: , situation . getUrl ( ) ) ; }
public static StoryListFragment newInstance ( @ StoryListViewModel . FeedType int feedType ) { StoryListFragment fragment = new StoryListFragment ( ) ; Bundle args = new Bundle ( ) ; args . putInt ( FEED_TO_LOAD , feedType ) ; fragment . setArguments ( args ) ; return fragment ; }
private void refresh ( ) { mRecyclerAdapter . clear ( ) ; getViewModel ( ) . setIsRestoring ( false ) ; getViewModel ( ) . setStoryList ( null ) ; react ( getViewModel ( ) . getStories ( ) , false ) ; }
private void react ( Observable < Story > stories , boolean pageTwo ) { stories . subscribe ( new Subscriber < Story > ( ) { @ Override public void onCompleted ( ) { showProgress ( false ) ; mSwipeRefreshLayout . setRefreshing ( false ) ; getViewModel ( ) . setPageTwoLoaded ( pageTwo ) ; } @ Override public void onError ( Throwable e ) { if ( e instanceof RetrofitError ) { Toast . makeText ( getActivity ( ) , R . string . story_list_error_toast_message , Toast . LENGTH_SHORT ) . show ( ) ; } else { throw new RuntimeException ( e ) ; } } @ Override public void onNext ( Story story ) { if ( story . getStoryId ( ) != null && mRecyclerAdapter . getPositionOfItem ( story ) == - 1 ) { mRecyclerAdapter . addStory ( story ) ; } } } ) ; }
@ Override public void onCompleted ( ) { showProgress ( false ) ; mSwipeRefreshLayout . setRefreshing ( false ) ; getViewModel ( ) . setPageTwoLoaded ( pageTwo ) ; }
@ Override public void onError ( Throwable e ) { if ( e instanceof RetrofitError ) { Toast . makeText ( getActivity ( ) , R . string . story_list_error_toast_message , Toast . LENGTH_SHORT ) . show ( ) ; } else { throw new RuntimeException ( e ) ; } }
@ Override public void onNext ( Story story ) { if ( story . getStoryId ( ) != null && mRecyclerAdapter . getPositionOfItem ( story ) == - 1 ) { mRecyclerAdapter . addStory ( story ) ; } }
@ Override public void onAttach ( Activity activity ) { super. onAttach ( activity ) ; try { mListener = ( OnStoryListFragmentInteractionListener ) activity ; } catch ( ClassCastException e ) { throw new ClassCastException ( activity . toString ( ) + " must implement OnStoryListFragmentInteractionListener" ) ; } }
@ Override public void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; DaggerViewModelComponent . builder ( ) . appComponent ( HackerNewsApplication . getAppComponent ( ) ) . build ( ) . inject ( this ) ; if( savedInstanceState != null ) { getViewModel ( ) . setStoryList ( savedInstanceState . getParcelableArrayList ( STORY_LIST ) ) ; getViewModel ( ) . setIsRestoring ( true ) ; } if ( getArguments ( ) != null ) { @ StoryListViewModel . FeedType final int feedType = getArguments ( ) . getInt ( FEED_TO_LOAD ) ; getViewModel ( ) . setFeedType ( feedType ) ; } setHasOptionsMenu ( true ) ; }
@ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View view = inflater . inflate ( R . layout . fragment_storylist_list , container , false ) ; ButterKnife . inject ( this , view ) ; getViewModel ( ) . setPageTwoLoaded ( false ) ; mContainer = view . findViewById ( R . id . story_list ) ; mProgressBar = ( ProgressBar ) view . findViewById ( R . id . progress_bar ) ; final ActionBar actionBar = ( ( AppCompatActivity ) getActivity ( ) ) . getSupportActionBar ( ) ; if ( actionBar != null ) { actionBar . setTitle ( getViewModel ( ) . getTitle ( ) ) ; } showProgress ( true ) ; if ( savedInstanceState == null || mRecyclerAdapter == null ) { setupRecyclerView ( ) ; showBetaPopup ( ) ; refresh ( ) ; } else { showProgress ( false ) ; } if ( getViewModel ( ) . getFeedType ( ) == StoryListViewModel . FEED_TYPE_TOP ) { mRecyclerView . setOnScrollListener ( new EndlessRecyclerOnScrollListener ( mLayoutManager ) { @ Override public void onLoadMore ( int current_page ) { if ( ! getViewModel ( ) . isPageTwoLoaded ( ) ) { react ( getViewModel ( ) . getTopStoriesPageTwo ( ) , true ) ; } } } ) ; } mRecyclerView . setAdapter ( mRecyclerAdapter ) ; setupSwipeToRefresh ( ) ; if ( savedInstanceState != null ) { mLayoutManager . scrollToPosition ( savedInstanceState . getInt ( TOP_OF_LIST ) ) ; } return view ; }
@ Override public void onLoadMore ( int current_page ) { if ( ! getViewModel ( ) . isPageTwoLoaded ( ) ) { react ( getViewModel ( ) . getTopStoriesPageTwo ( ) , true ) ; } }
private void showBetaPopup ( ) { if ( ! getViewModel ( ) . isReturningUser ( ) ) { new AlertDialog . Builder ( getActivity ( ) ) . setMessage ( R . string . beta_prompt_message ) . setPositiveButton ( android . R . string . ok , ( dialog , which ) -> { Intent gPlusIntent = new Intent ( ) ; gPlusIntent . setAction ( Intent . ACTION_VIEW ) ; gPlusIntent . setData ( Uri . parse ( "https: ) ) ; getActivity ( ) . startActivity ( gPlusIntent ) ; } ) . setNegativeButton ( R . string . beta_prompt_negative , ( dialog , which ) -> {                    } ) . create ( ) . show ( ) ; getViewModel ( ) . setReturningUser ( true ) ; } }
private void setupRecyclerView ( ) { StoryListAdapter . StoryListAdapterListener listener = new StoryListAdapter . StoryListAdapterListener ( ) { @ Override public void onStoryClick ( int position ) { getViewModel ( ) . markStoryAsRead ( mRecyclerAdapter . getItem ( position ) ) . subscribeOn ( Schedulers . io ( ) ) . observeOn ( AndroidSchedulers . mainThread ( ) ) . subscribe ( new Subscriber < Story > ( ) { @ Override public void onCompleted ( ) { mListener . onStoryListFragmentInteraction ( mRecyclerAdapter . getItemId ( position ) , getViewModel ( ) . getFeedType ( ) == StoryListViewModel . FEED_TYPE_SAVED ) ; } @ Override public void onError ( Throwable e ) {                                  } @ Override public void onNext ( Story story ) { mRecyclerAdapter . markStoryAsRead ( position , story ) ; } } ) ; } @ Override public void onStorySave ( int position , boolean save ) { if ( save ) { getViewModel ( ) . saveStory ( mRecyclerAdapter . getItem ( position ) ) . subscribeOn ( Schedulers . io ( ) ) . observeOn ( AndroidSchedulers . mainThread ( ) ) . subscribe ( ( Action1 ) o -> UIUtils . showToast ( getActivity ( ) , "Saved!" ) ) ; } else { getViewModel ( ) . deleteStory ( mRecyclerAdapter . getItem ( position ) ) . subscribeOn ( Schedulers . io ( ) ) . observeOn ( AndroidSchedulers . mainThread ( ) ) . subscribe ( new Subscriber < Object > ( ) { @ Override public void onCompleted ( ) { if ( getViewModel ( ) . getFeedType ( ) == StoryListViewModel . FEED_TYPE_SAVED ) { mRecyclerAdapter . removeItem ( position ) ; } } @ Override public void onError ( Throwable e ) {                                      } @ Override public void onNext ( Object o ) {                                      } } ) ; } mRecyclerAdapter . notifyItemChanged ( position ) ; } } ; mRecyclerAdapter = new StoryListAdapter ( getActivity ( ) , new ArrayList <> ( ) , listener , getViewModel ( ) . isNightMode ( ) ) ; mLayoutManager = new LinearLayoutManager ( getActivity ( ) ) ; mRecyclerView . setLayoutManager ( mLayoutManager ) ; mRecyclerView . addItemDecoration ( new SpacesItemDecoration ( 8 ) ) ; }
@ Override public void onStoryClick ( int position ) { getViewModel ( ) . markStoryAsRead ( mRecyclerAdapter . getItem ( position ) ) . subscribeOn ( Schedulers . io ( ) ) . observeOn ( AndroidSchedulers . mainThread ( ) ) . subscribe ( new Subscriber < Story > ( ) { @ Override public void onCompleted ( ) { mListener . onStoryListFragmentInteraction ( mRecyclerAdapter . getItemId ( position ) , getViewModel ( ) . getFeedType ( ) == StoryListViewModel . FEED_TYPE_SAVED ) ; } @ Override public void onError ( Throwable e ) {                                  } @ Override public void onNext ( Story story ) { mRecyclerAdapter . markStoryAsRead ( position , story ) ; } } ) ; }
@ Override public void onCompleted ( ) { mListener . onStoryListFragmentInteraction ( mRecyclerAdapter . getItemId ( position ) , getViewModel ( ) . getFeedType ( ) == StoryListViewModel . FEED_TYPE_SAVED ) ; }
@ Override public void onError ( Throwable e ) {                                  }
@ Override public void onNext ( Story story ) { mRecyclerAdapter . markStoryAsRead ( position , story ) ; }
@ Override public void onStorySave ( int position , boolean save ) { if ( save ) { getViewModel ( ) . saveStory ( mRecyclerAdapter . getItem ( position ) ) . subscribeOn ( Schedulers . io ( ) ) . observeOn ( AndroidSchedulers . mainThread ( ) ) . subscribe ( ( Action1 ) o -> UIUtils . showToast ( getActivity ( ) , "Saved!" ) ) ; } else { getViewModel ( ) . deleteStory ( mRecyclerAdapter . getItem ( position ) ) . subscribeOn ( Schedulers . io ( ) ) . observeOn ( AndroidSchedulers . mainThread ( ) ) . subscribe ( new Subscriber < Object > ( ) { @ Override public void onCompleted ( ) { if ( getViewModel ( ) . getFeedType ( ) == StoryListViewModel . FEED_TYPE_SAVED ) { mRecyclerAdapter . removeItem ( position ) ; } } @ Override public void onError ( Throwable e ) {                                      } @ Override public void onNext ( Object o ) {                                      } } ) ; } mRecyclerAdapter . notifyItemChanged ( position ) ; }
@ Override public void onCompleted ( ) { if ( getViewModel ( ) . getFeedType ( ) == StoryListViewModel . FEED_TYPE_SAVED ) { mRecyclerAdapter . removeItem ( position ) ; } }
@ Override public void onError ( Throwable e ) {                                      }
@ Override public void onNext ( Object o ) {                                      }
private void setupSwipeToRefresh ( ) { mSwipeRefreshLayout . setColorSchemeColors ( getResources ( ) . getColor ( R . color . colorPrimary ) , getResources ( ) . getColor ( R . color . colorPrimaryDark ) ) ; mSwipeRefreshLayout . setOnRefreshListener ( ( ) { mSwipeRefreshLayout . setRefreshing ( true ) ; if ( getViewModel ( ) . getFeedType ( ) == StoryListViewModel . FEED_TYPE_SAVED ) { mSwipeRefreshLayout . setRefreshing ( false ) ; new AlertDialog . Builder ( getActivity ( ) ) . setMessage ( getString ( R . string . action_refresh_saved_stories ) ) . setPositiveButton ( android . R . string . ok , ( dialog , which ) -> { getViewModel ( ) . saveAllStories ( ) . observeOn ( Schedulers . io ( ) ) . subscribeOn ( AndroidSchedulers . mainThread ( ) ) . subscribe ( new Observer < Object > ( ) { @ Override public void onCompleted ( ) { UIUtils . showToast ( getActivity ( ) , "Saved!" ) ; } @ Override public void onError ( Throwable e ) {                                              } @ Override public void onNext ( Object o ) {                                              } } ) ; } ) . setNegativeButton ( android . R . string . cancel , ( dialog , which ) -> { mSwipeRefreshLayout . setRefreshing ( false ) ; } ) . show ( ) ; } else { refresh ( ) ; } } ) ; }
@ Override public void onCompleted ( ) { UIUtils . showToast ( getActivity ( ) , "Saved!" ) ; }
@ Override public void onError ( Throwable e ) {                                              }
@ Override public void onNext ( Object o ) {                                              }
@ Override public void onSaveInstanceState ( Bundle outState ) { super. onSaveInstanceState ( outState ) ; outState . putInt ( TOP_OF_LIST , mLayoutManager . findFirstVisibleItemPosition ( ) ) ; outState . putParcelableArrayList ( STORY_LIST , getViewModel ( ) . getStoryList ( ) ) ; }
@ Override public void onDetach ( ) { mListener = null ; super. onDetach ( ) ; }
@ Override public void onDestroyView ( ) { super. onDestroyView ( ) ; ButterKnife . reset ( this ) ; }
@ Override public void onCreateOptionsMenu ( Menu menu , MenuInflater inflater ) { super. onCreateOptionsMenu ( menu , inflater ) ; if ( getViewModel ( ) . getFeedType ( ) != StoryListViewModel . FEED_TYPE_SAVED ) { inflater . inflate ( R . menu . menu_story_list_save , menu ) ; } else { inflater . inflate ( R . menu . menu_story_list_saved , menu ) ; } }
@ Override public boolean onOptionsItemSelected ( MenuItem item ) { switch ( item . getItemId ( ) ) { case R . id . action_delete : new AlertDialog . Builder ( getActivity ( ) ) . setMessage ( getString ( R . string . action_share_delete_all_stories ) ) . setPositiveButton ( android . R . string . ok , ( dialog , which ) -> { ProgressDialog progressDialog = new ProgressDialog ( getActivity ( ) ) ; progressDialog . setMessage ( getString ( R . string . action_delete_in_progress_message ) ) ; progressDialog . setCancelable ( false ) ; progressDialog . show ( ) ; getViewModel ( ) . deleteAllSavedStories ( ) . observeOn ( Schedulers . io ( ) ) . subscribeOn ( AndroidSchedulers . mainThread ( ) ) . subscribe ( new Observer < Object > ( ) { @ Override public void onCompleted ( ) { progressDialog . dismiss ( ) ; mRecyclerAdapter . removeAllItems ( ) ; } @ Override public void onError ( Throwable e ) {                                              } @ Override public void onNext ( Object o ) {                                              } } ) ; } ) . setNegativeButton ( android . R . string . cancel , null ) . show ( ) ; return true ; case R . id . action_save : new AlertDialog . Builder ( getActivity ( ) ) . setMessage ( getString ( R . string . action_save_all_stories ) ) . setPositiveButton ( android . R . string . ok , ( dialog , which ) -> { getViewModel ( ) . saveAllStories ( ) . subscribeOn ( Schedulers . io ( ) ) . observeOn ( AndroidSchedulers . mainThread ( ) ) . subscribe ( new Observer < Object > ( ) { @ Override public void onCompleted ( ) { UIUtils . showToast ( getActivity ( ) , "Saved!" ) ; } @ Override public void onError ( Throwable e ) {                                              } @ Override public void onNext ( Object o ) { } } ) ; } ) . setNegativeButton ( android . R . string . cancel , null ) . create ( ) . show ( ) ; return true ; } return super. onOptionsItemSelected ( item ) ; }
@ Override public void onCompleted ( ) { progressDialog . dismiss ( ) ; mRecyclerAdapter . removeAllItems ( ) ; }
@ Override public void onError ( Throwable e ) {                                              }
@ Override public void onNext ( Object o ) {                                              }
@ Override public void onCompleted ( ) { UIUtils . showToast ( getActivity ( ) , "Saved!" ) ; }
@ Override public void onError ( Throwable e ) {                                              }
@ Override public void onNext ( Object o ) { }
@ Override public StoryListViewModel getViewModel ( ) { return mViewModel ; }
void onStoryListFragmentInteraction ( long id , boolean saved );
Bounds ( ) { lat = 0 ; lon = 0 ; latSpan = 0 ; lonSpan = 0 ; }
public Bounds ( double lat , double lon , double latSpan , double lonSpan ) { this . lat = lat ; this . lon = lon ; this . latSpan = latSpan ; this . lonSpan = lonSpan ; }
@ Override public double getLat ( ) { return lat ; }
@ Override public double getLon ( ) { return lon ; }
@ Override public double getLatSpan ( ) { return latSpan ; }
@ Override public double getLonSpan ( ) { return lonSpan ; }
@ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "[" ) ; sb . append ( "lat=" ) . append ( lat ) . append ( "," ) ; sb . append ( "lon=" ) . append ( lon ) . append ( "," ) ; sb . append ( "latSpan=" ) . append ( latSpan ) . append ( "," ) ; sb . append ( "lonSpan=" ) . append ( lonSpan ) ; sb . append ( "]" ) ; return sb . toString ( ) ; }
public Open311Server ( ) { jurisdictionId = "" ; apiKey = "" ; baseUrl = "" ; }
public Open311Server ( String jurisdictionId , String apiKey , String baseUrl ) { this . jurisdictionId = jurisdictionId ; this . apiKey = apiKey ; this . baseUrl = baseUrl ; }
@ Override public String getJuridisctionId ( ) { return jurisdictionId ; }
@ Override public String getApiKey ( ) { return apiKey ; }
@ Override public String getBaseUrl ( ) { return baseUrl ; }
@ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "[" ) ; sb . append ( "jurisdictionId=" ) . append ( jurisdictionId ) . append ( "," ) ; sb . append ( "apiKey=" ) . append ( apiKey ) . append ( "," ) ; sb . append ( "baseUrl=" ) . append ( baseUrl ) ; sb . append ( "]" ) ; return sb . toString ( ) ; }
ObaRegionElement ( ) { id = 0 ; regionName = "" ; obaBaseUrl = null ; siriBaseUrl = null ; active = false ; bounds = Bounds . EMPTY_ARRAY ; open311Servers = Open311Server . EMPTY_ARRAY ; language = "" ; contactEmail = "" ; supportsObaDiscoveryApis = false ; supportsObaRealtimeApis = false ; supportsSiriRealtimeApis = false ; twitterUrl = "" ; experimental = true ; stopInfoUrl = "" ; otpBaseUrl = "" ; otpContactEmail = "" ; }
public ObaRegionElement ( long id , String name , boolean active , String obaBaseUrl , String siriBaseUrl , Bounds [] bounds , Open311Server [] open311Servers , String lang , String contactEmail , boolean supportsObaDiscoveryApis , boolean supportsObaRealtimeApis , boolean supportsSiriRealtimeApis , String twitterUrl , boolean experimental , String stopInfoUrl , String otpBaseUrl , String otpContactEmail ) { this . id = id ; this . regionName = name ; this . active = active ; this . obaBaseUrl = obaBaseUrl ; this . siriBaseUrl = siriBaseUrl ; this . bounds = bounds ; this . open311Servers = open311Servers ; this . language = lang ; this . contactEmail = contactEmail ; this . supportsObaDiscoveryApis = supportsObaDiscoveryApis ; this . supportsObaRealtimeApis = supportsObaRealtimeApis ; this . supportsSiriRealtimeApis = supportsSiriRealtimeApis ; this . twitterUrl = twitterUrl ; this . experimental = experimental ; this . stopInfoUrl = stopInfoUrl ; this . otpBaseUrl = otpBaseUrl ; this . otpContactEmail = otpContactEmail ; }
@ Override public long getId ( ) { return id ; }
@ Override public String getName ( ) { return regionName ; }
@ Override public boolean getActive ( ) { return active ; }
@ Override public String getObaBaseUrl ( ) { return obaBaseUrl ; }
@ Override public String getSiriBaseUrl ( ) { return siriBaseUrl ; }
@ Override public Bounds [] getBounds ( ) { return bounds ; }
@ Override public Open311Server [] getOpen311Servers ( ) { return open311Servers ; }
@ Override public String getLanguage ( ) { return language ; }
@ Override public String getContactEmail ( ) { return contactEmail ; }
@ Override public boolean getSupportsObaDiscoveryApis ( ) { return supportsObaDiscoveryApis ; }
@ Override public boolean getSupportsObaRealtimeApis ( ) { return supportsObaRealtimeApis ; }
@ Override public boolean getSupportsSiriRealtimeApis ( ) { return supportsSiriRealtimeApis ; }
@ Override public String getTwitterUrl ( ) { return twitterUrl ; }
@ Override public boolean getExperimental ( ) { return experimental ; }
@ Override public String getStopInfoUrl ( ) { return stopInfoUrl ; }
@ Override public String getOtpBaseUrl ( ) { return otpBaseUrl ; }
@ Override public String getOtpContactEmail ( ) { return otpContactEmail ; }
@ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( id == 0 ) ? 0 : Long . valueOf ( id ) . hashCode ( ) ) ; return result ; }
@ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( ! ( obj instanceof ObaRegionElement ) ) { return false ; } ObaRegionElement other = ( ObaRegionElement ) obj ; if ( id == 0 ) { if ( other . getId ( ) != 0 ) { return false ; } } else if ( id != other . getId ( ) ) { return false ; } return true ; }
@ Override public String toString ( ) { return "ObaRegionElement{" + "id=" + id + ", regionName='" + regionName + '\'' + ", active=" + active + ", obaBaseUrl='" + obaBaseUrl + '\'' + ", siriBaseUrl='" + siriBaseUrl + '\'' + ", bounds=" + Arrays . toString ( bounds ) + ", open311Servers=" + Arrays . toString ( open311Servers ) + ", language='" + language + '\'' + ", contactEmail='" + contactEmail + '\'' + ", supportsObaDiscoveryApis=" + supportsObaDiscoveryApis + ", supportsObaRealtimeApis=" + supportsObaRealtimeApis + ", supportsSiriRealtimeApis=" + supportsSiriRealtimeApis + ", twitterUrl='" + twitterUrl + '\'' + ", experimental=" + experimental + ", stopInfoUrl='" + stopInfoUrl + '\'' + ", otpBaseUrl='" + otpBaseUrl + '\'' + ", otpContactEmail='" + otpContactEmail + '\'' + '}' ; }
public BluetoothClassAssert ( BluetoothClass actual ) { super( actual , BluetoothClassAssert .class ); }
public BluetoothClassAssert hasDeviceClass ( int deviceClass ) { isNotNull ( ) ; int actualClass = actual . getDeviceClass ( ) ; assertThat ( actualClass ) . overridingErrorMessage ( "Expected device class <%s> but was <%s>." , deviceClassToString ( deviceClass ) , deviceClassToString ( actualClass ) ) . isEqualTo ( actualClass ) ; return this ; }
public BluetoothClassAssert hasMajorDeviceClass ( int majorDeviceClass ) { isNotNull ( ) ; int actualMajorDeviceClass = actual . getMajorDeviceClass ( ) ; assertThat ( majorDeviceClass ) . overridingErrorMessage ( "Expected major device class <%s> but was <%s>." , majorDeviceClassToString ( majorDeviceClass ) , majorDeviceClassToString ( actualMajorDeviceClass ) ) . isEqualTo ( majorDeviceClass ) ; return this ; }
public BluetoothClassAssert hasService ( int service ) { isNotNull ( ) ; assertThat ( actual . hasService ( service ) ) . overridingErrorMessage ( "Expected to have service <%s> but did not." , serviceToString ( service ) ) . isTrue ( ) ; return this ; }
public BluetoothClassAssert doesNotHave ( int service ) { isNotNull ( ) ; assertThat ( actual . hasService ( service ) ) . overridingErrorMessage ( "Expected to not have service <%s> but did." , serviceToString ( service ) ) . isFalse ( ) ; return this ; }
public static String deviceClassToString ( int deviceClass ) { return buildNamedValueString ( deviceClass ) . value ( BluetoothClass . Device . AUDIO_VIDEO_CAMCORDER , "AUDIO_VIDEO_CAMCORDER" ) . value ( BluetoothClass . Device . AUDIO_VIDEO_CAR_AUDIO , "AUDIO_VIDEO_CAR_AUDIO" ) . value ( BluetoothClass . Device . AUDIO_VIDEO_HANDSFREE , "AUDIO_VIDEO_HANDSFREE" ) . value ( BluetoothClass . Device . AUDIO_VIDEO_HEADPHONES , "AUDIO_VIDEO_HEADPHONES" ) . value ( BluetoothClass . Device . AUDIO_VIDEO_HIFI_AUDIO , "AUDIO_VIDEO_HIFI_AUDIO" ) . value ( BluetoothClass . Device . AUDIO_VIDEO_LOUDSPEAKER , "AUDIO_VIDEO_LOUDSPEAKER" ) . value ( BluetoothClass . Device . AUDIO_VIDEO_MICROPHONE , "AUDIO_VIDEO_MICROPHONE" ) . value ( BluetoothClass . Device . AUDIO_VIDEO_PORTABLE_AUDIO , "AUDIO_VIDEO_PORTABLE_AUDIO" ) . value ( BluetoothClass . Device . AUDIO_VIDEO_SET_TOP_BOX , "AUDIO_VIDEO_SET_TOP_BOX" ) . value ( BluetoothClass . Device . AUDIO_VIDEO_UNCATEGORIZED , "AUDIO_VIDEO_UNCATEGORIZED" ) . value ( BluetoothClass . Device . AUDIO_VIDEO_VCR , "AUDIO_VIDEO_VCR" ) . value ( BluetoothClass . Device . AUDIO_VIDEO_VIDEO_CAMERA , "AUDIO_VIDEO_VIDEO_CAMERA" ) . value ( BluetoothClass . Device . AUDIO_VIDEO_VIDEO_CONFERENCING , "AUDIO_VIDEO_VIDEO_CONFERENCING" ) . value ( BluetoothClass . Device . AUDIO_VIDEO_VIDEO_DISPLAY_AND_LOUDSPEAKER , "AUDIO_VIDEO_VIDEO_DISPLAY_AND_LOUDSPEAKER" ) . value ( BluetoothClass . Device . AUDIO_VIDEO_VIDEO_GAMING_TOY , "AUDIO_VIDEO_VIDEO_GAMING_TOY" ) . value ( BluetoothClass . Device . AUDIO_VIDEO_VIDEO_MONITOR , "AUDIO_VIDEO_VIDEO_MONITOR" ) . value ( BluetoothClass . Device . AUDIO_VIDEO_WEARABLE_HEADSET , "AUDIO_VIDEO_WEARABLE_HEADSET" ) . value ( BluetoothClass . Device . COMPUTER_DESKTOP , "COMPUTER_DESKTOP" ) . value ( BluetoothClass . Device . COMPUTER_HANDHELD_PC_PDA , "COMPUTER_HANDHELD_PC_PDA" ) . value ( BluetoothClass . Device . COMPUTER_LAPTOP , "COMPUTER_LAPTOP" ) . value ( BluetoothClass . Device . COMPUTER_PALM_SIZE_PC_PDA , "COMPUTER_PALM_SIZE_PC_PDA" ) . value ( BluetoothClass . Device . COMPUTER_SERVER , "COMPUTER_SERVER" ) . value ( BluetoothClass . Device . COMPUTER_UNCATEGORIZED , "COMPUTER_UNCATEGORIZED" ) . value ( BluetoothClass . Device . COMPUTER_WEARABLE , "COMPUTER_WEARABLE" ) . value ( BluetoothClass . Device . HEALTH_BLOOD_PRESSURE , "HEALTH_BLOOD_PRESSURE" ) . value ( BluetoothClass . Device . HEALTH_DATA_DISPLAY , "HEALTH_DATA_DISPLAY" ) . value ( BluetoothClass . Device . HEALTH_GLUCOSE , "HEALTH_GLUCOSE" ) . value ( BluetoothClass . Device . HEALTH_PULSE_OXIMETER , "HEALTH_PULSE_OXIMETER" ) . value ( BluetoothClass . Device . HEALTH_PULSE_RATE , "HEALTH_PULSE_RATE" ) . value ( BluetoothClass . Device . HEALTH_THERMOMETER , "HEALTH_THERMOMETER" ) . value ( BluetoothClass . Device . HEALTH_UNCATEGORIZED , "HEALTH_UNCATEGORIZED" ) . value ( BluetoothClass . Device . HEALTH_WEIGHING , "HEALTH_WEIGHING" ) . value ( BluetoothClass . Device . PHONE_CELLULAR , "PHONE_CELLULAR" ) . value ( BluetoothClass . Device . PHONE_CORDLESS , "PHONE_CORDLESS" ) . value ( BluetoothClass . Device . PHONE_ISDN , "PHONE_ISDN" ) . value ( BluetoothClass . Device . PHONE_MODEM_OR_GATEWAY , "PHONE_MODEM_OR_GATEWAY" ) . value ( BluetoothClass . Device . PHONE_SMART , "PHONE_SMART" ) . value ( BluetoothClass . Device . PHONE_UNCATEGORIZED , "PHONE_UNCATEGORIZED" ) . value ( BluetoothClass . Device . TOY_CONTROLLER , "TOY_CONTROLLER" ) . value ( BluetoothClass . Device . TOY_DOLL_ACTION_FIGURE , "TOY_DOLL_ACTION_FIGURE" ) . value ( BluetoothClass . Device . TOY_GAME , "TOY_GAME" ) . value ( BluetoothClass . Device . TOY_ROBOT , "TOY_ROBOT" ) . value ( BluetoothClass . Device . TOY_UNCATEGORIZED , "TOY_UNCATEGORIZED" ) . value ( BluetoothClass . Device . TOY_VEHICLE , "TOY_VEHICLE" ) . value ( BluetoothClass . Device . WEARABLE_GLASSES , "WEARABLE_GLASSES" ) . value ( BluetoothClass . Device . WEARABLE_HELMET , "WEARABLE_HELMET" ) . value ( BluetoothClass . Device . WEARABLE_JACKET , "WEARABLE_JACKET" ) . value ( BluetoothClass . Device . WEARABLE_PAGER , "WEARABLE_PAGER" ) . value ( BluetoothClass . Device . WEARABLE_UNCATEGORIZED , "WEARABLE_UNCATEGORIZED" ) . value ( BluetoothClass . Device . WEARABLE_WRIST_WATCH , "WEARABLE_WRIST_WATCH" ) . get ( ) ; }
public static String majorDeviceClassToString ( int majorDeviceClass ) { return buildNamedValueString ( majorDeviceClass ) . value ( BluetoothClass . Device . Major . AUDIO_VIDEO , "audio_video" ) . value ( BluetoothClass . Device . Major . COMPUTER , "computer" ) . value ( BluetoothClass . Device . Major . HEALTH , "health" ) . value ( BluetoothClass . Device . Major . IMAGING , "imaging" ) . value ( BluetoothClass . Device . Major . MISC , "misc" ) . value ( BluetoothClass . Device . Major . NETWORKING , "networking" ) . value ( BluetoothClass . Device . Major . PERIPHERAL , "peripheral" ) . value ( BluetoothClass . Device . Major . PHONE , "phone" ) . value ( BluetoothClass . Device . Major . TOY , "toy" ) . value ( BluetoothClass . Device . Major . UNCATEGORIZED , "uncategorized" ) . value ( BluetoothClass . Device . Major . WEARABLE , "wearable" ) . get ( ) ; }
public static String serviceToString ( int service ) { return buildNamedValueString ( service ) . value ( BluetoothClass . Service . AUDIO , "audio" ) . value ( BluetoothClass . Service . CAPTURE , "capture" ) . value ( BluetoothClass . Service . INFORMATION , "information" ) . value ( BluetoothClass . Service . LIMITED_DISCOVERABILITY , "limited_discoverability" ) . value ( BluetoothClass . Service . NETWORKING , "networking" ) . value ( BluetoothClass . Service . OBJECT_TRANSFER , "object_transfer" ) . value ( BluetoothClass . Service . POSITIONING , "positioning" ) . value ( BluetoothClass . Service . RENDER , "render" ) . value ( BluetoothClass . Service . TELEPHONY , "telephony" ) . get ( ) ; }
public String getShortName ( )
public String getLongName ( )
public String getDescription ( )
public int getType ( )
public String getUrl ( )
public Integer getColor ( )
public Integer getTextColor ( )
public String getAgencyId ( )
public static org . eclipse . aether . artifact . Artifact createAetherArtifact ( Artifact artifact ) { DefaultArtifact defaultArtifact ; if ( artifact . getClassifier ( ) != null ) { defaultArtifact = new DefaultArtifact ( artifact . getGroupId ( ) , artifact . getArtifactId ( ) , artifact . getClassifier ( ) , artifact . getType ( ) , artifact . getVersion ( ) ) ; } else { defaultArtifact = new DefaultArtifact ( artifact . getGroupId ( ) , artifact . getArtifactId ( ) , artifact . getType ( ) , artifact . getVersion ( ) ) ; } defaultArtifact . setFile ( artifact . getFile ( ) ) ; return defaultArtifact ; }
public static Set < Artifact > resolveArtifacts ( Set < Artifact > artifacts , RepositorySystem repositorySystem , RepositorySystemSession repositorySystemSession , List < RemoteRepository > repositories ) throws MojoExecutionException { try { final Set < Artifact > resolvedArtifacts = new LinkedHashSet < Artifact > ( ) ; for ( Artifact artifact : artifacts ) { final Artifact resolvedArtifact = AetherHelper . resolveArtifact ( artifact , repositorySystem , repositorySystemSession , repositories ) ; resolvedArtifacts . add ( resolvedArtifact ) ; } return resolvedArtifacts ; } catch ( Exception e ) { throw new MojoExecutionException ( "Error resolving dependencies: " + e . getMessage ( ) , e ) ; } }
public static Artifact resolveArtifact ( Artifact artifact , RepositorySystem repositorySystem , RepositorySystemSession repositorySystemSession , List < RemoteRepository > repositories ) throws MojoExecutionException { try { final ArtifactRequest artifactRequest = new ArtifactRequest ( ) ; org . eclipse . aether . artifact . Artifact aetherArtifact = AetherHelper . createAetherArtifact ( artifact ) ; artifactRequest . setArtifact ( aetherArtifact ) ; artifactRequest . setRepositories ( repositories ) ; final ArtifactResult artifactResult = repositorySystem . resolveArtifact ( repositorySystemSession , artifactRequest ) ; final org . apache . maven . artifact . DefaultArtifact defaultArtifact = new org . apache . maven . artifact . DefaultArtifact ( artifact . getGroupId ( ) , artifact . getArtifactId ( ) , artifact . getVersion ( ) , artifact . getScope ( ) , artifact . getType ( ) , artifact . getClassifier ( ) , artifact . getArtifactHandler ( ) ) ; defaultArtifact . setFile ( artifactResult . getArtifact ( ) . getFile ( ) ) ; return defaultArtifact ; } catch ( ArtifactResolutionException e ) { throw new MojoExecutionException ( "Error while resolving artifact: " + e . getMessage ( ) , e ) ; } }
@ Override public void onAttach ( Activity activity ) { super. onAttach ( activity ) ; GoogleApiAvailability api = GoogleApiAvailability . getInstance ( ) ; if ( api . isGooglePlayServicesAvailable ( getActivity ( ) ) == ConnectionResult . SUCCESS ) { mGoogleApiClient = LocationUtils . getGoogleApiClientWithCallbacks ( getActivity ( ) ) ; mGoogleApiClient . connect ( ) ; } mLocale = Locale . getDefault ( ) ; IMPERIAL = getString ( R . string . preferences_preferred_units_option_imperial ) ; METRIC = getString ( R . string . preferences_preferred_units_option_metric ) ; AUTOMATIC = getString ( R . string . preferences_preferred_units_option_automatic ) ; }
@ Override public void onActivityCreated ( Bundle savedInstanceState ) { super. onActivityCreated ( savedInstanceState ) ; setHasOptionsMenu ( true ) ; mLocation = Application . getLastKnownLocation ( getActivity ( ) , mGoogleApiClient ) ; mCurrentRegion = Application . get ( ) . getCurrentRegion ( ) ; Bundle args = new Bundle ( ) ; args . putBoolean ( RELOAD , false ) ; getLoaderManager ( ) . initLoader ( 0 , args , this ) ; }
@ Override public void onListItemClick ( ListView l , View v , int position , long id ) { ObaRegion region = mAdapter . getItem ( position ) ; Application . get ( ) . setCurrentRegion ( region ) ; if ( Application . getPrefs ( ) . getBoolean ( getString ( R . string . preference_key_auto_select_region ) , true ) ) { PreferenceUtils . saveBoolean ( getString ( R . string . preference_key_auto_select_region ) , false ) ; Toast . makeText ( this . getActivity ( ) , R . string . region_disabled_auto_selection , Toast . LENGTH_LONG ) . show ( ) ; } Log . d ( TAG , "User manually set region to '" + region . getName ( ) + "'." ) ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getString ( R . string . analytics_action_set_region ) , getString ( R . string . analytics_label_set_region ) + region . getName ( ) ) ; NavHelp . goHome ( getActivity ( ) , false ) ; }
@ Override public void onCreateOptionsMenu ( Menu menu , MenuInflater inflater ) { inflater . inflate ( R . menu . regions_list , menu ) ; }
@ Override public boolean onOptionsItemSelected ( MenuItem item ) { final int id = item . getItemId ( ) ; if ( id == R . id . refresh ) { refresh ( ) ; return true ; } return false ; }
@ Override public void onStart ( ) { super. onStart ( ) ; if ( mGoogleApiClient != null && ! mGoogleApiClient . isConnected ( ) ) { mGoogleApiClient . connect ( ) ; } }
@ Override public void onStop ( ) { if ( mGoogleApiClient != null && mGoogleApiClient . isConnected ( ) ) { mGoogleApiClient . disconnect ( ) ; } super. onStop ( ) ; }
private void refresh ( ) { setListShown ( false ) ; setListAdapter ( null ) ; mAdapter = null ; Bundle args = new Bundle ( ) ; args . putBoolean ( RELOAD , true ) ; getLoaderManager ( ) . restartLoader ( 0 , args , this ) ; }
@ Override public Loader < ArrayList < ObaRegion > > onCreateLoader ( int id , Bundle args ) { boolean refresh = args . getBoolean ( RELOAD ) ; return new ObaRegionsLoader ( getActivity ( ) , refresh ) ; }
@ Override public void onLoadFinished ( Loader < ArrayList < ObaRegion > > loader , ArrayList < ObaRegion > results ) { mAdapter = new Adapter ( getActivity ( ) ) ; setListAdapter ( mAdapter ) ; try { Iterator < ObaRegion > iter = results . iterator ( ) ; while ( iter . hasNext ( ) ) { ObaRegion r = iter . next ( ) ; if ( ! RegionUtils . isRegionUsable ( r ) ) { iter . remove ( ) ; Log . d ( TAG , "Removed region '" + r . getName ( ) + "' from adapter." ) ; } } } catch ( UnsupportedOperationException e ) { Log . w ( TAG , "Problem removing region from list using iterator: " + e ) ; ArrayList < ObaRegion > copy = new ArrayList < ObaRegion > ( results ) ; for ( ObaRegion r : copy ) { if ( ! RegionUtils . isRegionUsable ( r ) ) { results . remove ( r ) ; Log . d ( TAG , "Removed region '" + r . getName ( ) + "' from adapter." ) ; } } } mAdapter . setData ( results ) ; if ( mLocation != null ) { mAdapter . sort ( mClosest ) ; } }
@ Override public void onLoaderReset ( Loader < ArrayList < ObaRegion > > arg0 ) { setListAdapter ( null ) ; mAdapter = null ; }
@ Override public int compare ( ObaRegion r1 , ObaRegion r2 ) { Float r1distance = RegionUtils . getDistanceAway ( r1 , mLocation ) ; Float r2distance = RegionUtils . getDistanceAway ( r2 , mLocation ) ; if ( r1distance == null ) { r1distance = Float . MAX_VALUE ; } if ( r2distance == null ) { r2distance = Float . MAX_VALUE ; } return r1distance . compareTo ( r2distance ) ; }
Adapter ( Context context ) { super( context , R . layout . simple_list_item_2_checked ); }
@ Override protected void initView ( View view , ObaRegion region ) { TextView text1 = ( TextView ) view . findViewById ( android . R . id . text1 ) ; TextView text2 = ( TextView ) view . findViewById ( android . R . id . text2 ) ; ImageView image = ( ImageView ) view . findViewById ( android . R . id . selectedIcon ) ; text1 . setText ( region . getName ( ) ) ; Float distance = null ; int regionVis = View . INVISIBLE ; if ( mCurrentRegion != null && region . getId ( ) == mCurrentRegion . getId ( ) ) { regionVis = View . VISIBLE ; } image . setVisibility ( regionVis ) ; if ( mLocation != null ) { distance = RegionUtils . getDistanceAway ( region , mLocation ) ; } if ( distance != null ) { double miles = distance * 0.000621371 ; distance /= 1000 ; String preferredUnits = mSettings . getString ( getString ( R . string . preference_key_preferred_units ) , AUTOMATIC ) ; if ( preferredUnits . equalsIgnoreCase ( AUTOMATIC ) ) { Log . d ( TAG , "Setting units automatically" ) ; if ( mLocale . getISO3Country ( ) . equalsIgnoreCase ( Locale . US . getISO3Country ( ) ) ) { setDistanceTextView ( text2 , miles , IMPERIAL ) ; } else { setDistanceTextView ( text2 , distance , METRIC ) ; } } else if ( preferredUnits . equalsIgnoreCase ( IMPERIAL ) ) { setDistanceTextView ( text2 , miles , IMPERIAL ) ; } else if ( preferredUnits . equalsIgnoreCase ( METRIC ) ) { setDistanceTextView ( text2 , distance , METRIC ) ; } } else { view . setEnabled ( false ) ; text2 . setText ( R . string . region_unavailable ) ; } }
private void setDistanceTextView ( TextView text , double distance , String units ) { Resources r = getResources ( ) ; NumberFormat fmt = NumberFormat . getInstance ( ) ; if ( fmt instanceof DecimalFormat ) { fmt . setMaximumFractionDigits ( 1 ) ; } if ( units . equalsIgnoreCase ( getString ( R . string . preferences_preferred_units_option_imperial ) ) ) { text . setText ( r . getQuantityString ( R . plurals . distance_miles , ( int ) distance , fmt . format ( distance ) ) ) ; } else if ( units . equalsIgnoreCase ( getString ( R . string . preferences_preferred_units_option_metric ) ) ) { text . setText ( r . getQuantityString ( R . plurals . distance_kilometers , ( int ) distance , fmt . format ( distance ) ) ) ; } }
@ Override public void execute ( ) MojoExecutionException , MojoFailureException { ConfigHandler configHandler = new ConfigHandler ( this , this . session , this . execution ) ; configHandler . parseConfiguration ( ) ; doWithDevices ( new DeviceCallback ( ) { @ Override public void doWithDevice ( IDevice device ) throws MojoExecutionException , MojoFailureException { AndroidTestRunListener testRunListener = new AndroidTestRunListener ( device , getLog ( ) , parsedCreateReport , false , "" , "" , targetDirectory ) ; if ( isEnableIntegrationTest ( ) ) { run ( device , testRunListener ) ; } } } ) ; }
@ Override public void doWithDevice ( IDevice device ) throws MojoExecutionException , MojoFailureException { AndroidTestRunListener testRunListener = new AndroidTestRunListener ( device , getLog ( ) , parsedCreateReport , false , "" , "" , targetDirectory ) ; if ( isEnableIntegrationTest ( ) ) { run ( device , testRunListener ) ; } }
protected boolean isEnableIntegrationTest ( ) { return ! parsedSkip && ! mavenTestSkip && ! mavenSkipTests ; }
protected boolean isIgnoreTestFailures ( ) { return mavenIgnoreTestFailure || mavenTestFailureIgnore ; }
protected void run ( IDevice device , ITestRunListener ... iTestRunListeners ) throws MojoExecutionException , MojoFailureException { this . mTestListeners = iTestRunListeners ; getLog ( ) . debug ( "Parsed values for Android Monkey Runner invocation: " ) ; CommandExecutor executor = CommandExecutor . Factory . createDefaultCommmandExecutor ( ) ; if ( ! Os . isFamily ( Os . FAMILY_WINDOWS ) ) { executor . setCustomShell ( new CustomBourneShell ( ) ) ; } executor . setLogger ( this . getLog ( ) ) ; String command = getAndroidSdk ( ) . getMonkeyRunnerPath ( ) ; List < String > pluginParameters = new ArrayList < String > ( ) ; if ( parsedPlugins != null && parsedPlugins . length != 0 ) { for ( String plugin : parsedPlugins ) { String pluginFilePath = new File ( project . getBasedir ( ) , plugin ) . getAbsolutePath ( ) ; pluginParameters . add ( "-plugin " + pluginFilePath ) ; } } if ( parsedPrograms != null && ! parsedPrograms . isEmpty ( ) ) { handleTestRunStarted ( ) ; errorListener = new MonkeyRunnerErrorListener ( ) ; executor . setErrorListener ( errorListener ) ; for ( Program program : parsedPrograms ) { List < String > parameters = new ArrayList < String > ( pluginParameters ) ; String programFileName = new File ( project . getBasedir ( ) , program . getFilename ( ) ) . getAbsolutePath ( ) ; parameters . add ( programFileName ) ; String testName = programFileName ; if ( testName . contains ( "/" ) ) { testName . substring ( testName . indexOf ( '/' ) + 1 ) ; } mCurrentTestIndentifier = new TestIdentifier ( "MonkeyTest " , testName ) ; String programOptions = program . getOptions ( ) ; if ( parsedInjectDeviceSerialNumberIntoScript != null && parsedInjectDeviceSerialNumberIntoScript ) { parameters . add ( device . getSerialNumber ( ) ) ; } if ( programOptions != null && ! StringUtils . isEmpty ( programOptions ) ) { parameters . add ( programOptions ) ; } try { getLog ( ) . info ( "Running command: " + command ) ; getLog ( ) . info ( "with parameters: " + parameters ) ; handleTestStarted ( ) ; executor . setCaptureStdOut ( true ) ; executor . executeCommand ( command , parameters , true ) ; handleTestEnded ( ) ; } catch ( ExecutionException e ) { getLog ( ) . info ( "Monkey runner produced errors" ) ; handleTestRunFailed ( e . getMessage ( ) ) ; if ( ! isIgnoreTestFailures ( ) ) { getLog ( ) . info ( "Project is configured to fail on error." ) ; getLog ( ) . info ( "Inspect monkey runner reports or re-run with -X to see monkey runner errors in log" ) ; getLog ( ) . info ( "Failing build as configured. Ignore following error message." ) ; if ( errorListener . hasError ) { getLog ( ) . info ( "Stack trace is:" ) ; getLog ( ) . info ( errorListener . getStackTrace ( ) ) ; } throw new MojoExecutionException ( "" , e ) ; } } if ( errorListener . hasError ( ) ) { handleCrash ( ) ; } } handleTestRunEnded ( ) ; } getLog ( ) . info ( "Monkey runner test runs completed successfully." ) ; }
private void handleTestRunStarted ( ) { runMetrics = new HashMap < String , String > ( ) ; elapsedTime = System . currentTimeMillis ( ) ; for ( ITestRunListener listener : mTestListeners ) { listener . testRunStarted ( mRunName , eventCount ) ; } }
private void handleTestRunFailed ( String error ) { for ( ITestRunListener listener : mTestListeners ) { listener . testRunFailed ( error ) ; } }
private void handleTestRunEnded ( ) { elapsedTime = System . currentTimeMillis ( ) - elapsedTime ; for ( ITestRunListener listener : mTestListeners ) { listener . testRunEnded ( elapsedTime , runMetrics ) ; } }
private void handleTestStarted ( ) { System . out . println ( "TEST START " + mTestListeners . length ) ; for ( ITestRunListener listener : mTestListeners ) { listener . testStarted ( mCurrentTestIndentifier ) ; } }
private void handleTestEnded ( ) { if ( mCurrentTestIndentifier != null ) { for ( ITestRunListener listener : mTestListeners ) { listener . testEnded ( mCurrentTestIndentifier , new HashMap < String , String > ( ) ) ; } mCurrentTestIndentifier = null ; } }
private void handleCrash ( ) { String trace = errorListener . getStackTrace ( ) ; for ( ITestRunListener listener : mTestListeners ) { listener . testFailed ( mCurrentTestIndentifier , trace ) ; } mCurrentTestIndentifier = null ; }
@ Override public boolean isError ( String error ) { if ( isIgnoreTestFailures ( ) ) { return false ; } if ( hasError ) { stackTraceBuilder . append ( error ) . append ( '\n' ) ; } final Pattern pattern = Pattern . compile ( ".*error.*|.*exception.*" , Pattern . CASE_INSENSITIVE ) ; final Matcher matcher = pattern . matcher ( error ) ; if ( matcher . matches ( ) ) { hasError = true ; stackTraceBuilder . append ( error ) . append ( '\n' ) ; return true ; } return false ; }
public String getStackTrace ( ) { if ( hasError ) { return stackTraceBuilder . toString ( ) ; } else { return null ; } }
public boolean hasError ( ) { return hasError ; }
public String [] getPlugins ( ) { return parsedPlugins ; }
@ Override public List < String > getShellArgsList ( ) { List < String > shellArgs = new ArrayList < String > ( ) ; List < String > existingShellArgs = super. getShellArgsList ( ) ; if ( existingShellArgs != null && ! existingShellArgs . isEmpty ( ) ) { shellArgs . addAll ( existingShellArgs ) ; } return shellArgs ; }
@ Override public String [] getShellArgs ( ) { String [] shellArgs = super. getShellArgs ( ) ; if ( shellArgs == null ) { shellArgs = new String [ 0 ] ; } return shellArgs ; }
public List < Program > getPrograms ( ) { return parsedPrograms ; }
public static long [] pattern ( char c ) { if ( c >= 'A' && c <= 'Z' ) { return LETTERS [ c - 'A' ] ; } if ( c >= 'a' && c <= 'z' ) { return LETTERS [ c - 'a' ] ; } else if ( c >= '0' && c <= '9' ) { return NUMBERS [ c - '0' ] ; } else { return ERROR_GAP ; } }
public static long [] pattern ( String str ) { boolean lastWasWhitespace ; int strlen = str . length ( ) ; int len = 1 ; lastWasWhitespace = true ; for ( int i = 0 ; i < strlen ; i ++ ) { char c = str . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! lastWasWhitespace ) { len ++ ; lastWasWhitespace = true ; } } else { if ( ! lastWasWhitespace ) { len ++ ; } lastWasWhitespace = false ; len += pattern ( c ) . length ; } } long [] result = new long [ len + 1 ] ; result [ 0 ] = 0 ; int pos = 1 ; lastWasWhitespace = true ; for ( int i = 0 ; i < strlen ; i ++ ) { char c = str . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! lastWasWhitespace ) { result [ pos ] = WORD_GAP ; pos ++ ; lastWasWhitespace = true ; } } else { if ( ! lastWasWhitespace ) { result [ pos ] = LETTER_GAP ; pos ++ ; } lastWasWhitespace = false ; long [] letter = pattern ( c ) ; System . arraycopy ( letter , 0 , result , pos , letter . length ) ; pos += letter . length ; } } return result ; }
Uri getUri ( )
String [] getProjection ( )
String getSelection ( )
String [] getSelectionArgs ( )
String getSortOrder ( )
ContentValues getValues ( )
String getSelection ( )
String [] getSelectionArgs ( )
ContentValues getValues ( )
String getSelection ( )
String [] getSelectionArgs ( )
public CursorAdapterAssert ( CursorAdapter actual ) { super( actual , CursorAdapterAssert .class ); }
public void execute ( ) MojoExecutionException , MojoFailureException { String out = targetDirectory . getPath ( ) ; for ( String src : project . getCompileSourceRoots ( ) ) { if ( ! src . startsWith ( out ) ) { sourceFolders . add ( src ) ; } } generateIntermediateApk ( ) ; File outputFile = createApkLibraryFile ( ) ; if ( classifier == null ) { project . getArtifact ( ) . setFile ( outputFile ) ; } else { projectHelper . attachArtifact ( project , AndroidExtension . APKLIB , classifier , outputFile ) ; } if ( attachJar ) { final File jarFile = new File ( targetDirectory , finalName + ".jar" ) ; projectHelper . attachArtifact ( project , "jar" , project . getArtifact ( ) . getClassifier ( ) , jarFile ) ; } }
private File createApkLibraryFile ( ) MojoExecutionException { final File apklibrary = new File ( targetDirectory , finalName + "." + APKLIB ) ; FileUtils . deleteQuietly ( apklibrary ) ; try { JarArchiver jarArchiver = new JarArchiver ( ) ; jarArchiver . setDestFile ( apklibrary ) ; jarArchiver . addFile ( destinationManifestFile , "AndroidManifest.xml" ) ; addDirectory ( jarArchiver , assetsDirectory , "assets" ) ; addDirectory ( jarArchiver , resourceDirectory , "res" ) ; for ( String src : sourceFolders ) { addDirectory ( jarArchiver , new File ( src ) , "src" ) ; } File [] overlayDirectories = getResourceOverlayDirectories ( ) ; for ( File resOverlayDir : overlayDirectories ) { if ( resOverlayDir != null && resOverlayDir . exists ( ) ) { addDirectory ( jarArchiver , resOverlayDir , "res" ) ; } } addJavaResources ( jarArchiver , resources , "src" ) ; addNativeLibraries ( jarArchiver ) ; jarArchiver . createArchive ( ) ; } catch ( ArchiverException e ) { throw new MojoExecutionException ( "ArchiverException while creating ." + APKLIB + " file." , e ) ; } catch ( IOException e ) { throw new MojoExecutionException ( "IOException while creating ." + APKLIB + " file." , e ) ; } return apklibrary ; }
private void addNativeLibraries ( final JarArchiver jarArchiver ) throws MojoExecutionException { try { if ( nativeLibrariesDirectory . exists ( ) ) { getLog ( ) . info ( nativeLibrariesDirectory + " exists, adding libraries." ) ; addDirectory ( jarArchiver , nativeLibrariesDirectory , NATIVE_LIBRARIES_FOLDER ) ; } else { getLog ( ) . info ( nativeLibrariesDirectory + " does not exist, looking for libraries in target directory." ) ; String [] ndkArchitectures = NativeHelper . getNdkArchitectures ( ndkArchitecture , applicationMakefile , project . getBasedir ( ) ) ; for ( String architecture : ndkArchitectures ) { final File ndkLibsDirectory = new File ( ndkOutputDirectory , architecture ) ; addSharedLibraries ( jarArchiver , ndkLibsDirectory , architecture ) ; } } } catch ( ArchiverException e ) { throw new MojoExecutionException ( "IOException while creating ." + APKLIB + " file." , e ) ; } }
protected void addJavaResources ( JarArchiver jarArchiver , List < Resource > javaResources , String prefix )            throws IOException { for ( Resource javaResource : javaResources ) { addJavaResource ( jarArchiver , javaResource , prefix ) ; } }
protected void addJavaResource ( JarArchiver jarArchiver , Resource javaResource , String prefix )            throws IOException { if ( javaResource != null ) { final File javaResourceDirectory = new File ( javaResource . getDirectory ( ) ) ; if ( javaResourceDirectory . exists ( ) ) { final String resourcePath = javaResourceDirectory . getCanonicalPath ( ) ; final String apkLibUnpackBasePath = getUnpackedLibsDirectory ( ) . getCanonicalPath ( ) ; if ( ! resourcePath . startsWith ( apkLibUnpackBasePath ) ) { final DefaultFileSet javaResourceFileSet = new DefaultFileSet ( ) ; javaResourceFileSet . setDirectory ( javaResourceDirectory ) ; javaResourceFileSet . setPrefix ( endWithSlash ( prefix ) ) ; jarArchiver . addFileSet ( javaResourceFileSet ) ; } } } }
protected String endWithSlash ( String prefix ) { prefix = StringUtils . defaultIfEmpty ( prefix , "/" ) ; if ( ! prefix . endsWith ( "/" ) ) { prefix = prefix + "/" ; } return prefix ; }
protected void addDirectory ( JarArchiver jarArchiver , File directory , String prefix ) { if ( directory != null && directory . exists ( ) ) { final DefaultFileSet fileSet = new DefaultFileSet ( ) ; fileSet . setPrefix ( endWithSlash ( prefix ) ) ; fileSet . setDirectory ( directory ) ; fileSet . setExcludes ( new String [] { "**/R.java" , "**/BuildConfig.java" } ) ; jarArchiver . addFileSet ( fileSet ) ; getLog ( ) . debug ( "Added files from " + directory ) ; } }
protected void addSharedLibraries ( JarArchiver jarArchiver , File directory , String architecture ) { getLog ( ) . debug ( "Searching for shared libraries in " + directory ) ; File [] libFiles = directory . listFiles ( new FilenameFilter ( ) { public boolean accept ( final File dir , final String name ) { return name . startsWith ( "lib" ) && name . endsWith ( ".so" ) ; } } ) ; if ( libFiles != null ) { for ( File libFile : libFiles ) { String dest = NATIVE_LIBRARIES_FOLDER + "/" + architecture + "/" + libFile . getName ( ) ; getLog ( ) . debug ( "Adding " + libFile + " as " + dest ) ; jarArchiver . addFile ( libFile , dest ) ; } } }
public boolean accept ( final File dir , final String name ) { return name . startsWith ( "lib" ) && name . endsWith ( ".so" ) ; }
private void generateIntermediateApk ( ) MojoExecutionException { CommandExecutor executor = CommandExecutor . Factory . createDefaultCommmandExecutor ( ) ; executor . setLogger ( this . getLog ( ) ) ; File [] overlayDirectories = getResourceOverlayDirectories ( ) ; File androidJar = getAndroidSdk ( ) . getAndroidJar ( ) ; File outputFile = new File ( targetDirectory , finalName + ".ap_" ) ; List < File > dependencyArtifactResDirectoryList = new ArrayList < File > ( ) ; for ( Artifact libraryArtifact : getTransitiveDependencyArtifacts ( APKLIB , AAR ) ) { final File apklibResDirectory = getUnpackedLibResourceFolder ( libraryArtifact ) ; if ( apklibResDirectory . exists ( ) ) { dependencyArtifactResDirectoryList . add ( apklibResDirectory ) ; } } AaptCommandBuilder commandBuilder = AaptCommandBuilder . packageResources ( getLog ( ) ) . forceOverwriteExistingFiles ( ) . setPathToAndroidManifest ( destinationManifestFile ) . addResourceDirectoriesIfExists ( overlayDirectories ) . addResourceDirectoryIfExists ( resourceDirectory ) . addResourceDirectoriesIfExists ( dependencyArtifactResDirectoryList ) . autoAddOverlay ( ) . addRawAssetsDirectoryIfExists ( combinedAssets ) . addExistingPackageToBaseIncludeSet ( androidJar ) . setOutputApkFile ( outputFile ) . addConfigurations ( configurations ) . setVerbose ( aaptVerbose ) ; getLog ( ) . debug ( getAndroidSdk ( ) . getAaptPath ( ) + " " + commandBuilder . toString ( ) ) ; getLog ( ) . info ( "Generating apklib" ) ; try { executor . setCaptureStdOut ( true ) ; List < String > commands = commandBuilder . build ( ) ; executor . executeCommand ( getAndroidSdk ( ) . getAaptPath ( ) , commands , project . getBasedir ( ) , false ) ; } catch ( ExecutionException e ) { throw new MojoExecutionException ( "" , e ) ; } }
public PixelBuffer ( final int width , final int height ) { mWidth = width ; mHeight = height ; int [] version = new int [ 2 ] ; int [] attribList = new int [] { EGL_WIDTH , mWidth , EGL_HEIGHT , mHeight , EGL_NONE } ; mEGL = ( EGL10 ) EGLContext . getEGL ( ) ; mEGLDisplay = mEGL . eglGetDisplay ( EGL_DEFAULT_DISPLAY ) ; mEGL . eglInitialize ( mEGLDisplay , version ) ; mEGLConfig = chooseConfig ( ) ; int EGL_CONTEXT_CLIENT_VERSION = 0x3098 ; int [] attrib_list = { EGL_CONTEXT_CLIENT_VERSION , 2 , EGL10 . EGL_NONE } ; mEGLContext = mEGL . eglCreateContext ( mEGLDisplay , mEGLConfig , EGL_NO_CONTEXT , attrib_list ) ; mEGLSurface = mEGL . eglCreatePbufferSurface ( mEGLDisplay , mEGLConfig , attribList ) ; mEGL . eglMakeCurrent ( mEGLDisplay , mEGLSurface , mEGLSurface , mEGLContext ) ; mGL = ( GL10 ) mEGLContext . getGL ( ) ; mThreadOwner = Thread . currentThread ( ) . getName ( ) ; }
public void setRenderer ( final GLSurfaceView . Renderer renderer ) { mRenderer = renderer ; if ( ! Thread . currentThread ( ) . getName ( ) . equals ( mThreadOwner ) ) { Log . e ( TAG , "setRenderer: This thread does not own the OpenGL context." ) ; return; } mRenderer . onSurfaceCreated ( mGL , mEGLConfig ) ; mRenderer . onSurfaceChanged ( mGL , mWidth , mHeight ) ; }
public Bitmap getBitmap ( ) { if ( mRenderer == null ) { Log . e ( TAG , "getBitmap: Renderer was not set." ) ; return null ; } if ( ! Thread . currentThread ( ) . getName ( ) . equals ( mThreadOwner ) ) { Log . e ( TAG , "getBitmap: This thread does not own the OpenGL context." ) ; return null ; } mRenderer . onDrawFrame ( mGL ) ; mRenderer . onDrawFrame ( mGL ) ; convertToBitmap ( ) ; return mBitmap ; }
public void destroy ( ) { mRenderer . onDrawFrame ( mGL ) ; mRenderer . onDrawFrame ( mGL ) ; mEGL . eglMakeCurrent ( mEGLDisplay , EGL10 . EGL_NO_SURFACE , EGL10 . EGL_NO_SURFACE , EGL10 . EGL_NO_CONTEXT ) ; mEGL . eglDestroySurface ( mEGLDisplay , mEGLSurface ) ; mEGL . eglDestroyContext ( mEGLDisplay , mEGLContext ) ; mEGL . eglTerminate ( mEGLDisplay ) ; }
private EGLConfig chooseConfig ( ) { int [] attribList = new int [] { EGL_DEPTH_SIZE , 0 , EGL_STENCIL_SIZE , 0 , EGL_RED_SIZE , 8 , EGL_GREEN_SIZE , 8 , EGL_BLUE_SIZE , 8 , EGL_ALPHA_SIZE , 8 , EGL10 . EGL_RENDERABLE_TYPE , 4 , EGL_NONE } ; int [] numConfig = new int [ 1 ] ; mEGL . eglChooseConfig ( mEGLDisplay , attribList , null , 0 , numConfig ) ; int configSize = numConfig [ 0 ] ; mEGLConfigs = new EGLConfig [ configSize ] ; mEGL . eglChooseConfig ( mEGLDisplay , attribList , mEGLConfigs , configSize , numConfig ) ; if ( LIST_CONFIGS ) { listConfig ( ) ; } return mEGLConfigs [ 0 ] ; }
private void listConfig ( ) { Log . i ( TAG , "Config List {" ) ; for ( EGLConfig config : mEGLConfigs ) { int d , s , r , g , b , a ; d = getConfigAttrib ( config , EGL_DEPTH_SIZE ) ; s = getConfigAttrib ( config , EGL_STENCIL_SIZE ) ; r = getConfigAttrib ( config , EGL_RED_SIZE ) ; g = getConfigAttrib ( config , EGL_GREEN_SIZE ) ; b = getConfigAttrib ( config , EGL_BLUE_SIZE ) ; a = getConfigAttrib ( config , EGL_ALPHA_SIZE ) ; Log . i ( TAG , "    <d,s,r,g,b,a> = <" + d + "," + s + "," + r + "," + g + "," + b + "," + a + ">" ) ; } Log . i ( TAG , "}" ) ; }
private int getConfigAttrib ( final EGLConfig config , final int attribute ) { int [] value = new int [ 1 ] ; return mEGL . eglGetConfigAttrib ( mEGLDisplay , config , attribute , value ) ? value [ 0 ] : 0 ; }
private void convertToBitmap ( ) { int [] iat = new int [ mWidth * mHeight ] ; IntBuffer ib = IntBuffer . allocate ( mWidth * mHeight ) ; mGL . glReadPixels ( 0 , 0 , mWidth , mHeight , GL_RGBA , GL_UNSIGNED_BYTE , ib ) ; int [] ia = ib . array ( ) ; for ( int i = 0 ; i < mHeight ; i ++ ) { for ( int j = 0 ; j < mWidth ; j ++ ) { iat [ ( mHeight - i - 1 ) * mWidth + j ] = ia [ i * mWidth + j ] ; } } mBitmap = Bitmap . createBitmap ( mWidth , mHeight , Bitmap . Config . ARGB_8888 ) ; mBitmap . copyPixelsFromBuffer ( IntBuffer . wrap ( iat ) ) ; }
protected ObaStopRequest ( Uri uri ) { super( uri ); }
public Builder ( Context context , String stopId ) { super( context , getPathWithId ( "/stop/" , stopId ) ); }
public ObaStopRequest build ( ) { return new ObaStopRequest ( buildUri ( ) ) ; }
public static ObaStopRequest newRequest ( Context context , String stopId ) { return new Builder ( context , stopId ) . build ( ) ; }
@ Override public ObaStopResponse call ( ) { return call ( ObaStopResponse .class ) ; }
@ Override public String toString ( ) { return "ObaStopRequest [mUri=" + mUri + "]" ; }
public void onFragmentInteraction ( PasswordItem item );
public PasswordFragment ( ) {   }
@ Override public void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; String path = getArguments ( ) . getString ( "Path" ) ; settings = PreferenceManager . getDefaultSharedPreferences ( getActivity ( ) ) ; passListStack = new Stack < ArrayList < PasswordItem > > ( ) ; scrollPosition = new Stack < Integer > ( ) ; pathStack = new Stack < File > ( ) ; recyclerAdapter = new PasswordRecyclerAdapter ( ( PasswordStore ) getActivity ( ) , mListener , PasswordRepository . getPasswords ( new File ( path ) , PasswordRepository . getRepositoryDirectory ( getActivity ( ) ) ) ) ; }
@ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View view = inflater . inflate ( R . layout . password_recycler_view , container , false ) ; mLayoutManager = new LinearLayoutManager ( getActivity ( ) ) ; recyclerView = ( RecyclerView ) view . findViewById ( R . id . pass_recycler ) ; recyclerView . setLayoutManager ( mLayoutManager ) ; recyclerView . addItemDecoration ( new DividerItemDecoration ( getActivity ( ) , R . drawable . divider ) ) ; recyclerView . setAdapter ( recyclerAdapter ) ; final FloatingActionButton fab = ( FloatingActionButton ) view . findViewById ( R . id . fab ) ; fab . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { ( ( PasswordStore ) getActivity ( ) ) . createPassword ( ) ; } } ) ; registerForContextMenu ( recyclerView ) ; return view ; }
@ Override public void onClick ( View v ) { ( ( PasswordStore ) getActivity ( ) ) . createPassword ( ) ; }
@ Override public void onAttach ( final Context context ) { super. onAttach ( context ) ; try { mListener = new OnFragmentInteractionListener ( ) { public void onFragmentInteraction ( PasswordItem item ) { if ( item . getType ( ) == PasswordItem . TYPE_CATEGORY ) { passListStack . push ( pathStack . isEmpty ( ) ? PasswordRepository . getPasswords ( PasswordRepository . getRepositoryDirectory ( context ) ) : PasswordRepository . getPasswords ( pathStack . peek ( ) , PasswordRepository . getRepositoryDirectory ( context ) ) ) ; pathStack . push ( item . getFile ( ) ) ; scrollPosition . push ( recyclerView . getVerticalScrollbarPosition ( ) ) ; recyclerView . scrollToPosition ( 0 ) ; recyclerAdapter . clear ( ) ; recyclerAdapter . addAll ( PasswordRepository . getPasswords ( item . getFile ( ) , PasswordRepository . getRepositoryDirectory ( context ) ) ) ; ( ( AppCompatActivity ) getActivity ( ) ) . getSupportActionBar ( ) . setDisplayHomeAsUpEnabled ( true ) ; } else { if ( getArguments ( ) . getBoolean ( "matchWith" , false ) ) { ( ( PasswordStore ) getActivity ( ) ) . matchPasswordWithApp ( item ) ; } else { ( ( PasswordStore ) getActivity ( ) ) . decryptPassword ( item ) ; } } } public void savePosition ( Integer position ) {                } } ; } catch ( ClassCastException e ) { throw new ClassCastException ( context . toString ( ) + " must implement OnFragmentInteractionListener" ) ; } }
public void onFragmentInteraction ( PasswordItem item ) { if ( item . getType ( ) == PasswordItem . TYPE_CATEGORY ) { passListStack . push ( pathStack . isEmpty ( ) ? PasswordRepository . getPasswords ( PasswordRepository . getRepositoryDirectory ( context ) ) : PasswordRepository . getPasswords ( pathStack . peek ( ) , PasswordRepository . getRepositoryDirectory ( context ) ) ) ; pathStack . push ( item . getFile ( ) ) ; scrollPosition . push ( recyclerView . getVerticalScrollbarPosition ( ) ) ; recyclerView . scrollToPosition ( 0 ) ; recyclerAdapter . clear ( ) ; recyclerAdapter . addAll ( PasswordRepository . getPasswords ( item . getFile ( ) , PasswordRepository . getRepositoryDirectory ( context ) ) ) ; ( ( AppCompatActivity ) getActivity ( ) ) . getSupportActionBar ( ) . setDisplayHomeAsUpEnabled ( true ) ; } else { if ( getArguments ( ) . getBoolean ( "matchWith" , false ) ) { ( ( PasswordStore ) getActivity ( ) ) . matchPasswordWithApp ( item ) ; } else { ( ( PasswordStore ) getActivity ( ) ) . decryptPassword ( item ) ; } } }
public void savePosition ( Integer position ) {                }
@ Override public void onPause ( ) { super. onPause ( ) ; }
public void updateAdapter ( ) { passListStack . clear ( ) ; pathStack . clear ( ) ; scrollPosition . clear ( ) ; recyclerAdapter . clear ( ) ; recyclerAdapter . addAll ( PasswordRepository . getPasswords ( PasswordRepository . getRepositoryDirectory ( getActivity ( ) ) ) ) ; ( ( AppCompatActivity ) getActivity ( ) ) . getSupportActionBar ( ) . setDisplayHomeAsUpEnabled ( false ) ; }
public void refreshAdapter ( ) { recyclerAdapter . clear ( ) ; recyclerAdapter . addAll ( pathStack . isEmpty ( ) ? PasswordRepository . getPasswords ( PasswordRepository . getRepositoryDirectory ( getActivity ( ) ) ) : PasswordRepository . getPasswords ( pathStack . peek ( ) , PasswordRepository . getRepositoryDirectory ( getActivity ( ) ) ) ) ; }
public void filterAdapter ( String filter ) { Log . d ( "FRAG" , "filter: " + filter ) ; if ( filter . isEmpty ( ) ) { refreshAdapter ( ) ; } else { recursiveFilter ( filter , pathStack . isEmpty ( ) ? null : pathStack . peek ( ) ) ; } }
private void recursiveFilter ( String filter , File dir ) { ArrayList < PasswordItem > passwordItems = dir == null ? PasswordRepository . getPasswords ( PasswordRepository . getRepositoryDirectory ( getActivity ( ) ) ) : PasswordRepository . getPasswords ( dir , PasswordRepository . getRepositoryDirectory ( getActivity ( ) ) ) ; boolean rec = settings . getBoolean ( "filter_recursively" , true ) ; for ( PasswordItem item : passwordItems ) { if ( item . getType ( ) == PasswordItem . TYPE_CATEGORY && rec ) { recursiveFilter ( filter , item . getFile ( ) ) ; } boolean matches = item . toString ( ) . toLowerCase ( ) . contains ( filter . toLowerCase ( ) ) ; boolean inAdapter = recyclerAdapter . getValues ( ) . contains ( item ) ; if ( matches && ! inAdapter ) { recyclerAdapter . add ( item ) ; } else if ( ! matches && inAdapter ) { recyclerAdapter . remove ( recyclerAdapter . getValues ( ) . indexOf ( item ) ) ; } } }
public void popBack ( ) { if ( passListStack . isEmpty ( ) ) return; recyclerView . scrollToPosition ( scrollPosition . pop ( ) ) ; recyclerAdapter . clear ( ) ; recyclerAdapter . addAll ( passListStack . pop ( ) ) ; pathStack . pop ( ) ; }
public File getCurrentDir ( ) { if ( pathStack . isEmpty ( ) ) return PasswordRepository . getRepositoryDirectory ( getActivity ( ) . getApplicationContext ( ) ) ; else return pathStack . peek ( ) ; }
public boolean isNotEmpty ( ) { return ! passListStack . isEmpty ( ) ; }
@ Override protected void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; getWindow ( ) . setFlags ( WindowManager . LayoutParams . FLAG_SECURE , WindowManager . LayoutParams . FLAG_SECURE ) ; this . activity = this ; this . clipboard = ( ClipboardManager ) getSystemService ( CLIPBOARD_SERVICE ) ; if ( getIntent ( ) . getStringExtra ( "Operation" ) . equals ( "ENCRYPT" ) ) { setTitle ( "New password" ) ; } settings = PreferenceManager . getDefaultSharedPreferences ( this ) ; String providerPackageName = settings . getString ( "openpgp_provider_list" , "" ) ; keyIDs = settings . getStringSet ( "openpgp_key_ids_set" , new HashSet < String > ( ) ) ; registered = false ; if ( TextUtils . isEmpty ( providerPackageName ) ) { Toast . makeText ( this , this . getResources ( ) . getString ( R . string . provider_toast_text ) , Toast . LENGTH_LONG ) . show ( ) ; Intent intent = new Intent ( this , UserPreference .class ) ; startActivity ( intent ) ; setResult ( RESULT_CANCELED ) ; finish ( ) ; } else { mServiceConnection = new OpenPgpServiceConnection ( PgpHandler .this , providerPackageName , this ) ; mServiceConnection . bindToService ( ) ; registered = true ; getSupportActionBar ( ) . setDisplayHomeAsUpEnabled ( true ) ; } }
@ Override public void onStop ( ) { super. onStop ( ) ; if ( this . registered && this . mServiceConnection . isBound ( ) ) try { this . mServiceConnection . unbindFromService ( ) ; } catch ( Exception e ) {            } }
@ Override public boolean onCreateOptionsMenu ( Menu menu ) { switch ( getIntent ( ) . getStringExtra ( "Operation" ) ){ case "ENCRYPT" : getMenuInflater ( ) . inflate ( R . menu . pgp_handler_new_password , menu ) ; break; case "SELECTFOLDER" : getMenuInflater ( ) . inflate ( R . menu . pgp_handler_select_folder , menu ) ; break; default: getMenuInflater ( ) . inflate ( R . menu . pgp_handler , menu ) ; } return true ; }
@ Override public boolean onOptionsItemSelected ( MenuItem item ) { int id = item . getItemId ( ) ; switch ( id ) { case android . R . id . home : setResult ( RESULT_CANCELED ) ; finish ( ) ; return true ; case R . id . copy_password : copyToClipBoard ( ) ; break; case R . id . share_password_as_plaintext : shareAsPlaintext ( ) ; break; case R . id . edit_password : editPassword ( ) ; break; case R . id . crypto_confirm_add : encrypt ( new Intent ( ) ) ; break; case R . id . crypto_cancel_add : setResult ( RESULT_CANCELED ) ; finish ( ) ; return true ; case R . id . crypto_select : selectFolder ( ) ; break; } return super. onOptionsItemSelected ( item ) ; }
private void selectFolder ( ) { if ( selectFolderData == null || passwordList == null ) { Log . wtf ( Constants . TAG , "Folder selected while the app didn't ask for one to be selected?" ) ; } selectFolderData . putExtra ( "SELECTED_FOLDER_PATH" , passwordList . getCurrentDir ( ) . getAbsolutePath ( ) ) ; setResult ( RESULT_OK , selectFolderData ) ; finish ( ) ; }
public void editPassword ( ) { if ( findViewById ( R . id . crypto_password_show ) == null || findViewById ( R . id . crypto_container ) . getVisibility ( ) != View . VISIBLE ) return; CharSequence category = ( ( TextView ) findViewById ( R . id . crypto_password_category ) ) . getText ( ) ; CharSequence file = ( ( TextView ) findViewById ( R . id . crypto_password_file ) ) . getText ( ) ; CharSequence password = ( ( TextView ) findViewById ( R . id . crypto_password_show ) ) . getText ( ) ; CharSequence extra = ( ( TextView ) findViewById ( R . id . crypto_extra_show ) ) . getText ( ) ; setContentView ( R . layout . encrypt_layout ) ; Typeface monoTypeface = Typeface . createFromAsset ( getAssets ( ) , "fonts/sourcecodepro.ttf" ) ; ( ( EditText ) findViewById ( R . id . crypto_password_edit ) ) . setTypeface ( monoTypeface ) ; ( ( EditText ) findViewById ( R . id . crypto_extra_edit ) ) . setTypeface ( monoTypeface ) ; ( ( TextView ) findViewById ( R . id . crypto_password_category ) ) . setText ( category ) ; ( ( EditText ) findViewById ( R . id . crypto_password_file_edit ) ) . setText ( file ) ; ( ( EditText ) findViewById ( R . id . crypto_password_edit ) ) . setText ( password ) ; ( ( EditText ) findViewById ( R . id . crypto_extra_edit ) ) . setText ( extra ) ; findViewById ( R . id . crypto_password_file_edit ) . setEnabled ( false ) ; String filePath = getIntent ( ) . getExtras ( ) . getString ( "FILE_PATH" ) ; String directoryPath = filePath . substring ( 0 , filePath . lastIndexOf ( File . separator ) ) ; Intent intent = new Intent ( this , PgpHandler .class ) ; intent . putExtra ( "FILE_PATH" , directoryPath ) ; intent . putExtra ( "Operation" , "ENCRYPT" ) ; intent . putExtra ( "fromDecrypt" , true ) ; setIntent ( intent ) ; invalidateOptionsMenu ( ) ; }
public void shareAsPlaintext ( ) { if ( findViewById ( R . id . share_password_as_plaintext ) == null ) return; Intent sendIntent = new Intent ( ) ; sendIntent . setAction ( Intent . ACTION_SEND ) ; sendIntent . putExtra ( Intent . EXTRA_TEXT , decodedPassword ) ; sendIntent . setType ( "text/plain" ) ; startActivity ( Intent . createChooser ( sendIntent , getResources ( ) . getText ( R . string . send_plaintext_password_to ) ) ) ; }
public void copyToClipBoard ( ) { if ( findViewById ( R . id . crypto_password_show ) == null ) return; if ( decodedPassword . isEmpty ( ) ) { return; } setTimer ( ) ; ClipData clip = ClipData . newPlainText ( "pgp_handler_result_pm" , decodedPassword ) ; clipboard . setPrimaryClip ( clip ) ; try { showToast ( this . getResources ( ) . getString ( R . string . clipboard_beginning_toast_text ) + " " + Integer . parseInt ( settings . getString ( "general_show_time" , "45" ) ) + " " + this . getResources ( ) . getString ( R . string . clipboard_ending_toast_text ) ) ; } catch ( NumberFormatException e ) { showToast ( this . getResources ( ) . getString ( R . string . clipboard_beginning_toast_text ) + " 45 " + this . getResources ( ) . getString ( R . string . clipboard_ending_toast_text ) ) ; } }
public void handleClick ( View view ) { switch ( view . getId ( ) ) { case R . id . crypto_show_button : decryptAndVerify ( new Intent ( ) ) ; break; case R . id . crypto_delete_button : break; case R . id . crypto_get_key_ids : getKeyIds ( new Intent ( ) ) ; break; case R . id . generate_password : DialogFragment df = new pwgenDialogFragment ( ) ; df . show ( getFragmentManager ( ) , "generator" ) ; default: Log . wtf ( Constants . TAG , "This should not happen.... PgpHandler.java#handleClick(View) default reached." ) ; } }
private void handleError ( final OpenPgpError error ) { runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { Toast . makeText ( PgpHandler .this , "Error from OpenKeyChain : " + error . getMessage ( ) , Toast . LENGTH_LONG ) . show ( ) ; Log . e ( Constants . TAG , "onError getErrorId:" + error . getErrorId ( ) ) ; Log . e ( Constants . TAG , "onError getMessage:" + error . getMessage ( ) ) ; } } ) ; }
@ Override public void run ( ) { Toast . makeText ( PgpHandler .this , "Error from OpenKeyChain : " + error . getMessage ( ) , Toast . LENGTH_LONG ) . show ( ) ; Log . e ( Constants . TAG , "onError getErrorId:" + error . getErrorId ( ) ) ; Log . e ( Constants . TAG , "onError getMessage:" + error . getMessage ( ) ) ; }
private void showToast ( final String message ) { runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { Toast . makeText ( PgpHandler .this , message , Toast . LENGTH_SHORT ) . show ( ) ; } } ) ; }
@ Override public void run ( ) { Toast . makeText ( PgpHandler .this , message , Toast . LENGTH_SHORT ) . show ( ) ; }
@ Override protected void onPreExecute ( ) { try { showTime = Integer . parseInt ( settings . getString ( "general_show_time" , "45" ) ) ; } catch ( NumberFormatException e ) { showTime = 45 ; } current = 0 ; LinearLayout container = ( LinearLayout ) findViewById ( R . id . crypto_container ) ; container . setVisibility ( View . VISIBLE ) ; TextView extraText = ( TextView ) findViewById ( R . id . crypto_extra_show ) ; if ( extraText . getText ( ) . length ( ) != 0 ) findViewById ( R . id . crypto_extra_show_layout ) . setVisibility ( View . VISIBLE ) ; if ( showTime == 0 ) { cancel ( true ) ; } else { this . pb = ( ProgressBar ) findViewById ( R . id . pbLoading ) ; this . pb . setMax ( showTime ) ; } }
@ Override protected Boolean doInBackground ( Void ... params ) { while ( current < showTime ) { SystemClock . sleep ( 1000 ) ; current ++ ; publishProgress ( current ) ; } return true ; }
@ Override protected void onPostExecute ( Boolean b ) { if ( settings . getBoolean ( "copy_on_decrypt" , true ) && clearClipboard ) { Log . d ( "DELAY_SHOW" , "Clearing the clipboard" ) ; ClipData clip = ClipData . newPlainText ( "pgp_handler_result_pm" , "" ) ; clipboard . setPrimaryClip ( clip ) ; if ( settings . getBoolean ( "clear_clipboard_20x" , false ) ) { Handler handler = new Handler ( ) ; for ( int i = 0 ; i < 19 ; i ++ ) { final String count = String . valueOf ( i ) ; handler . postDelayed ( new Runnable ( ) { @ Override public void run ( ) { clipboard . setPrimaryClip ( ClipData . newPlainText ( count , count ) ) ; } } , i * 500 ) ; } } } decodedPassword = "" ; if ( findViewById ( R . id . crypto_password_show ) != null ) { ( ( TextView ) findViewById ( R . id . crypto_password_show ) ) . setText ( "" ) ; ( ( TextView ) findViewById ( R . id . crypto_extra_show ) ) . setText ( "" ) ; findViewById ( R . id . crypto_extra_show_layout ) . setVisibility ( View . INVISIBLE ) ; findViewById ( R . id . crypto_container ) . setVisibility ( View . INVISIBLE ) ; activity . setResult ( RESULT_CANCELED ) ; activity . finish ( ) ; } }
@ Override public void run ( ) { clipboard . setPrimaryClip ( ClipData . newPlainText ( count , count ) ) ; }
@ Override protected void onProgressUpdate ( Integer ... values ) { this . pb . setProgress ( values [ 0 ] ) ; }
public void setClearClipboard ( boolean value ) { clearClipboard = value ; }
@ Override protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super. onActivityResult ( requestCode , resultCode , data ) ; Log . d ( Constants . TAG , "onActivityResult resultCode: " + resultCode ) ; if ( resultCode == RESULT_OK ) { switch ( requestCode ) { case REQUEST_CODE_ENCRYPT : { encrypt ( data ) ; break; } case REQUEST_CODE_DECRYPT_AND_VERIFY : { findViewById ( R . id . progress_bar_label ) . setVisibility ( View . GONE ) ; decryptAndVerify ( data ) ; break; } case REQUEST_CODE_GET_KEY_IDS : getKeyIds ( data ) ; break; case REQUEST_CODE_EDIT : { edit ( data ) ; break; } } } else if ( resultCode == RESULT_CANCELED ) { setResult ( RESULT_CANCELED , data ) ; finish ( ) ; } }
private void selectFolder ( Intent data ) { if ( data . getStringExtra ( "Operation" ) == null || ! data . getStringExtra ( "Operation" ) . equals ( "SELECTFOLDER" ) ) { Log . e ( Constants . TAG , "PgpHandler#selectFolder(Intent) triggered with incorrect intent." ) ; if ( BuildConfig . DEBUG ) { throw new UnsupportedOperationException ( "Triggered with incorrect intent." ) ; } return; } Log . d ( Constants . TAG , "PgpHandler#selectFolder(Intent)." ) ; FragmentManager fragmentManager = getSupportFragmentManager ( ) ; FragmentTransaction fragmentTransaction = fragmentManager . beginTransaction ( ) ; passwordList = new SelectFolderFragment ( ) ; Bundle args = new Bundle ( ) ; args . putString ( "Path" , PasswordRepository . getRepositoryDirectory ( getApplicationContext ( ) ) . getAbsolutePath ( ) ) ; passwordList . setArguments ( args ) ; getSupportActionBar ( ) . show ( ) ; fragmentManager . popBackStack ( null , FragmentManager . POP_BACK_STACK_INCLUSIVE ) ; fragmentTransaction . replace ( R . id . pgp_handler_linearlayout , passwordList , "PasswordsList" ) ; fragmentTransaction . commit ( ) ; this . selectFolderData = data ; }
private PgpCallback ( boolean returnToCiphertextField , ByteArrayOutputStream os , int requestCode ) { this . returnToCiphertextField = returnToCiphertextField ; this . os = os ; this . requestCode = requestCode ; }
@ Override public void onReturn ( Intent result ) { switch ( result . getIntExtra ( OpenPgpApi . RESULT_CODE , OpenPgpApi . RESULT_CODE_ERROR ) ) { case OpenPgpApi . RESULT_CODE_SUCCESS : { final TextView textViewPassword = ( TextView ) findViewById ( R . id . crypto_password_show ) ; if ( requestCode == REQUEST_CODE_DECRYPT_AND_VERIFY && os != null ) { try { if ( returnToCiphertextField ) { findViewById ( R . id . progress_bar ) . setVisibility ( View . GONE ) ; findViewById ( R . id . progress_bar_label ) . setVisibility ( View . GONE ) ; boolean showPassword = settings . getBoolean ( "show_password" , true ) ; findViewById ( R . id . crypto_container ) . setVisibility ( View . VISIBLE ) ; Typeface monoTypeface = Typeface . createFromAsset ( getAssets ( ) , "fonts/sourcecodepro.ttf" ) ; final String [] passContent = os . toString ( "UTF-8" ) . split ( "\n" ) ; textViewPassword . setTypeface ( monoTypeface ) ; textViewPassword . setText ( passContent [ 0 ] ) ; Button toggleVisibilityButton = ( Button ) findViewById ( R . id . crypto_password_toggle_show ) ; toggleVisibilityButton . setVisibility ( showPassword ? View . GONE : View . VISIBLE ) ; textViewPassword . setTransformationMethod ( showPassword ? null : new HoldToShowPasswordTransformation ( toggleVisibilityButton , new Runnable ( ) { @ Override public void run ( ) { textViewPassword . setText ( passContent [ 0 ] ) ; } } ) ) ; decodedPassword = passContent [ 0 ] ; String extraContent = os . toString ( "UTF-8" ) . replaceFirst ( ".*\n" , "" ) ; if ( extraContent . length ( ) != 0 ) { ( ( TextView ) findViewById ( R . id . crypto_extra_show ) ) . setTypeface ( monoTypeface ) ; ( ( TextView ) findViewById ( R . id . crypto_extra_show ) ) . setText ( extraContent ) ; } if ( settings . getBoolean ( "copy_on_decrypt" , true ) ) { copyToClipBoard ( ) ; } } else { Log . d ( "PGPHANDLER" , "Error message after decrypt : " + os . toString ( ) ) ; } } catch ( UnsupportedEncodingException e ) { Log . e ( Constants . TAG , "UnsupportedEncodingException" , e ) ; } } if ( requestCode == REQUEST_CODE_ENCRYPT && os != null ) { try { String path = getIntent ( ) . getExtras ( ) . getString ( "FILE_PATH" ) + "/" + ( ( EditText ) findViewById ( R . id . crypto_password_file_edit ) ) . getText ( ) . toString ( ) + ".gpg" ; OutputStream outputStream = FileUtils . openOutputStream ( new File ( path ) ) ; outputStream . write ( os . toByteArray ( ) ) ; outputStream . close ( ) ; Intent data = new Intent ( ) ; data . putExtra ( "CREATED_FILE" , path ) ; data . putExtra ( "NAME" , ( ( EditText ) findViewById ( R . id . crypto_password_file_edit ) ) . getText ( ) . toString ( ) ) ; if ( getIntent ( ) . getBooleanExtra ( "fromDecrypt" , false ) ) { data . putExtra ( "needCommit" , true ) ; } setResult ( RESULT_OK , data ) ; finish ( ) ; } catch ( Exception e ) { Log . e ( Constants . TAG , "UnsupportedEncodingException" , e ) ; } } if ( result . hasExtra ( OpenPgpApi . RESULT_KEY_IDS ) ) { long [] ids = result . getLongArrayExtra ( OpenPgpApi . RESULT_KEY_IDS ) ; Set < String > keys = new HashSet < String > ( ) ; for ( long id : ids ) keys . add ( String . valueOf ( id ) ) ; settings . edit ( ) . putStringSet ( "openpgp_key_ids_set" , keys ) . apply ( ) ; showToast ( "PGP key selected" ) ; setResult ( RESULT_OK ) ; finish ( ) ; } if ( requestCode == REQUEST_CODE_EDIT && os != null ) { try { if ( returnToCiphertextField ) { findViewById ( R . id . progress_bar ) . setVisibility ( View . GONE ) ; findViewById ( R . id . progress_bar_label ) . setVisibility ( View . GONE ) ; findViewById ( R . id . crypto_container ) . setVisibility ( View . VISIBLE ) ; Typeface monoTypeface = Typeface . createFromAsset ( getAssets ( ) , "fonts/sourcecodepro.ttf" ) ; String [] passContent = os . toString ( "UTF-8" ) . split ( "\n" ) ; textViewPassword . setTypeface ( monoTypeface ) ; textViewPassword . setText ( passContent [ 0 ] ) ; decodedPassword = passContent [ 0 ] ; String extraContent = os . toString ( "UTF-8" ) . replaceFirst ( ".*\n" , "" ) ; if ( extraContent . length ( ) != 0 ) { ( ( TextView ) findViewById ( R . id . crypto_extra_show ) ) . setTypeface ( monoTypeface ) ; ( ( TextView ) findViewById ( R . id . crypto_extra_show ) ) . setText ( extraContent ) ; } editPassword ( ) ; } else { Log . d ( "PGPHANDLER" , "Error message after decrypt : " + os . toString ( ) ) ; } } catch ( UnsupportedEncodingException e ) { Log . e ( Constants . TAG , "UnsupportedEncodingException" , e ) ; } } break; } case OpenPgpApi . RESULT_CODE_USER_INTERACTION_REQUIRED : { Log . i ( "PgpHandler" , "RESULT_CODE_USER_INTERACTION_REQUIRED" ) ; View progress_bar_label = findViewById ( R . id . progress_bar_label ) ; if ( progress_bar_label != null ) { progress_bar_label . setVisibility ( View . VISIBLE ) ; } PendingIntent pi = result . getParcelableExtra ( OpenPgpApi . RESULT_INTENT ) ; try { PgpHandler .this . startIntentSenderForResult ( pi . getIntentSender ( ) , requestCode , null , 0 , 0 , 0 ) ; } catch ( IntentSender . SendIntentException e ) { Log . e ( Constants . TAG , "SendIntentException" , e ) ; } break; } case OpenPgpApi . RESULT_CODE_ERROR : { OpenPgpError error = result . getParcelableExtra ( OpenPgpApi . RESULT_ERROR ) ; handleError ( error ) ; break; } } }
@ Override public void run ( ) { textViewPassword . setText ( passContent [ 0 ] ) ; }
public void getKeyIds ( Intent data ) { data . setAction ( OpenPgpApi . ACTION_GET_KEY_IDS ) ; OpenPgpApi api = new OpenPgpApi ( this , mServiceConnection . getService ( ) ) ; api . executeApiAsync ( data , null , null , new PgpCallback ( false , null , PgpHandler . REQUEST_CODE_GET_KEY_IDS ) ) ; }
public void decryptAndVerify ( Intent data ) { data . setAction ( OpenPgpApi . ACTION_DECRYPT_VERIFY ) ; findViewById ( R . id . progress_bar ) . setVisibility ( View . VISIBLE ) ; try { InputStream is = FileUtils . openInputStream ( new File ( getIntent ( ) . getExtras ( ) . getString ( "FILE_PATH" ) ) ) ; ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; OpenPgpApi api = new OpenPgpApi ( this , mServiceConnection . getService ( ) ) ; api . executeApiAsync ( data , is , os , new PgpCallback ( true , os , REQUEST_CODE_DECRYPT_AND_VERIFY ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
public void encrypt ( Intent data ) { data . setAction ( OpenPgpApi . ACTION_ENCRYPT ) ; ArrayList < Long > longKeys = new ArrayList <> ( ) ; for ( String keyId : keyIDs ) longKeys . add ( Long . valueOf ( keyId ) ) ; data . putExtra ( OpenPgpApi . EXTRA_KEY_IDS , Longs . toArray ( longKeys ) ) ; data . putExtra ( OpenPgpApi . EXTRA_REQUEST_ASCII_ARMOR , true ) ; String name = ( ( EditText ) findViewById ( R . id . crypto_password_file_edit ) ) . getText ( ) . toString ( ) ; String pass = ( ( EditText ) findViewById ( R . id . crypto_password_edit ) ) . getText ( ) . toString ( ) ; String extra = ( ( EditText ) findViewById ( R . id . crypto_extra_edit ) ) . getText ( ) . toString ( ) ; if ( name . isEmpty ( ) ) { showToast ( this . getResources ( ) . getString ( R . string . file_toast_text ) ) ; return; } if ( pass . isEmpty ( ) && extra . isEmpty ( ) ) { showToast ( this . getResources ( ) . getString ( R . string . empty_toast_text ) ) ; return; } ByteArrayInputStream is ; try { is = new ByteArrayInputStream ( ( pass + "\n" + extra ) . getBytes ( "UTF-8" ) ) ; ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; OpenPgpApi api = new OpenPgpApi ( this , mServiceConnection . getService ( ) ) ; api . executeApiAsync ( data , is , os , new PgpCallback ( true , os , REQUEST_CODE_ENCRYPT ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
public void edit ( Intent data ) { data . setAction ( OpenPgpApi . ACTION_DECRYPT_VERIFY ) ; findViewById ( R . id . progress_bar ) . setVisibility ( View . VISIBLE ) ; try { InputStream is = FileUtils . openInputStream ( new File ( getIntent ( ) . getExtras ( ) . getString ( "FILE_PATH" ) ) ) ; ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; OpenPgpApi api = new OpenPgpApi ( this , mServiceConnection . getService ( ) ) ; api . executeApiAsync ( data , is , os , new PgpCallback ( true , os , REQUEST_CODE_EDIT ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
@ Override public void onBound ( IOpenPgpService2 service ) { Log . i ( "PGP" , "ISBOUND!!" ) ; Bundle extra = getIntent ( ) . getExtras ( ) ; final String operation = extra . getString ( "Operation" ) ; if ( operation == null ) { return; } if ( operation . equals ( "DECRYPT" ) ) { setContentView ( R . layout . decrypt_layout ) ; ( ( TextView ) findViewById ( R . id . crypto_password_file ) ) . setText ( extra . getString ( "NAME" ) ) ; String path = extra . getString ( "FILE_PATH" ) . replace ( PasswordRepository . getRepositoryDirectory ( getApplicationContext ( ) ) . getAbsolutePath ( ) , "" ) ; String cat = new File ( path ) . getParentFile ( ) . getName ( ) ; ( ( TextView ) findViewById ( R . id . crypto_password_category ) ) . setText ( cat + "/" ) ; decryptAndVerify ( new Intent ( ) ) ; } else if ( operation . equals ( "ENCRYPT" ) ) { setContentView ( R . layout . encrypt_layout ) ; Typeface monoTypeface = Typeface . createFromAsset ( getAssets ( ) , "fonts/sourcecodepro.ttf" ) ; ( ( EditText ) findViewById ( R . id . crypto_password_edit ) ) . setTypeface ( monoTypeface ) ; ( ( EditText ) findViewById ( R . id . crypto_extra_edit ) ) . setTypeface ( monoTypeface ) ; String cat = extra . getString ( "FILE_PATH" ) ; cat = cat . replace ( PasswordRepository . getRepositoryDirectory ( getApplicationContext ( ) ) . getAbsolutePath ( ) , "" ) ; cat = cat + "/" ; ( ( TextView ) findViewById ( R . id . crypto_password_category ) ) . setText ( cat ) ; } else if ( operation . equals ( "GET_KEY_ID" ) ) { getKeyIds ( new Intent ( ) ) ; } else if ( operation . equals ( "EDIT" ) ) { setContentView ( R . layout . decrypt_layout ) ; ( ( TextView ) findViewById ( R . id . crypto_password_file ) ) . setText ( extra . getString ( "NAME" ) ) ; String cat = new File ( extra . getString ( "FILE_PATH" ) . replace ( PasswordRepository . getRepositoryDirectory ( getApplicationContext ( ) ) . getAbsolutePath ( ) , "" ) ) . getParentFile ( ) . getName ( ) ; ( ( TextView ) findViewById ( R . id . crypto_password_category ) ) . setText ( cat + "/" ) ; edit ( new Intent ( ) ) ; } else if ( operation . equals ( "SELECTFOLDER" ) ) { setContentView ( R . layout . select_folder_layout ) ; selectFolder ( getIntent ( ) ) ; } }
@ Override public void onError ( Exception e ) {    }
private HoldToShowPasswordTransformation ( Button button , Runnable onToggle ) { this . onToggle = onToggle ; button . setOnTouchListener ( this ) ; }
@ Override public CharSequence getTransformation ( CharSequence charSequence , View view ) { return shown ? charSequence : super. getTransformation ( "12345" , view ) ; }
@ Override public boolean onTouch ( View view , MotionEvent motionEvent ) { switch ( motionEvent . getAction ( ) ) { case MotionEvent . ACTION_DOWN : shown = true ; onToggle . run ( ) ; break; case MotionEvent . ACTION_UP : shown = false ; onToggle . run ( ) ; break; } return false ; }
private void setTimer ( ) { if ( delayTask != null ) { delayTask . setClearClipboard ( false ) ; } delayTask = new DelayShow ( ) ; delayTask . executeOnExecutor ( AsyncTask . THREAD_POOL_EXECUTOR ) ; }
public CursorLoaderAssert ( CursorLoader actual ) { super( actual , CursorLoaderAssert .class ); }
public CursorLoaderAssert hasProjection ( String ... projection ) { isNotNull ( ) ; assertThat ( actual . getProjection ( ) ) . isEqualTo ( projection ) ; return this ; }
public CursorLoaderAssert doesNotHaveProjection ( ) { isNotNull ( ) ; String [] projection = actual . getProjection ( ) ; assertThat ( projection ) . overridingErrorMessage ( "Expected no projection but was <%s>." , Arrays . toString ( projection ) ) . isNullOrEmpty ( ) ; return this ; }
public CursorLoaderAssert projectionContains ( String ... projection ) { isNotNull ( ) ; assertThat ( actual . getProjection ( ) ) . contains ( projection ) ; return this ; }
public CursorLoaderAssert hasSelection ( String selection ) { isNotNull ( ) ; String actualSelection = actual . getSelection ( ) ; assertThat ( actualSelection ) . overridingErrorMessage ( "Expected cursor selection <%s> but was <%s>." , selection , actualSelection ) . isEqualTo ( selection ) ; return this ; }
public CursorLoaderAssert doesNotHaveSelection ( ) { isNotNull ( ) ; String selection = actual . getSelection ( ) ; assertThat ( selection ) . overridingErrorMessage ( "Expected no selection but was <%s>." , selection ) . isNullOrEmpty ( ) ; return this ; }
public CursorLoaderAssert hasSelectionArgs ( String ... selectionArgs ) { isNotNull ( ) ; assertThat ( actual . getSelectionArgs ( ) ) . isEqualTo ( selectionArgs ) ; return this ; }
public CursorLoaderAssert doesNotHaveSelectionArgs ( ) { isNotNull ( ) ; String [] selectionArgs = actual . getSelectionArgs ( ) ; assertThat ( selectionArgs ) . overridingErrorMessage ( "Excpected no selection arguments but was <%s>." , Arrays . toString ( selectionArgs ) ) . isNullOrEmpty ( ) ; return this ; }
public CursorLoaderAssert containsSelectionArgs ( String ... selectionArgs ) { isNotNull ( ) ; assertThat ( actual . getSelectionArgs ( ) ) . contains ( selectionArgs ) ; return this ; }
public CursorLoaderAssert hasSortOrder ( String sortOrder ) { isNotNull ( ) ; String actualSortOrder = actual . getSortOrder ( ) ; assertThat ( actualSortOrder ) . overridingErrorMessage ( "Expected cursor sort order <%s> but was <%s>." , sortOrder , actualSortOrder ) . isEqualTo ( sortOrder ) ; return this ; }
public CursorLoaderAssert doesNotHaveSortOrder ( ) { isNotNull ( ) ; String sortOrder = actual . getSortOrder ( ) ; assertThat ( sortOrder ) . overridingErrorMessage ( "Expected no sort order but was <%s>." , sortOrder ) . isNullOrEmpty ( ) ; return this ; }
public CursorLoaderAssert hasUri ( Uri uri ) { isNotNull ( ) ; Uri actualUri = actual . getUri ( ) ; assertThat ( actualUri ) . overridingErrorMessage ( "Expected cursor URI <%s> but was <%s>." , uri , actualUri ) . isEqualTo ( uri ) ; return this ; }
public ArrivalInfo ( Context context , ObaArrivalInfo info , long now , boolean includeArrivalDepartureInStatusLabel ) { mInfo = info ; final long nowMins = now / ms_in_mins ; long scheduled , predicted ; if ( info . getStopSequence ( ) != 0 ) { scheduled = info . getScheduledArrivalTime ( ) ; predicted = info . getPredictedArrivalTime ( ) ; mIsArrival = true ; } else { scheduled = info . getScheduledDepartureTime ( ) ; predicted = info . getPredictedDepartureTime ( ) ; mIsArrival = false ; } final long scheduledMins = scheduled / ms_in_mins ; final long predictedMins = predicted / ms_in_mins ; if ( predicted != 0 ) { mPredicted = true ; mEta = predictedMins - nowMins ; mDisplayTime = predicted ; } else { mPredicted = false ; mEta = scheduledMins - nowMins ; mDisplayTime = scheduled ; } mColor = ArrivalInfoUtils . computeColor ( scheduledMins , predictedMins ) ; mStatusText = computeStatusLabel ( context , info , now , predicted , scheduledMins , predictedMins , includeArrivalDepartureInStatusLabel ) ; mTimeText = computeTimeLabel ( context ) ; mIsRouteAndHeadsignFavorite = ObaContract . RouteHeadsignFavorites . isFavorite ( info . getRouteId ( ) , info . getHeadsign ( ) , info . getStopId ( ) ) ; mNotifyText = computeNotifyText ( context ) ; }
private String computeStatusLabel ( Context context , ObaArrivalInfo info , final long now , final long predicted , final long scheduledMins , final long predictedMins , boolean includeArrivalDeparture ) { if ( context == null ) { return "" ; } final Resources res = context . getResources ( ) ; Frequency frequency = info . getFrequency ( ) ; if ( frequency != null ) { int headwayAsMinutes = ( int ) ( frequency . getHeadway ( ) / 60 ) ; DateFormat formatter = DateFormat . getTimeInstance ( DateFormat . SHORT ) ; int statusLabelId = - 1 ; long time = 0 ; if ( now < frequency . getStartTime ( ) ) { statusLabelId = R . string . stop_info_frequency_from ; time = frequency . getStartTime ( ) ; } else { statusLabelId = R . string . stop_info_frequency_until ; time = frequency . getEndTime ( ) ; } String label = formatter . format ( new Date ( time ) ) ; return context . getString ( statusLabelId , headwayAsMinutes , label ) ; } if ( predicted != 0 ) { long delay = predictedMins - scheduledMins ; if ( mEta >= 0 ) { return ArrivalInfoUtils . computeArrivalLabelFromDelay ( res , delay ) ; } else { if ( ! includeArrivalDeparture ) { if ( delay > 0 ) { return res . getQuantityString ( R . plurals . stop_info_status_late_without_arrive_depart , ( int ) delay , delay ) ; } else if ( delay < 0 ) { delay = - delay ; return res . getQuantityString ( R . plurals . stop_info_status_early_without_arrive_depart , ( int ) delay , delay ) ; } else { return context . getString ( R . string . stop_info_ontime ) ; } } if ( mIsArrival ) { if ( delay > 0 ) { return res . getQuantityString ( R . plurals . stop_info_arrived_delayed , ( int ) delay , delay ) ; } else if ( delay < 0 ) { delay = - delay ; return res . getQuantityString ( R . plurals . stop_info_arrived_early , ( int ) delay , delay ) ; } else { return context . getString ( R . string . stop_info_arrived_ontime ) ; } } else { if ( delay > 0 ) { return res . getQuantityString ( R . plurals . stop_info_depart_delayed , ( int ) delay , delay ) ; } else if ( delay < 0 ) { delay = - delay ; return res . getQuantityString ( R . plurals . stop_info_depart_early , ( int ) delay , delay ) ; } else { return context . getString ( R . string . stop_info_departed_ontime ) ; } } } } else { if ( ! includeArrivalDeparture ) { return context . getString ( R . string . stop_info_scheduled ) ; } if ( mIsArrival ) { return context . getString ( R . string . stop_info_scheduled_arrival ) ; } else { return context . getString ( R . string . stop_info_scheduled_departure ) ; } } }
private String computeTimeLabel ( Context context ) { if ( context == null ) { return "" ; } String displayTime = UIUtils . formatTime ( context , getDisplayTime ( ) ) ; if ( mEta >= 0 ) { if ( mIsArrival ) { return context . getString ( R . string . stop_info_time_arriving_at , displayTime ) ; } else { return context . getString ( R . string . stop_info_time_departing_at , displayTime ) ; } } else { if ( mIsArrival ) { return context . getString ( R . string . stop_info_time_arrived_at , displayTime ) ; } else { return context . getString ( R . string . stop_info_time_departed_at , displayTime ) ; } } }
private String computeNotifyText ( Context context ) { if ( context == null ) { return "" ; } final String routeDisplayName = UIUtils . getRouteDisplayName ( mInfo ) ; if ( mEta > 0 ) { if ( mIsArrival ) { return context . getString ( R . string . trip_stat_arriving , routeDisplayName , ( int ) ( mEta ) ) ; } else { return context . getString ( R . string . trip_stat_departing , routeDisplayName , ( int ) ( mEta ) ) ; } } else if ( mEta < 0 ) { if ( mIsArrival ) { return context . getString ( R . string . trip_stat_gone_arrived , routeDisplayName ) ; } else { return context . getString ( R . string . trip_stat_gone_departed , routeDisplayName ) ; } } else { if ( mIsArrival ) { return context . getString ( R . string . trip_stat_lessthanone_arriving , routeDisplayName ) ; } else { return context . getString ( R . string . trip_stat_lessthanone_departing , routeDisplayName ) ; } } }
public final ObaArrivalInfo getInfo ( ) { return mInfo ; }
public final long getEta ( ) { return mEta ; }
public final long getDisplayTime ( ) { return mDisplayTime ; }
public final String getStatusText ( ) { return mStatusText ; }
public final String getTimeText ( ) { return mTimeText ; }
public final String getNotifyText ( ) { return mNotifyText ; }
public final boolean isArrival ( ) { return mIsArrival ; }
public final int getColor ( ) { return mColor ; }
public final boolean getPredicted ( ) { return mPredicted ; }
public final boolean isRouteAndHeadsignFavorite ( ) { return mIsRouteAndHeadsignFavorite ; }
public static boolean isMapsInstalled ( Context context ) { try { ApplicationInfo info = context . getPackageManager ( ) . getApplicationInfo ( "com.google.android.apps.maps" , 0 ) ; return true ; } catch ( PackageManager . NameNotFoundException e ) { return false ; } }
public static void promptUserInstallMaps ( final Context context ) { AlertDialog . Builder builder = new AlertDialog . Builder ( context ) ; builder . setMessage ( context . getString ( R . string . please_install_google_maps_dialog_title ) ) ; builder . setCancelable ( false ) ; builder . setPositiveButton ( context . getString ( R . string . install_google_maps_positive_button ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { Intent intent = new Intent ( Intent . ACTION_VIEW , Uri . parse ( context . getString ( R . string . android_maps_v2_market_url ) ) ) ; ResolveInfo info = context . getPackageManager ( ) . resolveActivity ( intent , PackageManager . MATCH_DEFAULT_ONLY ) ; if ( info != null ) { context . startActivity ( intent ) ; } else { AlertDialog . Builder builder = new AlertDialog . Builder ( context ) ; builder . setMessage ( context . getString ( R . string . no_play_store ) ) ; builder . setCancelable ( true ) ; builder . setPositiveButton ( context . getString ( R . string . ok ) , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int id ) { dialog . dismiss ( ) ; } } ) ; AlertDialog d = builder . create ( ) ; d . show ( ) ; } } } ) ; AlertDialog dialog = builder . create ( ) ; dialog . show ( ) ; }
@ Override public void onClick ( DialogInterface dialog , int which ) { Intent intent = new Intent ( Intent . ACTION_VIEW , Uri . parse ( context . getString ( R . string . android_maps_v2_market_url ) ) ) ; ResolveInfo info = context . getPackageManager ( ) . resolveActivity ( intent , PackageManager . MATCH_DEFAULT_ONLY ) ; if ( info != null ) { context . startActivity ( intent ) ; } else { AlertDialog . Builder builder = new AlertDialog . Builder ( context ) ; builder . setMessage ( context . getString ( R . string . no_play_store ) ) ; builder . setCancelable ( true ) ; builder . setPositiveButton ( context . getString ( R . string . ok ) , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int id ) { dialog . dismiss ( ) ; } } ) ; AlertDialog d = builder . create ( ) ; d . show ( ) ; } }
public void onClick ( DialogInterface dialog , int id ) { dialog . dismiss ( ) ; }
public static CustomAddress getCustomAddressFromPlacesIntent ( Context context , Intent intent ) { Place place = PlaceAutocomplete . getPlace ( context , intent ) ; CustomAddress address = new CustomAddress ( ) ; String placeName = place . getName ( ) . toString ( ) ; address . setAddressLine ( 0 , placeName ) ; String addressString = place . getAddress ( ) . toString ( ) ; String [] tokens = addressString . split ( PLACES_ADDRESS_SEPARATOR ) ; int start = placeName . equals ( tokens [ 0 ] ) ? 1 : 0 ; int j = 1 ; for ( int i = start ; i < tokens . length ; i ++ ) { address . setAddressLine ( j ++ , tokens [ i ] ) ; } LatLng loc = place . getLatLng ( ) ; address . setLatitude ( loc . latitude ) ; address . setLongitude ( loc . longitude ) ; return address ; }
public StartPlacesAutocompleteOnClick ( int requestCode , Fragment fragment , ObaRegion region ) { mRequestCode = requestCode ; mFragment = fragment ; mRegion = region ; }
@ Override public void onClick ( View v ) { Intent intent = null ; PlaceAutocomplete . IntentBuilder builder = new PlaceAutocomplete . IntentBuilder ( PlaceAutocomplete . MODE_OVERLAY ) ; if ( mRegion != null ) { LatLngBounds bounds = MapHelpV2 . getRegionBounds ( mRegion ) ; builder . setBoundsBias ( bounds ) ; } try { intent = builder . build ( mFragment . getActivity ( ) ) ; } catch ( GooglePlayServicesRepairableException e ) { e . printStackTrace ( ) ; } catch ( GooglePlayServicesNotAvailableException e ) { e . printStackTrace ( ) ; } mFragment . startActivityForResult ( intent , mRequestCode ) ; }
public static void setZIndex ( Marker m , float zIndex ) { m . setZIndex ( zIndex ) ; }
void inject ( PassViewActivityBase passViewActivityBase );
void inject ( PassListActivity passListActivity );
void inject ( PassEditActivity passEditActivity );
void inject ( PassandroidFragment passandroidFragment );
void inject ( PassAdapter passAdapter );
void inject ( PassImportActivity passImportActivity );
void inject ( PassMenuOptions passMenuOptions );
void inject ( SearchPassesIntentService searchPassesIntentService );
void inject ( USAirwaysLoadActivity usAirwaysLoadActivity );
void inject ( PassAndroidActivity passAndroidActivity );
void inject ( PassListFragment passListFragment );
void inject ( PassNavigationView passNavigationView );
void inject ( TouchImageActivity touchImageActivity );
void inject ( @ NotNull final FieldsEditFragment fieldsEditFragment );
PassStore passStore ( )
Tracker tracker ( )
Settings settings ( )
public static final LatLng makeLatLng ( double lat , double lon ) { return new LatLng ( lat , lon ) ; }
public static final LatLng makeLatLng ( Location l ) { return makeLatLng ( l . getLatitude ( ) , l . getLongitude ( ) ) ; }
public static final Location makeLocation ( LatLng latLng ) { Location l = new Location ( "FromLatLng" ) ; l . setLatitude ( latLng . latitude ) ; l . setLongitude ( latLng . longitude ) ; return l ; }
public static LatLngBounds getRegionBounds ( ObaRegion region ) { if ( region == null ) { throw new IllegalArgumentException ( "Region is null" ) ; } double latMin = 90 ; double latMax = - 90 ; double lonMin = 180 ; double lonMax = - 180 ; for ( ObaRegion . Bounds bound : region . getBounds ( ) ) { double lat = bound . getLat ( ) ; double latSpanHalf = bound . getLatSpan ( ) / 2.0 ; double lat1 = lat - latSpanHalf ; double lat2 = lat + latSpanHalf ; if ( lat1 < latMin ) { latMin = lat1 ; } if ( lat2 > latMax ) { latMax = lat2 ; } double lon = bound . getLon ( ) ; double lonSpanHalf = bound . getLonSpan ( ) / 2.0 ; double lon1 = lon - lonSpanHalf ; double lon2 = lon + lonSpanHalf ; if ( lon1 < lonMin ) { lonMin = lon1 ; } if ( lon2 > lonMax ) { lonMax = lon2 ; } } LatLngBounds . Builder builder = new LatLngBounds . Builder ( ) ; builder . include ( MapHelpV2 . makeLatLng ( latMin , lonMin ) ) ; builder . include ( MapHelpV2 . makeLatLng ( latMax , lonMax ) ) ; return builder . build ( ) ; }
public static boolean isMapsInstalled ( Context context ) { return ProprietaryMapHelpV2 . isMapsInstalled ( context ) ; }
public static void promptUserInstallMaps ( final Context context ) { ProprietaryMapHelpV2 . promptUserInstallMaps ( context ) ; }
public static LatLng getClosestVehicle ( ObaTripsForRouteResponse response , HashSet < String > routeIds , Location loc ) { if ( loc == null ) { return null ; } float minDist = Float . MAX_VALUE ; ObaTripStatus closestVehicle = null ; Location closestVehicleLocation = null ; Float distToVehicle ; for ( ObaTripDetails detail : response . getTrips ( ) ) { Location vehicleLocation ; ObaTripStatus status = detail . getStatus ( ) ; if ( status == null ) { continue; } String activeRoute = response . getTrip ( status . getActiveTripId ( ) ) . getRouteId ( ) ; if ( ! routeIds . contains ( activeRoute ) ) { continue; } if ( status . getLastKnownLocation ( ) != null ) { vehicleLocation = status . getLastKnownLocation ( ) ; } else if ( status . getPosition ( ) != null ) { vehicleLocation = status . getPosition ( ) ; } else { continue; } distToVehicle = vehicleLocation . distanceTo ( loc ) ; if ( distToVehicle < minDist ) { closestVehicleLocation = vehicleLocation ; closestVehicle = status ; minDist = distToVehicle ; } } if ( closestVehicleLocation == null ) { return null ; } Log . d ( TAG , "Closest vehicle is vehicleId=" + closestVehicle . getVehicleId ( ) + ", routeId=" + ", tripId=" + closestVehicle . getActiveTripId ( ) + " at " + closestVehicleLocation . getLatitude ( ) + "," + closestVehicleLocation . getLongitude ( ) ) ; return makeLatLng ( closestVehicleLocation ) ; }
@ Override public void execute ( ) MojoExecutionException , MojoFailureException { if ( getJack ( ) . isEnabled ( ) ) { return; } CommandExecutor executor = CommandExecutor . Factory . createDefaultCommmandExecutor ( ) ; executor . setLogger ( this . getLog ( ) ) ; parseConfiguration ( ) ; File outputFile ; if ( parsedMultiDex ) { outputFile = targetDirectory ; } else { outputFile = new File ( targetDirectory , "classes.dex" ) ; } if ( generateApk ) { runDex ( executor , outputFile ) ; } if ( attachJar ) { File jarFile = new File ( targetDirectory + File . separator + finalName + ".jar" ) ; projectHelper . attachArtifact ( project , "jar" , project . getArtifact ( ) . getClassifier ( ) , jarFile ) ; } if ( attachSources ) { final File apksources = createApkSourcesFile ( ) ; projectHelper . attachArtifact ( project , "apksources" , apksources ) ; } }
private Set < File > getDexInputFiles ( ) MojoExecutionException { Set < File > inputs = new HashSet < File > ( ) ; if ( obfuscatedJar != null && obfuscatedJar . exists ( ) ) { getLog ( ) . debug ( "Adding dex input (obfuscatedJar) : " + obfuscatedJar ) ; inputs . add ( obfuscatedJar ) ; } else { getLog ( ) . debug ( "Using non-obfuscated input" ) ; inputs . add ( projectOutputDirectory ) ; getLog ( ) . debug ( "Adding dex input : " + project . getBuild ( ) . getOutputDirectory ( ) ) ; for ( Artifact artifact : filterArtifacts ( getTransitiveDependencyArtifacts ( ) , skipDependencies , artifactTypeSet . getIncludes ( ) , artifactTypeSet . getExcludes ( ) , artifactSet . getIncludes ( ) , artifactSet . getExcludes ( ) ) ) { if ( artifact . getType ( ) . equals ( Const . ArtifactType . NATIVE_SYMBOL_OBJECT ) || artifact . getType ( ) . equals ( Const . ArtifactType . NATIVE_IMPLEMENTATION_ARCHIVE ) ) { } else if ( artifact . getType ( ) . equals ( APKLIB ) ) { } else if ( artifact . getType ( ) . equals ( AAR ) ) { } else if ( artifact . getType ( ) . equals ( APK ) ) { getLog ( ) . debug ( "Extracting APK classes to target/classes : " + artifact . getArtifactId ( ) ) ; final File apkClassesJar = getUnpackedLibHelper ( ) . getJarFileForApk ( artifact ) ; getLog ( ) . debug ( "Extracting APK : " + apkClassesJar + " to " + targetDirectory ) ; final ZipExtractor extractor = new ZipExtractor ( getLog ( ) ) ; extractor . extract ( apkClassesJar , targetDirectory , ".class" ) ; } else { getLog ( ) . debug ( "Adding dex input : " + artifact . getFile ( ) ) ; inputs . add ( artifact . getFile ( ) . getAbsoluteFile ( ) ) ; } } } return inputs ; }
private void parseConfiguration ( ) { if ( dex != null ) { if ( dex . getJvmArguments ( ) == null ) { parsedJvmArguments = dexJvmArguments ; } else { parsedJvmArguments = dex . getJvmArguments ( ) ; } if ( dex . isCoreLibrary ( ) == null ) { parsedCoreLibrary = dexCoreLibrary ; } else { parsedCoreLibrary = dex . isCoreLibrary ( ) ; } if ( dex . isNoLocals ( ) == null ) { parsedNoLocals = dexNoLocals ; } else { parsedNoLocals = dex . isNoLocals ( ) ; } if ( dex . isOptimize ( ) == null ) { parsedOptimize = dexOptimize ; } else { parsedOptimize = dex . isOptimize ( ) ; } if ( dex . isPreDex ( ) == null ) { parsedPreDex = dexPreDex ; } else { parsedPreDex = dex . isPreDex ( ) ; } if ( dex . getPreDexLibLocation ( ) == null ) { parsedPreDexLibLocation = dexPreDexLibLocation ; } else { parsedPreDexLibLocation = dex . getPreDexLibLocation ( ) ; } if ( dex . isIncremental ( ) == null ) { parsedIncremental = dexIncremental ; } else { parsedIncremental = dex . isIncremental ( ) ; } if ( dex . isForceJumbo ( ) == null ) { parsedForceJumbo = dexForceJumbo ; } else { parsedForceJumbo = dex . isForceJumbo ( ) ; } if ( dex . isMultiDex ( ) == null ) { parsedMultiDex = dexMultiDex ; } else { parsedMultiDex = dex . isMultiDex ( ) ; } if ( dex . getMainDexList ( ) == null ) { parsedMainDexList = dexMainDexList ; } else { parsedMainDexList = dex . getMainDexList ( ) ; } if ( dex . isMinimalMainDex ( ) == null ) { parsedMinimalMainDex = dexMinimalMainDex ; } else { parsedMinimalMainDex = dex . isMinimalMainDex ( ) ; } if ( dex . getDexArguments ( ) == null ) { parsedDexArguments = dexArguments ; } else { parsedDexArguments = dex . getDexArguments ( ) ; } } else { parsedJvmArguments = dexJvmArguments ; parsedCoreLibrary = dexCoreLibrary ; parsedNoLocals = dexNoLocals ; parsedOptimize = dexOptimize ; parsedPreDex = dexPreDex ; parsedPreDexLibLocation = dexPreDexLibLocation ; parsedIncremental = dexIncremental ; parsedForceJumbo = dexForceJumbo ; parsedMultiDex = dexMultiDex ; parsedMainDexList = dexMainDexList ; parsedMinimalMainDex = dexMinimalMainDex ; parsedDexArguments = dexArguments ; } }
private Set < File > preDex ( CommandExecutor executor , Set < File > inputFiles ) throws MojoExecutionException { Set < File > filtered = new HashSet < File > ( ) ; getLog ( ) . info ( "Pre dex-ing libraries for faster dex-ing of the final application." ) ; for ( File inputFile : inputFiles ) { if ( inputFile . getName ( ) . matches ( ".*\\.jar$" ) ) { List < String > commands = dexDefaultCommands ( ) ; File predexJar = predexJarPath ( inputFile ) ; commands . add ( "--output=" + predexJar . getAbsolutePath ( ) ) ; commands . add ( inputFile . getAbsolutePath ( ) ) ; filtered . add ( predexJar ) ; if ( ! predexJar . isFile ( ) || predexJar . lastModified ( ) < inputFile . lastModified ( ) ) { getLog ( ) . info ( "Pre-dex ing jar: " + inputFile . getAbsolutePath ( ) ) ; final String javaExecutable = getJavaExecutable ( ) . getAbsolutePath ( ) ; getLog ( ) . debug ( javaExecutable + " " + commands . toString ( ) ) ; try { executor . setCaptureStdOut ( true ) ; executor . executeCommand ( javaExecutable , commands , project . getBasedir ( ) , false ) ; } catch ( ExecutionException e ) { throw new MojoExecutionException ( "" , e ) ; } } } else { filtered . add ( inputFile ) ; } } return filtered ; }
private File predexJarPath ( File inputFile ) { final File predexLibsDirectory = new File ( parsedPreDexLibLocation . trim ( ) ) ; predexLibsDirectory . mkdirs ( ) ; return new File ( predexLibsDirectory , inputFile . getName ( ) ) ; }
private List < String > dexDefaultCommands ( ) MojoExecutionException { List < String > commands = new ArrayList < String > ( ) ; if ( parsedJvmArguments != null ) { for ( String jvmArgument : parsedJvmArguments ) { if ( ! jvmArgument . startsWith ( "-" ) ) { jvmArgument = "-" + jvmArgument ; } getLog ( ) . debug ( "Adding jvm argument " + jvmArgument ) ; commands . add ( jvmArgument ) ; } } commands . add ( "-jar" ) ; commands . add ( getAndroidSdk ( ) . getDxJarPath ( ) ) ; commands . add ( "--dex" ) ; return commands ; }
private void runDex ( CommandExecutor executor , File outputFile )            throws MojoExecutionException { final List < String > commands = dexDefaultCommands ( ) ; final Set < File > inputFiles = getDexInputFiles ( ) ; Set < File > filteredFiles = inputFiles ; if ( parsedPreDex ) { filteredFiles = preDex ( executor , inputFiles ) ; } if ( ! parsedOptimize ) { commands . add ( "--no-optimize" ) ; } if ( parsedCoreLibrary ) { commands . add ( "--core-library" ) ; } if ( parsedIncremental ) { commands . add ( "--incremental" ) ; } if ( parsedNoLocals ) { commands . add ( "--no-locals" ) ; } if ( parsedForceJumbo ) { commands . add ( "--force-jumbo" ) ; } if ( parsedMultiDex ) { commands . add ( "--multi-dex" ) ; if ( parsedMainDexList == null ) { File generatedMainDexClasses = generateMainDexClassesFile ( ) ; commands . add ( "--main-dex-list=" + generatedMainDexClasses ) ; parsedMinimalMainDex = true ; } else { commands . add ( "--main-dex-list=" + parsedMainDexList ) ; } if ( parsedMinimalMainDex ) { commands . add ( "--minimal-main-dex" ) ; } } if ( parsedDexArguments != null ) { commands . add ( parsedDexArguments ) ; } commands . add ( "--output=" + outputFile . getAbsolutePath ( ) ) ; for ( File inputFile : filteredFiles ) { commands . add ( inputFile . getAbsolutePath ( ) ) ; } final String javaExecutable = getJavaExecutable ( ) . getAbsolutePath ( ) ; getLog ( ) . debug ( javaExecutable + " " + commands . toString ( ) ) ; getLog ( ) . info ( "Convert classes to Dex : " + outputFile ) ; try { executor . setCaptureStdOut ( true ) ; executor . executeCommand ( javaExecutable , commands , project . getBasedir ( ) , false ) ; } catch ( ExecutionException e ) { throw new MojoExecutionException ( "" , e ) ; } }
private static File getJavaExecutable ( ) { final String javaHome = System . getProperty ( "java.home" ) ; final String slash = File . separator ; return new File ( javaHome + slash + "bin" + slash + "java" ) ; }
private File generateMainDexClassesFile ( ) MojoExecutionException { CommandExecutor executor = CommandExecutor . Factory . createDefaultCommmandExecutor ( ) ; executor . setLogger ( getLog ( ) ) ; List < String > commands = new ArrayList <> ( ) ; commands . add ( "--output" ) ; File mainDexClasses = new File ( targetDirectory , "mainDexClasses.txt" ) ; commands . add ( mainDexClasses . getAbsolutePath ( ) ) ; Set < File > inputFiles = getDexInputFiles ( ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( StringUtils . join ( inputFiles , File . pathSeparatorChar ) ) ; if ( Os . isFamily ( Os . FAMILY_WINDOWS ) ) { commands . add ( StringUtils . wrap ( sb . toString ( ) , '"' ) ) ; } else { commands . add ( sb . toString ( ) ) ; } String executable = getAndroidSdk ( ) . getMainDexClasses ( ) . getAbsolutePath ( ) ; try { executor . executeCommand ( executable , commands , project . getBasedir ( ) , false ) ; } catch ( ExecutionException ex ) { throw new MojoExecutionException ( "Failed to execute mainDexClasses" , ex ) ; } return mainDexClasses ; }
protected File createApkSourcesFile ( ) MojoExecutionException { final File apksources = new File ( targetDirectory , finalName + ".apksources" ) ; FileUtils . deleteQuietly ( apksources ) ; try { JarArchiver jarArchiver = new JarArchiver ( ) ; jarArchiver . setDestFile ( apksources ) ; addDirectory ( jarArchiver , assetsDirectory , "assets" ) ; addDirectory ( jarArchiver , resourceDirectory , "res" ) ; addDirectory ( jarArchiver , sourceDirectory , "src/main/java" ) ; addJavaResources ( jarArchiver , resources ) ; jarArchiver . createArchive ( ) ; } catch ( ArchiverException e ) { throw new MojoExecutionException ( "ArchiverException while creating .apksource file." , e ) ; } catch ( IOException e ) { throw new MojoExecutionException ( "IOException while creating .apksource file." , e ) ; } return apksources ; }
protected String endWithSlash ( String prefix ) { prefix = StringUtils . defaultIfEmpty ( prefix , "/" ) ; if ( ! prefix . endsWith ( "/" ) ) { prefix = prefix + "/" ; } return prefix ; }
protected void addDirectory ( JarArchiver jarArchiver , File directory , String prefix ) { if ( directory != null && directory . exists ( ) ) { final DefaultFileSet fileSet = new DefaultFileSet ( ) ; fileSet . setPrefix ( endWithSlash ( prefix ) ) ; fileSet . setDirectory ( directory ) ; jarArchiver . addFileSet ( fileSet ) ; } }
protected void addJavaResources ( JarArchiver jarArchiver , List < Resource > javaResources ) { for ( Resource javaResource : javaResources ) { addJavaResource ( jarArchiver , javaResource ) ; } }
protected void addJavaResource ( JarArchiver jarArchiver , Resource javaResource ) { if ( javaResource != null ) { final File javaResourceDirectory = new File ( javaResource . getDirectory ( ) ) ; if ( javaResourceDirectory . exists ( ) ) { final DefaultFileSet javaResourceFileSet = new DefaultFileSet ( ) ; javaResourceFileSet . setDirectory ( javaResourceDirectory ) ; javaResourceFileSet . setPrefix ( endWithSlash ( "src/main/resources" ) ) ; jarArchiver . addFileSet ( javaResourceFileSet ) ; } } }
Activity getActivity ( )
View getView ( )
void showProgress ( boolean show );
String getMapMode ( )
void setMapMode ( String mode , Bundle args );
ObaMapView getMapView ( )
void showStops ( List < ObaStop > stops , ObaReferences refs );
boolean setMyLocation ( boolean useDefaultZoom , boolean animateToLocation );
void notifyOutOfRange ( )
void zoomToRegion ( )
void setZoom ( float zoomLevel );
Location getMapCenterAsLocation ( )
void setMapCenter ( Location location , boolean animateToLocation , boolean overlayExpanded );
double getLatitudeSpanInDecDegrees ( )
double getLongitudeSpanInDecDegrees ( )
float getZoomLevelAsFloat ( )
void setRouteOverlay ( int lineOverlayColor , ObaShape [] shapes );
void setRouteOverlay ( int lineOverlayColor , ObaShape [] shapes , boolean clear );
void updateVehicles ( HashSet < String > routeIds , ObaTripsForRouteResponse response );
void removeVehicleOverlay ( )
void zoomToRoute ( )
void zoomToItinerary ( )
void zoomIncludeClosestVehicle ( HashSet < String > routeIds , ObaTripsForRouteResponse response );
void postInvalidate ( )
void removeRouteOverlay ( )
void removeStopOverlay ( boolean clearFocusedStop );
boolean canWatchMapChanges ( )
void setFocusStop ( ObaStop stop , List < ObaRoute > routes );
int addMarker ( Location location , Float hue );
void removeMarker ( int markerId );
void setPadding ( Integer left , Integer top , Integer right , Integer bottom );
String getMode ( )
void setState ( Bundle args );
void destroy ( )
void onPause ( )
void onHidden ( boolean hidden );
void onResume ( )
void onSaveInstanceState ( Bundle outState );
void onViewStateRestored ( Bundle savedInstanceState );
void onLocation ( )
void onNoLocation ( )
void notifyMapChanged ( )
protected ObaStopsForRouteRequest ( Uri uri ) { super( uri ); }
public Builder ( Context context , String routeId ) { super( context , getPathWithId ( "/stops-for-route/" , routeId ) ); }
public Builder setIncludeShapes ( boolean includePolylines ) { mBuilder . appendQueryParameter ( "includePolylines" , includePolylines ? "true" : "false" ) ; return this ; }
public ObaStopsForRouteRequest build ( ) { return new ObaStopsForRouteRequest ( buildUri ( ) ) ; }
@ Override public ObaStopsForRouteResponse call ( ) { return call ( ObaStopsForRouteResponse .class ) ; }
@ Override public String toString ( ) { return "ObaStopsForRouteRequest [mUri=" + mUri + "]" ; }
@ Override protected void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; if( Build . VERSION . SDK_INT >= Build . VERSION_CODES . LOLLIPOP ) { getWindow ( ) . setStatusBarColor ( getResources ( ) . getColor ( UserPreferenceManager . getInstance ( ) . isNightModeEnabled ( ) ? R . color . colorPrimaryDarkNight : R . color . colorPrimaryDark ) ) ; } setTheme ( UserPreferenceManager . getInstance ( ) . isNightModeEnabled ( ) ? R . style . AppThemeNight : R . style . AppTheme ) ; }
public Toolbar getToolbar ( ) { if ( mToolbar == null ) { mToolbar = ( Toolbar ) findViewById ( R . id . toolbar ) ; if ( mToolbar != null ) { setSupportActionBar ( mToolbar ) ; } } return mToolbar ; }
@ Override protected void onResume ( ) { super. onResume ( ) ; if ( getToolbar ( ) != null ) { if ( UserPreferenceManager . getInstance ( ) . isNightModeEnabled ( ) ) { getToolbar ( ) . setBackgroundColor ( getResources ( ) . getColor ( R . color . colorPrimaryDarkNight ) ) ; } else { getToolbar ( ) . setBackgroundColor ( getResources ( ) . getColor ( R . color . colorPrimary ) ) ; } } }
private ObaAgencyResponse ( ) { data = Data . EMPTY_OBJECT ; }
@ Override public String getId ( ) { return data . entry . getId ( ) ; }
@ Override public String getName ( ) { return data . entry . getName ( ) ; }
@ Override public String getUrl ( ) { return data . entry . getUrl ( ) ; }
@ Override public String getTimezone ( ) { return data . entry . getTimezone ( ) ; }
@ Override public String getLang ( ) { return data . entry . getLang ( ) ; }
@ Override public String getPhone ( ) { return data . entry . getPhone ( ) ; }
@ Override public String getDisclaimer ( ) { return data . entry . getDisclaimer ( ) ; }
@ Override public String getEmail ( ) { return data . entry . getEmail ( ) ; }
protected ObaTripRequest ( Uri uri ) { super( uri ); }
public Builder ( Context context , String tripId ) { super( context , getPathWithId ( "/trip/" , tripId ) ); }
public ObaTripRequest build ( ) { return new ObaTripRequest ( buildUri ( ) ) ; }
public static ObaTripRequest newRequest ( Context context , String tripId ) { return new Builder ( context , tripId ) . build ( ) ; }
@ Override public ObaTripResponse call ( ) { return call ( ObaTripResponse .class ) ; }
@ Override public String toString ( ) { return "ObaTripRequest [mUri=" + mUri + "]" ; }
@ Test public void testSplitSimpleFolder ( ) { String [] expected = { "foo" , "bar" , "baz" } ; assertEquals ( Arrays . asList ( expected ) , MakefileHelper . splitPath ( new File ( File . separator , FOLDER_FOOBARBAZ ) ) ) ; }
@ Test public void testSplitAbsoluteFolder ( ) IOException { List < String > expected = getSplit ( new File ( File . separator ) . getCanonicalFile ( ) ) ; expected . add ( "foo" ) ; expected . add ( "bar" ) ; expected . add ( "baz" ) ; assertEquals ( expected , MakefileHelper . splitPath ( new File ( File . separator , FOLDER_FOOBARBAZ ) . getAbsoluteFile ( ) ) ) ; }
@ Test public void testSplitSimpleFile ( ) { String [] expected = { "qux.file" } ; assertEquals ( Arrays . asList ( expected ) , MakefileHelper . splitPath ( new File ( File . separator , QUXFILE ) ) ) ; }
@ Test public void testSplitSimpleFolderAndFile ( ) { String [] expected = { "foo" , "bar" , "baz" , "qux.file" } ; assertEquals ( Arrays . asList ( expected ) , MakefileHelper . splitPath ( new File ( File . separator , FOOBARBAZ_QUXFILE ) ) ) ; }
@ Test public void testSplitRelativeFolder ( ) { String [] expected = { "foo" , "bar" , "baz" } ; assertEquals ( Arrays . asList ( expected ) , MakefileHelper . splitPath ( new File ( FOLDER_FOOBARBAZ ) ) ) ; }
@ Test public void testSplitAbsoluteFolderFromCWD ( ) IOException { List < String > expected = getCWDSplit ( ) ; expected . add ( "foo" ) ; expected . add ( "bar" ) ; assertEquals ( expected , MakefileHelper . splitPath ( new File ( FOLDER_FOOBAR ) . getAbsoluteFile ( ) ) ) ; }
@ Test public void testSplitRelativeFile ( ) { String [] expected = { "qux.file" } ; assertEquals ( Arrays . asList ( expected ) , MakefileHelper . splitPath ( new File ( QUXFILE ) ) ) ; }
@ Test public void testSplitRoot ( ) { assertEquals ( Collections . EMPTY_LIST , MakefileHelper . splitPath ( new File ( File . separator ) ) ) ; }
@ Test public void testResolveRelativePathSimpleRelative ( ) IOException { File directory = new File ( System . getProperty ( "user.dir" ) ) ; File file = new File ( System . getProperty ( "user.dir" ) , QUXFILE ) ; assertEquals ( "qux.file" , MakefileHelper . resolveRelativePath ( directory , file ) ) ; }
@ Test public void testResolveRelativePathSimpleRelative2 ( ) IOException { File directory = new File ( System . getProperty ( "user.dir" ) ) ; File file = new File ( System . getProperty ( "user.dir" ) , FOOBARBAZ_QUXFILE ) ; assertEquals ( FOOBARBAZ_QUXFILE , MakefileHelper . resolveRelativePath ( directory , file ) ) ; }
@ Test public void testResolveRelativePathParent ( ) IOException { File directory = new File ( File . separator + FOLDER_FOOBARBAZ ) ; File file = new File ( File . separator + FOOBAR_QUXFILE ) ; assertEquals ( ".." + File . separator + "qux.file" , MakefileHelper . resolveRelativePath ( directory , file ) ) ; }
@ Test public void testResolveRelativePathNointersect ( ) Exception { File directory = new File ( File . separator + FOLDER_FREDBARNY ) ; File file = new File ( File . separator + FOOBARBAZ_QUXFILE ) ; assertEquals ( ".." + File . separator + ".." + File . separator + FOOBARBAZ_QUXFILE , MakefileHelper . resolveRelativePath ( directory , file ) ) ; if ( MakefileHelper . IS_WINDOWS ) { boolean substY = setupWindowsDrive ( "Y:" ) ; boolean substZ = setupWindowsDrive ( "Z:" ) ; directory = new File ( "Y:\\" + FOLDER_FREDBARNY ) ; file = new File ( "Z:\\" + FOOBARBAZ_QUXFILE ) ; try { MakefileHelper . resolveRelativePath ( directory , file ) ; fail ( "Expected exception not thrown (relative paths cannot cross windows drives)" ) ; } catch ( IOException ioex ) { assertEquals ( "Unable to resolve relative path across windows drives" , ioex . getMessage ( ) ) ; } finally { if ( substY ) { clearWindowsDrive ( "Y:" ) ; } if ( substZ ) { clearWindowsDrive ( "Z:" ) ; } } } }
@ Test public void testResolveRelativePathNearRootParent ( ) IOException { File directory = new File ( File . separator + FOLDER_FOO ) ; File file = new File ( File . separator + QUXFILE ) ; assertEquals ( ".." + File . separator + "qux.file" , MakefileHelper . resolveRelativePath ( directory , file ) ) ; }
private List < String > getSplit ( File toSplit ) { List < String > result = new ArrayList < String > ( ) ; if ( File . separator . equals ( "\\" ) ) { result . addAll ( Arrays . asList ( toSplit . toString ( ) . split ( "\\\\" ) ) ) ; } else { result . addAll ( Arrays . asList ( toSplit . toString ( ) . split ( File . separator ) ) ) ; if ( ( result . size ( ) > 0 ) && ( result . get ( 0 ) . length ( ) == 0 ) ) { result . remove ( 0 ) ; } } return result ; }
private List < String > getCWDSplit ( ) IOException { return getSplit ( new File ( "." ) . getCanonicalFile ( ) ) ; }
private boolean setupWindowsDrive ( String drive ) throws IOException , InterruptedException { boolean result = false ; if ( ! new File ( drive ) . exists ( ) ) { Runtime . getRuntime ( ) . exec ( "subst " + drive + " C:\\" ) . waitFor ( ) ; result = true ; } return result ; }
private void clearWindowsDrive ( String drive ) throws IOException , InterruptedException { Runtime . getRuntime ( ) . exec ( "subst " + drive + " /D" ) . waitFor ( ) ; }
@ Override public void onCreate ( Bundle savedInstanceState ) { requestWindowFeature ( Window . FEATURE_INDETERMINATE_PROGRESS ) ; super. onCreate ( savedInstanceState ) ; UIUtils . setupActionBar ( this ) ; handleIntent ( getIntent ( ) ) ; }
@ Override protected void onStart ( ) { super. onStart ( ) ; ObaAnalytics . reportActivityStart ( this ) ; }
@ Override public void onNewIntent ( Intent intent ) { handleIntent ( intent ) ; }
@ Override public boolean onOptionsItemSelected ( MenuItem item ) { if ( item . getItemId ( ) == android . R . id . home ) { NavHelp . goHome ( this , false ) ; return true ; } return false ; }
private void handleIntent ( Intent intent ) { if ( Intent . ACTION_VIEW . equals ( intent . getAction ( ) ) ) { } else if ( Intent . ACTION_SEARCH . equals ( intent . getAction ( ) ) ) { String query = intent . getStringExtra ( SearchManager . QUERY ) ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getString ( R . string . analytics_action_button_press ) , getString ( R . string . analytics_label_button_press_search_button ) ) ; doSearch ( query ) ; } }
private void doSearch ( String query ) { FragmentManager fm = getSupportFragmentManager ( ) ; SearchResultsFragment list = ( SearchResultsFragment ) fm . findFragmentById ( android . R . id . content ) ; FragmentTransaction ft = fm . beginTransaction ( ) ; if ( list != null ) { ft . remove ( list ) ; } list = new SearchResultsFragment ( ) ; Bundle args = new Bundle ( ) ; args . putString ( SearchResultsFragment . QUERY_TEXT , query ) ; list . setArguments ( args ) ; ft . add ( android . R . id . content , list ) ; ft . commit ( ) ; }
@ Override public void handleMessage ( Message msg ) { throw new AssertionError ( "Unknown handler message received: " + msg . what ) ; }
public static Analytics with ( Context context ) { if ( singleton == null ) { if ( context == null ) { throw new IllegalArgumentException ( "Context must not be null." ) ; } synchronized ( Analytics .class ) { if ( singleton == null ) { String writeKey = getResourceString ( context , WRITE_KEY_RESOURCE_IDENTIFIER ) ; Builder builder = new Builder ( context , writeKey ) ; try { String packageName = context . getPackageName ( ) ; int flags = context . getPackageManager ( ) . getApplicationInfo ( packageName , 0 ) . flags ; boolean debugging = ( flags & ApplicationInfo . FLAG_DEBUGGABLE ) != 0 ; if ( debugging ) { builder . logLevel ( LogLevel . INFO ) ; } } catch ( PackageManager . NameNotFoundException ignored ) {          } singleton = builder . build ( ) ; } } } return singleton ; }
public static void setSingletonInstance ( Analytics analytics ) { synchronized ( Analytics .class ) { if ( singleton != null ) { throw new IllegalStateException ( "Singleton instance already exists." ) ; } singleton = analytics ; } }
Analytics ( Application application , ExecutorService networkExecutor , Stats stats , Traits . Cache traitsCache , AnalyticsContext analyticsContext , Options defaultOptions , @ NonNull Logger logger , String tag , @ NonNull List < Integration . Factory > factories , Client client , Cartographer cartographer , ProjectSettings . Cache projectSettingsCache , String writeKey , int flushQueueSize , long flushIntervalInMillis , final ExecutorService analyticsExecutor , final boolean shouldTrackApplicationLifecycleEvents , CountDownLatch advertisingIdLatch , final boolean shouldRecordScreenViews , final boolean trackAttributionInformation , BooleanPreference optOut , Crypto crypto , @ NonNull List < Middleware > middlewares ) { this . application = application ; this . networkExecutor = networkExecutor ; this . stats = stats ; this . traitsCache = traitsCache ; this . analyticsContext = analyticsContext ; this . defaultOptions = defaultOptions ; this . logger = logger ; this . tag = tag ; this . client = client ; this . cartographer = cartographer ; this . projectSettingsCache = projectSettingsCache ; this . writeKey = writeKey ; this . flushQueueSize = flushQueueSize ; this . flushIntervalInMillis = flushIntervalInMillis ; this . advertisingIdLatch = advertisingIdLatch ; this . optOut = optOut ; this . factories = factories ; this . analyticsExecutor = analyticsExecutor ; this . crypto = crypto ; this . middlewares = middlewares ; namespaceSharedPreferences ( ) ; analyticsExecutor . submit ( new Runnable ( ) { @ Override public void run ( ) { projectSettings = getSettings ( ) ; if ( isNullOrEmpty ( projectSettings ) ) { projectSettings = ProjectSettings . create ( new ValueMap ( ) . putValue ( "integrations" , new ValueMap ( ) . putValue ( "Segment.io" , new ValueMap ( ) . putValue ( "apiKey" , Analytics .this . writeKey ) ) ) ) ; } HANDLER . post ( new Runnable ( ) { @ Override public void run ( ) { performInitializeIntegrations ( projectSettings ) ; } } ) ; } } ) ; logger . debug ( "Created analytics client for project with tag:%s." , tag ) ; application . registerActivityLifecycleCallbacks ( new Application . ActivityLifecycleCallbacks ( ) { final AtomicBoolean trackedApplicationLifecycleEvents = new AtomicBoolean ( false ) ; @ Override public void onActivityCreated ( Activity activity , Bundle savedInstanceState ) { if ( ! trackedApplicationLifecycleEvents . getAndSet ( true ) && shouldTrackApplicationLifecycleEvents ) { trackApplicationLifecycleEvents ( ) ; if ( trackAttributionInformation ) { analyticsExecutor . submit ( new Runnable ( ) { @ Override public void run ( ) { trackAttributionInformation ( ) ; } } ) ; } } runOnMainThread ( IntegrationOperation . onActivityCreated ( activity , savedInstanceState ) ) ; } @ Override public void onActivityStarted ( Activity activity ) { if ( shouldRecordScreenViews ) { recordScreenViews ( activity ) ; } runOnMainThread ( IntegrationOperation . onActivityStarted ( activity ) ) ; } @ Override public void onActivityResumed ( Activity activity ) { runOnMainThread ( IntegrationOperation . onActivityResumed ( activity ) ) ; } @ Override public void onActivityPaused ( Activity activity ) { runOnMainThread ( IntegrationOperation . onActivityPaused ( activity ) ) ; } @ Override public void onActivityStopped ( Activity activity ) { runOnMainThread ( IntegrationOperation . onActivityStopped ( activity ) ) ; } @ Override public void onActivitySaveInstanceState ( Activity activity , Bundle outState ) { runOnMainThread ( IntegrationOperation . onActivitySaveInstanceState ( activity , outState ) ) ; } @ Override public void onActivityDestroyed ( Activity activity ) { runOnMainThread ( IntegrationOperation . onActivityDestroyed ( activity ) ) ; } } ) ; }
@ Override public void run ( ) { projectSettings = getSettings ( ) ; if ( isNullOrEmpty ( projectSettings ) ) { projectSettings = ProjectSettings . create ( new ValueMap ( ) . putValue ( "integrations" , new ValueMap ( ) . putValue ( "Segment.io" , new ValueMap ( ) . putValue ( "apiKey" , Analytics .this . writeKey ) ) ) ) ; } HANDLER . post ( new Runnable ( ) { @ Override public void run ( ) { performInitializeIntegrations ( projectSettings ) ; } } ) ; }
@ Override public void run ( ) { performInitializeIntegrations ( projectSettings ) ; }
@ Override public void onActivityCreated ( Activity activity , Bundle savedInstanceState ) { if ( ! trackedApplicationLifecycleEvents . getAndSet ( true ) && shouldTrackApplicationLifecycleEvents ) { trackApplicationLifecycleEvents ( ) ; if ( trackAttributionInformation ) { analyticsExecutor . submit ( new Runnable ( ) { @ Override public void run ( ) { trackAttributionInformation ( ) ; } } ) ; } } runOnMainThread ( IntegrationOperation . onActivityCreated ( activity , savedInstanceState ) ) ; }
@ Override public void run ( ) { trackAttributionInformation ( ) ; }
@ Override public void onActivityStarted ( Activity activity ) { if ( shouldRecordScreenViews ) { recordScreenViews ( activity ) ; } runOnMainThread ( IntegrationOperation . onActivityStarted ( activity ) ) ; }
@ Override public void onActivityResumed ( Activity activity ) { runOnMainThread ( IntegrationOperation . onActivityResumed ( activity ) ) ; }
@ Override public void onActivityPaused ( Activity activity ) { runOnMainThread ( IntegrationOperation . onActivityPaused ( activity ) ) ; }
@ Override public void onActivityStopped ( Activity activity ) { runOnMainThread ( IntegrationOperation . onActivityStopped ( activity ) ) ; }
@ Override public void onActivitySaveInstanceState ( Activity activity , Bundle outState ) { runOnMainThread ( IntegrationOperation . onActivitySaveInstanceState ( activity , outState ) ) ; }
@ Override public void onActivityDestroyed ( Activity activity ) { runOnMainThread ( IntegrationOperation . onActivityDestroyed ( activity ) ) ; }
@ Private void trackAttributionInformation ( ) { BooleanPreference trackedAttribution = new BooleanPreference ( getSegmentSharedPreferences ( application , tag ) , TRACKED_ATTRIBUTION_KEY , false ) ; if ( trackedAttribution . get ( ) ) { return; } waitForAdvertisingId ( ) ; Client . Connection connection = null ; try { connection = client . attribution ( ) ; Writer writer = new BufferedWriter ( new OutputStreamWriter ( connection . os ) ) ; cartographer . toJson ( analyticsContext , writer ) ; Map < String , Object > map = cartographer . fromJson ( buffer ( connection . connection . getInputStream ( ) ) ) ; Properties properties = new Properties ( map ) ; track ( "Install Attributed" , properties ) ; trackedAttribution . set ( true ) ; } catch ( IOException e ) { logger . error ( e , "Unable to track attribution information. Retrying on next launch." ) ; } finally { closeQuietly ( connection ) ; } }
@ Private void trackApplicationLifecycleEvents ( ) { PackageInfo packageInfo = getPackageInfo ( application ) ; String currentVersion = packageInfo . versionName ; int currentBuild = packageInfo . versionCode ; SharedPreferences sharedPreferences = getSegmentSharedPreferences ( application , tag ) ; String previousVersion = sharedPreferences . getString ( VERSION_KEY , null ) ; int previousBuild = sharedPreferences . getInt ( BUILD_KEY , - 1 ) ; if ( previousBuild == - 1 ) { track ( "Application Installed" , new Properties ( ) . putValue ( VERSION_KEY , currentVersion ) . putValue ( BUILD_KEY , currentBuild ) ) ; } else if ( currentBuild != previousBuild ) { track ( "Application Updated" , new Properties ( ) . putValue ( VERSION_KEY , currentVersion ) . putValue ( BUILD_KEY , currentBuild ) . putValue ( "previous_" + VERSION_KEY , previousVersion ) . putValue ( "previous_" + BUILD_KEY , previousBuild ) ) ; } track ( "Application Opened" , new Properties ( ) . putValue ( "version" , currentVersion ) . putValue ( "build" , currentBuild ) ) ; SharedPreferences . Editor editor = sharedPreferences . edit ( ) ; editor . putString ( VERSION_KEY , currentVersion ) ; editor . putInt ( BUILD_KEY , currentBuild ) ; editor . apply ( ) ; }
static PackageInfo getPackageInfo ( Context context ) { PackageManager packageManager = context . getPackageManager ( ) ; try { return packageManager . getPackageInfo ( context . getPackageName ( ) , 0 ) ; } catch ( PackageManager . NameNotFoundException e ) { throw new AssertionError ( "Package not found: " + context . getPackageName ( ) ) ; } }
@ Private void recordScreenViews ( Activity activity ) { PackageManager packageManager = activity . getPackageManager ( ) ; try { ActivityInfo info = packageManager . getActivityInfo ( activity . getComponentName ( ) , PackageManager . GET_META_DATA ) ; CharSequence activityLabel = info . loadLabel ( packageManager ) ; screen ( null , activityLabel . toString ( ) ) ; } catch ( PackageManager . NameNotFoundException e ) { throw new AssertionError ( "Activity Not Found: " + e . toString ( ) ) ; } }
@ Private void runOnMainThread ( final IntegrationOperation operation ) { analyticsExecutor . submit ( new Runnable ( ) { @ Override public void run ( ) { HANDLER . post ( new Runnable ( ) { @ Override public void run ( ) { performRun ( operation ) ; } } ) ; } } ) ; }
@ Override public void run ( ) { HANDLER . post ( new Runnable ( ) { @ Override public void run ( ) { performRun ( operation ) ; } } ) ; }
@ Override public void run ( ) { performRun ( operation ) ; }
public void identify ( @ NonNull String userId ) { identify ( userId , null , null ) ; }
public void identify ( @ NonNull Traits traits ) { identify ( null , traits , null ) ; }
public void identify ( @ Nullable String userId , @ Nullable Traits newTraits , final @ Nullable Options options ) { assertNotShutdown ( ) ; if ( isNullOrEmpty ( userId ) && isNullOrEmpty ( newTraits ) ) { throw new IllegalArgumentException ( "Either userId or some traits must be provided." ) ; } Traits traits = traitsCache . get ( ) ; if ( ! isNullOrEmpty ( userId ) ) { traits . putUserId ( userId ) ; } if ( ! isNullOrEmpty ( newTraits ) ) { traits . putAll ( newTraits ) ; } traitsCache . set ( traits ) ; analyticsContext . setTraits ( traits ) ; analyticsExecutor . submit ( new Runnable ( ) { @ Override public void run ( ) { final Options finalOptions ; if ( options == null ) { finalOptions = defaultOptions ; } else { finalOptions = options ; } IdentifyPayload . Builder builder = new IdentifyPayload . Builder ( ) . traits ( traitsCache . get ( ) ) ; fillAndEnqueue ( builder , finalOptions ) ; } } ) ; }
@ Override public void run ( ) { final Options finalOptions ; if ( options == null ) { finalOptions = defaultOptions ; } else { finalOptions = options ; } IdentifyPayload . Builder builder = new IdentifyPayload . Builder ( ) . traits ( traitsCache . get ( ) ) ; fillAndEnqueue ( builder , finalOptions ) ; }
public void group ( @ NonNull String groupId ) { group ( groupId , null , null ) ; }
public void group ( @ NonNull String groupId , @ Nullable Traits traits ) { group ( groupId , traits , null ) ; }
public void group ( @ NonNull final String groupId , @ Nullable final Traits groupTraits , @ Nullable final Options options ) { assertNotShutdown ( ) ; if ( isNullOrEmpty ( groupId ) ) { throw new IllegalArgumentException ( "groupId must not be null or empty." ) ; } analyticsExecutor . submit ( new Runnable ( ) { @ Override public void run ( ) { final Traits finalGroupTraits ; if ( groupTraits == null ) { finalGroupTraits = new Traits ( ) ; } else { finalGroupTraits = groupTraits ; } final Options finalOptions ; if ( options == null ) { finalOptions = defaultOptions ; } else { finalOptions = options ; } GroupPayload . Builder builder = new GroupPayload . Builder ( ) . groupId ( groupId ) . traits ( finalGroupTraits ) ; fillAndEnqueue ( builder , finalOptions ) ; } } ) ; }
@ Override public void run ( ) { final Traits finalGroupTraits ; if ( groupTraits == null ) { finalGroupTraits = new Traits ( ) ; } else { finalGroupTraits = groupTraits ; } final Options finalOptions ; if ( options == null ) { finalOptions = defaultOptions ; } else { finalOptions = options ; } GroupPayload . Builder builder = new GroupPayload . Builder ( ) . groupId ( groupId ) . traits ( finalGroupTraits ) ; fillAndEnqueue ( builder , finalOptions ) ; }
public void track ( @ NonNull String event ) { track ( event , null , null ) ; }
public void track ( @ NonNull String event , @ Nullable Properties properties ) { track ( event , properties , null ) ; }
public void track ( final @ NonNull String event , final @ Nullable Properties properties , @ Nullable final Options options ) { assertNotShutdown ( ) ; if ( isNullOrEmpty ( event ) ) { throw new IllegalArgumentException ( "event must not be null or empty." ) ; } analyticsExecutor . submit ( new Runnable ( ) { @ Override public void run ( ) { final Options finalOptions ; if ( options == null ) { finalOptions = defaultOptions ; } else { finalOptions = options ; } final Properties finalProperties ; if ( properties == null ) { finalProperties = EMPTY_PROPERTIES ; } else { finalProperties = properties ; } TrackPayload . Builder builder = new TrackPayload . Builder ( ) . event ( event ) . properties ( finalProperties ) ; fillAndEnqueue ( builder , finalOptions ) ; } } ) ; }
@ Override public void run ( ) { final Options finalOptions ; if ( options == null ) { finalOptions = defaultOptions ; } else { finalOptions = options ; } final Properties finalProperties ; if ( properties == null ) { finalProperties = EMPTY_PROPERTIES ; } else { finalProperties = properties ; } TrackPayload . Builder builder = new TrackPayload . Builder ( ) . event ( event ) . properties ( finalProperties ) ; fillAndEnqueue ( builder , finalOptions ) ; }
public void screen ( @ Nullable String category , @ Nullable String name ) { screen ( category , name , null , null ) ; }
public void screen ( @ Nullable String category , @ Nullable String name , @ Nullable Properties properties ) { screen ( category , name , properties , null ) ; }
public void screen ( @ Nullable String name ) { screen ( null , name , null , null ) ; }
public void screen ( @ Nullable String name , @ Nullable Properties properties ) { screen ( null , name , properties , null ) ; }
public void screen ( @ Nullable final String category , @ Nullable final String name , @ Nullable final Properties properties , @ Nullable final Options options ) { assertNotShutdown ( ) ; if ( isNullOrEmpty ( category ) && isNullOrEmpty ( name ) ) { throw new IllegalArgumentException ( "either category or name must be provided." ) ; } analyticsExecutor . submit ( new Runnable ( ) { @ Override public void run ( ) { final Options finalOptions ; if ( options == null ) { finalOptions = defaultOptions ; } else { finalOptions = options ; } final Properties finalProperties ; if ( properties == null ) { finalProperties = EMPTY_PROPERTIES ; } else { finalProperties = properties ; } ScreenPayload . Builder builder = new ScreenPayload . Builder ( ) . name ( name ) . category ( category ) . properties ( finalProperties ) ; fillAndEnqueue ( builder , finalOptions ) ; } } ) ; }
@ Override public void run ( ) { final Options finalOptions ; if ( options == null ) { finalOptions = defaultOptions ; } else { finalOptions = options ; } final Properties finalProperties ; if ( properties == null ) { finalProperties = EMPTY_PROPERTIES ; } else { finalProperties = properties ; } ScreenPayload . Builder builder = new ScreenPayload . Builder ( ) . name ( name ) . category ( category ) . properties ( finalProperties ) ; fillAndEnqueue ( builder , finalOptions ) ; }
public void alias ( @ NonNull String newId ) { alias ( newId , null ) ; }
public void alias ( final @ NonNull String newId , final @ Nullable Options options ) { assertNotShutdown ( ) ; if ( isNullOrEmpty ( newId ) ) { throw new IllegalArgumentException ( "newId must not be null or empty." ) ; } analyticsExecutor . submit ( new Runnable ( ) { @ Override public void run ( ) { final Options finalOptions ; if ( options == null ) { finalOptions = defaultOptions ; } else { finalOptions = options ; } AliasPayload . Builder builder = new AliasPayload . Builder ( ) . userId ( newId ) . previousId ( analyticsContext . traits ( ) . currentId ( ) ) ; fillAndEnqueue ( builder , finalOptions ) ; } } ) ; }
@ Override public void run ( ) { final Options finalOptions ; if ( options == null ) { finalOptions = defaultOptions ; } else { finalOptions = options ; } AliasPayload . Builder builder = new AliasPayload . Builder ( ) . userId ( newId ) . previousId ( analyticsContext . traits ( ) . currentId ( ) ) ; fillAndEnqueue ( builder , finalOptions ) ; }
private void waitForAdvertisingId ( ) { try { advertisingIdLatch . await ( 15 , TimeUnit . SECONDS ) ; } catch ( InterruptedException e ) { logger . error ( e , "Thread interrupted while waiting for advertising ID." ) ; } if ( advertisingIdLatch . getCount ( ) == 1 ) { logger . debug ( "Advertising ID may not be collected because the API did not respond within 15 seconds." ) ; } }
@ Private void fillAndEnqueue ( BasePayload . Builder < ? , ? > builder , Options options ) { waitForAdvertisingId ( ) ; AnalyticsContext contextCopy = analyticsContext . unmodifiableCopy ( ) ; builder . context ( contextCopy ) ; builder . anonymousId ( contextCopy . traits ( ) . anonymousId ( ) ) ; builder . integrations ( options . integrations ( ) ) ; String userId = contextCopy . traits ( ) . userId ( ) ; if ( ! isNullOrEmpty ( userId ) ) { builder . userId ( userId ) ; } enqueue ( builder . build ( ) ) ; }
void enqueue ( BasePayload payload ) { if ( optOut . get ( ) ) { return; } logger . verbose ( "Created payload %s." , payload ) ; Middleware . Chain chain = new RealMiddlewareChain ( 0 , payload , middlewares , this ) ; chain . proceed ( payload ) ; }
void run ( BasePayload payload ) { logger . verbose ( "Running payload %s." , payload ) ; final IntegrationOperation operation ; switch ( payload . type ( ) ) { case identify : operation = IntegrationOperation . identify ( ( IdentifyPayload ) payload ) ; break; case alias : operation = IntegrationOperation . alias ( ( AliasPayload ) payload ) ; break; case group : operation = IntegrationOperation . group ( ( GroupPayload ) payload ) ; break; case track : operation = IntegrationOperation . track ( ( TrackPayload ) payload ) ; break; case screen : operation = IntegrationOperation . screen ( ( ScreenPayload ) payload ) ; break; default: throw new AssertionError ( "unknown type " + payload . type ( ) ) ; } HANDLER . post ( new Runnable ( ) { @ Override public void run ( ) { performRun ( operation ) ; } } ) ; }
@ Override public void run ( ) { performRun ( operation ) ; }
public void flush ( ) { if ( shutdown ) { throw new IllegalStateException ( "Cannot enqueue messages after client is shutdown." ) ; } runOnMainThread ( IntegrationOperation . FLUSH ) ; }
@ SuppressWarnings ( "UnusedDeclaration" ) public AnalyticsContext getAnalyticsContext ( ) { return analyticsContext ; }
public StatsSnapshot getSnapshot ( ) { return stats . createSnapshot ( ) ; }
public Application getApplication ( ) { return application ; }
@ Deprecated public LogLevel getLogLevel ( ) { return logger . logLevel ; }
public Logger getLogger ( ) { return logger ; }
public Logger logger ( String tag ) { return logger . subLog ( tag ) ; }
@ Deprecated public void logout ( ) { reset ( ) ; }
public void reset ( ) { Utils . getSegmentSharedPreferences ( application , tag ) . edit ( ) . clear ( ) . apply ( ) ; traitsCache . delete ( ) ; traitsCache . set ( Traits . create ( ) ) ; analyticsContext . setTraits ( traitsCache . get ( ) ) ; runOnMainThread ( IntegrationOperation . RESET ) ; }
public void optOut ( boolean optOut ) { this . optOut . set ( optOut ) ; }
public < T > void onIntegrationReady ( final String key , final Callback < T > callback ) { if ( isNullOrEmpty ( key ) ) { throw new IllegalArgumentException ( "key cannot be null or empty." ) ; } analyticsExecutor . submit ( new Runnable ( ) { @ Override public void run ( ) { HANDLER . post ( new Runnable ( ) { @ Override public void run ( ) { performCallback ( key , callback ) ; } } ) ; } } ) ; }
@ Override public void run ( ) { HANDLER . post ( new Runnable ( ) { @ Override public void run ( ) { performCallback ( key , callback ) ; } } ) ; }
@ Override public void run ( ) { performCallback ( key , callback ) ; }
public void onIntegrationReady ( @ SuppressWarnings ( "deprecation" ) BundledIntegration integration , Callback callback ) { if ( integration == null ) { throw new IllegalArgumentException ( "integration cannot be null" ) ; } onIntegrationReady ( integration . key , callback ) ; }
BundledIntegration ( String key ) { this . key = key ; }
public void shutdown ( ) { if ( this == singleton ) { throw new UnsupportedOperationException ( "Default singleton instance cannot be shutdown." ) ; } if ( shutdown ) { return; } analyticsExecutor . shutdown ( ) ; if ( networkExecutor instanceof AnalyticsNetworkExecutorService ) { networkExecutor . shutdown ( ) ; } stats . shutdown ( ) ; shutdown = true ; synchronized ( INSTANCES ) { INSTANCES . remove ( tag ) ; } }
private void assertNotShutdown ( ) { if ( shutdown ) { throw new IllegalStateException ( "Cannot enqueue messages after client is shutdown." ) ; } }
public boolean log ( ) { return this != NONE ; }
void onReady ( T instance );
public Builder ( Context context , String writeKey ) { if ( context == null ) { throw new IllegalArgumentException ( "Context must not be null." ) ; } if ( ! hasPermission ( context , Manifest . permission . INTERNET ) ) { throw new IllegalArgumentException ( "INTERNET permission is required." ) ; } application = ( Application ) context . getApplicationContext ( ) ; if ( application == null ) { throw new IllegalArgumentException ( "Application context must not be null." ) ; } if ( isNullOrEmpty ( writeKey ) ) { throw new IllegalArgumentException ( "writeKey must not be null or empty." ) ; } this . writeKey = writeKey ; }
public Builder flushQueueSize ( int flushQueueSize ) { if ( flushQueueSize <= 0 ) { throw new IllegalArgumentException ( "flushQueueSize must be greater than or equal to zero." ) ; } if ( flushQueueSize > 250 ) { throw new IllegalArgumentException ( "flushQueueSize must be less than or equal to 250." ) ; } this . flushQueueSize = flushQueueSize ; return this ; }
public Builder flushInterval ( long flushInterval , TimeUnit timeUnit ) { if ( timeUnit == null ) { throw new IllegalArgumentException ( "timeUnit must not be null." ) ; } if ( flushInterval <= 0 ) { throw new IllegalArgumentException ( "flushInterval must be greater than zero." ) ; } this . flushIntervalInMillis = timeUnit . toMillis ( flushInterval ) ; return this ; }
public Builder collectDeviceId ( boolean collect ) { this . collectDeviceID = collect ; return this ; }
public Builder defaultOptions ( Options defaultOptions ) { if ( defaultOptions == null ) { throw new IllegalArgumentException ( "defaultOptions must not be null." ) ; } this . defaultOptions = new Options ( ) ; for ( Map . Entry < String , Object > entry : defaultOptions . integrations ( ) . entrySet ( ) ) { if ( entry . getValue ( ) instanceof Boolean ) { this . defaultOptions . setIntegration ( entry . getKey ( ) , ( Boolean ) entry . getValue ( ) ) ; } else { this . defaultOptions . setIntegration ( entry . getKey ( ) , true ) ; } } return this ; }
public Builder tag ( String tag ) { if ( isNullOrEmpty ( tag ) ) { throw new IllegalArgumentException ( "tag must not be null or empty." ) ; } this . tag = tag ; return this ; }
public Builder logLevel ( LogLevel logLevel ) { if ( logLevel == null ) { throw new IllegalArgumentException ( "LogLevel must not be null." ) ; } this . logLevel = logLevel ; return this ; }
@ Deprecated public Builder disableBundledIntegrations ( ) { return this ; }
public Builder networkExecutor ( ExecutorService networkExecutor ) { if ( networkExecutor == null ) { throw new IllegalArgumentException ( "Executor service must not be null." ) ; } this . networkExecutor = networkExecutor ; return this ; }
public Builder connectionFactory ( ConnectionFactory connectionFactory ) { if ( connectionFactory == null ) { throw new IllegalArgumentException ( "ConnectionFactory must not be null." ) ; } this . connectionFactory = connectionFactory ; return this ; }
public Builder crypto ( Crypto crypto ) { if ( crypto == null ) { throw new IllegalArgumentException ( "Crypto must not be null." ) ; } this . crypto = crypto ; return this ; }
public Builder use ( Integration . Factory factory ) { if ( factory == null ) { throw new IllegalArgumentException ( "Factory must not be null." ) ; } factories . add ( factory ) ; return this ; }
public Builder trackApplicationLifecycleEvents ( ) { this . trackApplicationLifecycleEvents = true ; return this ; }
public Builder recordScreenViews ( ) { this . recordScreenViews = true ; return this ; }
public Builder trackAttributionInformation ( ) { this . trackAttributionInformation = true ; return this ; }
public Builder middleware ( Middleware middleware ) { assertNotNull ( middleware , "middleware" ) ; if ( middlewares == null ) { middlewares = new ArrayList <> ( ) ; } if ( middlewares . contains ( middleware ) ) { throw new IllegalStateException ( "Middleware is already registered." ) ; } middlewares . add ( middleware ) ; return this ; }
Builder executor ( ExecutorService executor ) { this . executor = assertNotNull ( executor , "executor" ) ; return this ; }
public Analytics build ( ) { if ( isNullOrEmpty ( tag ) ) { tag = writeKey ; } synchronized ( INSTANCES ) { if ( INSTANCES . contains ( tag ) ) { throw new IllegalStateException ( "Duplicate analytics client created with tag: " + tag + ". If you want to use multiple Analytics clients, use a different writeKey " + "or set a tag via the builder during construction." ) ; } INSTANCES . add ( tag ) ; } if ( defaultOptions == null ) { defaultOptions = new Options ( ) ; } if ( logLevel == null ) { logLevel = LogLevel . NONE ; } if ( networkExecutor == null ) { networkExecutor = new AnalyticsNetworkExecutorService ( ) ; } if ( connectionFactory == null ) { connectionFactory = new ConnectionFactory ( ) ; } if ( crypto == null ) { crypto = Crypto . none ( ) ; } final Stats stats = new Stats ( ) ; final Cartographer cartographer = Cartographer . INSTANCE ; final Client client = new Client ( writeKey , connectionFactory ) ; ProjectSettings . Cache projectSettingsCache = new ProjectSettings . Cache ( application , cartographer , tag ) ; BooleanPreference optOut = new BooleanPreference ( getSegmentSharedPreferences ( application , tag ) , OPT_OUT_PREFERENCE_KEY , false ) ; Traits . Cache traitsCache = new Traits . Cache ( application , cartographer , tag ) ; if ( ! traitsCache . isSet ( ) || traitsCache . get ( ) == null ) { Traits traits = Traits . create ( ) ; traitsCache . set ( traits ) ; } Logger logger = Logger . with ( logLevel ) ; AnalyticsContext analyticsContext = AnalyticsContext . create ( application , traitsCache . get ( ) , collectDeviceID ) ; CountDownLatch advertisingIdLatch = new CountDownLatch ( 1 ) ; analyticsContext . attachAdvertisingId ( application , advertisingIdLatch , logger ) ; List < Integration . Factory > factories = new ArrayList <> ( 1 + this . factories . size ( ) ) ; factories . add ( SegmentIntegration . FACTORY ) ; factories . addAll ( this . factories ) ; List < Middleware > middlewares = Utils . immutableCopyOf ( this . middlewares ) ; ExecutorService executor = this . executor ; if ( executor == null ) { executor = Executors . newSingleThreadExecutor ( ) ; } return new Analytics ( application , networkExecutor , stats , traitsCache , analyticsContext , defaultOptions , logger , tag , Collections . unmodifiableList ( factories ) , client , cartographer , projectSettingsCache , writeKey , flushQueueSize , flushIntervalInMillis , executor , trackApplicationLifecycleEvents , advertisingIdLatch , recordScreenViews , trackAttributionInformation , optOut , crypto , middlewares ) ; }
private ProjectSettings downloadSettings ( ) { try { ProjectSettings projectSettings = networkExecutor . submit ( new Callable < ProjectSettings > ( ) { @ Override public ProjectSettings call ( ) Exception { Client . Connection connection = null ; try { connection = client . fetchSettings ( ) ; Map < String , Object > map = cartographer . fromJson ( buffer ( connection . is ) ) ; return ProjectSettings . create ( map ) ; } finally { closeQuietly ( connection ) ; } } } ) . get ( ) ; projectSettingsCache . set ( projectSettings ) ; return projectSettings ; } catch ( InterruptedException e ) { logger . error ( e , "Thread interrupted while fetching settings." ) ; } catch ( ExecutionException e ) { logger . error ( e , "Unable to fetch settings. Retrying in %s ms." , SETTINGS_RETRY_INTERVAL ) ; } return null ; }
@ Override public ProjectSettings call ( ) Exception { Client . Connection connection = null ; try { connection = client . fetchSettings ( ) ; Map < String , Object > map = cartographer . fromJson ( buffer ( connection . is ) ) ; return ProjectSettings . create ( map ) ; } finally { closeQuietly ( connection ) ; } }
@ Private ProjectSettings getSettings ( ) { ProjectSettings cachedSettings = projectSettingsCache . get ( ) ; if ( isNullOrEmpty ( cachedSettings ) ) { return downloadSettings ( ) ; } long expirationTime = cachedSettings . timestamp ( ) + SETTINGS_REFRESH_INTERVAL ; if ( expirationTime > System . currentTimeMillis ( ) ) { return cachedSettings ; } ProjectSettings downloadedSettings = downloadSettings ( ) ; if ( isNullOrEmpty ( downloadedSettings ) ) { return cachedSettings ; } return downloadedSettings ; }
void performInitializeIntegrations ( ProjectSettings projectSettings ) { ValueMap integrationSettings = projectSettings . integrations ( ) ; integrations = new LinkedHashMap <> ( factories . size ( ) ) ; for ( int i = 0 ; i < factories . size ( ) ; i ++ ) { Integration . Factory factory = factories . get ( i ) ; String key = factory . key ( ) ; ValueMap settings = integrationSettings . getValueMap ( key ) ; if ( isNullOrEmpty ( settings ) ) { logger . debug ( "Integration %s is not enabled." , key ) ; continue; } Integration integration = factory . create ( settings , this ) ; if ( integration == null ) { logger . info ( "Factory %s couldn't create integration." , factory ) ; } else { integrations . put ( key , integration ) ; bundledIntegrations . put ( key , false ) ; } } factories = null ; }
void performRun ( IntegrationOperation operation ) { for ( Map . Entry < String , Integration < ? > > entry : integrations . entrySet ( ) ) { String key = entry . getKey ( ) ; long startTime = System . nanoTime ( ) ; operation . run ( key , entry . getValue ( ) , projectSettings ) ; long endTime = System . nanoTime ( ) ; long durationInMillis = TimeUnit . NANOSECONDS . toMillis ( endTime - startTime ) ; stats . dispatchIntegrationOperation ( key , durationInMillis ) ; logger . debug ( "Ran %s on integration %s in %d ns." , operation , key , endTime - startTime ) ; } }
@ Private < T > void performCallback ( String key , Callback < T > callback ) { for ( Map . Entry < String , Integration < ? > > entry : integrations . entrySet ( ) ) { if ( key . equals ( entry . getKey ( ) ) ) { callback . onReady ( ( T ) entry . getValue ( ) . getUnderlyingInstance ( ) ) ; return; } } }
private void namespaceSharedPreferences ( ) { SharedPreferences newSharedPreferences = Utils . getSegmentSharedPreferences ( application , tag ) ; BooleanPreference namespaceSharedPreferences = new BooleanPreference ( newSharedPreferences , "namespaceSharedPreferences" , true ) ; if ( namespaceSharedPreferences . get ( ) ) { SharedPreferences legacySharedPreferences = application . getSharedPreferences ( "analytics-android" , Context . MODE_PRIVATE ) ; Utils . copySharedPreferences ( legacySharedPreferences , newSharedPreferences ) ; namespaceSharedPreferences . set ( false ) ; } }
public PasswordRecyclerAdapter ( PasswordStore activity , PasswordFragment . OnFragmentInteractionListener listener , ArrayList < PasswordItem > values ) { super( activity , values ); this . activity = activity ; this . listener = listener ; }
@ Override @ NonNull protected View . OnLongClickListener getOnLongClickListener ( final ViewHolder holder , final PasswordItem pass ) { return new View . OnLongClickListener ( ) { @ Override public boolean onLongClick ( View v ) { if ( mActionMode != null ) { return false ; } toggleSelection ( holder . getAdapterPosition ( ) ) ; canEdit = pass . getType ( ) == PasswordItem . TYPE_PASSWORD ; mActionMode = activity . startSupportActionMode ( mActionModeCallback ) ; mActionMode . setTitle ( "" + selectedItems . size ( ) ) ; mActionMode . invalidate ( ) ; notifyItemChanged ( holder . getAdapterPosition ( ) ) ; return true ; } } ; }
@ Override public boolean onLongClick ( View v ) { if ( mActionMode != null ) { return false ; } toggleSelection ( holder . getAdapterPosition ( ) ) ; canEdit = pass . getType ( ) == PasswordItem . TYPE_PASSWORD ; mActionMode = activity . startSupportActionMode ( mActionModeCallback ) ; mActionMode . setTitle ( "" + selectedItems . size ( ) ) ; mActionMode . invalidate ( ) ; notifyItemChanged ( holder . getAdapterPosition ( ) ) ; return true ; }
@ Override @ NonNull protected View . OnClickListener getOnClickListener ( final ViewHolder holder , final PasswordItem pass ) { return new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { if ( mActionMode != null ) { toggleSelection ( holder . getAdapterPosition ( ) ) ; mActionMode . setTitle ( "" + selectedItems . size ( ) ) ; if ( selectedItems . isEmpty ( ) ) { mActionMode . finish ( ) ; } else if ( selectedItems . size ( ) == 1 && ! canEdit ) { if ( getValues ( ) . get ( selectedItems . iterator ( ) . next ( ) ) . getType ( ) == PasswordItem . TYPE_PASSWORD ) { canEdit = true ; mActionMode . invalidate ( ) ; } } else if ( selectedItems . size ( ) >= 1 && canEdit ) { canEdit = false ; mActionMode . invalidate ( ) ; } } else { listener . onFragmentInteraction ( pass ) ; } notifyItemChanged ( holder . getAdapterPosition ( ) ) ; } } ; }
@ Override public void onClick ( View v ) { if ( mActionMode != null ) { toggleSelection ( holder . getAdapterPosition ( ) ) ; mActionMode . setTitle ( "" + selectedItems . size ( ) ) ; if ( selectedItems . isEmpty ( ) ) { mActionMode . finish ( ) ; } else if ( selectedItems . size ( ) == 1 && ! canEdit ) { if ( getValues ( ) . get ( selectedItems . iterator ( ) . next ( ) ) . getType ( ) == PasswordItem . TYPE_PASSWORD ) { canEdit = true ; mActionMode . invalidate ( ) ; } } else if ( selectedItems . size ( ) >= 1 && canEdit ) { canEdit = false ; mActionMode . invalidate ( ) ; } } else { listener . onFragmentInteraction ( pass ) ; } notifyItemChanged ( holder . getAdapterPosition ( ) ) ; }
@ Override public boolean onCreateActionMode ( ActionMode mode , Menu menu ) { mode . getMenuInflater ( ) . inflate ( R . menu . context_pass , menu ) ; return true ; }
@ Override public boolean onPrepareActionMode ( ActionMode mode , Menu menu ) { if ( canEdit ) { menu . findItem ( R . id . menu_edit_password ) . setVisible ( true ) ; } else { menu . findItem ( R . id . menu_edit_password ) . setVisible ( false ) ; } return true ; }
@ Override public boolean onActionItemClicked ( ActionMode mode , MenuItem item ) { switch ( item . getItemId ( ) ) { case R . id . menu_delete_password : activity . deletePasswords ( PasswordRecyclerAdapter .this , new TreeSet <> ( selectedItems ) ) ; mode . finish ( ) ; return true ; case R . id . menu_edit_password : activity . editPassword ( getValues ( ) . get ( selectedItems . iterator ( ) . next ( ) ) ) ; mode . finish ( ) ; return true ; case R . id . menu_move_password : ArrayList < PasswordItem > selectedPasswords = new ArrayList <> ( ) ; for ( Integer id : selectedItems ) { selectedPasswords . add ( getValues ( ) . get ( id ) ) ; } activity . movePasswords ( selectedPasswords ) ; default: return false ; } }
@ Override public void onDestroyActionMode ( ActionMode mode ) { for ( Iterator < Integer > it = selectedItems . iterator ( ) ; it . hasNext ( ) ; ) { notifyItemChanged ( it . next ( ) ) ; it . remove ( ) ; } mActionMode = null ; }
protected ObaCurrentTimeRequest ( Uri uri ) { super( uri ); }
public Builder ( Context context ) { super( context , BASE_PATH + "/current-time.json" ); }
public ObaCurrentTimeRequest build ( ) { return new ObaCurrentTimeRequest ( buildUri ( ) ) ; }
public static ObaCurrentTimeRequest newRequest ( Context context ) { return new Builder ( context ) . build ( ) ; }
@ Override public ObaCurrentTimeResponse call ( ) { return call ( ObaCurrentTimeResponse .class ) ; }
@ Override public String toString ( ) { return "ObaCurrentTimeRequest [mUri=" + mUri + "]" ; }
public ApkWithProvidedJarBuildExampleIT ( MavenRuntimeBuilder builder ) throws Exception { this . mavenRuntime = builder . build ( ) ; }
@ Test public void buildInstall ( ) Exception { File basedir = resources . getBasedir ( "aar-child" ) ; MavenExecutionResult result = mavenRuntime . forProject ( basedir ) . execute ( "clean" , "install" ) ; result . assertErrorFreeLog ( ) ; result . assertLogText ( "Failures: 0,  Errors: 0" ) ; }
@ Override public void onCreate ( ) { super. onCreate ( ) ; mApp = this ; mPrefs = PreferenceManager . getDefaultSharedPreferences ( this ) ; initOba ( ) ; initObaRegion ( ) ; initOpen311 ( getCurrentRegion ( ) ) ; ObaAnalytics . initAnalytics ( this ) ; reportAnalytics ( ) ; }
@ Override public void onTerminate ( ) { super. onTerminate ( ) ; mApp = null ; }
public static Application get ( ) { return mApp ; }
public static SharedPreferences getPrefs ( ) { return get ( ) . mPrefs ; }
public static synchronized Location getLastKnownLocation ( Context cxt , GoogleApiClient client ) { if ( mLastKnownLocation == null ) { try { mLastKnownLocation = getLocation2 ( cxt , client ) ; } catch ( SecurityException e ) { Log . e ( TAG , "User may have denied location permission - " + e ) ; } } return mLastKnownLocation ; }
public static synchronized void setLastKnownLocation ( Location l ) { if ( LocationUtils . compareLocations ( l , mLastKnownLocation ) ) { if ( mLastKnownLocation == null ) { mLastKnownLocation = new Location ( "Last known location" ) ; } mLastKnownLocation . set ( l ) ; mGeomagneticField = new GeomagneticField ( ( float ) l . getLatitude ( ) , ( float ) l . getLongitude ( ) , ( float ) l . getAltitude ( ) , System . currentTimeMillis ( ) ) ; } }
public static Float getMagneticDeclination ( ) { if ( mGeomagneticField != null ) { return mGeomagneticField . getDeclination ( ) ; } else { return null ; } }
private static Location getLocation ( Context cxt , GoogleApiClient client ) { Location last = getLocation2 ( cxt , client ) ; if ( last != null ) { return last ; } else { return LocationUtils . getDefaultSearchCenter ( ) ; } }
private static Location getLocation2 ( Context cxt , GoogleApiClient client )            throws SecurityException { GoogleApiAvailability api = GoogleApiAvailability . getInstance ( ) ; Location playServices = null ; if ( client != null && cxt != null && api . isGooglePlayServicesAvailable ( cxt ) == ConnectionResult . SUCCESS && client . isConnected ( ) ) { playServices = FusedLocationApi . getLastLocation ( client ) ; Log . d ( TAG , "Got location from Google Play Services, testing against API v1..." ) ; } Location apiV1 = getLocationApiV1 ( cxt ) ; if ( LocationUtils . compareLocationsByTime ( playServices , apiV1 ) ) { Log . d ( TAG , "Using location from Google Play Services" ) ; return playServices ; } else { Log . d ( TAG , "Using location from Location API v1" ) ; return apiV1 ; } }
private static Location getLocationApiV1 ( Context cxt ) { if ( cxt == null ) { return null ; } LocationManager mgr = ( LocationManager ) cxt . getSystemService ( Context . LOCATION_SERVICE ) ; List < String > providers = mgr . getProviders ( true ) ; Location last = null ; for ( Iterator < String > i = providers . iterator ( ) ; i . hasNext ( ) ; ) { Location loc = mgr . getLastKnownLocation ( i . next ( ) ) ; if ( LocationUtils . compareLocationsByTime ( loc , last ) ) { last = loc ; } } return last ; }
public synchronized ObaRegion getCurrentRegion ( ) { return ObaApi . getDefaultContext ( ) . getRegion ( ) ; }
public synchronized void setCurrentRegion ( ObaRegion region ) { setCurrentRegion ( region , true ) ; }
public synchronized void setCurrentRegion ( ObaRegion region , boolean regionChanged ) { if ( region != null ) { ObaApi . getDefaultContext ( ) . setRegion ( region ) ; PreferenceUtils . saveLong ( mPrefs , getString ( R . string . preference_key_region ) , region . getId ( ) ) ; setCustomApiUrl ( null ) ; if ( regionChanged && region . getOtpBaseUrl ( ) != null ) { setCustomOtpApiUrl ( null ) ; setUseOldOtpApiUrlVersion ( false ) ; } } else { ObaApi . getDefaultContext ( ) . setRegion ( null ) ; PreferenceUtils . saveLong ( mPrefs , getString ( R . string . preference_key_region ) , - 1 ) ; } initOpen311 ( region ) ; }
public long getLastRegionUpdateDate ( ) { SharedPreferences preferences = getPrefs ( ) ; return preferences . getLong ( getString ( R . string . preference_key_last_region_update ) , 0 ) ; }
public void setLastRegionUpdateDate ( long date ) { PreferenceUtils . saveLong ( mPrefs , getString ( R . string . preference_key_last_region_update ) , date ) ; }
public String getCustomApiUrl ( ) { SharedPreferences preferences = getPrefs ( ) ; return preferences . getString ( getString ( R . string . preference_key_oba_api_url ) , null ) ; }
public void setCustomApiUrl ( String url ) { PreferenceUtils . saveString ( getString ( R . string . preference_key_oba_api_url ) , url ) ; }
public String getCustomOtpApiUrl ( ) { SharedPreferences preferences = getPrefs ( ) ; return preferences . getString ( getString ( R . string . preference_key_otp_api_url ) , null ) ; }
public void setCustomOtpApiUrl ( String url ) { PreferenceUtils . saveString ( getString ( R . string . preference_key_otp_api_url ) , url ) ; }
public boolean getUseOldOtpApiUrlVersion ( ) { SharedPreferences preferences = getPrefs ( ) ; return preferences . getBoolean ( getString ( R . string . preference_key_otp_api_url_version ) , false ) ; }
public void setUseOldOtpApiUrlVersion ( boolean useOldOtpApiUrlVersion ) { PreferenceUtils . saveBoolean ( getString ( R . string . preference_key_otp_api_url_version ) , useOldOtpApiUrlVersion ) ; }
public static String getHex ( byte [] raw ) { final StringBuilder hex = new StringBuilder ( 2 * raw . length ) ; for ( byte b : raw ) { hex . append ( HEXES . charAt ( ( b & 0xF0 ) >> 4 ) ) . append ( HEXES . charAt ( ( b & 0x0F ) ) ) ; } return hex . toString ( ) ; }
private String getAppUid ( ) { try { final TelephonyManager telephony = ( TelephonyManager ) getSystemService ( Context . TELEPHONY_SERVICE ) ; final String id = telephony . getDeviceId ( ) ; MessageDigest digest = MessageDigest . getInstance ( "MD5" ) ; digest . update ( id . getBytes ( ) ) ; return getHex ( digest . digest ( ) ) ; } catch ( Exception e ) { return UUID . randomUUID ( ) . toString ( ) ; } }
private void initOba ( ) { String uuid = mPrefs . getString ( APP_UID , null ) ; if ( uuid == null ) { uuid = getAppUid ( ) ; PreferenceUtils . saveString ( APP_UID , uuid ) ; } checkArrivalStylePreferenceDefault ( ) ; PackageManager pm = getPackageManager ( ) ; PackageInfo appInfo = null ; try { appInfo = pm . getPackageInfo ( getPackageName ( ) , PackageManager . GET_META_DATA ) ; } catch ( NameNotFoundException e ) { return; } ObaApi . getDefaultContext ( ) . setAppInfo ( appInfo . versionCode , uuid ) ; }
private void checkArrivalStylePreferenceDefault ( ) { String arrivalInfoStylePrefKey = getResources ( ) . getString ( R . string . preference_key_arrival_info_style ) ; String arrivalInfoStylePref = mPrefs . getString ( arrivalInfoStylePrefKey , null ) ; if ( arrivalInfoStylePref == null ) { switch ( BuildConfig . ARRIVAL_INFO_STYLE ) { case BuildFlavorUtils . ARRIVAL_INFO_STYLE_A : PreferenceUtils . saveString ( arrivalInfoStylePrefKey , BuildFlavorUtils . getPreferenceOptionForArrivalInfoBuildFlavorStyle ( BuildFlavorUtils . ARRIVAL_INFO_STYLE_A ) ) ; Log . d ( TAG , "Using arrival info style A (OBA Classic) as default preference" ) ; break; case BuildFlavorUtils . ARRIVAL_INFO_STYLE_B : PreferenceUtils . saveString ( arrivalInfoStylePrefKey , BuildFlavorUtils . getPreferenceOptionForArrivalInfoBuildFlavorStyle ( BuildFlavorUtils . ARRIVAL_INFO_STYLE_B ) ) ; Log . d ( TAG , "Using arrival info style B (Cards) as default preference" ) ; break; default: PreferenceUtils . saveString ( arrivalInfoStylePrefKey , BuildFlavorUtils . getPreferenceOptionForArrivalInfoBuildFlavorStyle ( BuildFlavorUtils . ARRIVAL_INFO_STYLE_B ) ) ; Log . d ( TAG , "Using arrival info style B (Cards) as default preference" ) ; break; } } }
private void initObaRegion ( ) { long id = mPrefs . getLong ( getString ( R . string . preference_key_region ) , - 1 ) ; if ( id < 0 ) { Log . d ( TAG , "Regions preference ID is less than 0, returning..." ) ; return; } ObaRegion region = ObaContract . Regions . get ( this , ( int ) id ) ; if ( region == null ) { Log . d ( TAG , "Regions preference is null, returning..." ) ; return; } ObaApi . getDefaultContext ( ) . setRegion ( region ) ; }
private void initOpen311 ( ObaRegion region ) { if ( BuildConfig . DEBUG ) { Open311Manager . getSettings ( ) . setDebugMode ( true ) ; Open311Manager . getSettings ( ) . setDryRun ( true ) ; Log . w ( TAG , "Open311 issue reporting is in debug/dry run mode - no issues will be submitted." ) ; } Open311Manager . clearOpen311 ( ) ; if ( region != null && region . getOpen311Servers ( ) != null ) { for ( ObaRegion . Open311Server open311Server : region . getOpen311Servers ( ) ) { String jurisdictionId = open311Server . getJuridisctionId ( ) ; Open311Option option = new Open311Option ( open311Server . getBaseUrl ( ) , open311Server . getApiKey ( ) , TextUtils . isEmpty ( jurisdictionId ) ? null : jurisdictionId ) ; Open311Manager . initOpen311WithOption ( option ) ; } } }
public synchronized Tracker getTracker ( TrackerName trackerId ) { if ( ! mTrackers . containsKey ( trackerId ) ) { GoogleAnalytics analytics = GoogleAnalytics . getInstance ( this ) ; Tracker t = ( trackerId == TrackerName . APP_TRACKER ) ? analytics . newTracker ( R . xml . app_tracker ) : ( trackerId == TrackerName . GLOBAL_TRACKER ) ? analytics . newTracker ( R . xml . global_tracker ) : analytics . newTracker ( R . xml . global_tracker ) ; mTrackers . put ( trackerId , t ) ; } return mTrackers . get ( trackerId ) ; }
private void reportAnalytics ( ) { if ( getCustomApiUrl ( ) == null && getCurrentRegion ( ) != null ) { ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . APP_SETTINGS . toString ( ) , getString ( R . string . analytics_action_configured_region ) , getString ( R . string . analytics_label_region ) + getCurrentRegion ( ) . getName ( ) ) ; } else if ( Application . get ( ) . getCustomApiUrl ( ) != null ) { String customUrl = null ; MessageDigest digest = null ; try { digest = MessageDigest . getInstance ( "SHA-1" ) ; digest . update ( getCustomApiUrl ( ) . getBytes ( ) ) ; customUrl = getString ( R . string . analytics_label_custom_url ) + ": " + getHex ( digest . digest ( ) ) ; } catch ( Exception e ) { customUrl = Application . get ( ) . getString ( R . string . analytics_label_custom_url ) ; } ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . APP_SETTINGS . toString ( ) , getString ( R . string . analytics_action_configured_region ) , getString ( R . string . analytics_label_region ) + customUrl ) ; } Boolean experimentalRegions = getPrefs ( ) . getBoolean ( getString ( R . string . preference_key_experimental_regions ) , Boolean . FALSE ) ; Boolean autoRegion = getPrefs ( ) . getBoolean ( getString ( R . string . preference_key_auto_select_region ) , true ) ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . APP_SETTINGS . toString ( ) , getString ( R . string . analytics_action_edit_general ) , getString ( R . string . analytics_label_experimental ) + ( experimentalRegions ? "YES" : "NO" ) ) ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . APP_SETTINGS . toString ( ) , getString ( R . string . analytics_action_edit_general ) , getString ( R . string . analytics_label_region_auto ) + ( autoRegion ? "YES" : "NO" ) ) ; }
void trackException ( String s , Throwable e , boolean fatal );
void trackException ( String s , boolean fatal );
void trackEvent ( @ Nullable String category , @ Nullable String action , @ Nullable String label , @ Nullable Long val );
public GoogleMapAssert ( GoogleMap actual ) { super( actual , GoogleMapAssert .class ); }
public GoogleMapAssert hasMapType ( int mapType ) { isNotNull ( ) ; int actualMapType = actual . getMapType ( ) ; assertThat ( actualMapType ) . overridingErrorMessage ( "Expected map type <%s> but was <%s>." , mapType , actualMapType ) . isEqualTo ( mapType ) ; return this ; }
public GoogleMapAssert hasMaxZoomLevel ( float zoomLevel ) { isNotNull ( ) ; float actualZoomLevel = actual . getMaxZoomLevel ( ) ; assertThat ( actualZoomLevel ) . overridingErrorMessage ( "Expected maximum zoom level <%s> but was <%s>." , zoomLevel , actualZoomLevel ) . isEqualTo ( zoomLevel ) ; return this ; }
public GoogleMapAssert hasMinZoomLevel ( float zoomLevel ) { isNotNull ( ) ; float actualZoomLevel = actual . getMinZoomLevel ( ) ; assertThat ( actualZoomLevel ) . overridingErrorMessage ( "Expected minimum zoom level <%s> but was <%s>." , zoomLevel , actualZoomLevel ) . isEqualTo ( zoomLevel ) ; return this ; }
public GoogleMapAssert hasBuildingsEnabled ( ) { isNotNull ( ) ; assertThat ( actual . isBuildingsEnabled ( ) ) . overridingErrorMessage ( "Expected buildings to be enabled but was disabled." ) . isTrue ( ) ; return this ; }
public GoogleMapAssert hasBuildingsDisabled ( ) { isNotNull ( ) ; assertThat ( actual . isBuildingsEnabled ( ) ) . overridingErrorMessage ( "Expected buildings to be disabled but was enabled." ) . isFalse ( ) ; return this ; }
public GoogleMapAssert hasIndoorEnabled ( ) { isNotNull ( ) ; assertThat ( actual . isIndoorEnabled ( ) ) . overridingErrorMessage ( "Expected indoor to be enabled but was disabled." ) . isTrue ( ) ; return this ; }
public GoogleMapAssert hasIndoorDisabled ( ) { isNotNull ( ) ; assertThat ( actual . isIndoorEnabled ( ) ) . overridingErrorMessage ( "Expected indoor to be disabled but was enabled." ) . isFalse ( ) ; return this ; }
public GoogleMapAssert hasMyLocationEnabled ( ) { isNotNull ( ) ; assertThat ( actual . isMyLocationEnabled ( ) ) . overridingErrorMessage ( "Expected my location to be enabled but was disabled." ) . isTrue ( ) ; return this ; }
public GoogleMapAssert hasMyLocationDisabled ( ) { isNotNull ( ) ; assertThat ( actual . isMyLocationEnabled ( ) ) . overridingErrorMessage ( "Expected my location to be disabled but was enabled." ) . isFalse ( ) ; return this ; }
public GoogleMapAssert hasTrafficEnabled ( ) { isNotNull ( ) ; assertThat ( actual . isTrafficEnabled ( ) ) . overridingErrorMessage ( "Expected traffic to be enabled but was disabled." ) . isTrue ( ) ; return this ; }
public GoogleMapAssert hasTrafficDisabled ( ) { isNotNull ( ) ; assertThat ( actual . isTrafficEnabled ( ) ) . overridingErrorMessage ( "Expected traffic to be disabled but was enabled." ) . isFalse ( ) ; return this ; }
public BarCodeIntentIntegrator ( Activity activity ) { this . activity = activity ; this . fragment = null ; initializeConfiguration ( ) ; }
public BarCodeIntentIntegrator ( Fragment fragment ) { this . activity = fragment . getActivity ( ) ; this . fragment = fragment ; initializeConfiguration ( ) ; }
private void initializeConfiguration ( ) { title = DEFAULT_TITLE ; message = DEFAULT_MESSAGE ; buttonYes = DEFAULT_YES ; buttonNo = DEFAULT_NO ; targetApplications = TARGET_ALL_KNOWN ; }
public String getTitle ( ) { return title ; }
public void setTitle ( String title ) { this . title = title ; }
public void setTitleByID ( int titleID ) { title = activity . getString ( titleID ) ; }
public String getMessage ( ) { return message ; }
public void setMessage ( String message ) { this . message = message ; }
public void setMessageByID ( int messageID ) { message = activity . getString ( messageID ) ; }
public String getButtonYes ( ) { return buttonYes ; }
public void setButtonYes ( String buttonYes ) { this . buttonYes = buttonYes ; }
public void setButtonYesByID ( int buttonYesID ) { buttonYes = activity . getString ( buttonYesID ) ; }
public String getButtonNo ( ) { return buttonNo ; }
public void setButtonNo ( String buttonNo ) { this . buttonNo = buttonNo ; }
public void setButtonNoByID ( int buttonNoID ) { buttonNo = activity . getString ( buttonNoID ) ; }
public Collection < String > getTargetApplications ( ) { return targetApplications ; }
public final void setTargetApplications ( List < String > targetApplications ) { if ( targetApplications . isEmpty ( ) ) { throw new IllegalArgumentException ( "No target applications" ) ; } this . targetApplications = targetApplications ; }
public void setSingleTargetApplication ( String targetApplication ) { this . targetApplications = Collections . singletonList ( targetApplication ) ; }
public Map < String , ? > getMoreExtras ( ) { return moreExtras ; }
public final void addExtra ( String key , Object value ) { moreExtras . put ( key , value ) ; }
public final AlertDialog initiateScan ( ) { return initiateScan ( ALL_CODE_TYPES , - 1 ) ; }
public final AlertDialog initiateScan ( int cameraId ) { return initiateScan ( ALL_CODE_TYPES , cameraId ) ; }
public final AlertDialog initiateScan ( Collection < String > desiredBarcodeFormats ) { return initiateScan ( desiredBarcodeFormats , - 1 ) ; }
public final AlertDialog initiateScan ( Collection < String > desiredBarcodeFormats , int cameraId ) { Intent intentScan = new Intent ( BS_PACKAGE + ".SCAN" ) ; intentScan . addCategory ( Intent . CATEGORY_DEFAULT ) ; if ( desiredBarcodeFormats != null ) { StringBuilder joinedByComma = new StringBuilder ( ) ; for ( String format : desiredBarcodeFormats ) { if ( joinedByComma . length ( ) > 0 ) { joinedByComma . append ( ',' ) ; } joinedByComma . append ( format ) ; } intentScan . putExtra ( "SCAN_FORMATS" , joinedByComma . toString ( ) ) ; } if ( cameraId >= 0 ) { intentScan . putExtra ( "SCAN_CAMERA_ID" , cameraId ) ; } String targetAppPackage = findTargetAppPackage ( intentScan ) ; if ( targetAppPackage == null ) { return showDownloadDialog ( ) ; } intentScan . setPackage ( targetAppPackage ) ; intentScan . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_TOP ) ; intentScan . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET ) ; attachMoreExtras ( intentScan ) ; startActivityForResult ( intentScan , REQUEST_CODE ) ; return null ; }
protected void startActivityForResult ( Intent intent , int code ) { if ( fragment == null ) { activity . startActivityForResult ( intent , code ) ; } else { fragment . startActivityForResult ( intent , code ) ; } }
private String findTargetAppPackage ( Intent intent ) { PackageManager pm = activity . getPackageManager ( ) ; List < ResolveInfo > availableApps = pm . queryIntentActivities ( intent , PackageManager . MATCH_DEFAULT_ONLY ) ; if ( availableApps != null ) { for ( String targetApp : targetApplications ) { if ( contains ( availableApps , targetApp ) ) { return targetApp ; } } } return null ; }
private static boolean contains ( Iterable < ResolveInfo > availableApps , String targetApp ) { for ( ResolveInfo availableApp : availableApps ) { String packageName = availableApp . activityInfo . packageName ; if ( targetApp . equals ( packageName ) ) { return true ; } } return false ; }
private AlertDialog showDownloadDialog ( ) { AlertDialog . Builder downloadDialog = new AlertDialog . Builder ( activity ) ; downloadDialog . setTitle ( title ) ; downloadDialog . setMessage ( message ) ; downloadDialog . setPositiveButton ( buttonYes , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialogInterface , int i ) { String packageName ; if ( targetApplications . contains ( BS_PACKAGE ) ) { packageName = BS_PACKAGE ; } else { packageName = targetApplications . get ( 0 ) ; } Uri uri = Uri . parse ( "market: + packageName ) ; Intent intent = new Intent ( Intent . ACTION_VIEW , uri ) ; try { if ( fragment == null ) { activity . startActivity ( intent ) ; } else { fragment . startActivity ( intent ) ; } } catch ( ActivityNotFoundException anfe ) { Log . w ( TAG , "Google Play is not installed; cannot install " + packageName ) ; } } } ) ; downloadDialog . setNegativeButton ( buttonNo , null ) ; downloadDialog . setCancelable ( true ) ; return downloadDialog . show ( ) ; }
@ Override public void onClick ( DialogInterface dialogInterface , int i ) { String packageName ; if ( targetApplications . contains ( BS_PACKAGE ) ) { packageName = BS_PACKAGE ; } else { packageName = targetApplications . get ( 0 ) ; } Uri uri = Uri . parse ( "market: + packageName ) ; Intent intent = new Intent ( Intent . ACTION_VIEW , uri ) ; try { if ( fragment == null ) { activity . startActivity ( intent ) ; } else { fragment . startActivity ( intent ) ; } } catch ( ActivityNotFoundException anfe ) { Log . w ( TAG , "Google Play is not installed; cannot install " + packageName ) ; } }
public final AlertDialog shareText ( CharSequence text ) { return shareText ( text , "TEXT_TYPE" ) ; }
public final AlertDialog shareText ( CharSequence text , CharSequence type ) { Intent intent = new Intent ( ) ; intent . addCategory ( Intent . CATEGORY_DEFAULT ) ; intent . setAction ( BS_PACKAGE + ".ENCODE" ) ; intent . putExtra ( "ENCODE_TYPE" , type ) ; intent . putExtra ( "ENCODE_DATA" , text ) ; String targetAppPackage = findTargetAppPackage ( intent ) ; if ( targetAppPackage == null ) { return showDownloadDialog ( ) ; } intent . setPackage ( targetAppPackage ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_TOP ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET ) ; attachMoreExtras ( intent ) ; if ( fragment == null ) { activity . startActivity ( intent ) ; } else { fragment . startActivity ( intent ) ; } return null ; }
private static List < String > list ( String ... values ) { return Collections . unmodifiableList ( Arrays . asList ( values ) ) ; }
private void attachMoreExtras ( Intent intent ) { for ( Map . Entry < String , Object > entry : moreExtras . entrySet ( ) ) { String key = entry . getKey ( ) ; Object value = entry . getValue ( ) ; if ( value instanceof Integer ) { intent . putExtra ( key , ( Integer ) value ) ; } else if ( value instanceof Long ) { intent . putExtra ( key , ( Long ) value ) ; } else if ( value instanceof Boolean ) { intent . putExtra ( key , ( Boolean ) value ) ; } else if ( value instanceof Double ) { intent . putExtra ( key , ( Double ) value ) ; } else if ( value instanceof Float ) { intent . putExtra ( key , ( Float ) value ) ; } else if ( value instanceof Bundle ) { intent . putExtra ( key , ( Bundle ) value ) ; } else { intent . putExtra ( key , value . toString ( ) ) ; } } }
private DirectionTextData ( @ Nonnull GuiDragDirection direction , @ Nonnull String text ) { this . direction = direction ; this . text = text ; }
protected void init ( @ Nonnull Paint basePaint , int color , int alpha ) { paint . set ( basePaint ) ; paint . setColor ( color ) ; paint . setAlpha ( alpha ) ; paint . setTextSize ( basePaint . getTextSize ( ) * scale ) ; }
@ Nonnull public GuiDragDirection getDirection ( ) { return direction ; }
@ Nonnull public String getText ( ) { return text ; }
@ Nonnull public Point2d getPosition ( ) { return position ; }
@ Nonnull public TextPaint getPaint ( ) { return paint ; }
@ Nonnull public Float getScale ( ) { return scale ; }
public boolean isShow ( ) { return show ; }
@ Override public int getAttributeId ( ) { return R . styleable . DirectionDragButton_textUp ; }
@ Nonnull @ Override public Point2d getTextPosition ( @ Nonnull Paint paint , @ Nonnull Paint basePaint , @ Nonnull CharSequence text , CharSequence baseText , int w , int h ) { return getUpDownTextPosition ( paint , basePaint , text , baseText , 1 , w , h ) ; }
@ Override public int getAttributeId ( ) { return R . styleable . DirectionDragButton_textDown ; }
@ Nonnull @ Override public Point2d getTextPosition ( @ Nonnull Paint paint , @ Nonnull Paint basePaint , @ Nonnull CharSequence text , CharSequence baseText , int w , int h ) { return getUpDownTextPosition ( paint , basePaint , text , baseText , - 1 , w , h ) ; }
@ Override public int getAttributeId ( ) { return R . styleable . DirectionDragButton_textLeft ; }
@ Nonnull @ Override public Point2d getTextPosition ( @ Nonnull Paint paint , @ Nonnull Paint basePaint , @ Nonnull CharSequence text , CharSequence baseText , int w , int h ) { return getLeftRightTextPosition ( paint , basePaint , text , baseText , w , h , true ) ; }
@ Override public int getAttributeId ( ) { return R . styleable . DirectionDragButton_textRight ; }
@ Nonnull @ Override public Point2d getTextPosition ( @ Nonnull Paint paint , @ Nonnull Paint basePaint , @ Nonnull CharSequence text , CharSequence baseText , int w , int h ) { return getLeftRightTextPosition ( paint , basePaint , text , baseText , w , h , false ) ; }
GuiDragDirection ( @ Nonnull DragDirection dragDirection , int attributePosition ) { this . dragDirection = dragDirection ; this . attributePosition = attributePosition ; }
public abstract int getAttributeId ( )
public int getAttributePosition ( ) { return attributePosition ; }
@ Nonnull public abstract Point2d getTextPosition ( @ Nonnull Paint paint , @ Nonnull Paint basePaint , @ Nonnull CharSequence text , CharSequence baseText , int w , int h );
@ Nonnull private static Point2d getLeftRightTextPosition ( @ Nonnull Paint paint , @ Nonnull Paint basePaint , CharSequence text , @ Nonnull CharSequence baseText , int w , int h , boolean left ) { final Point2d result = new Point2d ( ) ; if ( left ) { float width = paint . measureText ( " " ) ; result . setX ( width ) ; } else { float width = paint . measureText ( text . toString ( ) + " " ) ; result . setX ( w - width ) ; } float selfHeight = paint . ascent ( ) + paint . descent ( ) ; basePaint . measureText ( Strings . getNotEmpty ( baseText , "|" ) ) ; result . setY ( h / 2 - selfHeight / 2 ) ; return result ; }
@ Nonnull private static Point2d getUpDownTextPosition ( @ Nonnull Paint paint , @ Nonnull Paint basePaint , @ Nonnull CharSequence text , CharSequence baseText , float direction , int w , int h ) { final Point2d result = new Point2d ( ) ; float width = paint . measureText ( text . toString ( ) + " " ) ; result . setX ( w - width ) ; float selfHeight = paint . ascent ( ) + paint . descent ( ) ; basePaint . measureText ( Strings . getNotEmpty ( baseText , "|" ) ) ; if ( direction < 0 ) { result . setY ( h / 2 + h / 3 - selfHeight / 2 ) ; } else { result . setY ( h / 2 - h / 3 - selfHeight / 2 ) ; } return result ; }
@ Nullable public static GuiDragDirection valueOf ( @ Nonnull DragDirection dragDirection ) { for ( GuiDragDirection guiDragDirection : values ( ) ) { if ( guiDragDirection . dragDirection == dragDirection ) { return guiDragDirection ; } } return null ; }
public DirectionDragButton ( Context context , @ Nonnull AttributeSet attrs ) { super( context , attrs ); init ( context , attrs ) ; }
public DirectionDragButton ( Context context , @ Nonnull DirectionDragButtonDef directionDragButtonDef ) { super( context , directionDragButtonDef ); init ( context , directionDragButtonDef ) ; }
private void init ( @ Nonnull Context context , @ Nonnull DirectionDragButtonDef directionDragButtonDef ) { for ( GuiDragDirection direction : GuiDragDirection . values ( ) ) { final CharSequence directionText = directionDragButtonDef . getText ( direction . dragDirection ) ; this . textDataMap . put ( direction , new DirectionTextData ( direction , Strings . getNotEmpty ( directionText , "" ) ) ) ; } this . initialized = true ; }
public void applyDef ( @ Nonnull DirectionDragButtonDef directionDragButtonDef ) { super. applyDef ( directionDragButtonDef ) ; for ( GuiDragDirection guiDragDirection : GuiDragDirection . values ( ) ) { final CharSequence directionText = directionDragButtonDef . getText ( guiDragDirection . dragDirection ) ; this . textDataMap . put ( guiDragDirection , new DirectionTextData ( guiDragDirection , Strings . getNotEmpty ( directionText , "" ) ) ) ; } }
private void init ( @ Nonnull Context context , @ Nonnull AttributeSet attrs ) { TypedArray a = context . obtainStyledAttributes ( attrs , R . styleable . DirectionDragButton ) ; for ( int i = 0 ; i < a . getIndexCount ( ) ; i ++ ) { int attr = a . getIndex ( i ) ; if ( a . hasValue ( attr ) ) { if ( attr == R . styleable . DirectionDragButton_directionTextColor ) { this . directionTextColor = a . getColor ( attr , DEFAULT_DIRECTION_TEXT_COLOR ) ; } else if ( attr == R . styleable . DirectionDragButton_directionTextScale ) { this . directionTextScale = a . getString ( attr ) ; } else if ( attr == R . styleable . DirectionDragButton_directionTextAlpha ) { this . directionTextAlpha = a . getInt ( attr , DEFAULT_DIRECTION_TEXT_ALPHA ) ; } else { for ( GuiDragDirection guiDragDirection : GuiDragDirection . values ( ) ) { if ( guiDragDirection . getAttributeId ( ) == attr ) { this . textDataMap . put ( guiDragDirection , new DirectionTextData ( guiDragDirection , a . getString ( attr ) ) ) ; break; } } } } } a . recycle ( ) ; for ( Map . Entry < GuiDragDirection , Float > entry : getDirectionTextScales ( ) . entrySet ( ) ) { final DirectionTextData td = textDataMap . get ( entry . getKey ( ) ) ; if ( td != null ) { td . scale = entry . getValue ( ) ; } } initialized = true ; }
@ Override public void onSizeChanged ( int w , int h , int oldW , int oldH ) { measureText ( ) ; }
@ Override protected void onTextChanged ( CharSequence text , int start , int before , int after ) { measureText ( ) ; }
protected void measureText ( ) { if ( initialized ) { final Paint basePaint = getPaint ( ) ; for ( DirectionTextData textData : textDataMap . values ( ) ) { initDirectionTextPaint ( basePaint , textData ) ; textData . position = textData . direction . getTextPosition ( textData . paint , basePaint , textData . text , getText ( ) , getWidth ( ) , getHeight ( ) ) ; } } }
protected void initDirectionTextPaint ( @ Nonnull Paint basePaint , @ Nonnull DirectionTextData textData ) { textData . init ( basePaint , directionTextColor , directionTextAlpha ) ; }
@ Override public void onDraw ( Canvas canvas ) { super. onDraw ( canvas ) ; final TextPaint paint = getPaint ( ) ; for ( DirectionTextData td : textDataMap . values ( ) ) { if ( td . show ) { initDirectionTextPaint ( paint , td ) ; final String text = td . text ; final Point2d position = td . position ; canvas . drawText ( text , 0 , text . length ( ) , position . getX ( ) , position . getY ( ) , td . paint ) ; } } }
@ SuppressWarnings ( "UnusedDeclaration" ) @ Nullable public String getTextUp ( ) { return getText ( GuiDragDirection . up ) ; }
@ SuppressWarnings ( "UnusedDeclaration" ) @ Nullable public String getTextDown ( ) { return getText ( GuiDragDirection . down ) ; }
@ Nullable public String getText ( @ Nonnull DragDirection direction ) { final GuiDragDirection guiDragDirection = GuiDragDirection . valueOf ( direction ) ; return guiDragDirection == null ? null : getText ( guiDragDirection ) ; }
@ SuppressWarnings ( "UnusedDeclaration" ) public void showDirectionText ( boolean show , @ Nonnull DragDirection direction ) { final GuiDragDirection guiDragDirection = GuiDragDirection . valueOf ( direction ) ; final DirectionTextData td = this . textDataMap . get ( guiDragDirection ) ; if ( td != null ) { td . show = show ; } }
@ Nullable private String getText ( @ Nonnull GuiDragDirection direction ) { DirectionTextData td = this . textDataMap . get ( direction ) ; if ( td == null ) { return null ; } else { if ( td . show ) { return td . text ; } else { return null ; } } }
@ Nonnull public String getDirectionTextScale ( ) { return directionTextScale ; }
@ Nonnull private Map < GuiDragDirection , Float > getDirectionTextScales ( ) { final List < Float > scales = StringCollections . split ( getDirectionTextScale ( ) , ";" , NumberParser . of ( Float .class ) ) ; final Map < GuiDragDirection , Float > result = new HashMap < GuiDragDirection , Float > ( ) ; for ( GuiDragDirection direction : GuiDragDirection . values ( ) ) { result . put ( direction , DEFAULT_DIRECTION_TEXT_SCALE_FLOAT ) ; } if ( scales . size ( ) == 1 ) { final Float scale = scales . get ( 0 ) ; for ( Map . Entry < GuiDragDirection , Float > entry : result . entrySet ( ) ) { entry . setValue ( scale ) ; } } else { for ( int i = 0 ; i < scales . size ( ) ; i ++ ) { for ( GuiDragDirection direction : GuiDragDirection . values ( ) ) { if ( direction . getAttributePosition ( ) == i ) { result . put ( direction , scales . get ( i ) ) ; } } } } return result ; }
public static void setupActionBar ( ActionBarActivity activity ) { ActionBar bar = activity . getSupportActionBar ( ) ; bar . setIcon ( android . R . color . transparent ) ; bar . setDisplayShowTitleEnabled ( true ) ; if ( ! ( activity instanceof HomeActivity ) ) { bar . setDisplayHomeAsUpEnabled ( true ) ; } }
public static void showProgress ( Fragment fragment , boolean visible ) { ActionBarActivity act = ( ActionBarActivity ) fragment . getActivity ( ) ; if ( act != null ) { act . setSupportProgressBarIndeterminateVisibility ( visible ) ; } }
public static void setChildClickable ( Activity parent , int id , ClickableSpan span ) { TextView v = ( TextView ) parent . findViewById ( id ) ; setClickable ( v , span ) ; }
public static void setChildClickable ( View parent , int id , ClickableSpan span ) { TextView v = ( TextView ) parent . findViewById ( id ) ; setClickable ( v , span ) ; }
public static void setClickable ( TextView v , ClickableSpan span ) { Spannable text = ( Spannable ) v . getText ( ) ; text . setSpan ( span , 0 , text . length ( ) , 0 ) ; v . setMovementMethod ( LinkMovementMethod . getInstance ( ) ) ; }
public static final int getStopDirectionText ( String direction ) { if ( direction . equals ( "N" ) ) { return R . string . direction_n ; } else if ( direction . equals ( "NW" ) ) { return R . string . direction_nw ; } else if ( direction . equals ( "W" ) ) { return R . string . direction_w ; } else if ( direction . equals ( "SW" ) ) { return R . string . direction_sw ; } else if ( direction . equals ( "S" ) ) { return R . string . direction_s ; } else if ( direction . equals ( "SE" ) ) { return R . string . direction_se ; } else if ( direction . equals ( "E" ) ) { return R . string . direction_e ; } else if ( direction . equals ( "NE" ) ) { return R . string . direction_ne ; } else { return R . string . direction_none ; } }
public static final String getRouteDisplayName ( ObaRoute route ) { String result = route . getShortName ( ) ; if ( ! TextUtils . isEmpty ( result ) ) { return result ; } result = route . getLongName ( ) ; if ( ! TextUtils . isEmpty ( result ) ) { return result ; } return "" ; }
public static final String getRouteDescription ( ObaRoute route ) { String shortName = route . getShortName ( ) ; String longName = route . getLongName ( ) ; if ( TextUtils . isEmpty ( shortName ) ) { shortName = longName ; } if ( TextUtils . isEmpty ( longName ) || shortName . equals ( longName ) ) { longName = route . getDescription ( ) ; } return MyTextUtils . toTitleCase ( longName ) ; }
public static final void setStopDirection ( View v , String direction , boolean show ) { final TextView text = ( TextView ) v ; final int directionText = UIHelp . getStopDirectionText ( direction ) ; if ( ( directionText != R . string . direction_none ) || show ) { text . setText ( directionText ) ; text . setVisibility ( View . VISIBLE ) ; } else { text . setVisibility ( View . GONE ) ; } }
public static final void setRouteView ( View view , ObaRoute route ) { TextView shortNameText = ( TextView ) view . findViewById ( R . id . short_name ) ; TextView longNameText = ( TextView ) view . findViewById ( R . id . long_name ) ; String shortName = route . getShortName ( ) ; String longName = MyTextUtils . toTitleCase ( route . getLongName ( ) ) ; if ( TextUtils . isEmpty ( shortName ) ) { shortName = longName ; } if ( TextUtils . isEmpty ( longName ) || shortName . equals ( longName ) ) { longName = MyTextUtils . toTitleCase ( route . getDescription ( ) ) ; } shortNameText . setText ( shortName ) ; longNameText . setText ( longName ) ; }
public StopUserInfoMap ( Context context ) { ContentResolver cr = context . getContentResolver ( ) ; Cursor c = cr . query ( ObaContract . Stops . CONTENT_URI , STOP_USER_PROJECTION , "(" + ObaContract . Stops . USER_NAME + " IS NOT NULL)" + "OR (" + ObaContract . Stops . FAVORITE + "=1)" , null , null ) ; mMap = new ContentQueryMap ( c , ObaContract . Stops . _ID , true , null ) ; }
public void close ( ) { mMap . close ( ) ; }
public void requery ( ) { mMap . requery ( ) ; }
public void setView ( View stopRoot , String stopId , String stopName ) { TextView nameView = ( TextView ) stopRoot . findViewById ( R . id . stop_name ) ; setView2 ( nameView , stopId , stopName , true ) ; }
public void setView2 ( TextView nameView , String stopId , String stopName , boolean showIcon ) { ContentValues values = mMap . getValues ( stopId ) ; int icon = 0 ; if ( values != null ) { Integer i = values . getAsInteger ( ObaContract . Stops . FAVORITE ) ; final boolean favorite = ( i != null ) && ( i == 1 ) ; final String userName = values . getAsString ( ObaContract . Stops . USER_NAME ) ; nameView . setText ( TextUtils . isEmpty ( userName ) ? MyTextUtils . toTitleCase ( stopName ) : userName ) ; icon = favorite && showIcon ? R . drawable . ic_toggle_star : 0 ; } else { nameView . setText ( MyTextUtils . toTitleCase ( stopName ) ) ; } nameView . setCompoundDrawablesWithIntrinsicBounds ( icon , 0 , 0 , 0 ) ; }
public static String serializeRouteDisplayNames ( ObaStop stop , HashMap < String , ObaRoute > routes ) { StringBuffer sb = new StringBuffer ( ) ; String [] routeIds = stop . getRouteIds ( ) ; for ( int i = 0 ; i < routeIds . length ; i ++ ) { if ( routes != null ) { ObaRoute route = routes . get ( routeIds [ i ] ) ; sb . append ( getRouteDisplayName ( route ) ) ; } else { sb . append ( routeIds [ i ] ) ; } if ( i != routeIds . length - 1 ) { sb . append ( "," ) ; } } return sb . toString ( ) ; }
public static List < String > deserializeRouteDisplayNames ( String serializedRouteDisplayNames ) { String routes [] = serializedRouteDisplayNames . split ( "," ) ; return Arrays . asList ( routes ) ; }
public static String formatRouteDisplayNames ( List < String > routeDisplayNames , List < String > nextArrivalRouteShortNames ) { Collections . sort ( routeDisplayNames , new AlphanumComparator ( ) ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < routeDisplayNames . size ( ) ; i ++ ) { boolean match = false ; for ( String nextArrivalRouteShortName : nextArrivalRouteShortNames ) { if ( routeDisplayNames . get ( i ) . equalsIgnoreCase ( nextArrivalRouteShortName ) ) { match = true ; break; } } if ( match ) { sb . append ( routeDisplayNames . get ( i ) + "*" ) ; } else { sb . append ( routeDisplayNames . get ( i ) ) ; } if ( i != routeDisplayNames . size ( ) - 1 ) { sb . append ( ", " ) ; } } return sb . toString ( ) ; }
public static final Intent makeShortcut ( Context context , String name , Intent destIntent ) { Intent intent = new Intent ( ) ; intent . putExtra ( Intent . EXTRA_SHORTCUT_INTENT , destIntent ) ; intent . putExtra ( Intent . EXTRA_SHORTCUT_NAME , name ) ; Parcelable iconResource = Intent . ShortcutIconResource . fromContext ( context , R . mipmap . ic_launcher ) ; intent . putExtra ( Intent . EXTRA_SHORTCUT_ICON_RESOURCE , iconResource ) ; return intent ; }
public static void goToUrl ( Context context , String url ) { Intent intent = new Intent ( Intent . ACTION_VIEW , Uri . parse ( url ) ) ; try { context . startActivity ( intent ) ; } catch ( ActivityNotFoundException e ) { Toast . makeText ( context , context . getString ( R . string . browser_error ) , Toast . LENGTH_SHORT ) . show ( ) ; } }
public static final String getRouteErrorString ( Context context , int code ) { if ( ! isConnected ( context ) ) { if ( isAirplaneMode ( context ) ) { return context . getString ( R . string . airplane_mode_error ) ; } else { return context . getString ( R . string . no_network_error ) ; } } switch ( code ) { case ObaApi . OBA_INTERNAL_ERROR : return context . getString ( R . string . internal_error ) ; case ObaApi . OBA_NOT_FOUND : ObaRegion r = Application . get ( ) . getCurrentRegion ( ) ; if ( r != null ) { return context . getString ( R . string . route_not_found_error_with_region_name , r . getName ( ) ) ; } else { return context . getString ( R . string . route_not_found_error_no_region ) ; } case ObaApi . OBA_BAD_GATEWAY : return context . getString ( R . string . bad_gateway_error ) ; case ObaApi . OBA_OUT_OF_MEMORY : return context . getString ( R . string . out_of_memory_error ) ; default: return context . getString ( R . string . generic_comm_error ) ; } }
public static final String getStopErrorString ( Context context , int code ) { if ( ! isConnected ( context ) ) { if ( isAirplaneMode ( context ) ) { return context . getString ( R . string . airplane_mode_error ) ; } else { return context . getString ( R . string . no_network_error ) ; } } switch ( code ) { case ObaApi . OBA_INTERNAL_ERROR : return context . getString ( R . string . internal_error ) ; case ObaApi . OBA_NOT_FOUND : ObaRegion r = Application . get ( ) . getCurrentRegion ( ) ; if ( r != null ) { return context . getString ( R . string . stop_not_found_error_with_region_name , r . getName ( ) ) ; } else { return context . getString ( R . string . stop_not_found_error_no_region ) ; } case ObaApi . OBA_BAD_GATEWAY : return context . getString ( R . string . bad_gateway_error ) ; case ObaApi . OBA_OUT_OF_MEMORY : return context . getString ( R . string . out_of_memory_error ) ; default: return context . getString ( R . string . generic_comm_error ) ; } }
public static final int getMapErrorString ( Context context , int code ) { if ( ! isConnected ( context ) ) { if ( isAirplaneMode ( context ) ) { return R . string . airplane_mode_error ; } else { return R . string . no_network_error ; } } switch ( code ) { case ObaApi . OBA_INTERNAL_ERROR : return R . string . internal_error ; case ObaApi . OBA_BAD_GATEWAY : return R . string . bad_gateway_error ; case ObaApi . OBA_OUT_OF_MEMORY : return R . string . out_of_memory_error ; default: return R . string . map_generic_error ; } }
public static boolean isAirplaneMode ( Context context ) { ContentResolver cr = context . getContentResolver ( ) ; return Settings . System . getInt ( cr , Settings . System . AIRPLANE_MODE_ON , 0 ) != 0 ; }
public static boolean isConnected ( Context context ) { ConnectivityManager cm = ( ConnectivityManager ) context . getSystemService ( Context . CONNECTIVITY_SERVICE ) ; NetworkInfo activeNetwork = cm . getActiveNetworkInfo ( ) ; return ( activeNetwork != null ) && activeNetwork . isConnectedOrConnecting ( ) ; }
public static String stringForQuery ( Context context , Uri uri , String column ) { ContentResolver cr = context . getContentResolver ( ) ; Cursor c = cr . query ( uri , new String [] { column } , null , null , null ) ; if ( c != null ) { try { if ( c . moveToFirst ( ) ) { return c . getString ( 0 ) ; } } finally { c . close ( ) ; } } return "" ; }
public static Integer intForQuery ( Context context , Uri uri , String column ) { ContentResolver cr = context . getContentResolver ( ) ; Cursor c = cr . query ( uri , new String [] { column } , null , null , null ) ; if ( c != null ) { try { if ( c . moveToFirst ( ) ) { return c . getInt ( 0 ) ; } } finally { c . close ( ) ; } } return null ; }
public static String getNoArrivalsMessage ( Context context , int minutes , boolean additionalArrivals , boolean shortFormat ) { if ( minutes <= MINUTES_IN_HOUR ) { if ( additionalArrivals ) { if ( shortFormat ) { return context . getString ( R . string . stop_info_no_additional_data_minutes_short_format , minutes ) ; } else { return context . getString ( R . string . stop_info_no_additional_data_minutes , minutes ) ; } } else { if ( shortFormat ) { return context . getString ( R . string . stop_info_nodata_minutes_short_format , minutes ) ; } else { return context . getString ( R . string . stop_info_nodata_minutes , minutes ) ; } } } else { if ( additionalArrivals ) { if ( shortFormat ) { return context . getResources ( ) . getQuantityString ( R . plurals . stop_info_no_additional_data_hours_minutes_short_format , minutes / 60 , minutes % 60 , minutes / 60 ) ; } else { return context . getResources ( ) . getQuantityString ( R . plurals . stop_info_no_additional_data_hours_minutes , minutes / 60 , minutes % 60 , minutes / 60 ) ; } } else { if ( shortFormat ) { return context . getResources ( ) . getQuantityString ( R . plurals . stop_info_nodata_hours_minutes_short_format , minutes / 60 , minutes % 60 , minutes / 60 ) ; } else { return context . getResources ( ) . getQuantityString ( R . plurals . stop_info_nodata_hours_minutes , minutes / 60 , minutes % 60 , minutes / 60 ) ; } } } }
public static boolean canDisplayDialog ( Activity activity ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . JELLY_BEAN_MR1 ) { return ! activity . isFinishing ( ) && ! activity . isDestroyed ( ) ; } else { return ! activity . isFinishing ( ) ; } }
public static boolean canAnimateViewModern ( ) { return Build . VERSION . SDK_INT >= Build . VERSION_CODES . HONEYCOMB_MR1 ; }
public static boolean canCancelAnimation ( ) { return Build . VERSION . SDK_INT >= Build . VERSION_CODES . ICE_CREAM_SANDWICH ; }
@ TargetApi ( 14 ) public static void showViewWithAnimation ( final View v , int animationDuration ) { if ( ! canAnimateViewModern ( ) ) { showViewWithoutAnimation ( v ) ; return; } if ( v . getVisibility ( ) == View . VISIBLE && v . getAlpha ( ) == 1 ) { return; } v . clearAnimation ( ) ; if ( canCancelAnimation ( ) ) { v . animate ( ) . cancel ( ) ; } if ( v . getVisibility ( ) != View . VISIBLE ) { v . setAlpha ( 0f ) ; v . setVisibility ( View . VISIBLE ) ; } v . animate ( ) . alpha ( 1f ) . setDuration ( animationDuration ) . setListener ( null ) ; }
public static void showViewWithoutAnimation ( final View v ) { if ( v . getVisibility ( ) == View . VISIBLE ) { return; } v . setVisibility ( View . VISIBLE ) ; }
@ TargetApi ( 14 ) public static void hideViewWithAnimation ( final View v , int animationDuration ) { if ( ! canAnimateViewModern ( ) ) { hideViewWithoutAnimation ( v ) ; return; } if ( v . getVisibility ( ) == View . GONE ) { return; } v . clearAnimation ( ) ; if ( canCancelAnimation ( ) ) { v . animate ( ) . cancel ( ) ; } v . animate ( ) . alpha ( 0f ) . setDuration ( animationDuration ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationEnd ( Animator animation ) { v . setVisibility ( View . GONE ) ; } } ) ; }
@ Override public void onAnimationEnd ( Animator animation ) { v . setVisibility ( View . GONE ) ; }
public static void hideViewWithoutAnimation ( final View v ) { if ( v . getVisibility ( ) == View . GONE ) { return; } v . setVisibility ( View . GONE ) ; }
@ TargetApi ( 12 ) public static void logViewVisibility ( View v ) { if ( v != null ) { if ( v . getVisibility ( ) == View . VISIBLE ) { Log . d ( TAG , v . getContext ( ) . getResources ( ) . getResourceEntryName ( v . getId ( ) ) + " is visible" ) ; if ( UIHelp . canAnimateViewModern ( ) ) { Log . d ( TAG , v . getContext ( ) . getResources ( ) . getResourceEntryName ( v . getId ( ) ) + " alpha - " + v . getAlpha ( ) ) ; } } else if ( v . getVisibility ( ) == View . INVISIBLE ) { Log . d ( TAG , v . getContext ( ) . getResources ( ) . getResourceEntryName ( v . getId ( ) ) + " is INVISIBLE" ) ; } else if ( v . getVisibility ( ) == View . GONE ) { Log . d ( TAG , v . getContext ( ) . getResources ( ) . getResourceEntryName ( v . getId ( ) ) + " is GONE" ) ; } else { Log . d ( TAG , v . getContext ( ) . getResources ( ) . getResourceEntryName ( v . getId ( ) ) + ".getVisibility() - " + v . getVisibility ( ) ) ; } } }
public static int dpToPixels ( Context context , float dp ) { final float scale = context . getResources ( ) . getDisplayMetrics ( ) . density ; return ( int ) ( dp * scale + 0.5f ) ; }
public static void setMargins ( View v , int l , int t , int r , int b ) { ViewGroup . MarginLayoutParams p = ( ViewGroup . MarginLayoutParams ) v . getLayoutParams ( ) ; p . setMargins ( l , t , r , b ) ; v . setLayoutParams ( p ) ; }
public static void setAccessibilityIgnore ( View view ) { view . setClickable ( false ) ; view . setFocusable ( false ) ; view . setContentDescription ( "" ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . JELLY_BEAN ) { view . setImportantForAccessibility ( View . IMPORTANT_FOR_ACCESSIBILITY_NO ) ; } }
public AndroidTestRunListener ( IDevice device , Log log , Boolean createReport , Boolean takeScreenshotOnFailure , String screenshotsPathOnDevice , String reportSuffix , File targetDirectory ) { this . device = device ; this . deviceLogLinePrefix = DeviceHelper . getDeviceLogLinePrefix ( device ) ; this . log = log ; this . createReport = createReport ; this . takeScreenshotOnFailure = takeScreenshotOnFailure ; this . screenshotsPathOnDevice = screenshotsPathOnDevice ; this . reportSuffix = reportSuffix ; this . targetDirectory = targetDirectory ; }
public Log getLog ( ) { return this . log ; }
@ Override public void testRunStarted ( String runName , int tCount ) { if ( takeScreenshotOnFailure ) { executeOnAdbShell ( "rm -f " + screenshotsPathOnDevice + " ) ; executeOnAdbShell ( "mkdir " + screenshotsPathOnDevice ) ; } this . testCount = tCount ; getLog ( ) . info ( deviceLogLinePrefix + INDENT + "Run started: " + runName + ", " + testCount + " tests:" ) ; if ( createReport ) { report = new Testsuite ( ) ; report . setName ( runName ) ; final Testsuite . Properties props = new Testsuite . Properties ( ) ; report . getProperties ( ) . add ( props ) ; for ( Map . Entry < Object , Object > systemProperty : System . getProperties ( ) . entrySet ( ) ) { final Testsuite . Properties . Property property = new Testsuite . Properties . Property ( ) ; property . setName ( systemProperty . getKey ( ) . toString ( ) ) ; property . setValue ( systemProperty . getValue ( ) . toString ( ) ) ; props . getProperty ( ) . add ( property ) ; } Map < String , String > deviceProperties = device . getProperties ( ) ; for ( Map . Entry < String , String > deviceProperty : deviceProperties . entrySet ( ) ) { final Testsuite . Properties . Property property = new Testsuite . Properties . Property ( ) ; property . setName ( deviceProperty . getKey ( ) ) ; property . setValue ( deviceProperty . getValue ( ) ) ; props . getProperty ( ) . add ( property ) ; } } }
@ Override public void testIgnored ( TestIdentifier testIdentifier ) { ++ testIgnoredCount ; getLog ( ) . info ( deviceLogLinePrefix + INDENT + INDENT + testIdentifier . toString ( ) ) ; }
@ Override public void testStarted ( TestIdentifier testIdentifier ) { testRunCount ++ ; getLog ( ) . info ( deviceLogLinePrefix + String . format ( "%1$s%1$sStart [%2$d/%3$d]: %4$s" , INDENT , testRunCount , testCount , testIdentifier . toString ( ) ) ) ; if ( createReport ) { currentTestCaseStartTime = System . currentTimeMillis ( ) ; currentTestCase = new Testsuite . Testcase ( ) ; currentTestCase . setClassname ( testIdentifier . getClassName ( ) ) ; currentTestCase . setName ( testIdentifier . getTestName ( ) ) ; } }
@ Override public void testFailed ( TestIdentifier testIdentifier , String trace ) { if ( takeScreenshotOnFailure ) { String suffix = "_error" ; String filepath = testIdentifier . getTestName ( ) + suffix + SCREENSHOT_SUFFIX ; executeOnAdbShell ( "screencap -p " + screenshotsPathOnDevice + "/" + filepath ) ; getLog ( ) . info ( deviceLogLinePrefix + INDENT + INDENT + filepath + " saved." ) ; } ++ testErrorCount ; getLog ( ) . info ( deviceLogLinePrefix + INDENT + INDENT + testIdentifier . toString ( ) ) ; getLog ( ) . info ( deviceLogLinePrefix + INDENT + INDENT + trace ) ; if ( createReport ) { final Testsuite . Testcase . Error error = new Testsuite . Testcase . Error ( ) ; error . setValue ( trace ) ; error . setMessage ( parseForMessage ( trace ) ) ; error . setType ( parseForException ( trace ) ) ; currentTestCase . setError ( objectFactory . createTestsuiteTestcaseError ( error ) ) ; } }
@ Override public void testAssumptionFailure ( TestIdentifier testIdentifier , String trace ) { if ( takeScreenshotOnFailure ) { String suffix = "_failure" ; String filepath = testIdentifier . getTestName ( ) + suffix + SCREENSHOT_SUFFIX ; executeOnAdbShell ( "screencap -p " + screenshotsPathOnDevice + "/" + filepath ) ; getLog ( ) . info ( deviceLogLinePrefix + INDENT + INDENT + filepath + " saved." ) ; } ++ testFailureCount ; getLog ( ) . info ( deviceLogLinePrefix + INDENT + INDENT + testIdentifier . toString ( ) ) ; getLog ( ) . info ( deviceLogLinePrefix + INDENT + INDENT + trace ) ; if ( createReport ) { final Testsuite . Testcase . Failure failure = new Testsuite . Testcase . Failure ( ) ; failure . setValue ( trace ) ; failure . setMessage ( parseForMessage ( trace ) ) ; failure . setType ( parseForException ( trace ) ) ; currentTestCase . getFailure ( ) . add ( failure ) ; } }
private void executeOnAdbShell ( String command ) { try { device . executeShellCommand ( command , new IShellOutputReceiver ( ) { @ Override public boolean isCancelled ( ) { return false ; } @ Override public void flush ( ) {                } @ Override public void addOutput ( byte [] data , int offset , int length ) {                } } ) ; } catch ( TimeoutException | AdbCommandRejectedException | IOException | ShellCommandUnresponsiveException e ) { getLog ( ) . error ( e ) ; } }
@ Override public boolean isCancelled ( ) { return false ; }
@ Override public void flush ( ) {                }
@ Override public void addOutput ( byte [] data , int offset , int length ) {                }
@ Override public void testEnded ( TestIdentifier testIdentifier , Map < String , String > testMetrics ) { getLog ( ) . info ( deviceLogLinePrefix + String . format ( "%1$s%1$sEnd [%2$d/%3$d]: %4$s" , INDENT , testRunCount , testCount , testIdentifier . toString ( ) ) ) ; logMetrics ( testMetrics ) ; if ( createReport ) { double seconds = ( System . currentTimeMillis ( ) - currentTestCaseStartTime ) / 1000.0 ; currentTestCase . setTime ( timeFormatter . format ( seconds ) ) ; report . getTestcase ( ) . add ( currentTestCase ) ; } }
@ Override public void testRunEnded ( long elapsedTime , Map < String , String > runMetrics ) { getLog ( ) . info ( deviceLogLinePrefix + INDENT + "Run ended: " + elapsedTime + " ms" ) ; if ( hasFailuresOrErrors ( ) ) { getLog ( ) . error ( deviceLogLinePrefix + INDENT + "FAILURES!!!" ) ; } getLog ( ) . info ( INDENT + "Tests run: " + testRunCount + ( testRunCount < testCount ? " (of " + testCount + ")" : "" ) + ",  Failures: " + testFailureCount + ",  Errors: " + testErrorCount + ",  Ignored: " + testIgnoredCount ) ; if ( createReport ) { report . setTests ( Integer . toString ( testCount ) ) ; report . setFailures ( Integer . toString ( testFailureCount ) ) ; report . setErrors ( Integer . toString ( testErrorCount ) ) ; report . setSkipped ( Integer . toString ( testIgnoredCount ) ) ; report . setTime ( timeFormatter . format ( elapsedTime / 1000.0 ) ) ; } logMetrics ( runMetrics ) ; if ( createReport ) { writeJunitReportToFile ( ) ; } }
@ Override public void testRunFailed ( String errorMessage ) { testRunFailureCause = errorMessage ; getLog ( ) . info ( deviceLogLinePrefix + INDENT + "Run failed: " + errorMessage ) ; }
@ Override public void testRunStopped ( long elapsedTime ) { getLog ( ) . info ( deviceLogLinePrefix + INDENT + "Run stopped:" + elapsedTime ) ; }
private String parseForMessage ( String trace ) { if ( StringUtils . isNotBlank ( trace ) ) { String newline = "\r\n" ; int messageEnd = trace . indexOf ( newline ) ; boolean hasMessage = ! trace . startsWith ( "junit." ) && messageEnd > 0 ; if ( hasMessage ) { int messageStart = trace . indexOf ( ":" ) + 2 ; if ( messageStart > messageEnd ) { messageEnd = trace . indexOf ( newline + "at" ) ; if ( messageStart > messageEnd ) { messageStart = 0 ; } } return trace . substring ( messageStart , messageEnd ) ; } else { return StringUtils . EMPTY ; } } else { return StringUtils . EMPTY ; } }
private String parseForException ( String trace ) { if ( StringUtils . isNotBlank ( trace ) ) { return trace . substring ( 0 , trace . indexOf ( ":" ) ) ; } else { return StringUtils . EMPTY ; } }
private void writeJunitReportToFile ( ) { try { final String directory = String . valueOf ( targetDirectory ) + "/surefire-reports" ; FileUtils . forceMkdir ( new File ( directory ) ) ; final StringBuilder b = new StringBuilder ( directory ) . append ( "/TEST-" ) . append ( DeviceHelper . getDescriptiveName ( device ) ) ; if ( StringUtils . isNotBlank ( reportSuffix ) ) { b . append ( reportSuffix . replace ( "/" , "" ) . replace ( "\\" , "" ) ) ; } final File reportFile = new File ( b . append ( ".xml" ) . toString ( ) ) ; final JAXBContext jaxbContext = JAXBContext . newInstance ( ObjectFactory .class ) ; final Marshaller marshaller = jaxbContext . createMarshaller ( ) ; marshaller . marshal ( report , reportFile ) ; getLog ( ) . info ( deviceLogLinePrefix + "Report file written to " + reportFile . getAbsolutePath ( ) ) ; } catch ( IOException e ) { threwException = true ; exceptionMessages . append ( "Failed to write test report file" ) ; exceptionMessages . append ( e . getMessage ( ) ) ; } catch ( JAXBException e ) { threwException = true ; exceptionMessages . append ( "Failed to create jaxb context" ) ; exceptionMessages . append ( e . getMessage ( ) ) ; } }
private void logMetrics ( Map < String , String > metrics ) { for ( Map . Entry < String , String > entry : metrics . entrySet ( ) ) { getLog ( ) . info ( deviceLogLinePrefix + INDENT + INDENT + entry . getKey ( ) + ": " + entry . getValue ( ) ) ; } }
public boolean hasFailuresOrErrors ( ) { return testErrorCount > 0 || testFailureCount > 0 ; }
public boolean testRunFailed ( ) { return testRunFailureCause != null ; }
public String getTestRunFailureCause ( ) { return testRunFailureCause ; }
public boolean threwException ( ) { return threwException ; }
public String getExceptionMessages ( ) { return exceptionMessages . toString ( ) ; }
public GPUImageSourceOverBlendFilter ( ) { super( SOURCE_OVER_BLEND_FRAGMENT_SHADER ); }
public DisplayAssert ( Display actual ) { super( actual , DisplayAssert .class ); }
public DisplayAssert hasDisplayId ( int id ) { isNotNull ( ) ; int actualId = actual . getDisplayId ( ) ; assertThat ( actualId ) . overridingErrorMessage ( "Expected ID <%s> but was <%s>" , id , actualId ) . isEqualTo ( id ) ; return this ; }
@ TargetApi ( JELLY_BEAN_MR1 ) public DisplayAssert hasFlag ( int flag ) { isNotNull ( ) ; assertThat ( actual . getFlags ( ) & flag ) . overridingErrorMessage ( "Expected flag <%s> but was not present" , flag ) . isNotZero ( ) ; return this ; }
@ TargetApi ( JELLY_BEAN_MR1 ) public DisplayAssert hasFlags ( @ DisplayFlags int flags ) { isNotNull ( ) ; int actualFlags = actual . getFlags ( ) ; assertThat ( actualFlags ) . overridingErrorMessage ( "Expected flags <%s> but was <%s>" , flagsToString ( flags ) , flagsToString ( actualFlags ) ) . isEqualTo ( flags ) ; return this ; }
public DisplayAssert hasHeight ( int height ) { isNotNull ( ) ; int actualHeight = actual . getHeight ( ) ; assertThat ( actualHeight ) . overridingErrorMessage ( "Expected height <%s> but was <%s>" , height , actualHeight ) . isEqualTo ( height ) ; return this ; }
@ TargetApi ( JELLY_BEAN_MR1 ) public DisplayAssert hasName ( String name ) { isNotNull ( ) ; String actualName = actual . getName ( ) ; assertThat ( actualName ) . overridingErrorMessage ( "Expected name <%s> but was <%s>" , name , actualName ) . isEqualTo ( name ) ; return this ; }
public DisplayAssert hasOrientation ( @ SurfaceRotation int orientation ) { isNotNull ( ) ; int actualOrientation = actual . getOrientation ( ) ; assertThat ( actualOrientation ) . overridingErrorMessage ( "Expected orientation <%s> but was <%s>" , orientationToString ( orientation ) , orientationToString ( actualOrientation ) ) . isEqualTo ( orientation ) ; return this ; }
public DisplayAssert isPortrait ( ) { isNotNull ( ) ; int actualOrientation = actual . getOrientation ( ) ; assertThat ( actualOrientation ) . overridingErrorMessage ( "Expected orientation <%s> or <%s>, but was <%s>" , orientationToString ( ROTATION_0 ) , orientationToString ( ROTATION_180 ) , orientationToString ( actualOrientation ) ) . isIn ( ROTATION_0 , ROTATION_180 ) ; return this ; }
public DisplayAssert isLandscape ( ) { isNotNull ( ) ; int actualOrientation = actual . getOrientation ( ) ; assertThat ( actualOrientation ) . overridingErrorMessage ( "Expected orientation <%s> or <%s>, but was <%s>" , orientationToString ( ROTATION_270 ) , orientationToString ( ROTATION_90 ) , orientationToString ( actualOrientation ) ) . isIn ( ROTATION_270 , ROTATION_90 ) ; return this ; }
public DisplayAssert hasPixelFormat ( @ DisplayPixelFormat int format ) { isNotNull ( ) ; int actualFormat = actual . getPixelFormat ( ) ; assertThat ( actualFormat ) . overridingErrorMessage ( "Expected pixel format <%s> but was <%s>" , pixelFormatToString ( format ) , pixelFormatToString ( actualFormat ) ) . isEqualTo ( format ) ; return this ; }
@ TargetApi ( JELLY_BEAN_MR1 ) public DisplayAssert hasRealSize ( int width , int height ) { isNotNull ( ) ; Point actualSize = new Point ( ) ; actual . getRealSize ( actualSize ) ; assertThat ( actualSize . x ) . overridingErrorMessage ( "Expected real size of <%s, %s> but was <%s, %s>" , width , height , actualSize . x , actualSize . y ) . isEqualTo ( width ) ; assertThat ( actualSize . y ) . overridingErrorMessage ( "Expected real size of <%s, %s> but was <%s, %s>" , width , height , actualSize . x , actualSize . y ) . isEqualTo ( height ) ; return this ; }
public DisplayAssert hasRefreshRate ( float rate ) { isNotNull ( ) ; float actualRate = actual . getRefreshRate ( ) ; assertThat ( actualRate ) . overridingErrorMessage ( "Expected refresh rate <%s> but was <%s>" , rate , actualRate ) . isEqualTo ( rate ) ; return this ; }
@ TargetApi ( FROYO ) public DisplayAssert hasRotation ( int rotation ) { isNotNull ( ) ; int actualRotation = actual . getRotation ( ) ; assertThat ( actualRotation ) . overridingErrorMessage ( "Expected rotation <%s> but was <%s>" , rotation , actualRotation ) . isEqualTo ( rotation ) ; return this ; }
@ TargetApi ( HONEYCOMB_MR2 ) public DisplayAssert hasSize ( int width , int height ) { isNotNull ( ) ; Point actualSize = new Point ( ) ; actual . getSize ( actualSize ) ; assertThat ( actualSize . x ) . overridingErrorMessage ( "Expected size of <%s, %s> but was <%s, %s>" , width , height , actualSize . x , actualSize . y ) . isEqualTo ( width ) ; assertThat ( actualSize . y ) . overridingErrorMessage ( "Expected size of <%s, %s> but was <%s, %s>" , width , height , actualSize . x , actualSize . y ) . isEqualTo ( height ) ; return this ; }
@ TargetApi ( KITKAT_WATCH ) public DisplayAssert hasState ( @ DisplayState int state ) { isNotNull ( ) ; assertThat ( actual . getState ( ) ) . overridingErrorMessage ( "Expected state <%s> but was <%s>" , stateToString ( state ) , stateToString ( actual . getState ( ) ) ) . isEqualTo ( state ) ; return this ; }
public DisplayAssert hasWidth ( int width ) { isNotNull ( ) ; int actualWidth = actual . getWidth ( ) ; assertThat ( actualWidth ) . overridingErrorMessage ( "Expected width <%s> but was <%s>" , width , actualWidth ) . isEqualTo ( width ) ; return this ; }
@ TargetApi ( JELLY_BEAN_MR1 ) public DisplayAssert isValid ( ) { isNotNull ( ) ; assertThat ( actual . isValid ( ) ) . overridingErrorMessage ( "Expected valid but was not valid" ) . isTrue ( ) ; return this ; }
@ TargetApi ( JELLY_BEAN_MR1 ) public DisplayAssert isNotValid ( ) { isNotNull ( ) ; assertThat ( actual . isValid ( ) ) . overridingErrorMessage ( "Expected invalid but was valid" ) . isFalse ( ) ; return this ; }
public static String orientationToString ( @ SurfaceRotation int orientation ) { return buildNamedValueString ( orientation ) . value ( ROTATION_0 , "portrait (0)" ) . value ( ROTATION_90 , "landscape (90)" ) . value ( ROTATION_180 , "inverted portrait (180)" ) . value ( ROTATION_270 , "inverted landscape (270)" ) . get ( ) ; }
@ TargetApi ( KITKAT_WATCH ) public static String stateToString ( @ DisplayState int state ) { return buildNamedValueString ( state ) . value ( STATE_DOZE , "dozing" ) . value ( STATE_DOZE_SUSPEND , "doze suspend" ) . value ( STATE_OFF , "off" ) . value ( STATE_ON , "on" ) . value ( STATE_UNKNOWN , "unknown" ) . get ( ) ; }
public static String flagsToString ( @ DisplayFlags int flags ) { return buildBitMaskString ( flags ) . flag ( FLAG_PRESENTATION , "presentation" ) . flag ( FLAG_PRIVATE , "private" ) . flag ( FLAG_SECURE , "secure" ) . flag ( FLAG_SUPPORTS_PROTECTED_BUFFERS , "supports_protected_buffers" ) . get ( ) ; }
public static String pixelFormatToString ( @ DisplayPixelFormat int format ) { return buildNamedValueString ( format ) . value ( UNKNOWN , "unknown" ) . value ( TRANSLUCENT , "translucent" ) . value ( TRANSPARENT , "transparent" ) . value ( OPAQUE , "opaque" ) . value ( RGBA_8888 , "rgba_8888" ) . value ( RGBX_8888 , "rgbx_8888" ) . value ( RGB_888 , "rgb_888" ) . value ( RGB_565 , "rgb_565" ) . value ( RGBA_5551 , "rgba_5551" ) . value ( RGBA_4444 , "rgba_4444" ) . value ( A_8 , "a_8" ) . value ( L_8 , "l_8" ) . value ( LA_88 , "la_88" ) . value ( RGB_332 , "rgb_332" ) . value ( YCbCr_422_SP , "ycbcr_422_sp" ) . value ( YCbCr_420_SP , "ycbcr_420_sp" ) . value ( YCbCr_422_I , "ycbcr_422_i" ) . value ( JPEG , "jpeg" ) . get ( ) ; }
public MediaRouteDescriptorAssert ( MediaRouteDescriptor actual ) { super( actual , MediaRouteDescriptorAssert .class ); }
public MediaRouteDescriptorAssert hasDescription ( String description ) { isNotNull ( ) ; String actualDescription = actual . getDescription ( ) ; assertThat ( actualDescription ) . overridingErrorMessage ( "Expected description <%s> but was <%s>." , description , actualDescription ) . isEqualTo ( description ) ; return this ; }
public MediaRouteDescriptorAssert hasId ( String id ) { isNotNull ( ) ; String actualId = actual . getId ( ) ; assertThat ( actualId ) . overridingErrorMessage ( "Expected id <%s> but was <%s>." , id , actualId ) . isEqualTo ( id ) ; return this ; }
public MediaRouteDescriptorAssert hasName ( String name ) { isNotNull ( ) ; String actualName = actual . getName ( ) ; assertThat ( actualName ) . overridingErrorMessage ( "Expected name <%s> but was <%s>." , name , actualName ) . isEqualTo ( name ) ; return this ; }
public MediaRouteDescriptorAssert hasPlaybackStream ( int playbackStream ) { isNotNull ( ) ; int actualPlaybackStream = actual . getPlaybackStream ( ) ; assertThat ( actualPlaybackStream ) . overridingErrorMessage ( "Expected playback stream <%s> but was <%s>." , playbackStream , actualPlaybackStream ) . isEqualTo ( playbackStream ) ; return this ; }
public MediaRouteDescriptorAssert hasPlaybackType ( int playbackType ) { isNotNull ( ) ; int actualPlaybackType = actual . getPlaybackType ( ) ; assertThat ( actualPlaybackType ) . overridingErrorMessage ( "Expected playback type <%s> but was <%s>." , playbackType , actualPlaybackType ) . isEqualTo ( playbackType ) ; return this ; }
public MediaRouteDescriptorAssert hasPresentationDisplayId ( int displayId ) { isNotNull ( ) ; int actualDisplayId = actual . getPresentationDisplayId ( ) ; assertThat ( actualDisplayId ) . overridingErrorMessage ( "Expected presentation display ID <%s> but was <%s>." , displayId , actualDisplayId ) . isEqualTo ( displayId ) ; return this ; }
public MediaRouteDescriptorAssert hasVolume ( int volume ) { isNotNull ( ) ; int actualVolume = actual . getVolume ( ) ; assertThat ( actualVolume ) . overridingErrorMessage ( "Expected volume <%s> but was <%s>." , volume , actualVolume ) . isEqualTo ( volume ) ; return this ; }
public MediaRouteDescriptorAssert hasVolumeHandling ( int volumeHandling ) { isNotNull ( ) ; int actualVolumeHandling = actual . getVolumeHandling ( ) ; assertThat ( actualVolumeHandling ) . overridingErrorMessage ( "Expected volume handling <%s> but was <%s>." , volumeHandling , actualVolumeHandling ) . isEqualTo ( volumeHandling ) ; return this ; }
public MediaRouteDescriptorAssert hasVolumeMax ( int volumeMax ) { isNotNull ( ) ; int actualVolumeMax = actual . getVolumeMax ( ) ; assertThat ( actualVolumeMax ) . overridingErrorMessage ( "Expected maximum volume <%s> but was <%s>." , volumeMax , actualVolumeMax ) . isEqualTo ( volumeMax ) ; return this ; }
public MediaRouteDescriptorAssert isConnecting ( ) { isNotNull ( ) ; assertThat ( actual . isConnecting ( ) ) . overridingErrorMessage ( "Expected to be connecting but was not." ) . isTrue ( ) ; return this ; }
public MediaRouteDescriptorAssert isNotConnecting ( ) { isNotNull ( ) ; assertThat ( actual . isConnecting ( ) ) . overridingErrorMessage ( "Expected to not be connecting but was." ) . isFalse ( ) ; return this ; }
public MediaRouteDescriptorAssert isEnabled ( ) { isNotNull ( ) ; assertThat ( actual . isEnabled ( ) ) . overridingErrorMessage ( "Expected to be enabled but was not." ) . isTrue ( ) ; return this ; }
public MediaRouteDescriptorAssert isDisabled ( ) { isNotNull ( ) ; assertThat ( actual . isEnabled ( ) ) . overridingErrorMessage ( "Expected to be disabled but was enabled." ) . isFalse ( ) ; return this ; }
public MediaRouteDescriptorAssert isValid ( ) { isNotNull ( ) ; assertThat ( actual . isValid ( ) ) . overridingErrorMessage ( "Expected to be valid but was not." ) . isTrue ( ) ; return this ; }
public MediaRouteDescriptorAssert isNotValid ( ) { isNotNull ( ) ; assertThat ( actual . isValid ( ) ) . overridingErrorMessage ( "Expected to not be valid but was." ) . isFalse ( ) ; return this ; }
public static void start ( Context context ) { Intent intent = new Intent ( context , AboutActivity .class ) ; context . startActivity ( intent ) ; }
@ Override protected void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; Toolbar toolbar = ( Toolbar ) findViewById ( R . id . toolbar ) ; setSupportActionBar ( toolbar ) ; CollapsingToolbarLayout toolBarLayout = ( CollapsingToolbarLayout ) findViewById ( R . id . toolbar_layout ) ; toolBarLayout . setTitle ( getTitle ( ) ) ; getSupportActionBar ( ) . setDisplayHomeAsUpEnabled ( true ) ; TextView tv = ( TextView ) findViewById ( R . id . about_text ) ; String versionString = "" ; int versionCode = 0 ; try { PackageInfo info = getPackageManager ( ) . getPackageInfo ( getPackageName ( ) , 0 ) ; versionString = info . versionName ; versionCode = info . versionCode ; } catch ( PackageManager . NameNotFoundException e ) { e . printStackTrace ( ) ; } StringBuilder builder = new StringBuilder ( ) ; builder . append ( "v" ) . append ( versionString ) . append ( " (" ) . append ( versionCode ) . append ( ")\n\n" ) ; builder . append ( getString ( R . string . about_text ) ) ; builder . append ( "\n\n" ) ; tv . setText ( builder . toString ( ) ) ; }
@ Override protected void onStart ( ) { super. onStart ( ) ; ObaAnalytics . reportActivityStart ( this ) ; }
static void notifyLoadFinished ( Context context ) { sendBroadcast ( context , CATEGORY_TEST , ACTION_LOAD_FINISHED ) ; }
static void sendBroadcast ( Context context , String action , String category ) { if ( BuildConfig . DEBUG ) { Intent intent = new Intent ( ) ; intent . setAction ( action ) ; intent . addCategory ( category ) ; context . sendBroadcast ( intent ) ; } }
public static void waitForLoadFinished ( Context context ) throws InterruptedException { waitForBroadcast ( context , ACTION_LOAD_FINISHED , CATEGORY_TEST ) ; }
public static void waitForBroadcast ( Context context , String action , String category )            throws InterruptedException { final CountDownLatch signal = new CountDownLatch ( 1 ) ; IntentFilter intentFilter = new IntentFilter ( action ) ; intentFilter . addCategory ( category ) ; BroadcastReceiver broadcastReceiver = new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { signal . countDown ( ) ; } } ; context . registerReceiver ( broadcastReceiver , intentFilter ) ; signal . await ( 10000 , TimeUnit . MILLISECONDS ) ; context . unregisterReceiver ( broadcastReceiver ) ; Thread . sleep ( 1000 ) ; }
@ Override public void onReceive ( Context context , Intent intent ) { signal . countDown ( ) ; }
public static boolean isRunningOnEmulator ( ) { return Build . FINGERPRINT . contains ( "generic" ) ; }
@ Override public Scheduler call ( ) Exception { return MainHolder . DEFAULT ; }
public static Scheduler mainThread ( ) { return RxAndroidPlugins . onMainThreadScheduler ( MAIN_THREAD ) ; }
public static Scheduler from ( Looper looper ) { if ( looper == null ) throw new NullPointerException ( "looper == null" ) ; return new HandlerScheduler ( new Handler ( looper ) ) ; }
private AndroidSchedulers ( ) { throw new AssertionError ( "No instances." ) ; }
public GridLayoutAssert ( GridLayout actual ) { super( actual , GridLayoutAssert .class ); }
public GridLayoutAssert hasAlignmentMode ( @ GridLayoutAlignmentMode int mode ) { isNotNull ( ) ; int actualMode = actual . getAlignmentMode ( ) ; assertThat ( actualMode ) . overridingErrorMessage ( "Expected alignment mode <%s> but was <%s>." , alignmentModeToString ( mode ) , alignmentModeToString ( actualMode ) ) . isEqualTo ( mode ) ; return this ; }
public GridLayoutAssert hasColumnCount ( int count ) { isNotNull ( ) ; int actualCount = actual . getColumnCount ( ) ; assertThat ( actualCount ) . overridingErrorMessage ( "Expected column count <%s> but was <%s>." , count , actualCount ) . isEqualTo ( count ) ; return this ; }
public GridLayoutAssert hasOrientation ( @ GridLayoutOrientation int orientation ) { isNotNull ( ) ; int actualOrientation = actual . getOrientation ( ) ; assertThat ( actualOrientation ) . overridingErrorMessage ( "Expected orientation <%s> but was <%s>." , orientationToString ( orientation ) , orientationToString ( actualOrientation ) ) . isEqualTo ( orientation ) ; return this ; }
public GridLayoutAssert isVertical ( ) { return hasOrientation ( VERTICAL ) ; }
public GridLayoutAssert isHorizontal ( ) { return hasOrientation ( HORIZONTAL ) ; }
public GridLayoutAssert hasRowCount ( int count ) { isNotNull ( ) ; int actualCount = actual . getRowCount ( ) ; assertThat ( actualCount ) . overridingErrorMessage ( "Expected row count <%s> but was <%s>." , count , actualCount ) . isEqualTo ( count ) ; return this ; }
public GridLayoutAssert isUsingDefaultMargins ( ) { isNotNull ( ) ; assertThat ( actual . getUseDefaultMargins ( ) ) . overridingErrorMessage ( "Expected to be using default margins but was not." ) . isTrue ( ) ; return this ; }
public GridLayoutAssert isNotUsingDefaultMargins ( ) { isNotNull ( ) ; assertThat ( actual . getUseDefaultMargins ( ) ) . overridingErrorMessage ( "Expected to not be using default margins but was." ) . isFalse ( ) ; return this ; }
public GridLayoutAssert isPreservingColumnOrder ( ) { isNotNull ( ) ; assertThat ( actual . isColumnOrderPreserved ( ) ) . overridingErrorMessage ( "Expected to be preserving column order but was not." ) . isTrue ( ) ; return this ; }
public GridLayoutAssert isNotPreservingColumnOrder ( ) { isNotNull ( ) ; assertThat ( actual . isColumnOrderPreserved ( ) ) . overridingErrorMessage ( "Expected to not be preserving column order but was." ) . isFalse ( ) ; return this ; }
public GridLayoutAssert isPreservingRowOrder ( ) { isNotNull ( ) ; assertThat ( actual . isRowOrderPreserved ( ) ) . overridingErrorMessage ( "Expected to be preserving row order but was not." ) . isTrue ( ) ; return this ; }
public GridLayoutAssert isNotPreservingRowOrder ( ) { isNotNull ( ) ; assertThat ( actual . isRowOrderPreserved ( ) ) . overridingErrorMessage ( "Expected to not be preserving row order but was." ) . isFalse ( ) ; return this ; }
public static String alignmentModeToString ( @ GridLayoutAlignmentMode int mode ) { return buildNamedValueString ( mode ) . value ( ALIGN_BOUNDS , "alignBounds" ) . value ( ALIGN_MARGINS , "alignMargins" ) . get ( ) ; }
public static String orientationToString ( @ GridLayoutOrientation int orientation ) { return buildNamedValueString ( orientation ) . value ( HORIZONTAL , "horizontal" ) . value ( VERTICAL , "vertical" ) . get ( ) ; }
public ToCloneOrNot ( ) { }
@ Override public void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; }
@ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { return inflater . inflate ( R . layout . fragment_to_clone_or_not , container , false ) ; }
public TimePickerAssert ( TimePicker actual ) { super( actual , TimePickerAssert .class ); }
public TimePickerAssert hasCurrentHour ( Integer hour ) { isNotNull ( ) ; Integer actualHour = actual . getCurrentHour ( ) ; assertThat ( actualHour ) . overridingErrorMessage ( "Expected current hour <%s> but was <%s>." , hour , actualHour ) . isEqualTo ( hour ) ; return this ; }
public TimePickerAssert hasCurrentMinute ( Integer minute ) { isNotNull ( ) ; Integer actualMinute = actual . getCurrentMinute ( ) ; assertThat ( actualMinute ) . overridingErrorMessage ( "Expected current minute <%s> but was <%s>." , minute , actualMinute ) . isEqualTo ( minute ) ; return this ; }
@ TargetApi ( M ) public TimePickerAssert hasHour ( @ IntRange ( from = 0 , to = 23 ) int hour ) { isNotNull ( ) ; int actualHour = actual . getHour ( ) ; assertThat ( actualHour ) . overridingErrorMessage ( "Expected hour <%s> but was <%s>." , hour , actualHour ) . isEqualTo ( hour ) ; return this ; }
@ TargetApi ( M ) public TimePickerAssert hasMinute ( @ IntRange ( from = 0 , to = 59 ) int minute ) { isNotNull ( ) ; int actualMinute = actual . getMinute ( ) ; assertThat ( actualMinute ) . overridingErrorMessage ( "Expected minute <%s> but was <%s>." , minute , actualMinute ) . isEqualTo ( minute ) ; return this ; }
public TimePickerAssert isIn24HourView ( ) { isNotNull ( ) ; assertThat ( actual . is24HourView ( ) ) . overridingErrorMessage ( "Expected to be in 24 hour view but was not." ) . isTrue ( ) ; return this ; }
public TimePickerAssert isNotIn24HourView ( ) { isNotNull ( ) ; assertThat ( actual . is24HourView ( ) ) . overridingErrorMessage ( "Expected to not be in 24 hour view but was." ) . isFalse ( ) ; return this ; }
public FragmentTransactionAssert ( FragmentTransaction actual ) { super( actual , FragmentManagerAssert .class ); }
public FragmentTransactionAssert isAddToBackStackAllowed ( ) { isNotNull ( ) ; assertThat ( actual . isAddToBackStackAllowed ( ) ) . overridingErrorMessage ( "Expected add to back stack to be allowed but was disallowed." ) . isTrue ( ) ; return this ; }
public FragmentTransactionAssert isAddToBackStackDisallowed ( ) { isNotNull ( ) ; assertThat ( actual . isAddToBackStackAllowed ( ) ) . overridingErrorMessage ( "Expected add to back stack to be disallowed but was allowed." ) . isFalse ( ) ; return this ; }
public FragmentTransactionAssert isEmpty ( ) { isNotNull ( ) ; assertThat ( actual . isEmpty ( ) ) . overridingErrorMessage ( "Expected empty transaction but was not empty." ) . isTrue ( ) ; return this ; }
public FragmentTransactionAssert isNotEmpty ( ) { isNotNull ( ) ; assertThat ( actual . isEmpty ( ) ) . overridingErrorMessage ( "Expected non-empty transaction but was empty." ) . isFalse ( ) ; return this ; }
protected AbstractCursorAdapterAssert ( A actual , Class < S > selfType ) { super( actual , selfType ); }
public S hasCursor ( Cursor cursor ) { isNotNull ( ) ; Cursor actualCursor = actual . getCursor ( ) ; assertThat ( actualCursor ) . overridingErrorMessage ( "Expected cursor <%s> but was <%s>." , cursor , actualCursor ) . isSameAs ( cursor ) ; return myself ; }
public S hasFilter ( Filter filter ) { isNotNull ( ) ; Filter actualFilter = actual . getFilter ( ) ; assertThat ( actualFilter ) . overridingErrorMessage ( "Expected filter <%s> but was <%s>." , filter , actualFilter ) . isSameAs ( filter ) ; return myself ; }
public LruCacheAssert ( LruCache < K , V > actual ) { super( actual , LruCacheAssert .class ); }
public LruCacheAssert < K , V > hasEntry ( K key ) { isNotNull ( ) ; assertThat ( actual . snapshot ( ) ) . overridingErrorMessage ( "Expected to contain entry with key <%s> but did not." ) . containsKey ( key ) ; return this ; }
public LruCacheAssert < K , V > hasCreateCount ( int count ) { isNotNull ( ) ; int actualCount = actual . createCount ( ) ; assertThat ( actualCount ) . overridingErrorMessage ( "Expected create count <%s> but was <%s>." , count , actualCount ) . isEqualTo ( count ) ; return this ; }
public LruCacheAssert < K , V > hasEvictionCount ( int count ) { isNotNull ( ) ; int actualCount = actual . evictionCount ( ) ; assertThat ( actualCount ) . overridingErrorMessage ( "Expected eviction count <%s> but was <%s>." , count , actualCount ) . isEqualTo ( count ) ; return this ; }
public LruCacheAssert < K , V > hasHitCount ( int count ) { isNotNull ( ) ; int actualCount = actual . hitCount ( ) ; assertThat ( actualCount ) . overridingErrorMessage ( "Expected hit count <%s> but was <%s>." , count , actualCount ) . isEqualTo ( count ) ; return this ; }
public LruCacheAssert < K , V > hasMaxSize ( int size ) { isNotNull ( ) ; int actualSize = actual . maxSize ( ) ; assertThat ( actualSize ) . overridingErrorMessage ( "Expected max size <%s> but was <%s>." , size , actualSize ) . isEqualTo ( size ) ; return this ; }
public LruCacheAssert < K , V > hasMissCount ( int count ) { isNotNull ( ) ; int actualCount = actual . missCount ( ) ; assertThat ( actualCount ) . overridingErrorMessage ( "Expected miss count <%s> but was <%s>." , count , actualCount ) . isEqualTo ( count ) ; return this ; }
public LruCacheAssert < K , V > hasPutCount ( int count ) { isNotNull ( ) ; int actualCount = actual . putCount ( ) ; assertThat ( actualCount ) . overridingErrorMessage ( "Expected put count <%s> but was <%s>." , count , actualCount ) . isEqualTo ( count ) ; return this ; }
public LruCacheAssert < K , V > hasSize ( int size ) { isNotNull ( ) ; int actualSize = actual . size ( ) ; assertThat ( actualSize ) . overridingErrorMessage ( "Expected size <%s> but was <%s>." , size , actualSize ) . isEqualTo ( size ) ; return this ; }
public ArrivalsListLoader ( Context context , String stopId ) { super( context ); mStopId = stopId ; }
@ Override public ObaArrivalInfoResponse loadInBackground ( ) { return ObaArrivalInfoRequest . newRequest ( getContext ( ) , mStopId , mMinutesAfter ) . call ( ) ; }
@ Override public void deliverResult ( ObaArrivalInfoResponse data ) { mLastResponseTime = System . currentTimeMillis ( ) ; if ( data . getCode ( ) == ObaApi . OBA_OK ) { mLastGoodResponse = data ; mLastGoodResponseTime = mLastResponseTime ; } super. deliverResult ( data ) ; }
public long getLastResponseTime ( ) { return mLastResponseTime ; }
public ObaArrivalInfoResponse getLastGoodResponse ( ) { return mLastGoodResponse ; }
public long getLastGoodResponseTime ( ) { return mLastGoodResponseTime ; }
public void incrementMinutesAfter ( ) { mMinutesAfter = mMinutesAfter + MINUTES_INCREMENT ; }
public int getMinutesAfter ( ) { return mMinutesAfter ; }
@ Override protected void onStopLoading ( ) { cancelLoad ( ) ; }
@ Override protected void onReset ( ) { super. onReset ( ) ; mLastGoodResponse = null ; mLastGoodResponseTime = 0 ; onStopLoading ( ) ; }
public void execute ( ) MojoExecutionException , MojoFailureException { if ( ! isCurrentProjectAndroid ( ) ) { return; } validateStandardLocations ( ) ; try { targetDirectory . mkdirs ( ) ; copyManifest ( ) ; if ( warnOnApklibDependencies ) { checkForApklibDependencies ( ) ; } extractSourceDependencies ( ) ; extractLibraryDependencies ( ) ; copyFolder ( assetsDirectory , combinedAssets ) ; final String [] relativeAidlFileNames1 = findRelativeAidlFileNames ( aidlSourceDirectory ) ; final String [] relativeAidlFileNames2 = findRelativeAidlFileNames ( extractedDependenciesJavaSources ) ; final Map < String , String [] > relativeApklibAidlFileNames = new HashMap < String , String [] > ( ) ; if ( ! isInstrumentationTest ( ) ) { for ( Artifact artifact : getTransitiveDependencyArtifacts ( APKLIB ) ) { final File libSourceFolder = getUnpackedApkLibSourceFolder ( artifact ) ; final String [] apklibAidlFiles = findRelativeAidlFileNames ( libSourceFolder ) ; relativeApklibAidlFileNames . put ( artifact . getId ( ) , apklibAidlFiles ) ; } } checkPackagesForDuplicates ( ) ; checkForConflictingLayouts ( ) ; generateR ( ) ; generateBuildConfig ( ) ; final Map < File , String [] > files = new HashMap < File , String [] > ( ) ; files . put ( aidlSourceDirectory , relativeAidlFileNames1 ) ; files . put ( extractedDependenciesJavaSources , relativeAidlFileNames2 ) ; if ( ! isInstrumentationTest ( ) ) { for ( Artifact artifact : getTransitiveDependencyArtifacts ( APKLIB ) ) { final File unpackedLibSourceFolder = getUnpackedApkLibSourceFolder ( artifact ) ; files . put ( unpackedLibSourceFolder , relativeApklibAidlFileNames . get ( artifact . getId ( ) ) ) ; } } generateAidlFiles ( files ) ; } catch ( MojoExecutionException e ) { getLog ( ) . error ( "Error when generating sources." , e ) ; throw e ; } }
private void validateStandardLocations ( ) MojoExecutionException { boolean hasNonStandardStructure = false ; if ( androidManifestFilePre4 . exists ( ) && ! androidManifestFilePre4 . equals ( androidManifestFile ) ) { getLog ( ) . warn ( "Non-standard location of AndroidManifest.xml file found, but not configured:\n " + androidManifestFilePre4 + "\nMove to the standard location src/main/AndroidManifest.xml\n" + "Or configure androidManifestFile. \n" ) ; hasNonStandardStructure = true ; } if ( resourceDirectoryPre4 . exists ( ) && ! resourceDirectoryPre4 . equals ( resourceDirectory ) ) { getLog ( ) . warn ( "Non-standard location of Android res folder found, but not configured:\n " + resourceDirectoryPre4 + "\nMove to the standard location src/main/res/\n" + "Or configure resourceDirectory. \n" ) ; hasNonStandardStructure = true ; } if ( assetsDirectoryPre4 . exists ( ) && ! assetsDirectoryPre4 . equals ( assetsDirectory ) ) { getLog ( ) . warn ( "Non-standard location assets folder found, but not configured:\n " + assetsDirectoryPre4 + "\nMove to the standard location src/main/assets/\n" + "Or configure assetsDirectory. \n" ) ; hasNonStandardStructure = true ; } if ( nativeLibrariesDirectoryPre4 . exists ( ) && ! nativeLibrariesDirectoryPre4 . equals ( nativeLibrariesDirectory ) ) { getLog ( ) . warn ( "Non-standard location native libs folder found, but not configured:\n " + nativeLibrariesDirectoryPre4 + "\nMove to the standard location src/main/libs/\n" + "Or configure nativeLibrariesDirectory. \n" ) ; hasNonStandardStructure = true ; } if ( hasNonStandardStructure && failOnNonStandardStructure ) { throw new MojoExecutionException ( "\n\nFound files or folders in non-standard locations in the project!\n" + "....This might be a side-effect of a migration to Android Maven Plugin 4+.\n" + "....Please observe the warnings for specific files and folders above.\n" + "....Ideally you should restructure your project.\n" + "....Alternatively add explicit configuration overrides for files or folders.\n" + "....Finally you could set failOnNonStandardStructure to false, potentially " + "resulting in other failures.\n\n\n" ) ; } }
protected void copyManifest ( ) MojoExecutionException { getLog ( ) . debug ( "copyManifest: " + androidManifestFile + " -> " + destinationManifestFile ) ; if ( androidManifestFile == null ) { getLog ( ) . debug ( "Manifest copying disabled. Using default manifest only" ) ; return; } try { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder db = dbf . newDocumentBuilder ( ) ; Document doc = db . parse ( androidManifestFile ) ; Source source = new DOMSource ( doc ) ; TransformerFactory xfactory = TransformerFactory . newInstance ( ) ; Transformer xformer = xfactory . newTransformer ( ) ; xformer . setOutputProperty ( OutputKeys . OMIT_XML_DECLARATION , "yes" ) ; FileWriter writer = null ; try { destinationManifestFile . getParentFile ( ) . mkdirs ( ) ; writer = new FileWriter ( destinationManifestFile , false ) ; if ( doc . getXmlEncoding ( ) != null && doc . getXmlVersion ( ) != null ) { String xmldecl = String . format ( "<?xml version=\"%s\" encoding=\"%s\"?>%n" , doc . getXmlVersion ( ) , doc . getXmlEncoding ( ) ) ; writer . write ( xmldecl ) ; } Result result = new StreamResult ( writer ) ; xformer . transform ( source , result ) ; getLog ( ) . info ( "Manifest copied from " + androidManifestFile + " to " + destinationManifestFile ) ; } finally { IOUtils . closeQuietly ( writer ) ; } } catch ( Exception e ) { getLog ( ) . error ( "Error during copyManifest" ) ; throw new MojoExecutionException ( "Error during copyManifest" , e ) ; } }
protected void extractSourceDependencies ( ) MojoExecutionException { for ( Artifact artifact : getDirectDependencyArtifacts ( ) ) { String type = artifact . getType ( ) ; if ( type . equals ( APKSOURCES ) ) { getLog ( ) . debug ( "Detected apksources dependency " + artifact + " with file " + artifact . getFile ( ) + ". Will resolve and extract..." ) ; final File apksourcesFile = resolveArtifactToFile ( artifact ) ; getLog ( ) . debug ( "Extracting " + apksourcesFile + "..." ) ; extractApksources ( apksourcesFile ) ; } } if ( extractedDependenciesJavaResources . exists ( ) ) { projectHelper . addResource ( project , extractedDependenciesJavaResources . getAbsolutePath ( ) , null , null ) ; project . addCompileSourceRoot ( extractedDependenciesJavaSources . getAbsolutePath ( ) ) ; } }
@ Deprecated private void extractApksources ( File apksourcesFile ) throws MojoExecutionException { if ( apksourcesFile . isDirectory ( ) ) { getLog ( ) . warn ( "The apksources artifact points to '" + apksourcesFile + "' which is a directory; skipping unpacking it." ) ; return; } final UnArchiver unArchiver = new ZipUnArchiver ( apksourcesFile ) { @ Override protected Logger getLogger ( ) { return new ConsoleLogger ( Logger . LEVEL_DEBUG , "dependencies-unarchiver" ) ; } } ; extractedDependenciesDirectory . mkdirs ( ) ; unArchiver . setDestDirectory ( extractedDependenciesDirectory ) ; try { unArchiver . extract ( ) ; } catch ( ArchiverException e ) { throw new MojoExecutionException ( "ArchiverException while extracting " + apksourcesFile . getAbsolutePath ( ) + ". Message: " + e . getLocalizedMessage ( ) , e ) ; } }
@ Override protected Logger getLogger ( ) { return new ConsoleLogger ( Logger . LEVEL_DEBUG , "dependencies-unarchiver" ) ; }
private void extractLibraryDependencies ( ) MojoExecutionException { final Collection < Artifact > artifacts = getTransitiveDependencyArtifacts ( EXCLUDED_DEPENDENCY_SCOPES_FOR_EXTRACTION ) ; getLog ( ) . info ( "Extracting libs" ) ; final boolean instrumentationTest = isInstrumentationTest ( ) ; for ( Artifact artifact : artifacts ) { final String type = artifact . getType ( ) ; if ( type . equals ( APKLIB ) && ! instrumentationTest ) { getLog ( ) . info ( "Extracting apklib " + artifact . getArtifactId ( ) + "..." ) ; extractApklib ( artifact ) ; } else if ( type . equals ( AAR ) ) { getLog ( ) . info ( "Extracting aar " + artifact . getArtifactId ( ) + "..." ) ; extractAarLib ( artifact ) ; } else if ( type . equals ( APK ) ) { getLog ( ) . info ( "Extracting apk " + artifact . getArtifactId ( ) + "..." ) ; extractApkClassesJar ( artifact ) ; } else { getLog ( ) . debug ( "Not extracting " + artifact . getArtifactId ( ) + "..." ) ; } } }
private void extractApklib ( Artifact apklibArtifact ) throws MojoExecutionException { getUnpackedLibHelper ( ) . extractApklib ( apklibArtifact ) ; copyFolder ( getUnpackedLibAssetsFolder ( apklibArtifact ) , combinedAssets ) ; final File apklibSourceFolder = getUnpackedApkLibSourceFolder ( apklibArtifact ) ; final List < String > resourceExclusions = Arrays . asList ( "** , "** ) ; projectHelper . addResource ( project , apklibSourceFolder . getAbsolutePath ( ) , null , resourceExclusions ) ; project . addCompileSourceRoot ( apklibSourceFolder . getAbsolutePath ( ) ) ; }
private void extractAarLib ( Artifact aarArtifact ) throws MojoExecutionException { getUnpackedLibHelper ( ) . extractAarLib ( aarArtifact ) ; if ( isAPKBuild ( ) ) { copyFolder ( getUnpackedLibAssetsFolder ( aarArtifact ) , combinedAssets ) ; } if ( isAPKBuild ( ) ) { getLog ( ) . debug ( "Not adding AAR resources to resource classpath : " + aarArtifact ) ; } }
private void extractApkClassesJar ( Artifact artifact ) throws MojoExecutionException { final File apkClassesJar = getUnpackedLibHelper ( ) . getJarFileForApk ( artifact ) ; final File unpackedClassesJar = getUnpackedLibHelper ( ) . getUnpackedClassesJar ( artifact ) ; try { FileUtils . copyFile ( apkClassesJar , unpackedClassesJar ) ; } catch ( IOException e ) { throw new MojoExecutionException ( "Could not copy APK classes jar " + apkClassesJar + " to " + unpackedClassesJar , e ) ; } getLog ( ) . debug ( "Copied APK classes jar into compile classpath : " + unpackedClassesJar ) ; }
private void checkForApklibDependencies ( ) MojoExecutionException { final boolean isAarBuild = project . getPackaging ( ) . equals ( AAR ) ; final DependencyResolver dependencyResolver = getDependencyResolver ( ) ; final Set < Artifact > allArtifacts = project . getArtifacts ( ) ; Set < Artifact > dependencyArtifacts = getArtifactResolverHelper ( ) . getFilteredArtifacts ( allArtifacts ) ; boolean foundApklib = false ; for ( Artifact artifact : dependencyArtifacts ) { final String type = artifact . getType ( ) ; if ( type . equals ( APKLIB ) && isAarBuild ) { getLog ( ) . warn ( "Detected APKLIB transitive dependency: " + artifact . getId ( ) ) ; foundApklib = true ; } else if ( type . equals ( AAR ) ) { final Set < Artifact > dependencies = dependencyResolver . getLibraryDependenciesFor ( session , repositorySystem , artifact ) ; for ( Artifact dependency : dependencies ) { if ( dependency . getType ( ) . equals ( APKLIB ) ) { getLog ( ) . warn ( "Detected " + artifact . getId ( ) + " that depends on APKLIB: " + dependency . getId ( ) ) ; foundApklib = true ; } } } } if ( foundApklib ) { getLog ( ) . warn ( "AAR libraries should not depend or include APKLIB artifacts.\n" + "APKLIBs have been deprecated and the combination of the two may yield unexpected results.\n" + "Check the problematic AAR libraries for newer versions that use AAR packaging." ) ; } }
private void checkPackagesForDuplicates ( ) MojoExecutionException { Set < Artifact > dependencyArtifacts = getTransitiveDependencyArtifacts ( AAR , APKLIB ) ; if ( dependencyArtifacts . isEmpty ( ) ) { return; } Map < String , Set < Artifact > > packageCompareMap = getPackageCompareMap ( dependencyArtifacts ) ; List < String > duplicatesMessageList = new ArrayList < String > ( ) ; for ( Map . Entry < String , Set < Artifact > > entry : packageCompareMap . entrySet ( ) ) { Set < Artifact > artifacts = entry . getValue ( ) ; if ( artifacts != null && artifacts . size ( ) > 1 ) { StringBuilder messageBuilder = new StringBuilder ( ) ; for ( Artifact item : artifacts ) { messageBuilder . append ( messageBuilder . length ( ) > 0 ? ", " : "    [" ) . append ( item . getArtifactId ( ) ) ; } messageBuilder . append ( "] have similar package='" ) . append ( entry . getKey ( ) ) . append ( "'" ) ; duplicatesMessageList . add ( messageBuilder . toString ( ) ) ; } } if ( ! duplicatesMessageList . isEmpty ( ) ) { List < String > messageList = new ArrayList < String > ( ) ; messageList . add ( "" ) ; messageList . add ( "Duplicate packages detected in AndroidManifest.xml files" ) ; messageList . add ( "" ) ; messageList . add ( "Such scenario generally means that the build will fail with a compilation error due to" + " missing resources in R file." ) ; messageList . add ( "You should consider renaming some of the duplicate packages listed below" + " to avoid the conflict." ) ; messageList . add ( "" ) ; messageList . add ( "Conflicting artifacts:" ) ; messageList . addAll ( duplicatesMessageList ) ; messageList . add ( "" ) ; if ( failOnDuplicatePackages ) { StringBuilder builder = new StringBuilder ( ) ; for ( String line : messageList ) { builder . append ( line ) ; builder . append ( "\n" ) ; } builder . append ( "\n" ) ; builder . append ( "You can downgrade the failure to a warning " ) ; builder . append ( "by setting the 'failOnDuplicatePackages' plugin property to false." ) ; throw new MojoExecutionException ( builder . toString ( ) ) ; } for ( String messageLine : messageList ) { getLog ( ) . warn ( messageLine ) ; } } }
private void checkForConflictingLayouts ( ) MojoExecutionException { final ConflictingLayoutDetector detector = new ConflictingLayoutDetector ( ) ; final FileRetriever retriever = new FileRetriever ( "layout* ) ; detector . addLayoutFiles ( getAndroidManifestPackageName ( ) , retriever . getFileNames ( resourceDirectory ) ) ; for ( final Artifact dependency : getTransitiveDependencyArtifacts ( AAR , APKLIB ) ) { final String packageName = extractPackageNameFromAndroidArtifact ( dependency ) ; final String [] layoutFiles = retriever . getFileNames ( getUnpackedLibResourceFolder ( dependency ) ) ; detector . addLayoutFiles ( packageName , layoutFiles ) ; } final Collection < ConflictingLayout > conflictingLayouts = detector . getConflictingLayouts ( ) ; getLog ( ) . debug ( "checkConflictingLayouts - conflicts : " + conflictingLayouts ) ; if ( ! conflictingLayouts . isEmpty ( ) ) { final List < String > sb = new ArrayList < String > ( ) ; sb . add ( "" ) ; sb . add ( "" ) ; sb . add ( "Duplicate layout files have been detected across more than one Android package." ) ; sb . add ( "" ) ; sb . add ( "Such a scenario generally means that the build will fail with a compilation error due to" ) ; sb . add ( "missing resource files. You should consider renaming some of the layout files listed below" ) ; sb . add ( "to avoid the conflict." ) ; sb . add ( "" ) ; sb . add ( "However, if you believe you know better, then you can downgrade the failure to a warning" ) ; sb . add ( "by setting the failOnConflictingLayouts plugin property to false." ) ; sb . add ( "But you really don't want to do that." ) ; sb . add ( "" ) ; sb . add ( "Conflicting Layouts:" ) ; for ( final ConflictingLayout layout : conflictingLayouts ) { sb . add ( "    " + layout . getLayoutFileName ( ) + "  packages=" + layout . getPackageNames ( ) . toString ( ) ) ; } sb . add ( "" ) ; if ( failOnConflictingLayouts ) { final StringBuilder builder = new StringBuilder ( ) ; for ( final String line : sb ) { builder . append ( line ) ; builder . append ( "\n" ) ; } throw new MojoExecutionException ( builder . toString ( ) ) ; } for ( final String line : sb ) { getLog ( ) . warn ( line ) ; } } }
Map < String , Set < Artifact > > getPackageCompareMap ( Set < Artifact > dependencyArtifacts ) throws MojoExecutionException { if ( dependencyArtifacts == null ) { throw new IllegalArgumentException ( "dependencies must be initialized" ) ; } Map < String , Set < Artifact > > packageCompareMap = new HashMap < String , Set < Artifact > > ( ) ; Set < Artifact > artifactSet = new HashSet < Artifact > ( ) ; artifactSet . add ( project . getArtifact ( ) ) ; packageCompareMap . put ( getAndroidManifestPackageName ( ) , artifactSet ) ; for ( Artifact artifact : dependencyArtifacts ) { String libPackage = extractPackageNameFromAndroidArtifact ( artifact ) ; Set < Artifact > artifacts = packageCompareMap . get ( libPackage ) ; if ( artifacts == null ) { artifacts = new HashSet < Artifact > ( ) ; packageCompareMap . put ( libPackage , artifacts ) ; } artifacts . add ( artifact ) ; } return packageCompareMap ; }
private void generateR ( ) MojoExecutionException { getLog ( ) . info ( "Generating R file for " + project . getArtifact ( ) ) ; genDirectory . mkdirs ( ) ; final AaptPackageCommandBuilder commandBuilder = AaptCommandBuilder . packageResources ( getLog ( ) ) . makePackageDirectories ( ) . setResourceConstantsFolder ( genDirectory ) . forceOverwriteExistingFiles ( ) . disablePngCrunching ( ) . generateRIntoPackage ( customPackage ) . setPathToAndroidManifest ( destinationManifestFile ) . addResourceDirectoriesIfExists ( getResourceOverlayDirectories ( ) ) . addResourceDirectoryIfExists ( resourceDirectory ) . addResourceDirectoriesIfExists ( getLibraryResourceFolders ( ) ) . autoAddOverlay ( ) . addRawAssetsDirectoryIfExists ( combinedAssets ) . addExistingPackageToBaseIncludeSet ( getAndroidSdk ( ) . getAndroidJar ( ) ) . addConfigurations ( configurations ) . setVerbose ( aaptVerbose ) . generateRTextFile ( targetDirectory ) . setProguardOptionsOutputFile ( proguardFile ) . makeResourcesNonConstant ( AAR . equals ( project . getArtifact ( ) . getType ( ) ) ) . addExtraArguments ( aaptExtraArgs ) ; getLog ( ) . debug ( getAndroidSdk ( ) . getAaptPath ( ) + " " + commandBuilder . toString ( ) ) ; try { final CommandExecutor executor = CommandExecutor . Factory . createDefaultCommmandExecutor ( ) ; executor . setLogger ( getLog ( ) ) ; executor . setCaptureStdOut ( true ) ; final List < String > commands = commandBuilder . build ( ) ; executor . executeCommand ( getAndroidSdk ( ) . getAaptPath ( ) , commands , project . getBasedir ( ) , false ) ; } catch ( ExecutionException e ) { throw new MojoExecutionException ( "" , e ) ; } final ResourceClassGenerator resGenerator = new ResourceClassGenerator ( this , targetDirectory , genDirectory ) ; generateCorrectRJavaForApklibDependencies ( resGenerator ) ; generateCorrectRJavaForAarDependencies ( resGenerator ) ; getLog ( ) . info ( "Adding R gen folder to compile classpath: " + genDirectory ) ; project . addCompileSourceRoot ( genDirectory . getAbsolutePath ( ) ) ; }
private void generateCorrectRJavaForApklibDependencies ( ResourceClassGenerator resourceGenerator )            throws MojoExecutionException { getLog ( ) . debug ( "" ) ; getLog ( ) . debug ( "#generateCorrectRJavaFoApklibDeps" ) ; getLog ( ) . debug ( "Generating Rs for apklib deps of project " + project . getArtifact ( ) ) ; final Set < Artifact > apklibDependencies = getTransitiveDependencyArtifacts ( APKLIB ) ; for ( final Artifact artifact : apklibDependencies ) { getLog ( ) . debug ( "Generating apklib R.java for " + artifact . getArtifactId ( ) + "..." ) ; generateRForApkLibDependency ( artifact ) ; } if ( ! apklibDependencies . isEmpty ( ) && APK . equals ( project . getArtifact ( ) . getType ( ) ) ) { getLog ( ) . debug ( "" ) ; getLog ( ) . debug ( "Rewriting R files for APKLIB dependencies : " + apklibDependencies ) ; resourceGenerator . generateLibraryRs ( apklibDependencies ) ; } }
private void generateCorrectRJavaForAarDependencies ( ResourceClassGenerator resourceGenerator )            throws MojoExecutionException { final Set < Artifact > aarLibraries = getTransitiveDependencyArtifacts ( AAR ) ; if ( ! aarLibraries . isEmpty ( ) ) { getLog ( ) . debug ( "Generating R file for AAR dependencies" ) ; resourceGenerator . generateLibraryRs ( aarLibraries ) ; } }
private List < File > getLibraryResourceFolders ( ) { final List < File > resourceFolders = new ArrayList < File > ( ) ; for ( Artifact artifact : getTransitiveDependencyArtifacts ( AAR , APKLIB ) ) { getLog ( ) . debug ( "Considering dep artifact : " + artifact ) ; final File resourceFolder = getUnpackedLibResourceFolder ( artifact ) ; if ( resourceFolder . exists ( ) ) { getLog ( ) . debug ( "Adding apklib or aar resource folder : " + resourceFolder ) ; resourceFolders . add ( resourceFolder ) ; } } return resourceFolders ; }
private void generateRForApkLibDependency ( Artifact apklibArtifact ) throws MojoExecutionException { final File unpackDir = getUnpackedLibFolder ( apklibArtifact ) ; getLog ( ) . debug ( "Generating incomplete R file for apklib: " + apklibArtifact . getGroupId ( ) + ":" + apklibArtifact . getArtifactId ( ) ) ; final File apklibManifest = new File ( unpackDir , "AndroidManifest.xml" ) ; final File apklibResDir = new File ( unpackDir , "res" ) ; List < File > dependenciesResDirectories = new ArrayList < File > ( ) ; final Set < Artifact > apklibDeps = getDependencyResolver ( ) . getLibraryDependenciesFor ( this . session , this . repositorySystem , apklibArtifact ) ; getLog ( ) . debug ( "apklib=" + apklibArtifact + "  dependencies=" + apklibDeps ) ; for ( Artifact dependency : apklibDeps ) { final String extension = dependency . getType ( ) ; final File dependencyResDir = getUnpackedLibResourceFolder ( dependency ) ; if ( ( extension . equals ( APKLIB ) || extension . equals ( AAR ) ) && dependencyResDir . exists ( ) ) { dependenciesResDirectories . add ( dependencyResDir ) ; } } final File apklibCombAssets = new File ( getUnpackedLibFolder ( apklibArtifact ) , "combined-assets" ) ; for ( Artifact dependency : apklibDeps ) { final String extension = dependency . getType ( ) ; final File dependencyAssetsDir = getUnpackedLibAssetsFolder ( dependency ) ; if ( ( extension . equals ( APKLIB ) || extension . equals ( AAR ) ) ) { copyFolder ( dependencyAssetsDir , apklibCombAssets ) ; } } final File apkLibAssetsDir = getUnpackedLibAssetsFolder ( apklibArtifact ) ; copyFolder ( apkLibAssetsDir , apklibCombAssets ) ; final CommandExecutor executor = CommandExecutor . Factory . createDefaultCommmandExecutor ( ) ; executor . setLogger ( getLog ( ) ) ; final AaptCommandBuilder commandBuilder = AaptCommandBuilder . packageResources ( getLog ( ) ) . makeResourcesNonConstant ( ) . makePackageDirectories ( ) . setResourceConstantsFolder ( genDirectory ) . generateRIntoPackage ( extractPackageNameFromAndroidManifest ( apklibManifest ) ) . setPathToAndroidManifest ( apklibManifest ) . addResourceDirectoryIfExists ( apklibResDir ) . addResourceDirectoriesIfExists ( dependenciesResDirectories ) . autoAddOverlay ( ) . addRawAssetsDirectoryIfExists ( apklibCombAssets ) . addExistingPackageToBaseIncludeSet ( getAndroidSdk ( ) . getAndroidJar ( ) ) . addConfigurations ( configurations ) . setVerbose ( aaptVerbose ) . addExtraArguments ( aaptExtraArgs ) . generateRTextFile ( unpackDir ) ; getLog ( ) . debug ( getAndroidSdk ( ) . getAaptPath ( ) + " " + commandBuilder . toString ( ) ) ; try { executor . setCaptureStdOut ( true ) ; final List < String > commands = commandBuilder . build ( ) ; executor . executeCommand ( getAndroidSdk ( ) . getAaptPath ( ) , commands , project . getBasedir ( ) , false ) ; } catch ( ExecutionException e ) { throw new MojoExecutionException ( "" , e ) ; } }
private void generateBuildConfig ( ) MojoExecutionException { getLog ( ) . debug ( "Generating BuildConfig file" ) ; String packageName = extractPackageNameFromAndroidManifest ( destinationManifestFile ) ; if ( StringUtils . isNotBlank ( customPackage ) ) { packageName = customPackage ; } generateBuildConfigForPackage ( packageName ) ; if ( project . getPackaging ( ) . equals ( AAR ) ) { return; } for ( Artifact artifact : getTransitiveDependencyArtifacts ( APKLIB , AAR ) ) { if ( skipBuildConfigGeneration ( artifact ) ) { getLog ( ) . info ( "Skip BuildConfig.java generation for " + artifact . getGroupId ( ) + " " + artifact . getArtifactId ( ) ) ; continue; } final String depPackageName = extractPackageNameFromAndroidArtifact ( artifact ) ; generateBuildConfigForPackage ( depPackageName ) ; } }
private boolean skipBuildConfigGeneration ( Artifact artifact ) throws MojoExecutionException { if ( artifact . getType ( ) . equals ( AAR ) ) { String depPackageName = extractPackageNameFromAndroidArtifact ( artifact ) ; if ( isBuildConfigPresent ( artifact , depPackageName ) ) { return true ; } Set < Artifact > transitiveDep = getArtifactResolverHelper ( ) . getFilteredArtifacts ( project . getArtifacts ( ) , AAR ) ; for ( Artifact transitiveArtifact : transitiveDep ) { if ( isBuildConfigPresent ( transitiveArtifact , depPackageName ) ) { return true ; } } } return false ; }
private boolean isBuildConfigPresent ( Artifact artifact ) throws MojoExecutionException { String depPackageName = extractPackageNameFromAndroidArtifact ( artifact ) ; return isBuildConfigPresent ( artifact , depPackageName ) ; }
private boolean isBuildConfigPresent ( Artifact artifact , String packageName ) throws MojoExecutionException { try { JarFile jar = new JarFile ( getUnpackedAarClassesJar ( artifact ) ) ; JarEntry entry = jar . getJarEntry ( packageName . replace ( '.' , '/' ) + "/BuildConfig.class" ) ; return ( entry != null ) ; } catch ( IOException e ) { getLog ( ) . error ( "Error generating BuildConfig " , e ) ; throw new MojoExecutionException ( "Error generating BuildConfig" , e ) ; } }
private void generateBuildConfigForPackage ( String packageName ) throws MojoExecutionException { getLog ( ) . debug ( "Creating BuildConfig for " + packageName ) ; File outputFolder = new File ( genDirectory , packageName . replace ( "." , File . separator ) ) ; outputFolder . mkdirs ( ) ; StringBuilder buildConfig = new StringBuilder ( ) ; buildConfig . append ( "package " ) . append ( packageName ) . append ( ";\n\n" ) ; buildConfig . append ( "public final class BuildConfig {\n" ) ; buildConfig . append ( "  public static final boolean DEBUG = " ) . append ( ! release ) . append ( ";\n" ) ; for ( BuildConfigConstant constant : buildConfigConstants ) { String value = constant . getValue ( ) ; if ( "String" . equals ( constant . getType ( ) ) ) { value = "\"" + value + "\"" ; } buildConfig . append ( "  public static final " ) . append ( constant . getType ( ) ) . append ( " " ) . append ( constant . getName ( ) ) . append ( " = " ) . append ( value ) . append ( ";\n" ) ; } buildConfig . append ( "}\n" ) ; File outputFile = new File ( outputFolder , "BuildConfig.java" ) ; try { FileUtils . writeStringToFile ( outputFile , buildConfig . toString ( ) ) ; } catch ( IOException e ) { getLog ( ) . error ( "Error generating BuildConfig " , e ) ; throw new MojoExecutionException ( "Error generating BuildConfig" , e ) ; } }
private void generateAidlFiles ( Map < File , String [] > files )            throws MojoExecutionException { List < String > protoCommands = new ArrayList < String > ( ) ; protoCommands . add ( "-p" + getAndroidSdk ( ) . getPathForFrameworkAidl ( ) ) ; genDirectoryAidl . mkdirs ( ) ; getLog ( ) . info ( "Adding AIDL gen folder to compile classpath: " + genDirectoryAidl ) ; project . addCompileSourceRoot ( genDirectoryAidl . getPath ( ) ) ; Set < File > sourceDirs = files . keySet ( ) ; for ( File sourceDir : sourceDirs ) { protoCommands . add ( "-I" + sourceDir ) ; } for ( File sourceDir : sourceDirs ) { for ( String relativeAidlFileName : files . get ( sourceDir ) ) { File targetDirectory = new File ( genDirectoryAidl , new File ( relativeAidlFileName ) . getParent ( ) ) ; targetDirectory . mkdirs ( ) ; final String shortAidlFileName = new File ( relativeAidlFileName ) . getName ( ) ; final String shortJavaFileName = shortAidlFileName . substring ( 0 , shortAidlFileName . lastIndexOf ( "." ) ) + ".java" ; final File aidlFileInSourceDirectory = new File ( sourceDir , relativeAidlFileName ) ; List < String > commands = new ArrayList < String > ( protoCommands ) ; commands . add ( aidlFileInSourceDirectory . getAbsolutePath ( ) ) ; commands . add ( new File ( targetDirectory , shortJavaFileName ) . getAbsolutePath ( ) ) ; try { CommandExecutor executor = CommandExecutor . Factory . createDefaultCommmandExecutor ( ) ; executor . setLogger ( this . getLog ( ) ) ; executor . setCaptureStdOut ( true ) ; executor . executeCommand ( getAndroidSdk ( ) . getAidlPath ( ) , commands , project . getBasedir ( ) , false ) ; } catch ( ExecutionException e ) { throw new MojoExecutionException ( "" , e ) ; } } } }
private String [] findRelativeAidlFileNames ( File sourceDirectory ) { final FileRetriever retriever = new FileRetriever ( "** ) ; final String [] relativeAidlFileNames = retriever . getFileNames ( sourceDirectory ) ; if ( relativeAidlFileNames . length == 0 ) { getLog ( ) . debug ( "ANDROID-904-002: No aidl files found" ) ; } else { getLog ( ) . info ( "ANDROID-904-002: Found aidl files: Count = " + relativeAidlFileNames . length ) ; } return relativeAidlFileNames ; }
private boolean isCurrentProjectAndroid ( ) { Set < String > androidArtifacts = new HashSet < String > ( ) { { addAll ( Arrays . asList ( APK , APKLIB , APKSOURCES , AAR ) ) ; } } ; return androidArtifacts . contains ( project . getArtifact ( ) . getType ( ) ) ; }
protected void instrument ( ) MojoExecutionException , MojoFailureException { parseConfiguration ( ) ; if ( parsedInstrumentationPackage == null ) { parsedInstrumentationPackage = extractPackageNameFromAndroidManifest ( destinationManifestFile ) ; } if ( parsedInstrumentationRunner == null ) { parsedInstrumentationRunner = extractInstrumentationRunnerFromAndroidManifest ( destinationManifestFile ) ; } packagesList = buildCommaSeparatedString ( parsedPackages ) ; packagesExists = StringUtils . isNotBlank ( packagesList ) ; if ( parsedClasses != null ) { classesExists = parsedClasses . size ( ) > 0 ; } else { classesExists = false ; } if ( classesExists && packagesExists ) { throw new MojoFailureException ( "packages and classes are mutually exclusive. They cannot be specified at" + " the same time. Please specify either packages or classes. For details, see " + "http: ) ; } DeviceCallback instrumentationTestExecutor = new DeviceCallback ( ) { public void doWithDevice ( final IDevice device ) throws MojoExecutionException , MojoFailureException { String deviceLogLinePrefix = DeviceHelper . getDeviceLogLinePrefix ( device ) ; RemoteAndroidTestRunner remoteAndroidTestRunner = new RemoteAndroidTestRunner ( parsedInstrumentationPackage , parsedInstrumentationRunner , device ) ; if ( packagesExists ) { for ( String str : packagesList . split ( "," ) ) { remoteAndroidTestRunner . setTestPackageName ( str ) ; getLog ( ) . info ( deviceLogLinePrefix + "Running tests for specified test package: " + str ) ; } } if ( classesExists ) { remoteAndroidTestRunner . setClassNames ( parsedClasses . toArray ( new String [ parsedClasses . size ( ) ] ) ) ; getLog ( ) . info ( deviceLogLinePrefix + "Running tests for specified test classes/methods: " + parsedClasses ) ; } if ( parsedAnnotations != null ) { for ( String annotation : parsedAnnotations ) { remoteAndroidTestRunner . addInstrumentationArg ( "annotation" , annotation ) ; } } if ( parsedExcludeAnnotations != null ) { for ( String annotation : parsedExcludeAnnotations ) { remoteAndroidTestRunner . addInstrumentationArg ( "notAnnotation" , annotation ) ; } } remoteAndroidTestRunner . setDebug ( parsedDebug ) ; remoteAndroidTestRunner . setCoverage ( parsedCoverage ) ; if ( StringUtils . isNotBlank ( parsedCoverageFile ) ) { remoteAndroidTestRunner . addInstrumentationArg ( "coverageFile" , parsedCoverageFile ) ; } remoteAndroidTestRunner . setLogOnly ( parsedLogOnly ) ; if ( StringUtils . isNotBlank ( parsedTestSize ) ) { IRemoteAndroidTestRunner . TestSize validSize = IRemoteAndroidTestRunner . TestSize . getTestSize ( parsedTestSize ) ; remoteAndroidTestRunner . setTestSize ( validSize ) ; } addAllInstrumentationArgs ( remoteAndroidTestRunner , parsedInstrumentationArgs ) ; getLog ( ) . info ( deviceLogLinePrefix + "Running instrumentation tests in " + parsedInstrumentationPackage ) ; try { AndroidTestRunListener testRunListener = new AndroidTestRunListener ( device , getLog ( ) , parsedCreateReport , false , "" , "" , targetDirectory ) ; remoteAndroidTestRunner . run ( testRunListener ) ; if ( testRunListener . hasFailuresOrErrors ( ) && ! testFailSafe ) { throw new MojoFailureException ( deviceLogLinePrefix + "Tests failed on device." ) ; } if ( testRunListener . testRunFailed ( ) && ! testFailSafe ) { throw new MojoFailureException ( deviceLogLinePrefix + "Test run failed to complete: " + testRunListener . getTestRunFailureCause ( ) ) ; } if ( testRunListener . threwException ( ) && ! testFailSafe ) { throw new MojoFailureException ( deviceLogLinePrefix + testRunListener . getExceptionMessages ( ) ) ; } } catch ( TimeoutException e ) { throw new MojoExecutionException ( deviceLogLinePrefix + "timeout" , e ) ; } catch ( AdbCommandRejectedException e ) { throw new MojoExecutionException ( deviceLogLinePrefix + "adb command rejected" , e ) ; } catch ( ShellCommandUnresponsiveException e ) { throw new MojoExecutionException ( deviceLogLinePrefix + "shell command " + "unresponsive" , e ) ; } catch ( IOException e ) { throw new MojoExecutionException ( deviceLogLinePrefix + "IO problem" , e ) ; } } } ; instrumentationTestExecutor = new ScreenshotServiceWrapper ( instrumentationTestExecutor , project , getLog ( ) ) ; doWithDevices ( instrumentationTestExecutor ) ; }
public void doWithDevice ( final IDevice device ) throws MojoExecutionException , MojoFailureException { String deviceLogLinePrefix = DeviceHelper . getDeviceLogLinePrefix ( device ) ; RemoteAndroidTestRunner remoteAndroidTestRunner = new RemoteAndroidTestRunner ( parsedInstrumentationPackage , parsedInstrumentationRunner , device ) ; if ( packagesExists ) { for ( String str : packagesList . split ( "," ) ) { remoteAndroidTestRunner . setTestPackageName ( str ) ; getLog ( ) . info ( deviceLogLinePrefix + "Running tests for specified test package: " + str ) ; } } if ( classesExists ) { remoteAndroidTestRunner . setClassNames ( parsedClasses . toArray ( new String [ parsedClasses . size ( ) ] ) ) ; getLog ( ) . info ( deviceLogLinePrefix + "Running tests for specified test classes/methods: " + parsedClasses ) ; } if ( parsedAnnotations != null ) { for ( String annotation : parsedAnnotations ) { remoteAndroidTestRunner . addInstrumentationArg ( "annotation" , annotation ) ; } } if ( parsedExcludeAnnotations != null ) { for ( String annotation : parsedExcludeAnnotations ) { remoteAndroidTestRunner . addInstrumentationArg ( "notAnnotation" , annotation ) ; } } remoteAndroidTestRunner . setDebug ( parsedDebug ) ; remoteAndroidTestRunner . setCoverage ( parsedCoverage ) ; if ( StringUtils . isNotBlank ( parsedCoverageFile ) ) { remoteAndroidTestRunner . addInstrumentationArg ( "coverageFile" , parsedCoverageFile ) ; } remoteAndroidTestRunner . setLogOnly ( parsedLogOnly ) ; if ( StringUtils . isNotBlank ( parsedTestSize ) ) { IRemoteAndroidTestRunner . TestSize validSize = IRemoteAndroidTestRunner . TestSize . getTestSize ( parsedTestSize ) ; remoteAndroidTestRunner . setTestSize ( validSize ) ; } addAllInstrumentationArgs ( remoteAndroidTestRunner , parsedInstrumentationArgs ) ; getLog ( ) . info ( deviceLogLinePrefix + "Running instrumentation tests in " + parsedInstrumentationPackage ) ; try { AndroidTestRunListener testRunListener = new AndroidTestRunListener ( device , getLog ( ) , parsedCreateReport , false , "" , "" , targetDirectory ) ; remoteAndroidTestRunner . run ( testRunListener ) ; if ( testRunListener . hasFailuresOrErrors ( ) && ! testFailSafe ) { throw new MojoFailureException ( deviceLogLinePrefix + "Tests failed on device." ) ; } if ( testRunListener . testRunFailed ( ) && ! testFailSafe ) { throw new MojoFailureException ( deviceLogLinePrefix + "Test run failed to complete: " + testRunListener . getTestRunFailureCause ( ) ) ; } if ( testRunListener . threwException ( ) && ! testFailSafe ) { throw new MojoFailureException ( deviceLogLinePrefix + testRunListener . getExceptionMessages ( ) ) ; } } catch ( TimeoutException e ) { throw new MojoExecutionException ( deviceLogLinePrefix + "timeout" , e ) ; } catch ( AdbCommandRejectedException e ) { throw new MojoExecutionException ( deviceLogLinePrefix + "adb command rejected" , e ) ; } catch ( ShellCommandUnresponsiveException e ) { throw new MojoExecutionException ( deviceLogLinePrefix + "shell command " + "unresponsive" , e ) ; } catch ( IOException e ) { throw new MojoExecutionException ( deviceLogLinePrefix + "IO problem" , e ) ; } }
private void addAllInstrumentationArgs ( final RemoteAndroidTestRunner remoteAndroidTestRunner , final Map < String , String > parsedInstrumentationArgs ) { for ( final Map . Entry < String , String > entry : parsedInstrumentationArgs . entrySet ( ) ) { remoteAndroidTestRunner . addInstrumentationArg ( entry . getKey ( ) , entry . getValue ( ) ) ; } }
private void parseConfiguration ( ) { if ( test != null ) { if ( StringUtils . isNotEmpty ( test . getSkip ( ) ) ) { parsedSkip = test . getSkip ( ) ; } else { parsedSkip = testSkip ; } if ( StringUtils . isNotEmpty ( test . getInstrumentationPackage ( ) ) ) { parsedInstrumentationPackage = test . getInstrumentationPackage ( ) ; } else { parsedInstrumentationPackage = testInstrumentationPackage ; } if ( StringUtils . isNotEmpty ( test . getInstrumentationRunner ( ) ) ) { parsedInstrumentationRunner = test . getInstrumentationRunner ( ) ; } else { parsedInstrumentationRunner = testInstrumentationRunner ; } if ( test . getClasses ( ) != null && ! test . getClasses ( ) . isEmpty ( ) ) { parsedClasses = test . getClasses ( ) ; } else { parsedClasses = testClasses ; } if ( test . getAnnotations ( ) != null && ! test . getAnnotations ( ) . isEmpty ( ) ) { parsedAnnotations = test . getAnnotations ( ) ; } else { parsedAnnotations = testAnnotations ; } if ( test . getExcludeAnnotations ( ) != null && ! test . getExcludeAnnotations ( ) . isEmpty ( ) ) { parsedExcludeAnnotations = test . getExcludeAnnotations ( ) ; } else { parsedExcludeAnnotations = testExcludeAnnotations ; } if ( test . getPackages ( ) != null && ! test . getPackages ( ) . isEmpty ( ) ) { parsedPackages = test . getPackages ( ) ; } else { parsedPackages = testPackages ; } if ( StringUtils . isNotEmpty ( test . getTestSize ( ) ) ) { parsedTestSize = test . getTestSize ( ) ; } else { parsedTestSize = testTestSize ; } if ( test . isCoverage ( ) != null ) { parsedCoverage = test . isCoverage ( ) ; } else { parsedCoverage = testCoverage ; } if ( test . getCoverageFile ( ) != null ) { parsedCoverageFile = test . getCoverageFile ( ) ; } else { parsedCoverageFile = "" ; } if ( test . isDebug ( ) != null ) { parsedDebug = test . isDebug ( ) ; } else { parsedDebug = testDebug ; } if ( test . isLogOnly ( ) != null ) { parsedLogOnly = test . isLogOnly ( ) ; } else { parsedLogOnly = testLogOnly ; } if ( test . isCreateReport ( ) != null ) { parsedCreateReport = test . isCreateReport ( ) ; } else { parsedCreateReport = testCreateReport ; } parsedInstrumentationArgs = InstrumentationArgumentParser . parse ( test . getInstrumentationArgs ( ) ) ; } else { parsedSkip = testSkip ; parsedInstrumentationPackage = testInstrumentationPackage ; parsedInstrumentationRunner = testInstrumentationRunner ; parsedClasses = testClasses ; parsedAnnotations = testAnnotations ; parsedExcludeAnnotations = testExcludeAnnotations ; parsedPackages = testPackages ; parsedTestSize = testTestSize ; parsedCoverage = testCoverage ; parsedCoverageFile = testCoverageFile ; parsedDebug = testDebug ; parsedLogOnly = testLogOnly ; parsedCreateReport = testCreateReport ; parsedInstrumentationArgs = InstrumentationArgumentParser . parse ( testInstrumentationArgs ) ; } }
protected boolean isEnableIntegrationTest ( ) MojoFailureException , MojoExecutionException { parseConfiguration ( ) ; if ( mavenTestSkip ) { getLog ( ) . info ( "maven.test.skip set - skipping tests" ) ; return false ; } if ( mavenSkipTests ) { getLog ( ) . info ( "maven.skip.tests set - skipping tests" ) ; return false ; } if ( "true" . equalsIgnoreCase ( parsedSkip ) ) { getLog ( ) . info ( "android.test.skip set - skipping tests" ) ; return false ; } if ( "false" . equalsIgnoreCase ( parsedSkip ) ) { return true ; } if ( parsedSkip == null || "auto" . equalsIgnoreCase ( parsedSkip ) ) { if ( extractInstrumentationRunnerFromAndroidManifest ( destinationManifestFile ) == null ) { getLog ( ) . info ( "No InstrumentationRunner found - skipping tests" ) ; return false ; } return AndroidTestFinder . containsAndroidTests ( projectOutputDirectory ) ; } throw new MojoFailureException ( "android.test.skip must be configured as 'true', 'false' or 'auto'." ) ; }
protected static String buildCommaSeparatedString ( List < String > lines ) { if ( lines == null || lines . size ( ) == 0 ) { return null ; } List < String > strings = new ArrayList < String > ( lines . size ( ) ) ; for ( String str : lines ) { if ( StringUtils . isNotBlank ( str ) ) { strings . add ( StringUtils . trimToEmpty ( str ) ) ; } } return StringUtils . join ( strings , "," ) ; }
@ Override public Loader < Cursor > onCreateLoader ( int id , Bundle args ) { final int currentStopOrder = PreferenceUtils . getStopSortOrderFromPreferences ( ) ; setSortByClause ( currentStopOrder ) ; return new CursorLoader ( getActivity ( ) , ObaContract . Stops . CONTENT_URI , PROJECTION , ObaContract . Stops . FAVORITE + "=1" + ( Application . get ( ) . getCurrentRegion ( ) == null ? "" : " AND " + QueryUtils . getRegionWhere ( ObaContract . Stops . REGION_ID , Application . get ( ) . getCurrentRegion ( ) . getId ( ) ) ) , null , sortBy ) ; }
@ Override public void onActivityCreated ( Bundle savedInstanceState ) { super. onActivityCreated ( savedInstanceState ) ; setHasOptionsMenu ( true ) ; showStarredStopsTutorials ( ) ; }
@ Override public void onHiddenChanged ( boolean hidden ) { super. onHiddenChanged ( hidden ) ; if ( ! hidden ) { showStarredStopsTutorials ( ) ; } }
private void showStarredStopsTutorials ( ) { if ( ! isVisible ( ) ) { return; } if ( mAdapter . getCount ( ) > 0 ) { ShowcaseViewUtils . showTutorial ( ShowcaseViewUtils . TUTORIAL_STARRED_STOPS_SHORTCUT , ( AppCompatActivity ) getActivity ( ) , null ) ; } if ( mAdapter . getCount ( ) > 1 ) { ShowcaseViewUtils . showTutorial ( ShowcaseViewUtils . TUTORIAL_STARRED_STOPS_SORT , ( AppCompatActivity ) getActivity ( ) , null ) ; } }
@ Override public void onStart ( ) { ObaAnalytics . reportFragmentStart ( this ) ; super. onStart ( ) ; }
@ Override public void onCreateContextMenu ( ContextMenu menu , View v , ContextMenuInfo menuInfo ) { super. onCreateContextMenu ( menu , v , menuInfo ) ; menu . add ( 0 , CONTEXT_MENU_DELETE , 0 , R . string . my_context_remove_star ) ; }
@ Override public boolean onContextItemSelected ( android . view . MenuItem item ) { AdapterContextMenuInfo info = ( AdapterContextMenuInfo ) item . getMenuInfo ( ) ; switch ( item . getItemId ( ) ) { case CONTEXT_MENU_DELETE : final String id = QueryUtils . StopList . getId ( getListView ( ) , info . position ) ; final Uri uri = Uri . withAppendedPath ( ObaContract . Stops . CONTENT_URI , id ) ; ObaContract . Stops . markAsFavorite ( getActivity ( ) , uri , false ) ; return true ; default: return super. onContextItemSelected ( item ) ; } }
@ Override public void onCreateOptionsMenu ( Menu menu , MenuInflater inflater ) { inflater . inflate ( R . menu . my_starred_stop_options , menu ) ; }
@ Override public boolean onOptionsItemSelected ( MenuItem item ) { final int id = item . getItemId ( ) ; if ( id == R . id . clear_starred ) { new ClearDialog ( ) . show ( getActivity ( ) . getSupportFragmentManager ( ) , "confirm_clear_starred_stops" ) ; return true ; } else if ( id == R . id . sort_stops ) { ShowcaseViewUtils . doNotShowTutorial ( ShowcaseViewUtils . TUTORIAL_STARRED_STOPS_SORT ) ; showSortByDialog ( ) ; } return false ; }
private void showSortByDialog ( ) { AlertDialog . Builder builder = new AlertDialog . Builder ( getActivity ( ) ) ; builder . setTitle ( R . string . menu_option_sort_by ) ; final int currentStopOrder = PreferenceUtils . getStopSortOrderFromPreferences ( ) ; builder . setSingleChoiceItems ( R . array . sort_stops , currentStopOrder , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int index ) { if ( currentStopOrder != index ) { setSortByClause ( index ) ; getLoaderManager ( ) . restartLoader ( 0 , null , MyStarredStopsFragment .this ) ; } dialog . dismiss ( ) ; } } ) ; AlertDialog dialog = builder . create ( ) ; dialog . setOwnerActivity ( getActivity ( ) ) ; dialog . show ( ) ; }
public void onClick ( DialogInterface dialog , int index ) { if ( currentStopOrder != index ) { setSortByClause ( index ) ; getLoaderManager ( ) . restartLoader ( 0 , null , MyStarredStopsFragment .this ) ; } dialog . dismiss ( ) ; }
private void setSortByClause ( int index ) { switch ( index ) { case 0 : Log . d ( TAG , "Sort by name" ) ; sortBy = ObaContract . Stops . UI_NAME + " asc" ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getActivity ( ) . getString ( R . string . analytics_action_button_press ) , getActivity ( ) . getString ( R . string . analytics_label_sort_by_name_stops ) ) ; break; case 1 : Log . d ( TAG , "Sort by frequently used" ) ; sortBy = ObaContract . Stops . USE_COUNT + " desc" ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getActivity ( ) . getString ( R . string . analytics_action_button_press ) , getActivity ( ) . getString ( R . string . analytics_label_sort_by_mfu_stops ) ) ; break; } final String [] sortOptions = getResources ( ) . getStringArray ( R . array . sort_stops ) ; PreferenceUtils . saveString ( getResources ( ) . getString ( R . string . preference_key_default_stop_sort ) , sortOptions [ index ] ) ; }
@ Override protected int getEmptyText ( ) { return R . string . my_no_starred_stops ; }
@ Override protected void doClear ( ) { ObaContract . Stops . markAsFavorite ( getActivity ( ) , ObaContract . Stops . CONTENT_URI , false ) ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getString ( R . string . analytics_action_edit_field ) , getString ( R . string . analytics_label_edit_field_bookmark_delete ) ) ; }
@ Before public void setUp ( ) { sdkTestSupport = new SdkTestSupport ( ) ; }
@ Test public void givenToolAdbThenPathIsPlatformTools ( ) { final String pathForTool = sdkTestSupport . getSdk_with_platform_default ( ) . getAdbPath ( ) ; Assert . assertEquals ( new File ( sdkTestSupport . getEnv_ANDROID_HOME ( ) + "/platform-tools" ) . getAbsolutePath ( ) , new File ( pathForTool ) . getParentFile ( ) . getAbsolutePath ( ) ) ; }
@ Test public void givenToolAndroidThenPathIsCommon ( ) { final String pathForTool = sdkTestSupport . getSdk_with_platform_default ( ) . getAndroidPath ( ) ; Assert . assertEquals ( new File ( sdkTestSupport . getEnv_ANDROID_HOME ( ) + "/tools" ) . getAbsolutePath ( ) , new File ( pathForTool ) . getParentFile ( ) . getAbsolutePath ( ) ) ; }
@ Test ( expected = InvalidSdkException .class ) public void givenInvalidPlatformStringThenException ( ) IOException { final AndroidSdk sdk = new AndroidSdk ( new File ( sdkTestSupport . getEnv_ANDROID_HOME ( ) ) , "invalidplatform" ) ; }
@ Test public void givenPlatformNullThenPlatformisSomethingValidLooking ( ) IllegalAccessException , URISyntaxException { final File sdkPath = ( File ) ReflectionUtils . getValueIncludingSuperclasses ( "sdkPath" , sdkTestSupport . getSdk_with_platform_default ( ) ) ; final File platform = sdkTestSupport . getSdk_with_platform_default ( ) . getPlatform ( ) ; final String platformPath = platform . getAbsoluteFile ( ) . toURI ( ) . toString ( ) ; final String regex = "/platforms/android-.*" ; String matcher = platformPath . substring ( sdkPath . toURI ( ) . toString ( ) . length ( ) - 1 ) ; Assert . assertTrue ( String . format ( "Platform [%s] does not match regex: [%s]" , matcher , regex ) , matcher . matches ( regex ) ) ; }
@ Test public void validPlatformsAndApiLevels19 ( ) { final AndroidSdk sdk19 = new AndroidSdk ( new File ( sdkTestSupport . getEnv_ANDROID_HOME ( ) ) , "19" ) ; }
@ Test public void validPlatformsAndApiLevels22 ( ) { final AndroidSdk sdk22 = new AndroidSdk ( new File ( sdkTestSupport . getEnv_ANDROID_HOME ( ) ) , "22" , null ) ; Assert . assertTrue ( sdk22 . getAaptPath ( ) != null && ! sdk22 . getAaptPath ( ) . equals ( "" ) ) ; }
@ Test public void validPlatformsAndApiLevels25 ( ) { final AndroidSdk sdk25 = new AndroidSdk ( new File ( sdkTestSupport . getEnv_ANDROID_HOME ( ) ) , "25" , "25.0.2" ) ; Assert . assertTrue ( sdk25 . getAaptPath ( ) != null && ! sdk25 . getAaptPath ( ) . equals ( "" ) ) ; }
@ Test public void validPlatformsAndApiLevels23 ( ) { final AndroidSdk sdk23 = new AndroidSdk ( new File ( sdkTestSupport . getEnv_ANDROID_HOME ( ) ) , "23" ) ; Assert . assertTrue ( sdk23 . getAaptPath ( ) != null && ! sdk23 . getAaptPath ( ) . equals ( "" ) ) ; }
@ Test ( expected = InvalidSdkException .class ) public void invalidPlatformAndApiLevels ( ) { final AndroidSdk invalid = new AndroidSdk ( new File ( sdkTestSupport . getEnv_ANDROID_HOME ( ) ) , "invalid" ) ; }
@ Test ( expected = NumberFormatException .class ) public void invalidBuildTools ( ) { final AndroidSdk invalid = new AndroidSdk ( new File ( sdkTestSupport . getEnv_ANDROID_HOME ( ) ) , "19" , "invalid" ) ; invalid . getAaptPath ( ) ; }
@ Ignore @ Test public void validPlatformsAndApiLevelsWithDiffBuildTools1 ( ) { final AndroidSdk sdk = new AndroidSdk ( new File ( sdkTestSupport . getEnv_ANDROID_HOME ( ) ) , "19" , "25.0.2" ) ; Assert . assertTrue ( sdk . getAaptPath ( ) != null && ! sdk . getAaptPath ( ) . equals ( "" ) ) ; }
@ Test public void validPlatformsAndApiLevelsWithDiffBuildTools2 ( ) { final AndroidSdk sdk = new AndroidSdk ( new File ( sdkTestSupport . getEnv_ANDROID_HOME ( ) ) , "19" , "24.0.1" ) ; Assert . assertTrue ( sdk . getAaptPath ( ) != null && ! sdk . getAaptPath ( ) . equals ( "" ) ) ; }
@ Test public void validPlatformsAndApiLevelsWithDiffBuildToolsMinor ( ) { final AndroidSdk sdk = new AndroidSdk ( new File ( sdkTestSupport . getEnv_ANDROID_HOME ( ) ) , "19" , "24.0.2" ) ; Assert . assertTrue ( sdk . getAaptPath ( ) != null && ! sdk . getAaptPath ( ) . equals ( "" ) ) ; }
public static AutofillService getInstance ( ) { return instance ; }
public void setResultData ( Intent data ) { resultData = data ; }
public void setPickedPassword ( String path ) { items . add ( new File ( PasswordRepository . getRepositoryDirectory ( getApplicationContext ( ) ) + "/" + path + ".gpg" ) ) ; bindDecryptAndVerify ( ) ; }
@ Override public void onCreate ( ) { super. onCreate ( ) ; instance = this ; }
@ Override protected void onServiceConnected ( ) { super. onServiceConnected ( ) ; serviceConnection = new OpenPgpServiceConnection ( AutofillService .this , "org.sufficientlysecure.keychain" ) ; serviceConnection . bindToService ( ) ; settings = PreferenceManager . getDefaultSharedPreferences ( this ) ; }
@ Override public void onAccessibilityEvent ( AccessibilityEvent event ) { if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . JELLY_BEAN_MR2 ) { return; } if ( event . getEventType ( ) == AccessibilityEvent . TYPE_WINDOW_STATE_CHANGED && event . getPackageName ( ) != null && event . getPackageName ( ) . equals ( packageName ) && resultData != null ) { bindDecryptAndVerify ( ) ; } if ( event . getEventType ( ) == AccessibilityEvent . TYPE_WINDOW_STATE_CHANGED || ( event . getEventType ( ) == AccessibilityEvent . TYPE_WINDOW_CONTENT_CHANGED && event . getPackageName ( ) != null && ( event . getPackageName ( ) . equals ( "com.android.chrome" ) || event . getPackageName ( ) . equals ( "com.android.browser" ) ) ) ) { AccessibilityNodeInfo root = getRootInActiveWindow ( ) ; webViewTitle = searchWebView ( root ) ; webViewURL = null ; if ( webViewTitle != null ) { List < AccessibilityNodeInfo > nodes = root . findAccessibilityNodeInfosByViewId ( "com.android.chrome:id/url_bar" ) ; if ( nodes . isEmpty ( ) ) { nodes = root . findAccessibilityNodeInfosByViewId ( "com.android.browser:id/url" ) ; } for ( AccessibilityNodeInfo node : nodes ) if ( node . getText ( ) != null ) { try { webViewURL = new URL ( node . getText ( ) . toString ( ) ) . getHost ( ) ; } catch ( MalformedURLException e ) { if ( e . toString ( ) . contains ( "Protocol not found" ) ) { try { webViewURL = new URL ( "http: + node . getText ( ) . toString ( ) ) . getHost ( ) ; } catch ( MalformedURLException ignored ) {                                } } } } } } if ( ! event . isPassword ( ) || event . getEventType ( ) == AccessibilityEvent . TYPE_WINDOW_CONTENT_CHANGED || event . getPackageName ( ) != null && event . getPackageName ( ) . equals ( "org.sufficientlysecure.keychain" ) || event . getPackageName ( ) != null && event . getPackageName ( ) . equals ( "com.android.systemui" ) ) { dismissDialog ( event ) ; return; } if ( dialog != null && dialog . isShowing ( ) ) { if ( event . getEventType ( ) == AccessibilityEvent . TYPE_VIEW_CLICKED ) { return; } dialog . dismiss ( ) ; dialog = null ; } if ( ignoreActionFocus ) { ignoreActionFocus = false ; return; } if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . M && ! Settings . canDrawOverlays ( this ) ) { Intent intent = new Intent ( Settings . ACTION_MANAGE_OVERLAY_PERMISSION , Uri . parse ( "package:" + getPackageName ( ) ) ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; startActivity ( intent ) ; return; } info = event . getSource ( ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . LOLLIPOP ) { window = info . getWindow ( ) ; } String packageName ; String appName ; boolean isWeb ; if ( webViewTitle == null || ( webViewTitle . equals ( "" ) && webViewURL == null ) ) { packageName = info . getPackageName ( ) . toString ( ) ; PackageManager packageManager = getPackageManager ( ) ; ApplicationInfo applicationInfo ; try { applicationInfo = packageManager . getApplicationInfo ( event . getPackageName ( ) . toString ( ) , 0 ) ; } catch ( PackageManager . NameNotFoundException e ) { applicationInfo = null ; } appName = ( applicationInfo != null ? packageManager . getApplicationLabel ( applicationInfo ) : "" ) . toString ( ) ; isWeb = false ; setAppMatchingPasswords ( appName , packageName ) ; } else { packageName = setWebMatchingPasswords ( webViewTitle , webViewURL ) ; appName = packageName ; isWeb = true ; } if ( items . isEmpty ( ) && ! settings . getBoolean ( "autofill_always" , false ) ) { return; } showDialog ( packageName , appName , isWeb ) ; }
private String searchWebView ( AccessibilityNodeInfo source ) { if ( source == null ) { return null ; } for ( int i = 0 ; i < source . getChildCount ( ) ; i ++ ) { AccessibilityNodeInfo u = source . getChild ( i ) ; if ( u == null ) { continue; } if ( u . getClassName ( ) != null && u . getClassName ( ) . equals ( "android.webkit.WebView" ) ) { if ( u . getContentDescription ( ) != null ) { return u . getContentDescription ( ) . toString ( ) ; } return "" ; } if ( searchWebView ( u ) != null ) { return searchWebView ( u ) ; } u . recycle ( ) ; } return null ; }
private void dismissDialog ( AccessibilityEvent event ) { boolean dismiss ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . LOLLIPOP ) { dismiss = ! getWindows ( ) . contains ( window ) ; } else { dismiss = ! ( event . getEventType ( ) == AccessibilityEvent . TYPE_WINDOW_STATE_CHANGED && event . getPackageName ( ) != null && event . getPackageName ( ) . toString ( ) . contains ( "inputmethod" ) ) ; } if ( dismiss && dialog != null && dialog . isShowing ( ) ) { dialog . dismiss ( ) ; dialog = null ; } }
private String setWebMatchingPasswords ( String webViewTitle , String webViewURL ) { String settingsURL = webViewURL ; String defValue = settings . getBoolean ( "autofill_default" , true ) ? "/first" : "/never" ; SharedPreferences prefs ; String preference ; prefs = getSharedPreferences ( "autofill_web" , Context . MODE_PRIVATE ) ; preference = defValue ; if ( webViewURL != null ) { Map < String , ? > prefsMap = prefs . getAll ( ) ; for ( String key : prefsMap . keySet ( ) ) { if ( ( webViewURL . toLowerCase ( ) . contains ( key . toLowerCase ( ) ) || key . toLowerCase ( ) . contains ( webViewURL . toLowerCase ( ) ) ) && ! prefs . getString ( key , null ) . equals ( "" ) ) { preference = prefs . getString ( key , null ) ; settingsURL = key ; } } } switch ( preference ) { case "/first" : if ( ! PasswordRepository . isInitialized ( ) ) { PasswordRepository . initialize ( this ) ; } items = searchPasswords ( PasswordRepository . getRepositoryDirectory ( this ) , webViewTitle ) ; break; case "/never" : items = new ArrayList <> ( ) ; break; default: getPreferredPasswords ( preference ) ; } return settingsURL ; }
private void setAppMatchingPasswords ( String appName , String packageName ) { String defValue = settings . getBoolean ( "autofill_default" , true ) ? "/first" : "/never" ; SharedPreferences prefs ; String preference ; prefs = getSharedPreferences ( "autofill" , Context . MODE_PRIVATE ) ; preference = prefs . getString ( packageName , defValue ) ; switch ( preference ) { case "/first" : if ( ! PasswordRepository . isInitialized ( ) ) { PasswordRepository . initialize ( this ) ; } items = searchPasswords ( PasswordRepository . getRepositoryDirectory ( this ) , appName ) ; break; case "/never" : items = new ArrayList <> ( ) ; break; default: getPreferredPasswords ( preference ) ; } }
private void getPreferredPasswords ( String preference ) { if ( ! PasswordRepository . isInitialized ( ) ) { PasswordRepository . initialize ( this ) ; } String preferredPasswords [] = preference . split ( "\n" ) ; items = new ArrayList <> ( ) ; for ( String password : preferredPasswords ) { String path = PasswordRepository . getRepositoryDirectory ( getApplicationContext ( ) ) + "/" + password + ".gpg" ; if ( new File ( path ) . exists ( ) ) { items . add ( new File ( path ) ) ; } } }
private ArrayList < File > searchPasswords ( File path , String appName ) { ArrayList < File > passList = PasswordRepository . getFilesList ( path ) ; if ( passList . size ( ) == 0 ) return new ArrayList <> ( ) ; ArrayList < File > items = new ArrayList <> ( ) ; for ( File file : passList ) { if ( file . isFile ( ) ) { if ( appName . toLowerCase ( ) . contains ( file . getName ( ) . toLowerCase ( ) . replace ( ".gpg" , "" ) ) ) { items . add ( file ) ; } } else { if ( file . getName ( ) . equals ( ".git" ) ) continue; items . addAll ( searchPasswords ( file , appName ) ) ; } } return items ; }
private void showDialog ( final String packageName , final String appName , final boolean isWeb ) { AlertDialog . Builder builder = new AlertDialog . Builder ( this , R . style . Theme_AppCompat_Dialog ) ; builder . setNegativeButton ( R . string . dialog_cancel , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface d , int which ) { dialog . dismiss ( ) ; dialog = null ; } } ) ; builder . setNeutralButton ( "Settings" , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { Intent intent = new Intent ( AutofillService .this , AutofillPreferenceActivity .class ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK | Intent . FLAG_ACTIVITY_CLEAR_TASK ) ; intent . putExtra ( "packageName" , packageName ) ; intent . putExtra ( "appName" , appName ) ; intent . putExtra ( "isWeb" , isWeb ) ; startActivity ( intent ) ; } } ) ; CharSequence itemNames [] = new CharSequence [ items . size ( ) + 2 ] ; for ( int i = 0 ; i < items . size ( ) ; i ++ ) { itemNames [ i ] = items . get ( i ) . getName ( ) . replace ( ".gpg" , "" ) ; } itemNames [ items . size ( ) ] = "Pick..." ; itemNames [ items . size ( ) + 1 ] = "Pick and match..." ; builder . setItems ( itemNames , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { lastWhichItem = which ; if ( which < items . size ( ) ) { bindDecryptAndVerify ( ) ; } else if ( which == items . size ( ) ) { Intent intent = new Intent ( AutofillService .this , AutofillActivity .class ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK | Intent . FLAG_ACTIVITY_CLEAR_TASK ) ; intent . putExtra ( "pick" , true ) ; startActivity ( intent ) ; } else { lastWhichItem -- ; Intent intent = new Intent ( AutofillService .this , AutofillActivity .class ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK | Intent . FLAG_ACTIVITY_CLEAR_TASK ) ; intent . putExtra ( "pickMatchWith" , true ) ; intent . putExtra ( "packageName" , packageName ) ; intent . putExtra ( "isWeb" , isWeb ) ; startActivity ( intent ) ; } } } ) ; dialog = builder . create ( ) ; dialog . getWindow ( ) . setType ( WindowManager . LayoutParams . TYPE_SYSTEM_ALERT ) ; dialog . getWindow ( ) . addFlags ( WindowManager . LayoutParams . FLAG_NOT_FOCUSABLE ) ; dialog . getWindow ( ) . clearFlags ( WindowManager . LayoutParams . FLAG_DIM_BEHIND ) ; int height = 154 ; if ( itemNames . length > 1 ) { height += 46 ; } dialog . getWindow ( ) . setLayout ( ( int ) ( 240 * getApplicationContext ( ) . getResources ( ) . getDisplayMetrics ( ) . density ) , ( int ) ( height * getApplicationContext ( ) . getResources ( ) . getDisplayMetrics ( ) . density ) ) ; dialog . show ( ) ; }
@ Override public void onClick ( DialogInterface d , int which ) { dialog . dismiss ( ) ; dialog = null ; }
@ Override public void onClick ( DialogInterface dialog , int which ) { Intent intent = new Intent ( AutofillService .this , AutofillPreferenceActivity .class ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK | Intent . FLAG_ACTIVITY_CLEAR_TASK ) ; intent . putExtra ( "packageName" , packageName ) ; intent . putExtra ( "appName" , appName ) ; intent . putExtra ( "isWeb" , isWeb ) ; startActivity ( intent ) ; }
@ Override public void onClick ( DialogInterface dialog , int which ) { lastWhichItem = which ; if ( which < items . size ( ) ) { bindDecryptAndVerify ( ) ; } else if ( which == items . size ( ) ) { Intent intent = new Intent ( AutofillService .this , AutofillActivity .class ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK | Intent . FLAG_ACTIVITY_CLEAR_TASK ) ; intent . putExtra ( "pick" , true ) ; startActivity ( intent ) ; } else { lastWhichItem -- ; Intent intent = new Intent ( AutofillService .this , AutofillActivity .class ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK | Intent . FLAG_ACTIVITY_CLEAR_TASK ) ; intent . putExtra ( "pickMatchWith" , true ) ; intent . putExtra ( "packageName" , packageName ) ; intent . putExtra ( "isWeb" , isWeb ) ; startActivity ( intent ) ; } }
@ Override public void onInterrupt ( ) {    }
@ Override public void onBound ( IOpenPgpService2 service ) { decryptAndVerify ( ) ; }
@ Override public void onError ( Exception e ) { e . printStackTrace ( ) ; }
private void bindDecryptAndVerify ( ) { if ( serviceConnection . getService ( ) == null ) { serviceConnection = new OpenPgpServiceConnection ( AutofillService .this , "org.sufficientlysecure.keychain" , new onBoundListener ( ) ) ; serviceConnection . bindToService ( ) ; } else { decryptAndVerify ( ) ; } }
private void decryptAndVerify ( ) { packageName = info . getPackageName ( ) ; Intent data ; if ( resultData == null ) { data = new Intent ( ) ; data . setAction ( OpenPgpApi . ACTION_DECRYPT_VERIFY ) ; } else { data = resultData ; resultData = null ; } InputStream is = null ; try { is = FileUtils . openInputStream ( items . get ( lastWhichItem ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; OpenPgpApi api = new OpenPgpApi ( AutofillService .this , serviceConnection . getService ( ) ) ; Intent result = api . executeApi ( data , is , os ) ; switch ( result . getIntExtra ( OpenPgpApi . RESULT_CODE , OpenPgpApi . RESULT_CODE_ERROR ) ) { case OpenPgpApi . RESULT_CODE_SUCCESS : { try { String [] passContent = os . toString ( "UTF-8" ) . split ( "\n" ) ; ignoreActionFocus = info . performAction ( AccessibilityNodeInfo . ACTION_FOCUS ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . LOLLIPOP ) { Bundle args = new Bundle ( ) ; args . putCharSequence ( AccessibilityNodeInfo . ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE , passContent [ 0 ] ) ; info . performAction ( AccessibilityNodeInfo . ACTION_SET_TEXT , args ) ; } else { ClipboardManager clipboard = ( ClipboardManager ) getSystemService ( Context . CLIPBOARD_SERVICE ) ; ClipData clip = ClipData . newPlainText ( "autofill_pm" , passContent [ 0 ] ) ; clipboard . setPrimaryClip ( clip ) ; info . performAction ( AccessibilityNodeInfo . ACTION_PASTE ) ; clip = ClipData . newPlainText ( "autofill_pm" , "" ) ; clipboard . setPrimaryClip ( clip ) ; if ( settings . getBoolean ( "clear_clipboard_20x" , false ) ) { for ( int i = 0 ; i < 19 ; i ++ ) { clip = ClipData . newPlainText ( String . valueOf ( i ) , String . valueOf ( i ) ) ; clipboard . setPrimaryClip ( clip ) ; } } } info . recycle ( ) ; } catch ( UnsupportedEncodingException e ) { Log . e ( Constants . TAG , "UnsupportedEncodingException" , e ) ; } break; } case OpenPgpApi . RESULT_CODE_USER_INTERACTION_REQUIRED : { Log . i ( "PgpHandler" , "RESULT_CODE_USER_INTERACTION_REQUIRED" ) ; PendingIntent pi = result . getParcelableExtra ( OpenPgpApi . RESULT_INTENT ) ; Intent intent = new Intent ( AutofillService .this , AutofillActivity .class ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK | Intent . FLAG_ACTIVITY_CLEAR_TASK ) ; intent . putExtra ( "pending_intent" , pi ) ; startActivity ( intent ) ; break; } case OpenPgpApi . RESULT_CODE_ERROR : { OpenPgpError error = result . getParcelableExtra ( OpenPgpApi . RESULT_ERROR ) ; Toast . makeText ( AutofillService .this , "Error from OpenKeyChain : " + error . getMessage ( ) , Toast . LENGTH_LONG ) . show ( ) ; Log . e ( Constants . TAG , "onError getErrorId:" + error . getErrorId ( ) ) ; Log . e ( Constants . TAG , "onError getMessage:" + error . getMessage ( ) ) ; break; } } }
public SimpleMarkerOverlay ( GoogleMap map ) { mMap = map ; }
public synchronized int addMarker ( Location l , Float hue ) { MarkerOptions options = new MarkerOptions ( ) . position ( MapHelpV2 . makeLatLng ( l ) ) ; if ( hue != null ) { options . icon ( BitmapDescriptorFactory . defaultMarker ( hue ) ) ; } Marker m = mMap . addMarker ( options ) ; mMarkers . put ( mMarkerId , m ) ; int temp = mMarkerId ; mMarkerId ++ ; return temp ; }
public void removeMarker ( int markerId ) { Marker m = mMarkers . get ( markerId ) ; if ( m != null ) { m . remove ( ) ; mMarkers . remove ( markerId ) ; } }
public double getLat ( )
public double getLon ( )
public double getLatSpan ( )
public double getLonSpan ( )
public String getJuridisctionId ( )
public String getApiKey ( )
public String getBaseUrl ( )
public long getId ( )
public String getName ( )
public boolean getActive ( )
public String getObaBaseUrl ( )
public String getSiriBaseUrl ( )
public Bounds [] getBounds ( )
public Open311Server [] getOpen311Servers ( )
public String getLanguage ( )
public String getContactEmail ( )
public boolean getSupportsObaDiscoveryApis ( )
public boolean getSupportsObaRealtimeApis ( )
public boolean getSupportsSiriRealtimeApis ( )
public String getTwitterUrl ( )
public boolean getExperimental ( )
public String getStopInfoUrl ( )
public String getOtpBaseUrl ( )
public String getOtpContactEmail ( )
public GPUImageChromaKeyBlendFilter ( ) { super( CHROMA_KEY_BLEND_FRAGMENT_SHADER ); }
@ Override public void onInit ( ) { super. onInit ( ) ; mThresholdSensitivityLocation = GLES20 . glGetUniformLocation ( getProgram ( ) , "thresholdSensitivity" ) ; mSmoothingLocation = GLES20 . glGetUniformLocation ( getProgram ( ) , "smoothing" ) ; mColorToReplaceLocation = GLES20 . glGetUniformLocation ( getProgram ( ) , "colorToReplace" ) ; }
@ Override public void onInitialized ( ) { super. onInitialized ( ) ; setSmoothing ( mSmoothing ) ; setThresholdSensitivity ( mThresholdSensitivity ) ; setColorToReplace ( mColorToReplace [ 0 ] , mColorToReplace [ 1 ] , mColorToReplace [ 2 ] ) ; }
public void setSmoothing ( final float smoothing ) { mSmoothing = smoothing ; setFloat ( mSmoothingLocation , mSmoothing ) ; }
public void setThresholdSensitivity ( final float thresholdSensitivity ) { mThresholdSensitivity = thresholdSensitivity ; setFloat ( mThresholdSensitivityLocation , mThresholdSensitivity ) ; }
public void setColorToReplace ( float redComponent , float greenComponent , float blueComponent ) { mColorToReplace = new float [] { redComponent , greenComponent , blueComponent } ; setFloatVec3 ( mColorToReplaceLocation , mColorToReplace ) ; }
@ Override public void onCreate ( final Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_camera ) ; ( ( SeekBar ) findViewById ( R . id . seekBar ) ) . setOnSeekBarChangeListener ( this ) ; findViewById ( R . id . button_choose_filter ) . setOnClickListener ( this ) ; findViewById ( R . id . button_capture ) . setOnClickListener ( this ) ; mGPUImage = new GPUImage ( this ) ; mGPUImage . setGLSurfaceView ( ( GLSurfaceView ) findViewById ( R . id . surfaceView ) ) ; mCameraHelper = new CameraHelper ( this ) ; mCamera = new CameraLoader ( ) ; View cameraSwitchView = findViewById ( R . id . img_switch_camera ) ; cameraSwitchView . setOnClickListener ( this ) ; if ( ! mCameraHelper . hasFrontCamera ( ) || ! mCameraHelper . hasBackCamera ( ) ) { cameraSwitchView . setVisibility ( View . GONE ) ; } }
@ Override protected void onResume ( ) { super. onResume ( ) ; mCamera . onResume ( ) ; }
@ Override protected void onPause ( ) { mCamera . onPause ( ) ; super. onPause ( ) ; }
@ Override public void onClick ( final View v ) { switch ( v . getId ( ) ) { case R . id . button_choose_filter : GPUImageFilterTools . showDialog ( this , new OnGpuImageFilterChosenListener ( ) { @ Override public void onGpuImageFilterChosenListener ( final GPUImageFilter filter ) { switchFilterTo ( filter ) ; } } ) ; break; case R . id . button_capture : if ( mCamera . mCameraInstance . getParameters ( ) . getFocusMode ( ) . equals ( Parameters . FOCUS_MODE_CONTINUOUS_PICTURE ) ) { takePicture ( ) ; } else { mCamera . mCameraInstance . autoFocus ( new Camera . AutoFocusCallback ( ) { @ Override public void onAutoFocus ( final boolean success , final Camera camera ) { takePicture ( ) ; } } ) ; } break; case R . id . img_switch_camera : mCamera . switchCamera ( ) ; break; } }
@ Override public void onGpuImageFilterChosenListener ( final GPUImageFilter filter ) { switchFilterTo ( filter ) ; }
@ Override public void onAutoFocus ( final boolean success , final Camera camera ) { takePicture ( ) ; }
private void takePicture ( ) { Camera . Parameters params = mCamera . mCameraInstance . getParameters ( ) ; params . setRotation ( 90 ) ; mCamera . mCameraInstance . setParameters ( params ) ; for ( Camera . Size size : params . getSupportedPictureSizes ( ) ) { Log . i ( "ASDF" , "Supported: " + size . width + "x" + size . height ) ; } mCamera . mCameraInstance . takePicture ( null , null , new Camera . PictureCallback ( ) { @ Override public void onPictureTaken ( byte [] data , final Camera camera ) { final File pictureFile = getOutputMediaFile ( MEDIA_TYPE_IMAGE ) ; if ( pictureFile == null ) { Log . d ( "ASDF" , "Error creating media file, check storage permissions" ) ; return; } try { FileOutputStream fos = new FileOutputStream ( pictureFile ) ; fos . write ( data ) ; fos . close ( ) ; } catch ( FileNotFoundException e ) { Log . d ( "ASDF" , "File not found: " + e . getMessage ( ) ) ; } catch ( IOException e ) { Log . d ( "ASDF" , "Error accessing file: " + e . getMessage ( ) ) ; } data = null ; Bitmap bitmap = BitmapFactory . decodeFile ( pictureFile . getAbsolutePath ( ) ) ; final GLSurfaceView view = ( GLSurfaceView ) findViewById ( R . id . surfaceView ) ; view . setRenderMode ( GLSurfaceView . RENDERMODE_WHEN_DIRTY ) ; mGPUImage . saveToPictures ( bitmap , "GPUImage" , System . currentTimeMillis ( ) + ".jpg" , new OnPictureSavedListener ( ) { @ Override public void onPictureSaved ( final Uri uri ) { pictureFile . delete ( ) ; camera . startPreview ( ) ; view . setRenderMode ( GLSurfaceView . RENDERMODE_CONTINUOUSLY ) ; } } ) ; } } ) ; }
@ Override public void onPictureTaken ( byte [] data , final Camera camera ) { final File pictureFile = getOutputMediaFile ( MEDIA_TYPE_IMAGE ) ; if ( pictureFile == null ) { Log . d ( "ASDF" , "Error creating media file, check storage permissions" ) ; return; } try { FileOutputStream fos = new FileOutputStream ( pictureFile ) ; fos . write ( data ) ; fos . close ( ) ; } catch ( FileNotFoundException e ) { Log . d ( "ASDF" , "File not found: " + e . getMessage ( ) ) ; } catch ( IOException e ) { Log . d ( "ASDF" , "Error accessing file: " + e . getMessage ( ) ) ; } data = null ; Bitmap bitmap = BitmapFactory . decodeFile ( pictureFile . getAbsolutePath ( ) ) ; final GLSurfaceView view = ( GLSurfaceView ) findViewById ( R . id . surfaceView ) ; view . setRenderMode ( GLSurfaceView . RENDERMODE_WHEN_DIRTY ) ; mGPUImage . saveToPictures ( bitmap , "GPUImage" , System . currentTimeMillis ( ) + ".jpg" , new OnPictureSavedListener ( ) { @ Override public void onPictureSaved ( final Uri uri ) { pictureFile . delete ( ) ; camera . startPreview ( ) ; view . setRenderMode ( GLSurfaceView . RENDERMODE_CONTINUOUSLY ) ; } } ) ; }
@ Override public void onPictureSaved ( final Uri uri ) { pictureFile . delete ( ) ; camera . startPreview ( ) ; view . setRenderMode ( GLSurfaceView . RENDERMODE_CONTINUOUSLY ) ; }
private static File getOutputMediaFile ( final int type ) { File mediaStorageDir = new File ( Environment . getExternalStoragePublicDirectory ( Environment . DIRECTORY_PICTURES ) , "MyCameraApp" ) ; if ( ! mediaStorageDir . exists ( ) ) { if ( ! mediaStorageDir . mkdirs ( ) ) { Log . d ( "MyCameraApp" , "failed to create directory" ) ; return null ; } } String timeStamp = new SimpleDateFormat ( "yyyyMMdd_HHmmss" ) . format ( new Date ( ) ) ; File mediaFile ; if ( type == MEDIA_TYPE_IMAGE ) { mediaFile = new File ( mediaStorageDir . getPath ( ) + File . separator + "IMG_" + timeStamp + ".jpg" ) ; } else if ( type == MEDIA_TYPE_VIDEO ) { mediaFile = new File ( mediaStorageDir . getPath ( ) + File . separator + "VID_" + timeStamp + ".mp4" ) ; } else { return null ; } return mediaFile ; }
private void switchFilterTo ( final GPUImageFilter filter ) { if ( mFilter == null || ( filter != null && ! mFilter . getClass ( ) . equals ( filter . getClass ( ) ) ) ) { mFilter = filter ; mGPUImage . setFilter ( mFilter ) ; mFilterAdjuster = new FilterAdjuster ( mFilter ) ; } }
@ Override public void onProgressChanged ( final SeekBar seekBar , final int progress , final boolean fromUser ) { if ( mFilterAdjuster != null ) { mFilterAdjuster . adjust ( progress ) ; } }
@ Override public void onStartTrackingTouch ( final SeekBar seekBar ) {    }
@ Override public void onStopTrackingTouch ( final SeekBar seekBar ) {    }
public void onResume ( ) { setUpCamera ( mCurrentCameraId ) ; }
public void onPause ( ) { releaseCamera ( ) ; }
public void switchCamera ( ) { releaseCamera ( ) ; mCurrentCameraId = ( mCurrentCameraId + 1 ) % mCameraHelper . getNumberOfCameras ( ) ; setUpCamera ( mCurrentCameraId ) ; }
private void setUpCamera ( final int id ) { mCameraInstance = getCameraInstance ( id ) ; Parameters parameters = mCameraInstance . getParameters ( ) ; if ( parameters . getSupportedFocusModes ( ) . contains ( Camera . Parameters . FOCUS_MODE_CONTINUOUS_PICTURE ) ) { parameters . setFocusMode ( Parameters . FOCUS_MODE_CONTINUOUS_PICTURE ) ; } mCameraInstance . setParameters ( parameters ) ; int orientation = mCameraHelper . getCameraDisplayOrientation ( ActivityCamera .this , mCurrentCameraId ) ; CameraInfo2 cameraInfo = new CameraInfo2 ( ) ; mCameraHelper . getCameraInfo ( mCurrentCameraId , cameraInfo ) ; boolean flipHorizontal = cameraInfo . facing == CameraInfo . CAMERA_FACING_FRONT ; mGPUImage . setUpCamera ( mCameraInstance , orientation , flipHorizontal , false ) ; }
private Camera getCameraInstance ( final int id ) { Camera c = null ; try { c = mCameraHelper . openCamera ( id ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return c ; }
private void releaseCamera ( ) { mCameraInstance . setPreviewCallback ( null ) ; mCameraInstance . release ( ) ; mCameraInstance = null ; }
@ Override public void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; UIHelp . setupActionBar ( this ) ; FragmentManager fm = getSupportFragmentManager ( ) ; if ( fm . findFragmentById ( android . R . id . content ) == null ) { TripListFragment list = new TripListFragment ( ) ; fm . beginTransaction ( ) . add ( android . R . id . content , list ) . commit ( ) ; } }
@ Override public boolean onOptionsItemSelected ( MenuItem item ) { if ( item . getItemId ( ) == android . R . id . home ) { NavHelp . goHome ( this ) ; return true ; } return false ; }
Observer ( ) { super( mHandler ); }
@ Override public boolean deliverSelfNotifications ( ) { return false ; }
public void onChange ( boolean selfChange ) { if ( isAdded ( ) ) { getLoaderManager ( ) . restartLoader ( 0 , null , TripListFragment .this ) ; } }
@ Override public void onActivityCreated ( Bundle savedInstanceState ) { super. onActivityCreated ( savedInstanceState ) ; setEmptyText ( getString ( R . string . trip_list_notrips ) ) ; registerForContextMenu ( getListView ( ) ) ; mAdapter = newAdapter ( ) ; setListAdapter ( mAdapter ) ; ContentResolver cr = getActivity ( ) . getContentResolver ( ) ; mObserver = new Observer ( ) ; cr . registerContentObserver ( ObaContract . Trips . CONTENT_URI , true , mObserver ) ; getLoaderManager ( ) . initLoader ( 0 , null , this ) ; }
@ Override public void onDestroy ( ) { if ( mObserver != null ) { ContentResolver cr = getActivity ( ) . getContentResolver ( ) ; cr . unregisterContentObserver ( mObserver ) ; mObserver = null ; } super. onDestroy ( ) ; }
@ Override public Loader < Cursor > onCreateLoader ( int id , Bundle args ) { return new CursorLoader ( getActivity ( ) , ObaContract . Trips . CONTENT_URI , PROJECTION , null , null , ObaContract . Trips . NAME + " asc" ) ; }
@ Override public void onLoadFinished ( Loader < Cursor > loader , Cursor data ) { mAdapter . swapCursor ( data ) ; }
@ Override public void onLoaderReset ( Loader < Cursor > loader ) { mAdapter . swapCursor ( null ) ; }
private SimpleCursorAdapter newAdapter ( ) { final String [] from = { ObaContract . Trips . NAME , ObaContract . Trips . HEADSIGN , ObaContract . Trips . DEPARTURE , ObaContract . Trips . ROUTE_ID } ; final int [] to = { R . id . name , R . id . headsign , R . id . departure_time , R . id . route_name } ; SimpleCursorAdapter simpleAdapter = new SimpleCursorAdapter ( getActivity ( ) , R . layout . trip_list_listitem , null , from , to , 0 ) ; simpleAdapter . setViewBinder ( new SimpleCursorAdapter . ViewBinder ( ) { public boolean setViewValue ( View view , Cursor cursor , int columnIndex ) { if ( columnIndex == COL_NAME ) { TextView text = ( TextView ) view ; String name = cursor . getString ( columnIndex ) ; if ( name . length ( ) == 0 ) { name = getString ( R . string . trip_info_noname ) ; } text . setText ( name ) ; return true ; } else if ( columnIndex == COL_HEADSIGN ) { String headSign = cursor . getString ( columnIndex ) ; TextView text = ( TextView ) view ; text . setText ( MyTextUtils . toTitleCase ( headSign ) ) ; return true ; } else if ( columnIndex == COL_DEPARTURE ) { TextView text = ( TextView ) view ; text . setText ( TripInfoActivity . getDepartureTime ( getActivity ( ) , ObaContract . Trips . convertDBToTime ( cursor . getInt ( columnIndex ) ) ) ) ; return true ; } else if ( columnIndex == COL_ROUTE_ID ) { TextView text = ( TextView ) view ; final String routeId = cursor . getString ( columnIndex ) ; final String routeName = TripService . getRouteShortName ( getActivity ( ) , routeId ) ; if ( routeName != null ) { text . setText ( getString ( R . string . trip_info_route , routeName ) ) ; } return true ; } return false ; } } ) ; return simpleAdapter ; }
public boolean setViewValue ( View view , Cursor cursor , int columnIndex ) { if ( columnIndex == COL_NAME ) { TextView text = ( TextView ) view ; String name = cursor . getString ( columnIndex ) ; if ( name . length ( ) == 0 ) { name = getString ( R . string . trip_info_noname ) ; } text . setText ( name ) ; return true ; } else if ( columnIndex == COL_HEADSIGN ) { String headSign = cursor . getString ( columnIndex ) ; TextView text = ( TextView ) view ; text . setText ( MyTextUtils . toTitleCase ( headSign ) ) ; return true ; } else if ( columnIndex == COL_DEPARTURE ) { TextView text = ( TextView ) view ; text . setText ( TripInfoActivity . getDepartureTime ( getActivity ( ) , ObaContract . Trips . convertDBToTime ( cursor . getInt ( columnIndex ) ) ) ) ; return true ; } else if ( columnIndex == COL_ROUTE_ID ) { TextView text = ( TextView ) view ; final String routeId = cursor . getString ( columnIndex ) ; final String routeName = TripService . getRouteShortName ( getActivity ( ) , routeId ) ; if ( routeName != null ) { text . setText ( getString ( R . string . trip_info_route , routeName ) ) ; } return true ; } return false ; }
@ Override public void onListItemClick ( ListView l , View v , int position , long id ) { String [] ids = getIds ( l , position ) ; TripInfoActivity . start ( getActivity ( ) , ids [ 0 ] , ids [ 1 ] ) ; }
@ Override public void onCreateContextMenu ( ContextMenu menu , View v , ContextMenuInfo menuInfo ) { super. onCreateContextMenu ( menu , v , menuInfo ) ; AdapterContextMenuInfo info = ( AdapterContextMenuInfo ) menuInfo ; final TextView text = ( TextView ) info . targetView . findViewById ( R . id . name ) ; menu . setHeaderTitle ( text . getText ( ) ) ; menu . add ( 0 , CONTEXT_MENU_DEFAULT , 0 , R . string . trip_list_context_edit ) ; menu . add ( 0 , CONTEXT_MENU_DELETE , 0 , R . string . trip_list_context_delete ) ; menu . add ( 0 , CONTEXT_MENU_SHOWSTOP , 0 , R . string . trip_list_context_showstop ) ; menu . add ( 0 , CONTEXT_MENU_SHOWROUTE , 0 , R . string . trip_list_context_showroute ) ; }
@ Override public boolean onContextItemSelected ( android . view . MenuItem item ) { AdapterContextMenuInfo info = ( AdapterContextMenuInfo ) item . getMenuInfo ( ) ; switch ( item . getItemId ( ) ) { case CONTEXT_MENU_DEFAULT : onListItemClick ( getListView ( ) , info . targetView , info . position , info . id ) ; return true ; case CONTEXT_MENU_DELETE : deleteTrip ( getListView ( ) , info . position ) ; return true ; case CONTEXT_MENU_SHOWSTOP : goToStop ( getListView ( ) , info . position ) ; return true ; case CONTEXT_MENU_SHOWROUTE : goToRoute ( getListView ( ) , info . position ) ; return true ; default: return super. onContextItemSelected ( item ) ; } }
private void deleteTrip ( ListView l , int position ) { String [] ids = getIds ( l , position ) ; ContentResolver cr = getActivity ( ) . getContentResolver ( ) ; cr . delete ( ObaContract . Trips . buildUri ( ids [ 0 ] , ids [ 1 ] ) , null , null ) ; TripService . scheduleAll ( getActivity ( ) ) ; getLoaderManager ( ) . getLoader ( 0 ) . onContentChanged ( ) ; }
private void goToStop ( ListView l , int position ) { String [] ids = getIds ( l , position ) ; ArrivalsListActivity . start ( getActivity ( ) , ids [ 1 ] ) ; }
private void goToRoute ( ListView l , int position ) { String [] ids = getIds ( l , position ) ; RouteInfoActivity . start ( getActivity ( ) , ids [ 2 ] ) ; }
private String [] getIds ( ListView l , int position ) { SimpleCursorAdapter cursorAdapter = ( SimpleCursorAdapter ) l . getAdapter ( ) ; final Cursor c = cursorAdapter . getCursor ( ) ; c . moveToPosition ( position - l . getHeaderViewsCount ( ) ) ; final String [] result = new String [] { c . getString ( COL_ID ) , c . getString ( COL_STOP_ID ) , c . getString ( COL_ROUTE_ID ) } ; return result ; }
ObaStopDistance ( final String s , final int i ) { stringValue = s ; distanceInMeters = i ; }
public String toString ( ) { return stringValue ; }
public int getDistanceInMeters ( ) { return distanceInMeters ; }
ObaEventCategory ( final String s ) { stringValue = s ; }
public String toString ( ) { return stringValue ; }
public static void reportEventWithCategory ( String category , String action , String label ) { if ( isAnalyticsActive ( ) ) { Tracker tracker = Application . get ( ) . getTracker ( Application . TrackerName . APP_TRACKER ) ; Tracker tracker2 = Application . get ( ) . getTracker ( Application . TrackerName . GLOBAL_TRACKER ) ; String obaRegionName = RegionUtils . getObaRegionName ( ) ; tracker . send ( new HitBuilders . EventBuilder ( ) . setCategory ( category ) . setAction ( action ) . setLabel ( label ) . setCustomDimension ( 1 , obaRegionName ) . build ( ) ) ; tracker2 . send ( new HitBuilders . EventBuilder ( ) . setCategory ( category ) . setAction ( action ) . setLabel ( label ) . setCustomDimension ( 1 , obaRegionName ) . build ( ) ) ; } }
public static void trackBusStopDistance ( String stopId , Location myLocation , Location stopLocation ) { if ( isAnalyticsActive ( ) ) { if ( myLocation == null ) { return; } if ( myLocation . getAccuracy ( ) < LOCATION_ACCURACY_THRESHOLD ) { float distanceInMeters = myLocation . distanceTo ( stopLocation ) ; ObaStopDistance stopDistance ; if ( distanceInMeters < ObaStopDistance . DISTANCE_1 . getDistanceInMeters ( ) ) { stopDistance = ObaStopDistance . DISTANCE_1 ; } else if ( distanceInMeters < ObaStopDistance . DISTANCE_2 . getDistanceInMeters ( ) ) { stopDistance = ObaStopDistance . DISTANCE_2 ; } else if ( distanceInMeters < ObaStopDistance . DISTANCE_3 . getDistanceInMeters ( ) ) { stopDistance = ObaStopDistance . DISTANCE_3 ; } else if ( distanceInMeters < ObaStopDistance . DISTANCE_4 . getDistanceInMeters ( ) ) { stopDistance = ObaStopDistance . DISTANCE_4 ; } else if ( distanceInMeters < ObaStopDistance . DISTANCE_5 . getDistanceInMeters ( ) ) { stopDistance = ObaStopDistance . DISTANCE_5 ; } else if ( distanceInMeters < ObaStopDistance . DISTANCE_6 . getDistanceInMeters ( ) ) { stopDistance = ObaStopDistance . DISTANCE_6 ; } else if ( distanceInMeters < ObaStopDistance . DISTANCE_7 . getDistanceInMeters ( ) ) { stopDistance = ObaStopDistance . DISTANCE_7 ; } else { stopDistance = ObaStopDistance . DISTANCE_8 ; } reportEventWithCategory ( ObaEventCategory . STOP_ACTION . toString ( ) , "Stop Id: " + stopId , stopDistance . toString ( ) ) ; } } }
public static void reportActivityStart ( Activity activity ) { if ( isAnalyticsActive ( ) ) { Tracker tracker = Application . get ( ) . getTracker ( Application . TrackerName . APP_TRACKER ) ; tracker . setScreenName ( activity . getClass ( ) . getSimpleName ( ) ) ; tracker . send ( new HitBuilders . ScreenViewBuilder ( ) . build ( ) ) ; Tracker tracker2 = Application . get ( ) . getTracker ( Application . TrackerName . GLOBAL_TRACKER ) ; tracker2 . setScreenName ( activity . getClass ( ) . getSimpleName ( ) ) ; tracker2 . send ( new HitBuilders . ScreenViewBuilder ( ) . build ( ) ) ; } }
public static void reportFragmentStart ( Fragment fragment ) { if ( isAnalyticsActive ( ) ) { Tracker tracker = Application . get ( ) . getTracker ( Application . TrackerName . APP_TRACKER ) ; tracker . setScreenName ( fragment . getClass ( ) . getSimpleName ( ) ) ; tracker . send ( new HitBuilders . ScreenViewBuilder ( ) . build ( ) ) ; Tracker tracker2 = Application . get ( ) . getTracker ( Application . TrackerName . GLOBAL_TRACKER ) ; tracker2 . setScreenName ( fragment . getClass ( ) . getSimpleName ( ) ) ; tracker2 . send ( new HitBuilders . ScreenViewBuilder ( ) . build ( ) ) ; } }
public static void initAnalytics ( Context context ) { if ( BuildConfig . DEBUG ) { GoogleAnalytics . getInstance ( context ) . setDryRun ( true ) ; if ( android . os . Build . MANUFACTURER . toLowerCase ( ) . contains ( mAmazonManufacturer ) ) { GoogleAnalytics . getInstance ( context ) . setAppOptOut ( true ) ; } } }
private static Boolean isAnalyticsActive ( ) { SharedPreferences settings = Application . getPrefs ( ) ; return settings . getBoolean ( Application . get ( ) . getString ( R . string . preferences_key_analytics ) , Boolean . TRUE ) ; }
public ApplicationTest ( ) { super( Application .class ); }
SearchResponse ( int code , List < ObaElement > r ) { mCode = code ; mResults = r ; }
int getCode ( ) { return mCode ; }
List < ObaElement > getResults ( ) { return mResults ; }
@ Override public void onAttach ( Activity activity ) { super. onAttach ( activity ) ; GoogleApiAvailability api = GoogleApiAvailability . getInstance ( ) ; if ( api . isGooglePlayServicesAvailable ( getActivity ( ) ) == ConnectionResult . SUCCESS ) { mGoogleApiClient = LocationUtils . getGoogleApiClientWithCallbacks ( getActivity ( ) ) ; mGoogleApiClient . connect ( ) ; } }
@ Override public void onActivityCreated ( Bundle savedInstanceState ) { super. onActivityCreated ( savedInstanceState ) ; mAdapter = new MyAdapter ( getActivity ( ) ) ; setListAdapter ( mAdapter ) ; search ( ) ; }
@ Override public void onStart ( ) { super. onStart ( ) ; ObaAnalytics . reportFragmentStart ( this ) ; if ( mGoogleApiClient != null && ! mGoogleApiClient . isConnected ( ) ) { mGoogleApiClient . connect ( ) ; } }
@ Override public void onStop ( ) { if ( mGoogleApiClient != null && mGoogleApiClient . isConnected ( ) ) { mGoogleApiClient . disconnect ( ) ; } super. onStop ( ) ; }
private void search ( ) { UIUtils . showProgress ( this , true ) ; Loader < ? > loader = getLoaderManager ( ) . restartLoader ( 0 , getArguments ( ) , this ) ; loader . forceLoad ( ) ; }
@ Override public Loader < SearchResponse > onCreateLoader ( int id , Bundle args ) { String query = args . getString ( QUERY_TEXT ) ; Location location = Application . getLastKnownLocation ( getActivity ( ) , mGoogleApiClient ) ; if ( location == null ) { location = LocationUtils . getDefaultSearchCenter ( ) ; } return new MyLoader ( getActivity ( ) , query , location ) ; }
@ Override public void onLoadFinished ( Loader < SearchResponse > loader , SearchResponse response ) { UIUtils . showProgress ( this , false ) ; final int code = response . getCode ( ) ; if ( code == ObaApi . OBA_OK ) { setEmptyText ( getString ( R . string . find_hint_noresults ) ) ; mAdapter . setData ( response . getResults ( ) ) ; } else if ( code != 0 ) { setEmptyText ( getString ( R . string . find_hint_noresults ) ) ; } else { setEmptyText ( getString ( R . string . generic_comm_error ) ) ; } }
@ Override public void onLoaderReset ( Loader < SearchResponse > loader ) { mAdapter . clear ( ) ; }
@ Override public void onListItemClick ( ListView l , View v , int position , long id ) { ListAdapter adapter = l . getAdapter ( ) ; ObaElement e = ( ObaElement ) adapter . getItem ( position - l . getHeaderViewsCount ( ) ) ; if ( e instanceof ObaRoute ) { clickRoute ( ( ObaRoute ) e ) ; } else if ( e instanceof ObaStop ) { clickStop ( ( ObaStop ) e ) ; } }
private void clickRoute ( ObaRoute route ) { final String routeId = route . getId ( ) ; AlertDialog . Builder builder = new AlertDialog . Builder ( getActivity ( ) ) ; builder . setTitle ( UIUtils . getRouteDescription ( route ) ) ; builder . setItems ( R . array . search_route_options , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int which ) { switch ( which ) { case 0 : RouteInfoActivity . start ( getActivity ( ) , routeId ) ; break; case 1 : HomeActivity . start ( getActivity ( ) , routeId ) ; break; } } } ) ; AlertDialog dialog = builder . create ( ) ; dialog . setOwnerActivity ( getActivity ( ) ) ; dialog . show ( ) ; }
public void onClick ( DialogInterface dialog , int which ) { switch ( which ) { case 0 : RouteInfoActivity . start ( getActivity ( ) , routeId ) ; break; case 1 : HomeActivity . start ( getActivity ( ) , routeId ) ; break; } }
private void clickStop ( final ObaStop stop ) { AlertDialog . Builder builder = new AlertDialog . Builder ( getActivity ( ) ) ; builder . setTitle ( UIUtils . formatDisplayText ( stop . getName ( ) ) ) ; builder . setItems ( R . array . search_stop_options , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int which ) { switch ( which ) { case 0 : ArrivalsListActivity . start ( getActivity ( ) , stop . getId ( ) ) ; break; case 1 : HomeActivity . start ( getActivity ( ) , stop . getId ( ) , stop . getLatitude ( ) , stop . getLongitude ( ) ) ; break; } } } ) ; AlertDialog dialog = builder . create ( ) ; dialog . setOwnerActivity ( getActivity ( ) ) ; dialog . show ( ) ; }
public void onClick ( DialogInterface dialog , int which ) { switch ( which ) { case 0 : ArrivalsListActivity . start ( getActivity ( ) , stop . getId ( ) ) ; break; case 1 : HomeActivity . start ( getActivity ( ) , stop . getId ( ) , stop . getLatitude ( ) , stop . getLongitude ( ) ) ; break; } }
public MyAdapter ( Context context ) { super( context , R . layout . route_list_item ); }
@ Override public View getView ( int position , View convertView , ViewGroup parent ) { View view ; LayoutInflater inflater = getLayoutInflater ( ) ; ObaElement elem = getItem ( position ) ; if ( elem instanceof ObaRoute ) { view = inflater . inflate ( R . layout . route_list_item , parent , false ) ; UIUtils . setRouteView ( view , ( ObaRoute ) elem ) ; } else if ( elem instanceof ObaStop ) { view = inflater . inflate ( R . layout . stop_list_item , parent , false ) ; initStop ( view , ( ObaStop ) elem ) ; } else { view = null ; } return view ; }
private void initStop ( View view , ObaStop stop ) { TextView nameView = ( TextView ) view . findViewById ( R . id . stop_name ) ; nameView . setText ( UIUtils . formatDisplayText ( stop . getName ( ) ) ) ; UIUtils . setStopDirection ( view . findViewById ( R . id . direction ) , stop . getDirection ( ) , true ) ; }
@ Override protected void initView ( View view , ObaElement t ) { throw new AssertionError ( "Should never be called" ) ; }
public MyLoader ( Context context , String query , Location center ) { super( context ); mQueryText = query ; mCenter = center ; }
private ObaRoutesForLocationResponse getRoutes ( ) { ObaRoutesForLocationResponse response = new ObaRoutesForLocationRequest . Builder ( getContext ( ) , mCenter ) . setRadius ( LocationUtils . DEFAULT_SEARCH_RADIUS ) . setQuery ( mQueryText ) . build ( ) . call ( ) ; if ( response . getCode ( ) == ObaApi . OBA_OK ) { ObaRoute [] routes = response . getRoutesForLocation ( ) ; if ( routes . length != 0 ) { return response ; } } Location center = LocationUtils . getDefaultSearchCenter ( ) ; if ( center != null ) { return new ObaRoutesForLocationRequest . Builder ( getContext ( ) , center ) . setRadius ( LocationUtils . DEFAULT_SEARCH_RADIUS ) . setQuery ( mQueryText ) . build ( ) . call ( ) ; } return response ; }
private ObaStopsForLocationResponse getStops ( ) { return new ObaStopsForLocationRequest . Builder ( getContext ( ) , mCenter ) . setRadius ( LocationUtils . DEFAULT_SEARCH_RADIUS ) . setQuery ( mQueryText ) . build ( ) . call ( ) ; }
@ Override public SearchResponse loadInBackground ( ) { ArrayList < ObaElement > results = new ArrayList < ObaElement > ( ) ; ObaRoutesForLocationResponse routes = getRoutes ( ) ; ObaStopsForLocationResponse stops = getStops ( ) ; int routeCode = routes . getCode ( ) ; int stopCode = stops . getCode ( ) ; int code = ObaApi . OBA_OK ; if ( routeCode != ObaApi . OBA_OK && stopCode != ObaApi . OBA_OK ) { code = routeCode ; } if ( code == ObaApi . OBA_OK ) { results . addAll ( Arrays . asList ( routes . getRoutesForLocation ( ) ) ) ; results . addAll ( Arrays . asList ( stops . getStops ( ) ) ) ; } return new SearchResponse ( code , results ) ; }
public static void start ( Context context , String tripId , String stopId ) { Intent myIntent = new Intent ( context , TripInfoActivity .class ) ; myIntent . setData ( ObaContract . Trips . buildUri ( tripId , stopId ) ) ; context . startActivity ( myIntent ) ; }
public static void start ( Context context , String tripId , String stopId , String routeId , String routeName , String stopName , long departureTime , String headsign ) { Intent myIntent = new Intent ( context , TripInfoActivity .class ) ; myIntent . setData ( ObaContract . Trips . buildUri ( tripId , stopId ) ) ; myIntent . putExtra ( ROUTE_ID , routeId ) ; myIntent . putExtra ( ROUTE_NAME , routeName ) ; myIntent . putExtra ( STOP_NAME , stopName ) ; myIntent . putExtra ( DEPARTURE_TIME , departureTime ) ; myIntent . putExtra ( HEADSIGN , headsign ) ; context . startActivity ( myIntent ) ; }
@ Override public void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; UIUtils . setupActionBar ( this ) ; FragmentManager fm = getSupportFragmentManager ( ) ; if ( fm . findFragmentById ( android . R . id . content ) == null ) { TripInfoFragment content = new TripInfoFragment ( ) ; content . setArguments ( FragmentUtils . getIntentArgs ( getIntent ( ) ) ) ; fm . beginTransaction ( ) . add ( android . R . id . content , content ) . commit ( ) ; } }
@ Override public boolean onOptionsItemSelected ( MenuItem item ) { if ( item . getItemId ( ) == android . R . id . home ) { finish ( ) ; return true ; } return false ; }
TripInfoFragment getTripInfoFragment ( ) { FragmentManager fm = getSupportFragmentManager ( ) ; return ( TripInfoFragment ) fm . findFragmentById ( android . R . id . content ) ; }
@ Override public void onActivityCreated ( Bundle savedInstanceState ) { super. onActivityCreated ( savedInstanceState ) ; setHasOptionsMenu ( true ) ; if ( savedInstanceState != null ) { initFromBundle ( savedInstanceState ) ; initForm ( ) ; } else if ( initFromBundle ( getArguments ( ) ) ) { getLoaderManager ( ) . initLoader ( 0 , null , this ) ; } else { Log . e ( TAG , "Information missing from intent" ) ; return; } }
@ Override public View onCreateView ( LayoutInflater inflater , ViewGroup root , Bundle savedInstanceState ) { if ( root == null ) { return null ; } return inflater . inflate ( R . layout . trip_info , null ) ; }
@ Override public Loader < Cursor > onCreateLoader ( int id , Bundle args ) { return new CursorLoader ( getActivity ( ) , mTripUri , PROJECTION , null , null , null ) ; }
@ Override public void onLoadFinished ( Loader < Cursor > loader , Cursor data ) { mNewTrip = ! initFromCursor ( data ) ; initForm ( ) ; getActivity ( ) . supportInvalidateOptionsMenu ( ) ; }
@ Override public void onLoaderReset ( Loader < Cursor > loader ) {        }
@ Override public void onStart ( ) { ObaAnalytics . reportActivityStart ( getActivity ( ) ) ; super. onStart ( ) ; }
private boolean initFromBundle ( Bundle bundle ) { final Uri data = bundle . getParcelable ( FragmentUtils . URI ) ; if ( data == null ) { return false ; } List < String > segments = data . getPathSegments ( ) ; mTripId = segments . get ( 1 ) ; mStopId = segments . get ( 2 ) ; mTripUri = data ; if ( mTripId == null || mStopId == null ) { return false ; } mRouteId = bundle . getString ( ROUTE_ID ) ; mHeadsign = bundle . getString ( HEADSIGN ) ; mDepartTime = bundle . getLong ( DEPARTURE_TIME ) ; mStopName = bundle . getString ( STOP_NAME ) ; mRouteName = bundle . getString ( ROUTE_NAME ) ; if ( mRouteName != null ) { ContentValues values = new ContentValues ( ) ; values . put ( ObaContract . Routes . SHORTNAME , mRouteName ) ; ObaContract . Routes . insertOrUpdate ( getActivity ( ) , mRouteId , values , false ) ; } String name = bundle . getString ( TRIP_NAME ) ; if ( name != null ) { mTripName = name ; } mReminderTime = bundle . getInt ( REMINDER_TIME , mReminderTime ) ; mReminderDays = bundle . getInt ( REMINDER_DAYS , mReminderDays ) ; return true ; }
private boolean initFromCursor ( Cursor cursor ) { if ( cursor == null || cursor . getCount ( ) < 1 ) { mReminderTime = 10 ; return false ; } cursor . moveToFirst ( ) ; mTripName = cursor . getString ( COL_NAME ) ; mReminderTime = cursor . getInt ( COL_REMINDER ) ; mReminderDays = cursor . getInt ( COL_DAYS ) ; if ( mRouteId == null ) { mRouteId = cursor . getString ( COL_ROUTE_ID ) ; } if ( mHeadsign == null ) { mHeadsign = cursor . getString ( COL_HEADSIGN ) ; } if ( mDepartTime == 0 ) { mDepartTime = ObaContract . Trips . convertDBToTime ( cursor . getInt ( COL_DEPARTURE ) ) ; } if ( mRouteName == null ) { mRouteName = TripService . getRouteShortName ( getActivity ( ) , mRouteId ) ; } if ( mStopName == null ) { mStopName = UIUtils . stringForQuery ( getActivity ( ) , Uri . withAppendedPath ( ObaContract . Stops . CONTENT_URI , mStopId ) , ObaContract . Stops . NAME ) ; } return true ; }
private void initForm ( ) { View view = getView ( ) ; final Spinner reminder = ( Spinner ) view . findViewById ( R . id . trip_info_reminder_time ) ; ArrayAdapter < ? > adapter = ArrayAdapter . createFromResource ( getActivity ( ) , R . array . reminder_time , android . R . layout . simple_spinner_item ) ; adapter . setDropDownViewResource ( android . R . layout . simple_spinner_dropdown_item ) ; reminder . setAdapter ( adapter ) ; final TextView stopName = ( TextView ) view . findViewById ( R . id . stop_name ) ; stopName . setText ( UIUtils . formatDisplayText ( mStopName ) ) ; final TextView routeName = ( TextView ) view . findViewById ( R . id . route_name ) ; routeName . setText ( UIUtils . formatDisplayText ( getString ( R . string . trip_info_route , mRouteName ) ) ) ; final TextView headsign = ( TextView ) view . findViewById ( R . id . headsign ) ; headsign . setText ( UIUtils . formatDisplayText ( mHeadsign ) ) ; final TextView departText = ( TextView ) view . findViewById ( R . id . departure_time ) ; departText . setText ( getDepartureTime ( getActivity ( ) , mDepartTime ) ) ; final TextView tripName = ( TextView ) view . findViewById ( R . id . name ) ; tripName . setText ( mTripName ) ; reminder . setSelection ( reminderToSelection ( mReminderTime ) ) ; final Button repeats = ( Button ) view . findViewById ( R . id . trip_info_reminder_days ) ; repeats . setText ( getRepeatText ( getActivity ( ) , mReminderDays ) ) ; repeats . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { showReminderDaysDialog ( ) ; } } ) ; }
public void onClick ( View v ) { showReminderDaysDialog ( ) ; }
void finish ( ) { getActivity ( ) . finish ( ) ; }
@ Override public void onSaveInstanceState ( Bundle outState ) { super. onSaveInstanceState ( outState ) ; outState . putParcelable ( FragmentUtils . URI , mTripUri ) ; outState . putString ( ROUTE_ID , mRouteId ) ; outState . putString ( ROUTE_NAME , mRouteName ) ; outState . putString ( STOP_NAME , mStopName ) ; outState . putString ( HEADSIGN , mHeadsign ) ; outState . putLong ( DEPARTURE_TIME , mDepartTime ) ; View view = getView ( ) ; Spinner reminderView = ( Spinner ) view . findViewById ( R . id . trip_info_reminder_time ) ; TextView nameView = ( TextView ) view . findViewById ( R . id . name ) ; final int reminder = selectionToReminder ( reminderView . getSelectedItemPosition ( ) ) ; outState . putString ( TRIP_NAME , nameView . getText ( ) . toString ( ) ) ; outState . putInt ( REMINDER_TIME , reminder ) ; outState . putInt ( REMINDER_DAYS , mReminderDays ) ; }
@ Override public void onCreateOptionsMenu ( Menu menu , MenuInflater inflater ) { inflater . inflate ( R . menu . trip_info_options , menu ) ; }
@ Override public void onPrepareOptionsMenu ( Menu menu ) { menu . findItem ( R . id . trip_info_delete ) . setVisible ( ! mNewTrip ) ; }
@ Override public boolean onOptionsItemSelected ( MenuItem item ) { int id = item . getItemId ( ) ; if ( id == R . id . trip_info_save ) { saveTrip ( ) ; } else if ( id == R . id . trip_info_delete ) { Bundle args = new Bundle ( ) ; args . putParcelable ( "uri" , mTripUri ) ; DeleteDialog dialog = new DeleteDialog ( ) ; dialog . setArguments ( args ) ; dialog . show ( getActivity ( ) . getSupportFragmentManager ( ) , TAG_DELETE_DIALOG ) ; } else if ( id == R . id . show_route ) { RouteInfoActivity . start ( getActivity ( ) , mRouteId ) ; return true ; } else if ( id == R . id . show_stop ) { new ArrivalsListActivity . Builder ( getActivity ( ) , mStopId ) . setStopName ( mStopName ) . start ( ) ; return true ; } return false ; }
public void saveTrip ( ) { View view = getView ( ) ; final Spinner reminderView = ( Spinner ) view . findViewById ( R . id . trip_info_reminder_time ) ; final TextView nameView = ( TextView ) view . findViewById ( R . id . name ) ; final int reminder = selectionToReminder ( reminderView . getSelectedItemPosition ( ) ) ; ContentValues values = new ContentValues ( ) ; values . put ( ObaContract . Trips . ROUTE_ID , mRouteId ) ; values . put ( ObaContract . Trips . DEPARTURE , ObaContract . Trips . convertTimeToDB ( mDepartTime ) ) ; values . put ( ObaContract . Trips . HEADSIGN , mHeadsign ) ; values . put ( ObaContract . Trips . NAME , nameView . getText ( ) . toString ( ) ) ; values . put ( ObaContract . Trips . REMINDER , reminder ) ; values . put ( ObaContract . Trips . DAYS , mReminderDays ) ; ContentResolver cr = getActivity ( ) . getContentResolver ( ) ; Cursor c = cr . query ( mTripUri , new String [] { ObaContract . Trips . _ID } , null , null , null ) ; if ( c != null && c . getCount ( ) > 0 ) { cr . update ( mTripUri , values , null , null ) ; } else { values . put ( ObaContract . Trips . _ID , mTripId ) ; values . put ( ObaContract . Trips . STOP_ID , mStopId ) ; cr . insert ( ObaContract . Trips . CONTENT_URI , values ) ; } if ( c != null ) { c . close ( ) ; } TripService . scheduleAll ( getActivity ( ) ) ; Toast . makeText ( getActivity ( ) , R . string . trip_info_saved , Toast . LENGTH_SHORT ) . show ( ) ; finish ( ) ; }
void showReminderDaysDialog ( ) { final boolean [] checks = ObaContract . Trips . daysToArray ( mReminderDays ) ; Bundle args = new Bundle ( ) ; args . putBooleanArray ( ReminderDaysDialog . CHECKS , checks ) ; ReminderDaysDialog frag = new ReminderDaysDialog ( ) ; frag . setArguments ( args ) ; frag . show ( getActivity ( ) . getSupportFragmentManager ( ) , ".ReminderDaysDialog" ) ; }
@ Override public Dialog onCreateDialog ( Bundle savedInstanceState ) { Bundle args = getArguments ( ) ; mChecks = args . getBooleanArray ( CHECKS ) ; if ( savedInstanceState != null ) { mChecks = args . getBooleanArray ( CHECKS ) ; } AlertDialog . Builder builder = new AlertDialog . Builder ( getActivity ( ) ) ; return builder . setTitle ( R . string . trip_info_reminder_repeat ) . setMultiChoiceItems ( R . array . reminder_days , mChecks , this ) . setPositiveButton ( R . string . trip_info_save , this ) . setNegativeButton ( R . string . trip_info_dismiss , null ) . create ( ) ; }
@ Override public void onSaveInstanceState ( Bundle outState ) { outState . putBooleanArray ( CHECKS , mChecks ) ; }
@ Override public void onClick ( DialogInterface dialog , int which ) { TripInfoActivity act = ( TripInfoActivity ) getActivity ( ) ; TripInfoFragment frag = act . getTripInfoFragment ( ) ; frag . setReminderDays ( mChecks ) ; dialog . dismiss ( ) ; }
@ Override public void onClick ( DialogInterface arg0 , int which , boolean isChecked ) { mChecks [ which ] = isChecked ; }
private void setReminderDays ( boolean [] checks ) { View view = getView ( ) ; mReminderDays = ObaContract . Trips . arrayToDays ( checks ) ; final Button repeats = ( Button ) view . findViewById ( R . id . trip_info_reminder_days ) ; repeats . setText ( getRepeatText ( getActivity ( ) , mReminderDays ) ) ; }
@ Override public Dialog onCreateDialog ( Bundle savedInstanceState ) { Bundle args = getArguments ( ) ; final Uri tripUri = args . getParcelable ( "uri" ) ; AlertDialog . Builder builder = new AlertDialog . Builder ( getActivity ( ) ) ; builder . setMessage ( R . string . trip_info_delete_trip ) . setTitle ( R . string . trip_info_delete ) . setIcon ( android . R . drawable . ic_dialog_alert ) . setPositiveButton ( android . R . string . ok , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int which ) { ContentResolver cr = getActivity ( ) . getContentResolver ( ) ; cr . delete ( tripUri , null , null ) ; TripService . scheduleAll ( getActivity ( ) ) ; getActivity ( ) . finish ( ) ; } } ) . setNegativeButton ( android . R . string . cancel , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int which ) { dialog . dismiss ( ) ; } } ) ; return builder . create ( ) ; }
public void onClick ( DialogInterface dialog , int which ) { ContentResolver cr = getActivity ( ) . getContentResolver ( ) ; cr . delete ( tripUri , null , null ) ; TripService . scheduleAll ( getActivity ( ) ) ; getActivity ( ) . finish ( ) ; }
public void onClick ( DialogInterface dialog , int which ) { dialog . dismiss ( ) ; }
private static int reminderToSelection ( int reminder ) { switch ( reminder ) { case 0 : return 0 ; case 1 : return 1 ; case 3 : return 2 ; case 5 : return 3 ; case 10 : return 4 ; case 15 : return 5 ; case 20 : return 6 ; case 25 : return 7 ; case 30 : return 8 ; default: Log . e ( TAG , "Invalid reminder value in DB: " + reminder ) ; return 0 ; } }
private static int selectionToReminder ( int selection ) { switch ( selection ) { case 0 : return 0 ; case 1 : return 1 ; case 2 : return 3 ; case 3 : return 5 ; case 4 : return 10 ; case 5 : return 15 ; case 6 : return 20 ; case 7 : return 25 ; case 8 : return 30 ; default: Log . e ( TAG , "Invalid selection: " + selection ) ; return 0 ; } }
static String getDepartureTime ( Context ctx , long departure ) { return ctx . getString ( R . string . trip_info_depart , DateUtils . formatDateTime ( ctx , departure , DateUtils . FORMAT_SHOW_TIME | DateUtils . FORMAT_NO_NOON | DateUtils . FORMAT_NO_MIDNIGHT ) ) ; }
static String getRepeatText ( Context ctx , int days ) { final Resources res = ctx . getResources ( ) ; if ( ( days & ObaContract . Trips . DAY_ALL ) == ObaContract . Trips . DAY_ALL ) { return res . getString ( R . string . trip_info_repeat_everyday ) ; } if ( ( ( days & ObaContract . Trips . DAY_WEEKDAY ) == ObaContract . Trips . DAY_WEEKDAY ) && ( days & ~ ObaContract . Trips . DAY_WEEKDAY ) == 0 ) { return res . getString ( R . string . trip_info_repeat_weekdays ) ; } if ( days == 0 ) { return res . getString ( R . string . trip_info_repeat_norepeat ) ; } final boolean [] array = ObaContract . Trips . daysToArray ( days ) ; final String [] dayNames = res . getStringArray ( R . array . reminder_days ) ; StringBuffer buf = new StringBuffer ( ) ; int rangeStart = 0 ; while ( rangeStart < 7 ) { for (; rangeStart < 7 && ! array [ rangeStart ] ; ++ rangeStart ) {            } if ( rangeStart == 7 ) { break; } int rangeEnd = rangeStart + 1 ; for (; rangeEnd < 7 && array [ rangeEnd ] ; ++ rangeEnd ) {            } if ( buf . length ( ) != 0 ) { buf . append ( ", " ) ; } if ( ( rangeEnd - rangeStart ) == 1 ) { buf . append ( dayNames [ rangeStart ] ) ; } else { buf . append ( dayNames [ rangeStart ] ) ; buf . append ( " - " ) ; buf . append ( dayNames [ rangeEnd - 1 ] ) ; } rangeStart = rangeEnd ; } return res . getString ( R . string . trip_info_repeat_every , buf . toString ( ) ) ; }
@ Override protected void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_viewpagertab2 ) ; setSupportActionBar ( ( Toolbar ) findViewById ( R . id . toolbar ) ) ; ViewCompat . setElevation ( findViewById ( R . id . header ) , getResources ( ) . getDimension ( R . dimen . toolbar_elevation ) ) ; mToolbarView = findViewById ( R . id . toolbar ) ; mPagerAdapter = new NavigationAdapter ( getSupportFragmentManager ( ) ) ; mPager = ( ViewPager ) findViewById ( R . id . pager ) ; mPager . setAdapter ( mPagerAdapter ) ; final int tabHeight = getResources ( ) . getDimensionPixelSize ( R . dimen . tab_height ) ; findViewById ( R . id . pager_wrapper ) . setPadding ( 0 , getActionBarSize ( ) + tabHeight , 0 , 0 ) ; SlidingTabLayout slidingTabLayout = ( SlidingTabLayout ) findViewById ( R . id . sliding_tabs ) ; slidingTabLayout . setCustomTabView ( R . layout . tab_indicator , android . R . id . text1 ) ; slidingTabLayout . setSelectedIndicatorColors ( getResources ( ) . getColor ( R . color . accent ) ) ; slidingTabLayout . setDistributeEvenly ( true ) ; slidingTabLayout . setViewPager ( mPager ) ; ViewConfiguration vc = ViewConfiguration . get ( this ) ; mSlop = vc . getScaledTouchSlop ( ) ; mInterceptionLayout = ( TouchInterceptionFrameLayout ) findViewById ( R . id . container ) ; mInterceptionLayout . setScrollInterceptionListener ( mInterceptionListener ) ; }
@ Override public void onScrollChanged ( int scrollY , boolean firstScroll , boolean dragging ) {    }
@ Override public void onDownMotionEvent ( ) {    }
@ Override public void onUpOrCancelMotionEvent ( ScrollState scrollState ) { if ( ! mScrolled ) { adjustToolbar ( scrollState ) ; } }
@ Override public boolean shouldInterceptTouchEvent ( MotionEvent ev , boolean moving , float diffX , float diffY ) { if ( ! mScrolled && mSlop < Math . abs ( diffX ) && Math . abs ( diffY ) < Math . abs ( diffX ) ) { return false ; } Scrollable scrollable = getCurrentScrollable ( ) ; if ( scrollable == null ) { mScrolled = false ; return false ; } int toolbarHeight = mToolbarView . getHeight ( ) ; int translationY = ( int ) ViewHelper . getTranslationY ( mInterceptionLayout ) ; boolean scrollingUp = 0 < diffY ; boolean scrollingDown = diffY < 0 ; if ( scrollingUp ) { if ( translationY < 0 ) { mScrolled = true ; mLastScrollState = ScrollState . UP ; return true ; } } else if ( scrollingDown ) { if ( - toolbarHeight < translationY ) { mScrolled = true ; mLastScrollState = ScrollState . DOWN ; return true ; } } mScrolled = false ; return false ; }
@ Override public void onDownMotionEvent ( MotionEvent ev ) {        }
@ Override public void onMoveMotionEvent ( MotionEvent ev , float diffX , float diffY ) { float translationY = ScrollUtils . getFloat ( ViewHelper . getTranslationY ( mInterceptionLayout ) + diffY , - mToolbarView . getHeight ( ) , 0 ) ; ViewHelper . setTranslationY ( mInterceptionLayout , translationY ) ; if ( translationY < 0 ) { FrameLayout . LayoutParams lp = ( FrameLayout . LayoutParams ) mInterceptionLayout . getLayoutParams ( ) ; lp . height = ( int ) ( - translationY + getScreenHeight ( ) ) ; mInterceptionLayout . requestLayout ( ) ; } }
@ Override public void onUpOrCancelMotionEvent ( MotionEvent ev ) { mScrolled = false ; adjustToolbar ( mLastScrollState ) ; }
private Scrollable getCurrentScrollable ( ) { Fragment fragment = getCurrentFragment ( ) ; if ( fragment == null ) { return null ; } View view = fragment . getView ( ) ; if ( view == null ) { return null ; } return ( Scrollable ) view . findViewById ( R . id . scroll ) ; }
private void adjustToolbar ( ScrollState scrollState ) { int toolbarHeight = mToolbarView . getHeight ( ) ; final Scrollable scrollable = getCurrentScrollable ( ) ; if ( scrollable == null ) { return; } int scrollY = scrollable . getCurrentScrollY ( ) ; if ( scrollState == ScrollState . DOWN ) { showToolbar ( ) ; } else if ( scrollState == ScrollState . UP ) { if ( toolbarHeight <= scrollY ) { hideToolbar ( ) ; } else { showToolbar ( ) ; } } else if ( ! toolbarIsShown ( ) && ! toolbarIsHidden ( ) ) { showToolbar ( ) ; } }
private Fragment getCurrentFragment ( ) { return mPagerAdapter . getItemAt ( mPager . getCurrentItem ( ) ) ; }
private boolean toolbarIsShown ( ) { return ViewHelper . getTranslationY ( mInterceptionLayout ) == 0 ; }
private boolean toolbarIsHidden ( ) { return ViewHelper . getTranslationY ( mInterceptionLayout ) == - mToolbarView . getHeight ( ) ; }
private void showToolbar ( ) { animateToolbar ( 0 ) ; }
private void hideToolbar ( ) { animateToolbar ( - mToolbarView . getHeight ( ) ) ; }
private void animateToolbar ( final float toY ) { float layoutTranslationY = ViewHelper . getTranslationY ( mInterceptionLayout ) ; if ( layoutTranslationY != toY ) { ValueAnimator animator = ValueAnimator . ofFloat ( ViewHelper . getTranslationY ( mInterceptionLayout ) , toY ) . setDuration ( 200 ) ; animator . addUpdateListener ( new ValueAnimator . AnimatorUpdateListener ( ) { @ Override public void onAnimationUpdate ( ValueAnimator animation ) { float translationY = ( float ) animation . getAnimatedValue ( ) ; ViewHelper . setTranslationY ( mInterceptionLayout , translationY ) ; if ( translationY < 0 ) { FrameLayout . LayoutParams lp = ( FrameLayout . LayoutParams ) mInterceptionLayout . getLayoutParams ( ) ; lp . height = ( int ) ( - translationY + getScreenHeight ( ) ) ; mInterceptionLayout . requestLayout ( ) ; } } } ) ; animator . start ( ) ; } }
@ Override public void onAnimationUpdate ( ValueAnimator animation ) { float translationY = ( float ) animation . getAnimatedValue ( ) ; ViewHelper . setTranslationY ( mInterceptionLayout , translationY ) ; if ( translationY < 0 ) { FrameLayout . LayoutParams lp = ( FrameLayout . LayoutParams ) mInterceptionLayout . getLayoutParams ( ) ; lp . height = ( int ) ( - translationY + getScreenHeight ( ) ) ; mInterceptionLayout . requestLayout ( ) ; } }
public NavigationAdapter ( FragmentManager fm ) { super( fm ); }
@ Override protected Fragment createItem ( int position ) { Fragment f ; final int pattern = position % 5 ; switch ( pattern ) { case 0 : f = new ViewPagerTab2ScrollViewFragment ( ) ; break; case 1 : f = new ViewPagerTab2ListViewFragment ( ) ; break; case 2 : f = new ViewPagerTab2RecyclerViewFragment ( ) ; break; case 3 : f = new ViewPagerTab2GridViewFragment ( ) ; break; case 4 : default: f = new ViewPagerTab2WebViewFragment ( ) ; break; } return f ; }
@ Override public int getCount ( ) { return TITLES . length ; }
@ Override public CharSequence getPageTitle ( int position ) { return TITLES [ position ] ; }
@ Override public void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; setContentView ( R . layout . main ) ; table = ( TableLayout ) findViewById ( R . id . Table ) ; redButton = ( Button ) findViewById ( R . id . ButtonRed ) ; greenButton = ( Button ) findViewById ( R . id . ButtonGreen ) ; blueButton = ( Button ) findViewById ( R . id . ButtonBlue ) ; blackButton = ( Button ) findViewById ( R . id . ButtonBlack ) ; whiteButton = ( Button ) findViewById ( R . id . ButtonWhite ) ; table . setBackgroundColor ( Color . WHITE ) ; redButton . setOnClickListener ( OnClickChangeColor ( Color . RED ) ) ; greenButton . setOnClickListener ( OnClickChangeColor ( Color . GREEN ) ) ; blueButton . setOnClickListener ( OnClickChangeColor ( Color . BLUE ) ) ; blackButton . setOnClickListener ( OnClickChangeColor ( Color . BLACK ) ) ; whiteButton . setOnClickListener ( OnClickChangeColor ( Color . WHITE ) ) ; }
View . OnClickListener OnClickChangeColor ( final int color ) { return ( view ) -> { table . setBackgroundColor ( color ) ; } ; }
public LayoutAnimationControllerAssert ( LayoutAnimationController actual ) { super( actual , LayoutAnimationControllerAssert .class ); }
protected ObaAgenciesWithCoverageRequest ( Uri uri ) { super( uri ); }
public Builder ( Context context ) { super( context , BASE_PATH + "/agencies-with-coverage.json" ); }
public ObaAgenciesWithCoverageRequest build ( ) { return new ObaAgenciesWithCoverageRequest ( buildUri ( ) ) ; }
public static ObaAgenciesWithCoverageRequest newRequest ( Context context ) { return new Builder ( context ) . build ( ) ; }
@ Override public ObaAgenciesWithCoverageResponse call ( ) { return call ( ObaAgenciesWithCoverageResponse .class ) ; }
@ Override public String toString ( ) { return "ObaAgenciesWithCoverageRequest [mUri=" + mUri + "]" ; }
public void execute ( ) MojoExecutionException , MojoFailureException { String out = targetDirectory . getPath ( ) ; for ( String src : project . getCompileSourceRoots ( ) ) { if ( ! src . startsWith ( out ) ) { sourceFolders . add ( src ) ; } } getLog ( ) . info ( "Generating AAR file : " + project . getArtifactId ( ) ) ; generateIntermediateApk ( ) ; final File outputFile = createAarLibraryFile ( createAarClassesJar ( ) ) ; if ( classifier == null ) { project . getArtifact ( ) . setFile ( outputFile ) ; } else { projectHelper . attachArtifact ( project , AndroidExtension . AAR , classifier , outputFile ) ; } }
protected File createAarClassesJar ( ) MojoExecutionException { final File obfuscatedJarFile = new File ( obfuscatedJar ) ; if ( obfuscatedJarFile . exists ( ) ) { return obfuscatedJarFile ; } final File classesJar = new File ( targetDirectory , finalName + ".aar.classes.jar" ) ; try { JarArchiver jarArchiver = new JarArchiver ( ) ; jarArchiver . setDestFile ( classesJar ) ; jarArchiver . addDirectory ( projectOutputDirectory , classesJarIncludes , classesJarExcludes ) ; jarArchiver . createArchive ( ) ; return classesJar ; } catch ( ArchiverException e ) { throw new MojoExecutionException ( "ArchiverException while creating ." + classesJar + " file." , e ) ; } catch ( IOException e ) { throw new MojoExecutionException ( "IOException while creating ." + classesJar + " file." , e ) ; } }
protected File createAarLibraryFile ( File classesJar ) throws MojoExecutionException { final File aarLibrary = new File ( targetDirectory , finalName + "." + AAR ) ; FileUtils . deleteQuietly ( aarLibrary ) ; try { final ZipArchiver zipArchiver = new ZipArchiver ( ) ; zipArchiver . setDestFile ( aarLibrary ) ; zipArchiver . addFile ( destinationManifestFile , "AndroidManifest.xml" ) ; addDirectory ( zipArchiver , assetsDirectory , "assets" , false ) ; if ( ! resourceDirectory . exists ( ) ) { resourceDirectory . mkdir ( ) ; } addDirectory ( zipArchiver , resourceDirectory , "res" , true ) ; zipArchiver . addFile ( classesJar , SdkConstants . FN_CLASSES_JAR ) ; final File [] overlayDirectories = getResourceOverlayDirectories ( ) ; for ( final File resOverlayDir : overlayDirectories ) { if ( resOverlayDir != null && resOverlayDir . exists ( ) ) { addDirectory ( zipArchiver , resOverlayDir , "res" , false ) ; } } if ( consumerProguardFiles != null ) { final File mergedConsumerProguardFile = new File ( targetDirectory , "consumer-proguard.txt" ) ; if ( mergedConsumerProguardFile . exists ( ) ) { FileUtils . forceDelete ( mergedConsumerProguardFile ) ; } mergedConsumerProguardFile . createNewFile ( ) ; StringBuilder mergedConsumerProguardFileBuilder = new StringBuilder ( ) ; for ( File consumerProguardFile : consumerProguardFiles ) { if ( consumerProguardFile . exists ( ) ) { getLog ( ) . info ( "Adding consumer proguard file " + consumerProguardFile ) ; FileInputStream consumerProguardFileInputStream = null ; try { consumerProguardFileInputStream = new FileInputStream ( consumerProguardFile ) ; mergedConsumerProguardFileBuilder . append ( IOUtils . toString ( consumerProguardFileInputStream ) ) ; mergedConsumerProguardFileBuilder . append ( SystemUtils . LINE_SEPARATOR ) ; } catch ( IOException e ) { throw new MojoExecutionException ( "Error writing consumer proguard file " , e ) ; } finally { IOUtils . closeQuietly ( consumerProguardFileInputStream ) ; } } } FileOutputStream mergedConsumerProguardFileOutputStream = null ; try { mergedConsumerProguardFileOutputStream = new FileOutputStream ( mergedConsumerProguardFile ) ; IOUtils . write ( mergedConsumerProguardFileBuilder , mergedConsumerProguardFileOutputStream ) ; } catch ( IOException e ) { throw new MojoExecutionException ( "Error writing consumer proguard file " , e ) ; } finally { IOUtils . closeQuietly ( mergedConsumerProguardFileOutputStream ) ; } zipArchiver . addFile ( mergedConsumerProguardFile , "proguard.txt" ) ; } addR ( zipArchiver ) ; addNativeLibraries ( zipArchiver ) ; zipArchiver . createArchive ( ) ; } catch ( ArchiverException e ) { throw new MojoExecutionException ( "ArchiverException while creating ." + AAR + " file." , e ) ; } catch ( IOException e ) { throw new MojoExecutionException ( "IOException while creating ." + AAR + " file." , e ) ; } return aarLibrary ; }
private void addR ( ZipArchiver zipArchiver ) throws MojoExecutionException , IOException { final File rFile = new File ( targetDirectory , "R.txt" ) ; if ( ! rFile . exists ( ) ) { getLog ( ) . debug ( "No resources - creating empty R.txt" ) ; if ( ! rFile . createNewFile ( ) ) { getLog ( ) . warn ( "Unable to create R.txt in AAR" ) ; } } zipArchiver . addFile ( rFile , "R.txt" ) ; getLog ( ) . debug ( "Packaging R.txt in AAR" ) ; }
private void addNativeLibraries ( final ZipArchiver zipArchiver ) throws MojoExecutionException { try { if ( nativeLibrariesDirectory . exists ( ) ) { getLog ( ) . info ( nativeLibrariesDirectory + " exists, adding libraries." ) ; addDirectory ( zipArchiver , nativeLibrariesDirectory , NATIVE_LIBRARIES_FOLDER , false ) ; } else { getLog ( ) . info ( nativeLibrariesDirectory + " does not exist, looking for libraries in target directory." ) ; String [] ndkArchitectures = NativeHelper . getNdkArchitectures ( ndkArchitecture , applicationMakefile , project . getBasedir ( ) ) ; for ( String architecture : ndkArchitectures ) { final File ndkLibsDirectory = new File ( ndkOutputDirectory , architecture ) ; addSharedLibraries ( zipArchiver , ndkLibsDirectory , architecture ) ; } } } catch ( ArchiverException e ) { throw new MojoExecutionException ( "IOException while creating ." + AAR + " file." , e ) ; } }
protected String endWithSlash ( String prefix ) { prefix = StringUtils . defaultIfEmpty ( prefix , "/" ) ; if ( ! prefix . endsWith ( "/" ) ) { prefix = prefix + "/" ; } return prefix ; }
protected void addDirectory ( ZipArchiver zipArchiver , File directory , String prefix , boolean includeEmptyFolders ) { if ( directory != null && directory . exists ( ) ) { final DefaultFileSet fileSet = new DefaultFileSet ( ) ; fileSet . setPrefix ( endWithSlash ( prefix ) ) ; fileSet . setDirectory ( directory ) ; fileSet . setIncludingEmptyDirectories ( includeEmptyFolders ) ; zipArchiver . addFileSet ( fileSet ) ; getLog ( ) . debug ( "Added files from " + directory ) ; } }
protected void addSharedLibraries ( ZipArchiver zipArchiver , File directory , String architecture ) { getLog ( ) . debug ( "Searching for shared libraries in " + directory ) ; File [] libFiles = directory . listFiles ( new FilenameFilter ( ) { public boolean accept ( final File dir , final String name ) { return name . startsWith ( "lib" ) && name . endsWith ( ".so" ) ; } } ) ; if ( libFiles != null ) { for ( File libFile : libFiles ) { String dest = NATIVE_LIBRARIES_FOLDER + "/" + architecture + "/" + libFile . getName ( ) ; getLog ( ) . debug ( "Adding " + libFile + " as " + dest ) ; zipArchiver . addFile ( libFile , dest ) ; } } }
public boolean accept ( final File dir , final String name ) { return name . startsWith ( "lib" ) && name . endsWith ( ".so" ) ; }
private void generateIntermediateApk ( ) MojoExecutionException { List < File > dependenciesResDirectories = new ArrayList < File > ( ) ; for ( Artifact libraryArtifact : getTransitiveDependencyArtifacts ( APKLIB , AAR ) ) { final File apkLibResDir = getUnpackedLibResourceFolder ( libraryArtifact ) ; if ( apkLibResDir . exists ( ) ) { dependenciesResDirectories . add ( apkLibResDir ) ; } } final CommandExecutor executor = CommandExecutor . Factory . createDefaultCommmandExecutor ( ) ; executor . setLogger ( this . getLog ( ) ) ; File outputFile = new File ( targetDirectory , finalName + ".ap_" ) ; final AaptCommandBuilder commandBuilder = AaptCommandBuilder . packageResources ( getLog ( ) ) . makePackageDirectories ( ) . forceOverwriteExistingFiles ( ) . setPathToAndroidManifest ( destinationManifestFile ) . addResourceDirectoriesIfExists ( getResourceOverlayDirectories ( ) ) . addResourceDirectoryIfExists ( resourceDirectory ) . addResourceDirectoriesIfExists ( dependenciesResDirectories ) . autoAddOverlay ( ) . addRawAssetsDirectoryIfExists ( combinedAssets ) . addExistingPackageToBaseIncludeSet ( getAndroidSdk ( ) . getAndroidJar ( ) ) . setOutputApkFile ( outputFile ) . addConfigurations ( configurations ) . setResourceConstantsFolder ( genDirectory ) . makeResourcesNonConstant ( ) . generateRTextFile ( targetDirectory ) . setVerbose ( aaptVerbose ) ; getLog ( ) . debug ( getAndroidSdk ( ) . getAaptPath ( ) + " " + commandBuilder . toString ( ) ) ; getLog ( ) . info ( "Generating aar" ) ; try { executor . setCaptureStdOut ( true ) ; final List < String > commands = commandBuilder . build ( ) ; executor . executeCommand ( getAndroidSdk ( ) . getAaptPath ( ) , commands , project . getBasedir ( ) , false ) ; } catch ( ExecutionException e ) { throw new MojoExecutionException ( "" , e ) ; } }
public void testBasicUrlUsingCustomUrl ( ) { so use Puget Sound base URL        */ ObaRegion region = MockRegion . getPugetSound ( getContext ( ) ) ; Application . get ( ) . setCustomApiUrl ( region . getObaBaseUrl ( ) ) ; _assertBasicUrl ( ) ; }
public void testBasicUrlUsingRegion ( ) { so use Puget Sound base URL        */ ObaRegion region = MockRegion . getPugetSound ( getContext ( ) ) ; Application . get ( ) . setCurrentRegion ( region ) ; _assertBasicUrl ( ) ; }
private void _assertBasicUrl ( ) { ObaArrivalInfoRequest . Builder builder = new ObaArrivalInfoRequest . Builder ( getContext ( ) , "1_29261" ) ; ObaArrivalInfoRequest request = builder . build ( ) ; UriAssert . assertUriMatch ( "http: , new HashMap < String , String > ( ) { { put ( "key" , "*" ) ; put ( "version" , "2" ) ; } } , request ) ; }
public void testUrlWithSpacesUsingCustomUrl ( ) { ObaRegion region = MockRegion . getTampa ( getContext ( ) ) ; Application . get ( ) . setCustomApiUrl ( region . getObaBaseUrl ( ) ) ; _assertUrlWithSpaces ( ) ; }
public void testUrlWithSpacesUsingRegion ( ) { ObaRegion region = MockRegion . getTampa ( getContext ( ) ) ; Application . get ( ) . setCurrentRegion ( region ) ; _assertUrlWithSpaces ( ) ; }
private void _assertUrlWithSpaces ( ) { ObaArrivalInfoRequest . Builder builder = new ObaArrivalInfoRequest . Builder ( getContext ( ) , "Hillsborough Area Regional Transit_3105" ) ; ObaArrivalInfoRequest request = builder . build ( ) ; UriAssert . assertUriMatch ( "http: , new HashMap < String , String > ( ) { { put ( "key" , "*" ) ; put ( "version" , "2" ) ; } } , request ) ; }
public void testUrlWithPathAndSeparatorUsingCustomUrl ( ) { ObaRegion region = MockRegion . getTampa ( getContext ( ) ) ; Application . get ( ) . setCustomApiUrl ( region . getObaBaseUrl ( ) ) ; _assertUrlWithPathAndSeparator ( ) ; }
public void testUrlWithPathAndSeparatorUsingRegion ( ) { ObaRegion region = MockRegion . getTampa ( getContext ( ) ) ; Application . get ( ) . setCurrentRegion ( region ) ; _assertUrlWithPathAndSeparator ( ) ; }
private void _assertUrlWithPathAndSeparator ( ) { ObaArrivalInfoRequest . Builder builder = new ObaArrivalInfoRequest . Builder ( getContext ( ) , "Hillsborough Area Regional Transit_3105" ) ; ObaArrivalInfoRequest request = builder . build ( ) ; UriAssert . assertUriMatch ( "http: , new HashMap < String , String > ( ) { { put ( "key" , "*" ) ; put ( "version" , "2" ) ; } } , request ) ; }
public void testUrlWithPathNoSeparatorUsingCustomUrl ( ) { ObaRegion region = MockRegion . getRegionWithPathNoSeparator ( getContext ( ) ) ; Application . get ( ) . setCustomApiUrl ( region . getObaBaseUrl ( ) ) ; _assertUrlWithPathNoSeparator ( ) ; }
public void testUrlWithPathNoSeparatorUsingRegion ( ) { ObaRegion region = MockRegion . getRegionWithPathNoSeparator ( getContext ( ) ) ; Application . get ( ) . setCurrentRegion ( region ) ; _assertUrlWithPathNoSeparator ( ) ; }
private void _assertUrlWithPathNoSeparator ( ) { ObaArrivalInfoRequest . Builder builder = new ObaArrivalInfoRequest . Builder ( getContext ( ) , "Hillsborough Area Regional Transit_3105" ) ; ObaArrivalInfoRequest request = builder . build ( ) ; UriAssert . assertUriMatch ( "http: , new HashMap < String , String > ( ) { { put ( "key" , "*" ) ; put ( "version" , "2" ) ; } } , request ) ; }
public void testUrlNoSeparatorUsingCustomUrl ( ) { ObaRegion region = MockRegion . getRegionNoSeparator ( getContext ( ) ) ; Application . get ( ) . setCustomApiUrl ( region . getObaBaseUrl ( ) ) ; _assertUrlNoSeparator ( ) ; }
public void testUrlNoSeparatorUsingRegion ( ) { ObaRegion region = MockRegion . getRegionNoSeparator ( getContext ( ) ) ; Application . get ( ) . setCurrentRegion ( region ) ; _assertUrlNoSeparator ( ) ; }
private void _assertUrlNoSeparator ( ) { ObaArrivalInfoRequest . Builder builder = new ObaArrivalInfoRequest . Builder ( getContext ( ) , "1_29261" ) ; ObaArrivalInfoRequest request = builder . build ( ) ; UriAssert . assertUriMatch ( "http: , new HashMap < String , String > ( ) { { put ( "key" , "*" ) ; put ( "version" , "2" ) ; } } , request ) ; }
public void testUrlWithPortUsingCustomUrl ( ) { ObaRegion region = MockRegion . getRegionWithPort ( getContext ( ) ) ; Application . get ( ) . setCustomApiUrl ( region . getObaBaseUrl ( ) ) ; _assertUrlWithPort ( ) ; }
public void testUrlWithPortUsingRegion ( ) { ObaRegion region = MockRegion . getRegionWithPort ( getContext ( ) ) ; Application . get ( ) . setCurrentRegion ( region ) ; _assertUrlWithPort ( ) ; }
private void _assertUrlWithPort ( ) { ObaArrivalInfoRequest . Builder builder = new ObaArrivalInfoRequest . Builder ( getContext ( ) , "Hillsborough Area Regional Transit_3105" ) ; ObaArrivalInfoRequest request = builder . build ( ) ; UriAssert . assertUriMatch ( "http: , new HashMap < String , String > ( ) { { put ( "key" , "*" ) ; put ( "version" , "2" ) ; } } , request ) ; }
public void testUrlNoSchemeUsingCustomUrl ( ) { ObaRegion region = MockRegion . getRegionNoScheme ( getContext ( ) ) ; Application . get ( ) . setCustomApiUrl ( region . getObaBaseUrl ( ) ) ; _assertUrlNoScheme ( ) ; }
private void _assertUrlNoScheme ( ) { ObaArrivalInfoRequest . Builder builder = new ObaArrivalInfoRequest . Builder ( getContext ( ) , "Hillsborough Area Regional Transit_3105" ) ; ObaArrivalInfoRequest request = builder . build ( ) ; UriAssert . assertUriMatch ( "http: , new HashMap < String , String > ( ) { { put ( "key" , "*" ) ; put ( "version" , "2" ) ; } } , request ) ; }
public void testHttps ( ) { ObaRegion region = MockRegion . getRegionWithHttps ( ) ; Application . get ( ) . setCustomApiUrl ( region . getObaBaseUrl ( ) ) ; _assertUrlHttps ( ) ; }
private void _assertUrlHttps ( ) { ObaArrivalInfoRequest . Builder builder = new ObaArrivalInfoRequest . Builder ( getContext ( ) , "Hillsborough Area Regional Transit_3105" ) ; ObaArrivalInfoRequest request = builder . build ( ) ; UriAssert . assertUriMatch ( "https: , new HashMap < String , String > ( ) { { put ( "key" , "*" ) ; put ( "version" , "2" ) ; } } , request ) ; }
public void testHttpsAndPort ( ) { ObaRegion region = MockRegion . getRegionWithHttpsAndPort ( ) ; Application . get ( ) . setCustomApiUrl ( region . getObaBaseUrl ( ) ) ; _assertUrlHttpsWithPort ( ) ; }
private void _assertUrlHttpsWithPort ( ) { ObaArrivalInfoRequest . Builder builder = new ObaArrivalInfoRequest . Builder ( getContext ( ) , "Hillsborough Area Regional Transit_3105" ) ; ObaArrivalInfoRequest request = builder . build ( ) ; UriAssert . assertUriMatch ( "https: , new HashMap < String , String > ( ) { { put ( "key" , "*" ) ; put ( "version" , "2" ) ; } } , request ) ; }
public void testRegionBaseUrls ( ) { ArrayList < ObaRegion > regions = RegionUtils . getRegionsFromResources ( getContext ( ) ) ; for ( ObaRegion r : regions ) { try { URL url = new URL ( r . getObaBaseUrl ( ) ) ; } catch ( MalformedURLException e ) { fail ( "Region '" + r . getName ( ) + "' has an invalid base URL: " + e . getMessage ( ) ) ; } } }
public void testRegionTwitterUrls ( ) { ArrayList < ObaRegion > regions = RegionUtils . getRegionsFromResources ( getContext ( ) ) ; for ( ObaRegion r : regions ) { try { if ( r . getTwitterUrl ( ) != null && ! r . getTwitterUrl ( ) . isEmpty ( ) ) { URL url = new URL ( r . getTwitterUrl ( ) ) ; } } catch ( MalformedURLException e ) { fail ( "Region '" + r . getName ( ) + "' has an invalid Twitter URL: " + e . getMessage ( ) ) ; } } }
@ Override public void onScrollStateChanged ( AbsListView view , int scrollState ) { if ( mOriginalScrollListener != null ) { mOriginalScrollListener . onScrollStateChanged ( view , scrollState ) ; } }
@ Override public void onScroll ( AbsListView view , int firstVisibleItem , int visibleItemCount , int totalItemCount ) { if ( mOriginalScrollListener != null ) { mOriginalScrollListener . onScroll ( view , firstVisibleItem , visibleItemCount , totalItemCount ) ; } onScrollChanged ( ) ; }
public ObservableListView ( Context context ) { super( context ); init ( ) ; }
public ObservableListView ( Context context , AttributeSet attrs ) { super( context , attrs ); init ( ) ; }
public ObservableListView ( Context context , AttributeSet attrs , int defStyle ) { super( context , attrs , defStyle ); init ( ) ; }
@ Override public void onRestoreInstanceState ( Parcelable state ) { SavedState ss = ( SavedState ) state ; mPrevFirstVisiblePosition = ss . prevFirstVisiblePosition ; mPrevFirstVisibleChildHeight = ss . prevFirstVisibleChildHeight ; mPrevScrolledChildrenHeight = ss . prevScrolledChildrenHeight ; mPrevScrollY = ss . prevScrollY ; mScrollY = ss . scrollY ; mChildrenHeights = ss . childrenHeights ; super. onRestoreInstanceState ( ss . getSuperState ( ) ) ; }
@ Override public Parcelable onSaveInstanceState ( ) { Parcelable superState = super. onSaveInstanceState ( ) ; SavedState ss = new SavedState ( superState ) ; ss . prevFirstVisiblePosition = mPrevFirstVisiblePosition ; ss . prevFirstVisibleChildHeight = mPrevFirstVisibleChildHeight ; ss . prevScrolledChildrenHeight = mPrevScrolledChildrenHeight ; ss . prevScrollY = mPrevScrollY ; ss . scrollY = mScrollY ; ss . childrenHeights = mChildrenHeights ; return ss ; }
@ Override public boolean onInterceptTouchEvent ( MotionEvent ev ) { if ( hasNoCallbacks ( ) ) { return super. onInterceptTouchEvent ( ev ) ; } switch ( ev . getActionMasked ( ) ) { case MotionEvent . ACTION_DOWN : mFirstScroll = mDragging = true ; dispatchOnDownMotionEvent ( ) ; break; } return super. onInterceptTouchEvent ( ev ) ; }
@ Override public boolean onTouchEvent ( MotionEvent ev ) { if ( hasNoCallbacks ( ) ) { return super. onTouchEvent ( ev ) ; } switch ( ev . getActionMasked ( ) ) { case MotionEvent . ACTION_UP : case MotionEvent . ACTION_CANCEL : mIntercepted = false ; mDragging = false ; dispatchOnUpOrCancelMotionEvent ( mScrollState ) ; break; case MotionEvent . ACTION_MOVE : if ( mPrevMoveEvent == null ) { mPrevMoveEvent = ev ; } float diffY = ev . getY ( ) - mPrevMoveEvent . getY ( ) ; mPrevMoveEvent = MotionEvent . obtainNoHistory ( ev ) ; if ( getCurrentScrollY ( ) - diffY <= 0 ) { if ( mIntercepted ) { return false ; } final ViewGroup parent ; if ( mTouchInterceptionViewGroup == null ) { parent = ( ViewGroup ) getParent ( ) ; } else { parent = mTouchInterceptionViewGroup ; } float offsetX = 0 ; float offsetY = 0 ; for ( View v = this ; v != null && v != parent ; ) { offsetX += v . getLeft ( ) - v . getScrollX ( ) ; offsetY += v . getTop ( ) - v . getScrollY ( ) ; try { v = ( View ) v . getParent ( ) ; } catch ( ClassCastException ex ) { break; } } final MotionEvent event = MotionEvent . obtainNoHistory ( ev ) ; event . offsetLocation ( offsetX , offsetY ) ; if ( parent . onInterceptTouchEvent ( event ) ) { mIntercepted = true ; event . setAction ( MotionEvent . ACTION_DOWN ) ; post ( new Runnable ( ) { @ Override public void run ( ) { parent . dispatchTouchEvent ( event ) ; } } ) ; return false ; } return super. onTouchEvent ( ev ) ; } break; } return super. onTouchEvent ( ev ) ; }
@ Override public void run ( ) { parent . dispatchTouchEvent ( event ) ; }
@ Override public void setOnScrollListener ( OnScrollListener l ) { mOriginalScrollListener = l ; }
@ Override public void setScrollViewCallbacks ( ObservableScrollViewCallbacks listener ) { mCallbacks = listener ; }
@ Override public void addScrollViewCallbacks ( ObservableScrollViewCallbacks listener ) { if ( mCallbackCollection == null ) { mCallbackCollection = new ArrayList <> ( ) ; } mCallbackCollection . add ( listener ) ; }
@ Override public void removeScrollViewCallbacks ( ObservableScrollViewCallbacks listener ) { if ( mCallbackCollection != null ) { mCallbackCollection . remove ( listener ) ; } }
@ Override public void clearScrollViewCallbacks ( ) { if ( mCallbackCollection != null ) { mCallbackCollection . clear ( ) ; } }
@ Override public void setTouchInterceptionViewGroup ( ViewGroup viewGroup ) { mTouchInterceptionViewGroup = viewGroup ; }
@ Override public void scrollVerticallyTo ( int y ) { View firstVisibleChild = getChildAt ( 0 ) ; if ( firstVisibleChild != null ) { int baseHeight = firstVisibleChild . getHeight ( ) ; int position = y / baseHeight ; setSelection ( position ) ; } }
@ Override public int getCurrentScrollY ( ) { return mScrollY ; }
private void init ( ) { mChildrenHeights = new SparseIntArray ( ) ; super. setOnScrollListener ( mScrollListener ) ; }
private void onScrollChanged ( ) { if ( hasNoCallbacks ( ) ) { return; } if ( getChildCount ( ) > 0 ) { int firstVisiblePosition = getFirstVisiblePosition ( ) ; for ( int i = getFirstVisiblePosition ( ) , j = 0 ; i <= getLastVisiblePosition ( ) ; i ++ , j ++ ) { if ( mChildrenHeights . indexOfKey ( i ) < 0 || getChildAt ( j ) . getHeight ( ) != mChildrenHeights . get ( i ) ) { mChildrenHeights . put ( i , getChildAt ( j ) . getHeight ( ) ) ; } } View firstVisibleChild = getChildAt ( 0 ) ; if ( firstVisibleChild != null ) { if ( mPrevFirstVisiblePosition < firstVisiblePosition ) { int skippedChildrenHeight = 0 ; if ( firstVisiblePosition - mPrevFirstVisiblePosition != 1 ) { for ( int i = firstVisiblePosition - 1 ; i > mPrevFirstVisiblePosition ; i -- ) { if ( 0 < mChildrenHeights . indexOfKey ( i ) ) { skippedChildrenHeight += mChildrenHeights . get ( i ) ; } else { skippedChildrenHeight += firstVisibleChild . getHeight ( ) ; } } } mPrevScrolledChildrenHeight += mPrevFirstVisibleChildHeight + skippedChildrenHeight ; mPrevFirstVisibleChildHeight = firstVisibleChild . getHeight ( ) ; } else if ( firstVisiblePosition < mPrevFirstVisiblePosition ) { int skippedChildrenHeight = 0 ; if ( mPrevFirstVisiblePosition - firstVisiblePosition != 1 ) { for ( int i = mPrevFirstVisiblePosition - 1 ; i > firstVisiblePosition ; i -- ) { if ( 0 < mChildrenHeights . indexOfKey ( i ) ) { skippedChildrenHeight += mChildrenHeights . get ( i ) ; } else { skippedChildrenHeight += firstVisibleChild . getHeight ( ) ; } } } mPrevScrolledChildrenHeight -= firstVisibleChild . getHeight ( ) + skippedChildrenHeight ; mPrevFirstVisibleChildHeight = firstVisibleChild . getHeight ( ) ; } else if ( firstVisiblePosition == 0 ) { mPrevFirstVisibleChildHeight = firstVisibleChild . getHeight ( ) ; mPrevScrolledChildrenHeight = 0 ; } if ( mPrevFirstVisibleChildHeight < 0 ) { mPrevFirstVisibleChildHeight = 0 ; } mScrollY = mPrevScrolledChildrenHeight - firstVisibleChild . getTop ( ) + firstVisiblePosition * getDividerHeight ( ) + getPaddingTop ( ) ; mPrevFirstVisiblePosition = firstVisiblePosition ; dispatchOnScrollChanged ( mScrollY , mFirstScroll , mDragging ) ; if ( mFirstScroll ) { mFirstScroll = false ; } if ( mPrevScrollY < mScrollY ) { mScrollState = ScrollState . UP ; } else if ( mScrollY < mPrevScrollY ) { mScrollState = ScrollState . DOWN ; } else { mScrollState = ScrollState . STOP ; } mPrevScrollY = mScrollY ; } } }
private void dispatchOnDownMotionEvent ( ) { if ( mCallbacks != null ) { mCallbacks . onDownMotionEvent ( ) ; } if ( mCallbackCollection != null ) { for ( int i = 0 ; i < mCallbackCollection . size ( ) ; i ++ ) { ObservableScrollViewCallbacks callbacks = mCallbackCollection . get ( i ) ; callbacks . onDownMotionEvent ( ) ; } } }
private void dispatchOnScrollChanged ( int scrollY , boolean firstScroll , boolean dragging ) { if ( mCallbacks != null ) { mCallbacks . onScrollChanged ( scrollY , firstScroll , dragging ) ; } if ( mCallbackCollection != null ) { for ( int i = 0 ; i < mCallbackCollection . size ( ) ; i ++ ) { ObservableScrollViewCallbacks callbacks = mCallbackCollection . get ( i ) ; callbacks . onScrollChanged ( scrollY , firstScroll , dragging ) ; } } }
private void dispatchOnUpOrCancelMotionEvent ( ScrollState scrollState ) { if ( mCallbacks != null ) { mCallbacks . onUpOrCancelMotionEvent ( scrollState ) ; } if ( mCallbackCollection != null ) { for ( int i = 0 ; i < mCallbackCollection . size ( ) ; i ++ ) { ObservableScrollViewCallbacks callbacks = mCallbackCollection . get ( i ) ; callbacks . onUpOrCancelMotionEvent ( scrollState ) ; } } }
private boolean hasNoCallbacks ( ) { return mCallbacks == null && mCallbackCollection == null ; }
SavedState ( Parcelable superState ) { super( superState ); }
private SavedState ( Parcel in ) { super( in ); prevFirstVisiblePosition = in . readInt ( ) ; prevFirstVisibleChildHeight = in . readInt ( ) ; prevScrolledChildrenHeight = in . readInt ( ) ; prevScrollY = in . readInt ( ) ; scrollY = in . readInt ( ) ; childrenHeights = new SparseIntArray ( ) ; final int numOfChildren = in . readInt ( ) ; if ( 0 < numOfChildren ) { for ( int i = 0 ; i < numOfChildren ; i ++ ) { final int key = in . readInt ( ) ; final int value = in . readInt ( ) ; childrenHeights . put ( key , value ) ; } } }
@ Override public void writeToParcel ( Parcel out , int flags ) { super. writeToParcel ( out , flags ) ; out . writeInt ( prevFirstVisiblePosition ) ; out . writeInt ( prevFirstVisibleChildHeight ) ; out . writeInt ( prevScrolledChildrenHeight ) ; out . writeInt ( prevScrollY ) ; out . writeInt ( scrollY ) ; final int numOfChildren = childrenHeights == null ? 0 : childrenHeights . size ( ) ; out . writeInt ( numOfChildren ) ; if ( 0 < numOfChildren ) { for ( int i = 0 ; i < numOfChildren ; i ++ ) { out . writeInt ( childrenHeights . keyAt ( i ) ) ; out . writeInt ( childrenHeights . valueAt ( i ) ) ; } } }
@ Override public SavedState createFromParcel ( Parcel in ) { return new SavedState ( in ) ; }
@ Override public SavedState [] newArray ( int size ) { return new SavedState [ size ] ; }
public void testSetup ( ) { Assert . assertEquals ( MorseCodeConverter . GAP , 100 ) ; Assert . assertEquals ( MorseCodeConverter . DASH , 300 ) ; Assert . assertEquals ( MorseCodeConverter . DOT , 100 ) ; }
public void testSOS ( ) { long [] sosArrayExpected = new long [] { 0 , 100 , 100 , 100 , 100 , 100 , 300 , 300 , 100 , 300 , 100 , 300 , 300 , 100 , 100 , 100 , 100 , 100 , 0 } ; long [] actual = MorseCodeConverter . pattern ( "SOS" ) ; Assert . assertArrayEquals ( sosArrayExpected , actual ) ; }
public void testCaseSensitivity ( ) { Assert . assertArrayEquals ( MorseCodeConverter . pattern ( "sos" ) , MorseCodeConverter . pattern ( "SOS" ) ) ; Assert . assertArrayEquals ( MorseCodeConverter . pattern ( "sOs" ) , MorseCodeConverter . pattern ( "SOS" ) ) ; }
public void testSomeNumbers ( ) { long [] expected = new long [] { 0 , 100 , 100 , 300 , 100 , 300 , 100 , 300 , 100 , 300 , 300 , 100 , 100 , 100 , 100 , 300 , 100 , 300 , 100 , 300 , 300 , 100 , 100 , 100 , 100 , 100 , 100 , 300 , 100 , 300 , 0 } ; long [] actual = MorseCodeConverter . pattern ( "123" ) ; Assert . assertArrayEquals ( expected , actual ) ; }
public void testWhitespaceTreatment ( ) { long [] expected = new long [] { 0 , 100 , 100 , 100 , 100 , 100 , 100 , 100 , 700 , 100 , 100 , 300 , 100 , 300 , 0 } ; long [] actual = MorseCodeConverter . pattern ( "H W" ) ; Assert . assertArrayEquals ( expected , actual ) ; }
public void testChars ( ) { Assert . assertArrayEquals ( new long [] { 100 , 100 , 300 } , MorseCodeConverter . pattern ( 'A' ) ) ; Assert . assertArrayEquals ( new long [] { 300 , 100 , 300 } , MorseCodeConverter . pattern ( 'm' ) ) ; Assert . assertArrayEquals ( new long [] { 300 , 100 , 300 } , MorseCodeConverter . pattern ( 'M' ) ) ; Assert . assertArrayEquals ( new long [] { 100 } , MorseCodeConverter . pattern ( ' ' ) ) ; Assert . assertArrayEquals ( new long [] { 100 , 100 , 100 , 100 , 100 , 100 , 100 , 100 , 300 } , MorseCodeConverter . pattern ( '4' ) ) ; Assert . assertArrayEquals ( new long [] { 100 } , MorseCodeConverter . pattern ( '?' ) ) ; }
public AppModule ( App app ) { this . app = app ; }
@ Singleton @ Provides PassStore providePassStore ( Settings settings , Moshi moshi , EventBus bus ) { return new AndroidFileSystemPassStore ( app , settings , moshi , bus ) ; }
@ Singleton @ Provides Moshi provideMoshi ( ) { return new Moshi . Builder ( ) . add ( new ZonedTimeAdapter ( ) ) . add ( new ColorAdapter ( ) ) . build ( ) ; }
@ Singleton @ Provides Settings provideSettings ( ) { return new AndroidSettings ( app ) ; }
@ Singleton @ Provides SharedPreferences provideSharedPreferences ( ) { return PreferenceManager . getDefaultSharedPreferences ( app ) ; }
@ Singleton @ Provides EventBus provideBus ( ) { return EventBus . getDefault ( ) ; }
@ Singleton @ Provides State provideState ( ) { return new State ( ) ; }
protected ObaStopsForLocationRequest ( Uri uri ) { super( uri ); }
public Builder ( Context context , Location location ) { super( context , BASE_PATH + "/stops-for-location.json" ); mBuilder . appendQueryParameter ( "lat" , String . valueOf ( location . getLatitude ( ) ) ) ; mBuilder . appendQueryParameter ( "lon" , String . valueOf ( location . getLongitude ( ) ) ) ; }
public Builder setRadius ( int radius ) { mBuilder . appendQueryParameter ( "radius" , String . valueOf ( radius ) ) ; return this ; }
public Builder setSpan ( double latSpan , double lonSpan ) { mBuilder . appendQueryParameter ( "latSpan" , String . valueOf ( latSpan ) ) ; mBuilder . appendQueryParameter ( "lonSpan" , String . valueOf ( lonSpan ) ) ; return this ; }
public Builder setSpan ( int latSpan , int lonSpan ) { mBuilder . appendQueryParameter ( "latSpan" , String . valueOf ( latSpan / 1E6 ) ) ; mBuilder . appendQueryParameter ( "lonSpan" , String . valueOf ( lonSpan / 1E6 ) ) ; return this ; }
public Builder setQuery ( String query ) { mBuilder . appendQueryParameter ( "query" , query ) ; return this ; }
public ObaStopsForLocationRequest build ( ) { return new ObaStopsForLocationRequest ( buildUri ( ) ) ; }
@ Override public ObaStopsForLocationResponse call ( ) { return call ( ObaStopsForLocationResponse .class ) ; }
@ Override public String toString ( ) { return "ObaStopsForLocationRequest [mUri=" + mUri + "]" ; }
@ SuppressWarnings ( "deprecation" ) public void onCreate ( Bundle savedInstanceState ) { requestWindowFeature ( Window . FEATURE_INDETERMINATE_PROGRESS ) ; super. onCreate ( savedInstanceState ) ; setProgressBarIndeterminate ( true ) ; addPreferencesFromResource ( R . xml . preferences ) ; mPreference = findPreference ( getString ( R . string . preference_key_region ) ) ; mPreference . setOnPreferenceClickListener ( this ) ; mLeftHandMode = findPreference ( getString ( R . string . preference_key_left_hand_mode ) ) ; mLeftHandMode . setOnPreferenceChangeListener ( this ) ; mCustomApiUrlPref = findPreference ( getString ( R . string . preference_key_oba_api_url ) ) ; mCustomApiUrlPref . setOnPreferenceChangeListener ( this ) ; mCustomOtpApiUrlPref = findPreference ( getString ( R . string . preference_key_otp_api_url ) ) ; mCustomOtpApiUrlPref . setOnPreferenceChangeListener ( this ) ; mAnalyticsPref = findPreference ( getString ( R . string . preferences_key_analytics ) ) ; mAnalyticsPref . setOnPreferenceChangeListener ( this ) ; mTutorialPref = findPreference ( getString ( R . string . preference_key_tutorial ) ) ; mTutorialPref . setOnPreferenceClickListener ( this ) ; mDonatePref = findPreference ( getString ( R . string . preferences_key_donate ) ) ; mDonatePref . setOnPreferenceClickListener ( this ) ; mPoweredByObaPref = findPreference ( getString ( R . string . preferences_key_powered_by_oba ) ) ; mPoweredByObaPref . setOnPreferenceClickListener ( this ) ; mAboutPref = findPreference ( getString ( R . string . preferences_key_about ) ) ; mAboutPref . setOnPreferenceClickListener ( this ) ; SharedPreferences settings = Application . getPrefs ( ) ; mAutoSelectInitialValue = settings . getBoolean ( getString ( R . string . preference_key_auto_select_region ) , true ) ; preferredUnits = ( ListPreference ) findPreference ( getString ( R . string . preference_key_preferred_units ) ) ; settings . registerOnSharedPreferenceChangeListener ( this ) ; PreferenceScreen preferenceScreen = getPreferenceScreen ( ) ; if ( BuildConfig . USE_FIXED_REGION ) { PreferenceCategory regionCategory = ( PreferenceCategory ) findPreference ( getString ( R . string . preferences_category_location ) ) ; regionCategory . removeAll ( ) ; preferenceScreen . removePreference ( regionCategory ) ; PreferenceCategory advancedCategory = ( PreferenceCategory ) findPreference ( getString ( R . string . preferences_category_advanced ) ) ; Preference experimentalRegion = findPreference ( getString ( R . string . preference_key_experimental_regions ) ) ; advancedCategory . removePreference ( experimentalRegion ) ; } PreferenceCategory aboutCategory = ( PreferenceCategory ) findPreference ( getString ( R . string . preferences_category_about ) ) ; if ( BuildConfig . FLAVOR_brand . equalsIgnoreCase ( BuildFlavorUtils . OBA_FLAVOR_BRAND ) ) { aboutCategory . removePreference ( mPoweredByObaPref ) ; } else { aboutCategory . removePreference ( mDonatePref ) ; } boolean showCheckRegionDialog = getIntent ( ) . getBooleanExtra ( SHOW_CHECK_REGION_DIALOG , false ) ; if ( showCheckRegionDialog ) { showCheckRegionDialog ( ) ; } }
@ Override protected void onResume ( ) { super. onResume ( ) ; changePreferenceSummary ( getString ( R . string . preference_key_region ) ) ; changePreferenceSummary ( getString ( R . string . preference_key_preferred_units ) ) ; changePreferenceSummary ( getString ( R . string . preference_key_otp_api_url ) ) ; ObaRegion obaRegion = Application . get ( ) . getCurrentRegion ( ) ; if ( obaRegion != null && TextUtils . isEmpty ( obaRegion . getOtpBaseUrl ( ) ) ) { PreferenceCategory notifications = ( PreferenceCategory ) findPreference ( getString ( R . string . preference_key_notifications ) ) ; Preference tripPlan = findPreference ( getString ( R . string . preference_key_trip_plan_notifications ) ) ; if ( notifications != null ) { notifications . removePreference ( tripPlan ) ; if ( notifications . getPreferenceCount ( ) == 0 ) { getPreferenceScreen ( ) . removePreference ( notifications ) ; } } } }
@ Override protected void onStart ( ) { super. onStart ( ) ; ObaAnalytics . reportActivityStart ( this ) ; }
@ Override protected void onPostCreate ( Bundle savedInstanceState ) { super. onPostCreate ( savedInstanceState ) ; setupActionBar ( ) ; }
private void showCheckRegionDialog ( ) { ObaRegion obaRegion = Application . get ( ) . getCurrentRegion ( ) ; if ( obaRegion == null ) { return; } new AlertDialog . Builder ( this ) . setTitle ( getString ( R . string . preference_region_dialog_title ) ) . setMessage ( getString ( R . string . preference_region_dialog_message , obaRegion . getName ( ) ) ) . setPositiveButton ( "OK" , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int which ) {                    } } ) . show ( ) ; }
public void onClick ( DialogInterface dialog , int which ) {                    }
private void changePreferenceSummary ( String preferenceKey ) { if ( preferenceKey . equalsIgnoreCase ( getString ( R . string . preference_key_region ) ) || preferenceKey . equalsIgnoreCase ( getString ( R . string . preference_key_oba_api_url ) ) ) { if ( Application . get ( ) . getCurrentRegion ( ) != null ) { mPreference . setSummary ( Application . get ( ) . getCurrentRegion ( ) . getName ( ) ) ; mCustomApiUrlPref . setSummary ( getString ( R . string . preferences_oba_api_servername_summary ) ) ; String customOtpApiUrl = Application . get ( ) . getCustomOtpApiUrl ( ) ; if ( ! TextUtils . isEmpty ( customOtpApiUrl ) ) { mCustomOtpApiUrlPref . setSummary ( customOtpApiUrl ) ; } else { mCustomOtpApiUrlPref . setSummary ( getString ( R . string . preferences_otp_api_servername_summary ) ) ; } } else { mPreference . setSummary ( getString ( R . string . preferences_region_summary_custom_api ) ) ; mCustomApiUrlPref . setSummary ( Application . get ( ) . getCustomApiUrl ( ) ) ; } } else if ( preferenceKey . equalsIgnoreCase ( getString ( R . string . preference_key_preferred_units ) ) ) { preferredUnits . setSummary ( preferredUnits . getValue ( ) ) ; } else if ( preferenceKey . equalsIgnoreCase ( getString ( R . string . preference_key_otp_api_url ) ) ) { String customOtpApiUrl = Application . get ( ) . getCustomOtpApiUrl ( ) ; if ( ! TextUtils . isEmpty ( customOtpApiUrl ) ) { mCustomOtpApiUrlPref . setSummary ( customOtpApiUrl ) ; } else { mCustomOtpApiUrlPref . setSummary ( getString ( R . string . preferences_otp_api_servername_summary ) ) ; } Application . get ( ) . setUseOldOtpApiUrlVersion ( false ) ; } }
@ Override public boolean onPreferenceClick ( Preference pref ) { Log . d ( TAG , "preference - " + pref . getKey ( ) ) ; if ( pref . equals ( mPreference ) ) { RegionsActivity . start ( this ) ; } else if ( pref . equals ( mTutorialPref ) ) { ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getString ( R . string . analytics_action_button_press ) , getString ( R . string . analytics_label_button_press_tutorial ) ) ; ShowcaseViewUtils . resetAllTutorials ( this ) ; NavHelp . goHome ( this , true ) ; } else if ( pref . equals ( mDonatePref ) ) { ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getString ( R . string . analytics_action_button_press ) , getString ( R . string . analytics_label_button_press_donate ) ) ; Intent intent = new Intent ( Intent . ACTION_VIEW , Uri . parse ( getString ( R . string . donate_url ) ) ) ; startActivity ( intent ) ; } else if ( pref . equals ( mPoweredByObaPref ) ) { ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getString ( R . string . analytics_action_button_press ) , getString ( R . string . analytics_label_button_press_powered_by_oba ) ) ; Intent intent = new Intent ( Intent . ACTION_VIEW , Uri . parse ( getString ( R . string . powered_by_oba_url ) ) ) ; startActivity ( intent ) ; } else if ( pref . equals ( mAboutPref ) ) { ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getString ( R . string . analytics_action_button_press ) , getString ( R . string . analytics_label_button_press_about ) ) ; AboutActivity . start ( this ) ; } return true ; }
@ Override public boolean onPreferenceChange ( Preference preference , Object newValue ) { if ( preference . equals ( mCustomApiUrlPref ) && newValue instanceof String ) { String apiUrl = ( String ) newValue ; if ( ! TextUtils . isEmpty ( apiUrl ) ) { boolean validUrl = validateUrl ( apiUrl ) ; if ( ! validUrl ) { Toast . makeText ( this , getString ( R . string . custom_api_url_error ) , Toast . LENGTH_SHORT ) . show ( ) ; return false ; } Application . get ( ) . setCurrentRegion ( null ) ; Log . d ( TAG , "User entered new API URL, set region to null." ) ; } else { Log . d ( TAG , "User entered blank API URL, re-initializing regions..." ) ; NavHelp . goHome ( this , false ) ; } } if ( preference . equals ( mCustomOtpApiUrlPref ) && newValue instanceof String ) { String apiUrl = ( String ) newValue ; if ( ! TextUtils . isEmpty ( apiUrl ) ) { boolean validUrl = validateUrl ( apiUrl ) ; if ( ! validUrl ) { Toast . makeText ( this , getString ( R . string . custom_otp_api_url_error ) , Toast . LENGTH_SHORT ) . show ( ) ; return false ; } } mOtpCustomAPIUrlChanged = true ; } else if ( preference . equals ( mAnalyticsPref ) && newValue instanceof Boolean ) { Boolean isAnalyticsActive = ( Boolean ) newValue ; if ( ! isAnalyticsActive ) { ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . APP_SETTINGS . toString ( ) , getString ( R . string . analytics_action_edit_general ) , getString ( R . string . analytics_label_analytic_preference ) + ( isAnalyticsActive ? "YES" : "NO" ) ) ; GoogleAnalytics . getInstance ( getBaseContext ( ) ) . dispatchLocalHits ( ) ; } } else if ( preference . equals ( mLeftHandMode ) && newValue instanceof Boolean ) { Boolean isLeftHandEnabled = ( Boolean ) newValue ; if ( isLeftHandEnabled ) { ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . APP_SETTINGS . toString ( ) , getString ( R . string . analytics_action_edit_general ) , getString ( R . string . analytics_label_left_hand_preference ) + ( isLeftHandEnabled ? "YES" : "NO" ) ) ; } } return true ; }
@ Override protected void onDestroy ( ) { SharedPreferences settings = Application . getPrefs ( ) ; boolean currentValue = settings . getBoolean ( getString ( R . string . preference_key_auto_select_region ) , true ) ; if ( ( currentValue && ! mAutoSelectInitialValue ) ) { Log . d ( TAG , "User re-enabled auto-select regions pref, auto-selecting via Home Activity..." ) ; NavHelp . goHome ( this , false ) ; } else if ( mOtpCustomAPIUrlChanged ) { NavHelp . goHome ( this , false ) ; } super. onDestroy ( ) ; }
@ Override public void onSharedPreferenceChanged ( SharedPreferences sharedPreferences , String key ) { SharedPreferences settings = Application . getPrefs ( ) ; if ( key . equals ( getString ( R . string . preference_key_experimental_regions ) ) ) { boolean experimentalServers = settings . getBoolean ( getString ( R . string . preference_key_experimental_regions ) , false ) ; Log . d ( TAG , "Experimental regions shared preference changed to " + experimentalServers ) ; setProgressBarIndeterminateVisibility ( true ) ; List < ObaRegionsTask . Callback > callbacks = new ArrayList <> ( ) ; callbacks . add ( this ) ; ObaRegionsTask task = new ObaRegionsTask ( this , callbacks , true , false ) ; task . execute ( ) ; if ( experimentalServers ) { ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getString ( R . string . analytics_action_button_press ) , getString ( R . string . analytics_label_button_press_experimental_on ) ) ; } else { ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getString ( R . string . analytics_action_button_press ) , getString ( R . string . analytics_label_button_press_experimental_off ) ) ; } } else if ( key . equals ( getString ( R . string . preference_key_oba_api_url ) ) ) { changePreferenceSummary ( key ) ; } else if ( key . equals ( getString ( R . string . preference_key_otp_api_url ) ) ) { changePreferenceSummary ( key ) ; } else if ( key . equalsIgnoreCase ( getString ( R . string . preference_key_preferred_units ) ) ) { changePreferenceSummary ( key ) ; } else if ( key . equalsIgnoreCase ( getString ( R . string . preference_key_auto_select_region ) ) ) { boolean autoSelect = settings . getBoolean ( getString ( R . string . preference_key_auto_select_region ) , true ) ; if ( autoSelect ) { ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getString ( R . string . analytics_action_button_press ) , getString ( R . string . analytics_label_button_press_auto ) ) ; } else { ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getString ( R . string . analytics_action_button_press ) , getString ( R . string . analytics_label_button_press_manual ) ) ; } } else if ( key . equalsIgnoreCase ( getString ( R . string . preferences_key_analytics ) ) ) { Boolean isAnalyticsActive = settings . getBoolean ( Application . get ( ) . getString ( R . string . preferences_key_analytics ) , Boolean . FALSE ) ; if ( isAnalyticsActive ) ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . APP_SETTINGS . toString ( ) , getString ( R . string . analytics_action_edit_general ) , getString ( R . string . analytics_label_analytic_preference ) + ( isAnalyticsActive ? "YES" : "NO" ) ) ; } else if ( key . equalsIgnoreCase ( getString ( R . string . preference_key_arrival_info_style ) ) ) { changePreferenceSummary ( key ) ; } else if ( key . equalsIgnoreCase ( getString ( R . string . preference_key_show_negative_arrivals ) ) ) { boolean showDepartedBuses = settings . getBoolean ( Application . get ( ) . getString ( R . string . preference_key_show_negative_arrivals ) , Boolean . FALSE ) ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . APP_SETTINGS . toString ( ) , getString ( R . string . analytics_action_edit_general ) , getString ( R . string . analytics_label_show_departed_bus_preference ) + ( showDepartedBuses ? "YES" : "NO" ) ) ; } }
private boolean validateUrl ( String apiUrl ) { try { URL url = new URL ( apiUrl ) ; } catch ( MalformedURLException e ) { apiUrl = getString ( R . string . http_prefix ) + apiUrl ; } return Patterns . WEB_URL . matcher ( apiUrl ) . matches ( ) ; }
private void setupActionBar ( ) { Toolbar bar ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . ICE_CREAM_SANDWICH ) { LinearLayout root = ( LinearLayout ) findViewById ( android . R . id . list ) . getParent ( ) . getParent ( ) . getParent ( ) ; bar = ( Toolbar ) LayoutInflater . from ( this ) . inflate ( R . layout . settings_toolbar , root , false ) ; root . addView ( bar , 0 ) ; } else { ViewGroup root = ( ViewGroup ) findViewById ( android . R . id . content ) ; ListView content = ( ListView ) root . getChildAt ( 0 ) ; root . removeAllViews ( ) ; bar = ( Toolbar ) LayoutInflater . from ( this ) . inflate ( R . layout . settings_toolbar , root , false ) ; int height ; TypedValue tv = new TypedValue ( ) ; if ( getTheme ( ) . resolveAttribute ( R . attr . actionBarSize , tv , true ) ) { height = TypedValue . complexToDimensionPixelSize ( tv . data , getResources ( ) . getDisplayMetrics ( ) ) ; } else { height = bar . getHeight ( ) ; } content . setPadding ( 0 , height , 0 , 0 ) ; root . addView ( content ) ; root . addView ( bar ) ; } bar . setNavigationOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { finish ( ) ; } } ) ; }
@ Override public void onClick ( View v ) { finish ( ) ; }
public void onRegionTaskFinished ( boolean currentRegionChanged ) { setProgressBarIndeterminateVisibility ( false ) ; if ( currentRegionChanged ) { if ( Application . getPrefs ( ) . getBoolean ( getString ( R . string . preference_key_auto_select_region ) , true ) && Application . get ( ) . getCurrentRegion ( ) != null ) { Toast . makeText ( this , getString ( R . string . region_region_found , Application . get ( ) . getCurrentRegion ( ) . getName ( ) ) , Toast . LENGTH_LONG ) . show ( ) ; } changePreferenceSummary ( getString ( R . string . preference_key_region ) ) ; NavHelp . goHome ( this , false ) ; } }
public SlideExpandableListView ( Context context ) { super( context ); }
public SlideExpandableListView ( Context context , AttributeSet attrs ) { super( context , attrs ); }
public SlideExpandableListView ( Context context , AttributeSet attrs , int defStyle ) { super( context , attrs , defStyle ); }
public boolean collapse ( ) { if( adapter != null ) { return adapter . collapseLastOpen ( ) ; } return false ; }
public void setAdapter ( ListAdapter adapter ) { this . adapter = new SlideExpandableListAdapter ( adapter ) ; super. setAdapter ( this . adapter ) ; }
public void enableExpandOnItemClick ( ) { this . setOnItemClickListener ( new OnItemClickListener ( ) { @ Override public void onItemClick ( AdapterView < ? > adapterView , View view , int i , long l ) { SlideExpandableListAdapter adapter = ( SlideExpandableListAdapter ) getAdapter ( ) ; adapter . getExpandToggleButton ( view ) . performClick ( ) ; } } ) ; }
@ Override public void onItemClick ( AdapterView < ? > adapterView , View view , int i , long l ) { SlideExpandableListAdapter adapter = ( SlideExpandableListAdapter ) getAdapter ( ) ; adapter . getExpandToggleButton ( view ) . performClick ( ) ; }
@ Override public Parcelable onSaveInstanceState ( ) { return adapter . onSaveInstanceState ( super. onSaveInstanceState ( ) ) ; }
@ Override public void onRestoreInstanceState ( Parcelable state ) { if( ! ( state instanceof AbstractSlideExpandableListAdapter . SavedState ) ) { super. onRestoreInstanceState ( state ) ; return; } AbstractSlideExpandableListAdapter . SavedState ss = ( AbstractSlideExpandableListAdapter . SavedState ) state ; super. onRestoreInstanceState ( ss . getSuperState ( ) ) ; adapter . onRestoreInstanceState ( ss ) ; }
public static void start ( Context context ) { Intent intent = new Intent ( context , AgenciesActivity .class ) ; context . startActivity ( intent ) ; }
@ Override public void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; UIUtils . setupActionBar ( this ) ; FragmentManager fm = getSupportFragmentManager ( ) ; if ( fm . findFragmentById ( android . R . id . content ) == null ) { AgenciesFragment list = new AgenciesFragment ( ) ; fm . beginTransaction ( ) . add ( android . R . id . content , list ) . commit ( ) ; } }
@ Override protected void onStart ( ) { super. onStart ( ) ; ObaAnalytics . reportActivityStart ( this ) ; }
@ Override public boolean onOptionsItemSelected ( MenuItem item ) { if ( item . getItemId ( ) == android . R . id . home ) { NavHelp . goHome ( this , false ) ; return true ; } return false ; }
public ObaAgencyElement ( ) { id = "" ; name = "" ; url = "" ; timezone = "" ; lang = "" ; phone = "" ; disclaimer = "" ; email = "" ; }
@ Override public String getId ( ) { return id ; }
@ Override public String getName ( ) { return name ; }
@ Override public String getUrl ( ) { return url ; }
@ Override public String getTimezone ( ) { return timezone ; }
@ Override public String getLang ( ) { return lang ; }
@ Override public String getPhone ( ) { return phone ; }
@ Override public String getDisclaimer ( ) { return disclaimer ; }
@ Override public String getEmail ( ) { return email ; }
@ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( id == null ) ? 0 : id . hashCode ( ) ) ; return result ; }
@ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( ! ( obj instanceof ObaAgencyElement ) ) { return false ; } ObaAgencyElement other = ( ObaAgencyElement ) obj ; if ( id == null ) { if ( other . id != null ) { return false ; } } else if ( ! id . equals ( other . id ) ) { return false ; } return true ; }
@ Override public String toString ( ) { return "ObaAgencyElement [id=" + id + ", name=" + name + "]" ; }
@ Before public void setUp ( ) Exception { mockExecutor = PowerMock . createNiceMock ( CommandExecutor .class ) ; mockExecutor . executeCommand ( anyObject ( String .class ) , isNull ( List .class ) ) ; PowerMock . replay ( mockExecutor ) ; mockStatic ( CommandExecutor . Factory .class ) ; expect ( CommandExecutor . Factory . createDefaultCommmandExecutor ( ) ) . andReturn ( mockExecutor ) ; PowerMock . replay ( CommandExecutor . Factory .class ) ; mockAndroidDebugBridge = createMock ( AndroidDebugBridge .class ) ; abstractEmulatorMojo = new AbstractEmulatorMojoToTest ( ) ; }
@ Test public void testStartAndroidEmulatorWithTimeoutToConnect ( ) MojoExecutionException , ExecutionException { boolean onlineAtSecondTry = false ; int extraBootStatusPollCycles = - 1 ; abstractEmulatorMojo . setWait ( DEFAULT_TIMEOUT ) ; IDevice emulatorDevice = withEmulatorDevice ( onlineAtSecondTry , extraBootStatusPollCycles ) ; withConnectedDebugBridge ( emulatorDevice ) ; try { abstractEmulatorMojo . startAndroidEmulator ( ) ; fail ( ) ; } catch ( MojoExecutionException e ) { verify ( mockExecutor ) ; } }
@ Test public void testStartAndroidEmulatorAlreadyBooted ( ) MojoExecutionException , ExecutionException { boolean onlineAtSecondTry = true ; int extraBootStatusPollCycles = 0 ; abstractEmulatorMojo . setWait ( DEFAULT_TIMEOUT ) ; IDevice emulatorDevice = withEmulatorDevice ( onlineAtSecondTry , extraBootStatusPollCycles ) ; withConnectedDebugBridge ( emulatorDevice ) ; abstractEmulatorMojo . startAndroidEmulator ( ) ; verify ( mockExecutor ) ; }
@ Test public void testStartAndroidEmulatorWithOngoingBoot ( ) MojoExecutionException , ExecutionException { boolean onlineAtSecondTry = true ; int extraBootStatusPollCycles = 1 ; abstractEmulatorMojo . setWait ( extraBootStatusPollCycles * 5000 + 500 ) ; IDevice emulatorDevice = withEmulatorDevice ( onlineAtSecondTry , extraBootStatusPollCycles ) ; withConnectedDebugBridge ( emulatorDevice ) ; abstractEmulatorMojo . startAndroidEmulator ( ) ; verify ( mockExecutor ) ; }
@ Test public void testStartAndroidEmulatorWithBootTimeout ( ) MojoExecutionException , ExecutionException { boolean onlineAtSecondTry = true ; int extraBootStatusPollCycles = - 1 ; abstractEmulatorMojo . setWait ( DEFAULT_TIMEOUT ) ; IDevice emulatorDevice = withEmulatorDevice ( onlineAtSecondTry , extraBootStatusPollCycles ) ; withConnectedDebugBridge ( emulatorDevice ) ; try { abstractEmulatorMojo . startAndroidEmulator ( ) ; fail ( ) ; } catch ( MojoExecutionException e ) { verify ( mockExecutor ) ; } }
private IDevice withEmulatorDevice ( boolean onlineAtSecondTry , int extraBootStatusPollCycles ) { IDevice emulatorDevice = createMock ( IDevice .class ) ; expect ( emulatorDevice . getAvdName ( ) ) . andReturn ( AVD_NAME ) . atLeastOnce ( ) ; expect ( emulatorDevice . isEmulator ( ) ) . andReturn ( true ) . atLeastOnce ( ) ; if ( onlineAtSecondTry ) { try { expect ( emulatorDevice . isOnline ( ) ) . andReturn ( false ) . andReturn ( true ) ; if ( extraBootStatusPollCycles < 0 ) { expect ( emulatorDevice . getPropertySync ( "dev.bootcomplete" ) ) . andReturn ( null ) . atLeastOnce ( ) ; expect ( emulatorDevice . getPropertySync ( "sys.boot_completed" ) ) . andReturn ( null ) . atLeastOnce ( ) ; expect ( emulatorDevice . getPropertySync ( "init.svc.bootanim" ) ) . andReturn ( null ) . once ( ) . andReturn ( "running" ) . atLeastOnce ( ) ; } else if ( extraBootStatusPollCycles == 0 ) { expect ( emulatorDevice . getPropertySync ( "dev.bootcomplete" ) ) . andReturn ( "1" ) . once ( ) ; expect ( emulatorDevice . getPropertySync ( "sys.boot_completed" ) ) . andReturn ( "1" ) . once ( ) ; expect ( emulatorDevice . getPropertySync ( "init.svc.bootanim" ) ) . andReturn ( "stopped" ) . once ( ) ; } else if ( extraBootStatusPollCycles == 1 ) { expect ( emulatorDevice . getPropertySync ( "dev.bootcomplete" ) ) . andReturn ( null ) . once ( ) . andReturn ( "1" ) . once ( ) ; expect ( emulatorDevice . getPropertySync ( "sys.boot_completed" ) ) . andReturn ( null ) . once ( ) . andReturn ( "1" ) . once ( ) ; expect ( emulatorDevice . getPropertySync ( "init.svc.bootanim" ) ) . andReturn ( "running" ) . once ( ) . andReturn ( "stopped" ) . once ( ) ; } else if( extraBootStatusPollCycles >= 3 ) { expect ( emulatorDevice . getPropertySync ( "dev.bootcomplete" ) ) . andReturn ( null ) . times ( extraBootStatusPollCycles - 1 ) . andReturn ( "1" ) . once ( ) ; expect ( emulatorDevice . getPropertySync ( "sys.boot_completed" ) ) . andReturn ( null ) . times ( extraBootStatusPollCycles - 1 ) . andReturn ( "1" ) . once ( ) ; expect ( emulatorDevice . getPropertySync ( "init.svc.bootanim" ) ) . andReturn ( null ) . times ( extraBootStatusPollCycles / 2 ) . andReturn ( "running" ) . times ( extraBootStatusPollCycles / 2 + extraBootStatusPollCycles % 2 ) . andReturn ( "stopped" ) . once ( ) ; } else if( extraBootStatusPollCycles >= 2 ) { expect ( emulatorDevice . getPropertySync ( "dev.bootcomplete" ) ) . andReturn ( null ) . times ( extraBootStatusPollCycles - 1 ) . andReturn ( "1" ) . once ( ) ; expect ( emulatorDevice . getPropertySync ( "sys.boot_completed" ) ) . andReturn ( null ) . times ( extraBootStatusPollCycles - 1 ) . andReturn ( "1" ) . once ( ) ; expect ( emulatorDevice . getPropertySync ( "init.svc.bootanim" ) ) . andReturn ( "running" ) . times ( extraBootStatusPollCycles - 1 ) . andReturn ( "stopped" ) . once ( ) ; } } catch ( TimeoutException e ) { throw new RuntimeException ( "Unexpected checked exception during mock setup" , e ) ; } catch ( AdbCommandRejectedException e ) { throw new RuntimeException ( "Unexpected checked exception during mock setup" , e ) ; } catch ( ShellCommandUnresponsiveException e ) { throw new RuntimeException ( "Unexpected checked exception during mock setup" , e ) ; } catch ( IOException e ) { throw new RuntimeException ( "Unexpected checked exception during mock setup" , e ) ; } } else { expect ( emulatorDevice . isOnline ( ) ) . andReturn ( false ) . atLeastOnce ( ) ; } replay ( emulatorDevice ) ; return emulatorDevice ; }
private void withConnectedDebugBridge ( IDevice emulatorDevice ) { expect ( mockAndroidDebugBridge . isConnected ( ) ) . andReturn ( true ) ; expect ( mockAndroidDebugBridge . hasInitialDeviceList ( ) ) . andReturn ( true ) ; expect ( mockAndroidDebugBridge . getDevices ( ) ) . andReturn ( new IDevice [ 0 ] ) . andReturn ( new IDevice [] { emulatorDevice } ) . atLeastOnce ( ) ; replay ( mockAndroidDebugBridge ) ; }
public long getWait ( ) { return wait ; }
public void setWait ( long wait ) { this . wait = wait ; }
@ Override protected AndroidSdk getAndroidSdk ( ) { return new SdkTestSupport ( ) . getSdk_with_platform_default ( ) ; }
@ Override public void execute ( ) MojoExecutionException , MojoFailureException {        }
@ Override protected AndroidDebugBridge initAndroidDebugBridge ( ) MojoExecutionException { return mockAndroidDebugBridge ; }
@ Override String determineAvd ( ) { return AVD_NAME ; }
@ Override String determineWait ( ) { return String . valueOf ( wait ) ; }
public ActionBarAssert ( ActionBar actual ) { super( actual , ActionBarAssert .class ); }
public ActionBarAssert hasCustomView ( ) { isNotNull ( ) ; assertThat ( actual . getCustomView ( ) ) . overridingErrorMessage ( "Expected custom view but was not present." ) . isNotNull ( ) ; return this ; }
public ActionBarAssert hasDisplayOptions ( @ ActionBarDisplayOptions int options ) { isNotNull ( ) ; final int actualOptions = actual . getDisplayOptions ( ) ; assertThat ( actualOptions ) . overridingErrorMessage ( "Expected display options <%s> but was <%s>." , displayOptionsToString ( options ) , displayOptionsToString ( actualOptions ) ) . isEqualTo ( options ) ; return this ; }
public ActionBarAssert hasHeight ( int height ) { isNotNull ( ) ; int actualHeight = actual . getHeight ( ) ; assertThat ( actualHeight ) . overridingErrorMessage ( "Expected height <%s> but was <%s>." , height , actualHeight ) . isEqualTo ( height ) ; return this ; }
public ActionBarAssert hasNavigationItemCount ( int count ) { isNotNull ( ) ; int actualCount = actual . getNavigationItemCount ( ) ; assertThat ( actualCount ) . overridingErrorMessage ( "Expected count <%s> but was <%s>." , count , actualCount ) . isEqualTo ( count ) ; return this ; }
public ActionBarAssert hasNavigationMode ( int mode ) { isNotNull ( ) ; int actualMode = actual . getNavigationMode ( ) ; assertThat ( actualMode ) . overridingErrorMessage ( "Expected mode <%s> but was <%s>." , navigationModeToString ( mode ) , navigationModeToString ( actualMode ) ) . isEqualTo ( mode ) ; return this ; }
public ActionBarAssert hasSelectedNavigationIndex ( int index ) { isNotNull ( ) ; int actualIndex = actual . getSelectedNavigationIndex ( ) ; assertThat ( actualIndex ) . overridingErrorMessage ( "Expected selected index <%s> but was <%s>." , index , actualIndex ) . isEqualTo ( index ) ; return this ; }
public ActionBarAssert hasSubtitle ( CharSequence subtitle ) { isNotNull ( ) ; CharSequence actualSubtitle = actual . getSubtitle ( ) ; assertThat ( actualSubtitle ) . overridingErrorMessage ( "Expected subtitle <%s> but was <%s>." , subtitle , actualSubtitle ) . isEqualTo ( subtitle ) ; return this ; }
public ActionBarAssert hasSubtitle ( int resId ) { return hasSubtitle ( actual . getThemedContext ( ) . getString ( resId ) ) ; }
public ActionBarAssert hasTabCount ( int count ) { isNotNull ( ) ; int actualCount = actual . getTabCount ( ) ; assertThat ( actualCount ) . overridingErrorMessage ( "Expected tab count of <%s> but was <%s>." , count , actualCount ) . isEqualTo ( count ) ; return this ; }
public ActionBarAssert hasTitle ( CharSequence title ) { isNotNull ( ) ; CharSequence actualTitle = actual . getTitle ( ) ; assertThat ( actualTitle ) . overridingErrorMessage ( "Expected title <%s> but was <%s>." , title , actualTitle ) . isEqualTo ( title ) ; return this ; }
public ActionBarAssert hasTitle ( int resId ) { return hasTitle ( actual . getThemedContext ( ) . getString ( resId ) ) ; }
public ActionBarAssert isShowing ( ) { isNotNull ( ) ; assertThat ( actual . isShowing ( ) ) . overridingErrorMessage ( "Expected to be showing but was not showing." ) . isTrue ( ) ; return this ; }
public ActionBarAssert isNotShowing ( ) { isNotNull ( ) ; assertThat ( actual . isShowing ( ) ) . overridingErrorMessage ( "Expected to be not showing but was showing." ) . isFalse ( ) ; return this ; }
public static String navigationModeToString ( @ ActionBarNavigationMode int mode ) { return buildNamedValueString ( mode ) . value ( NAVIGATION_MODE_LIST , "list" ) . value ( NAVIGATION_MODE_STANDARD , "standard" ) . value ( NAVIGATION_MODE_TABS , "tabs" ) . get ( ) ; }
public static String displayOptionsToString ( @ ActionBarDisplayOptions int options ) { return buildBitMaskString ( options ) . flag ( DISPLAY_HOME_AS_UP , "homeAsUp" ) . flag ( DISPLAY_SHOW_CUSTOM , "showCustom" ) . flag ( DISPLAY_SHOW_HOME , "showHome" ) . flag ( DISPLAY_SHOW_TITLE , "showTitle" ) . flag ( DISPLAY_USE_LOGO , "useLogo" ) . get ( ) ; }
protected AbstractViewAssert ( A actual , Class < S > selfType ) { super( actual , selfType ); }
@ TargetApi ( HONEYCOMB ) public S hasAlpha ( float alpha ) { isNotNull ( ) ; float actualAlpha = actual . getAlpha ( ) ; assertThat ( actualAlpha ) . overridingErrorMessage ( "Expected alpha <%s> but was <%s>" , alpha , actualAlpha ) . isEqualTo ( alpha ) ; return myself ; }
public S hasAnimation ( Animation animation ) { isNotNull ( ) ; Animation actualAnimation = actual . getAnimation ( ) ; assertThat ( actualAnimation ) . overridingErrorMessage ( "Expected animation <%s> but was <%s>" , animation , actualAnimation ) . isSameAs ( animation ) ; return myself ; }
public S hasBackground ( Drawable background ) { isNotNull ( ) ; Drawable actualDrawable = actual . getBackground ( ) ; assertThat ( actualDrawable ) . overridingErrorMessage ( "Expected background <%s> but was <%s>" , background , actualDrawable ) . isSameAs ( background ) ; return myself ; }
public S hasBaseline ( int baseline ) { isNotNull ( ) ; int actualBaseline = actual . getBaseline ( ) ; assertThat ( actualBaseline ) . overridingErrorMessage ( "Expected baseline <%s> but was <%s>" , baseline , actualBaseline ) . isEqualTo ( baseline ) ; return myself ; }
public S hasBottom ( int bottom ) { isNotNull ( ) ; int actualBottom = actual . getBottom ( ) ; assertThat ( actualBottom ) . overridingErrorMessage ( "Expected bottom <%s> but was <%s>" , bottom , actualBottom ) . isEqualTo ( bottom ) ; return myself ; }
public S hasContentDescription ( CharSequence contentDescription ) { isNotNull ( ) ; CharSequence actualContentDescription = actual . getContentDescription ( ) ; assertThat ( actualContentDescription ) . overridingErrorMessage ( "Expected content description <%s> but was <%s>" , contentDescription , actualContentDescription ) . isEqualTo ( contentDescription ) ; return myself ; }
public S hasContentDescription ( int resId ) { isNotNull ( ) ; return hasContentDescription ( actual . getContext ( ) . getString ( resId ) ) ; }
public S hasDrawingCacheBackgroundColor ( int color ) { isNotNull ( ) ; int actualColor = actual . getDrawingCacheBackgroundColor ( ) ; assertThat ( actualColor ) . overridingErrorMessage ( "Expected drawing cache background color <%s> but was <%s>" , Integer . toHexString ( color ) , Integer . toHexString ( actualColor ) ) . isEqualTo ( color ) ; return myself ; }
public S hasDrawingCacheQuality ( int quality ) { isNotNull ( ) ; int actualQuality = actual . getDrawingCacheQuality ( ) ; assertThat ( actualQuality ) . overridingErrorMessage ( "Expected drawing cache quality <%s> but was <%s>" , quality , actualQuality ) . isEqualTo ( quality ) ; return myself ; }
@ TargetApi ( LOLLIPOP ) public S hasElevation ( float elevation ) { isNotNull ( ) ; float actualElevation = actual . getElevation ( ) ; assertThat ( actualElevation ) . overridingErrorMessage ( "Expected elevation <%s> but was <%s>" , elevation , actualElevation ) . isEqualTo ( elevation ) ; return myself ; }
public S hasHeight ( int height ) { isNotNull ( ) ; int actualHeight = actual . getHeight ( ) ; assertThat ( actualHeight ) . overridingErrorMessage ( "Expected height <%s> but was <%s>" , height , actualHeight ) . isEqualTo ( height ) ; return myself ; }
public S hasHorizontalFadingEdgeLength ( int length ) { isNotNull ( ) ; int actualLength = actual . getHorizontalFadingEdgeLength ( ) ; assertThat ( actualLength ) . overridingErrorMessage ( "Expected horizontal fading edge length <%s> but was <%s>" , length , actualLength ) . isEqualTo ( length ) ; return myself ; }
public S hasId ( int id ) { isNotNull ( ) ; int actualId = actual . getId ( ) ; assertThat ( actualId ) . overridingErrorMessage ( "Expected ID <%s> but was <%s>" , Integer . toHexString ( id ) , Integer . toHexString ( actualId ) ) . isEqualTo ( id ) ; return myself ; }
public S isKeepingScreenOn ( ) { isNotNull ( ) ; assertThat ( actual . getKeepScreenOn ( ) ) . overridingErrorMessage ( "Expected to be keeping screen on but was not" ) . isTrue ( ) ; return myself ; }
public S isNotKeepingScreenOn ( ) { isNotNull ( ) ; assertThat ( actual . getKeepScreenOn ( ) ) . overridingErrorMessage ( "Expected to not be keeping screen on but was" ) . isFalse ( ) ; return myself ; }
@ TargetApi ( JELLY_BEAN_MR1 ) public S hasLabelFor ( int id ) { isNotNull ( ) ; int actualId = actual . getLabelFor ( ) ; assertThat ( actualId ) . overridingErrorMessage ( "Expected to have label for ID <%s> but was <%s>" , id , actualId ) . isEqualTo ( id ) ; return myself ; }
@ TargetApi ( HONEYCOMB ) public S hasLayerType ( @ ViewLayerType int type ) { isNotNull ( ) ; int actualType = actual . getLayerType ( ) ; assertThat ( actualType ) . overridingErrorMessage ( "Expected layer type <%s> but was <%s>" , layerTypeToString ( type ) , layerTypeToString ( actualType ) ) . isEqualTo ( type ) ; return myself ; }
@ TargetApi ( JELLY_BEAN_MR1 ) public S hasLayoutDirection ( int direction ) { isNotNull ( ) ; int actualDirection = actual . getLayoutDirection ( ) ; assertThat ( actualDirection ) . overridingErrorMessage ( "Expected layout direction <%s> but was <%s>" , layoutDirectionToString ( direction ) , layoutDirectionToString ( actualDirection ) ) . isEqualTo ( direction ) ; return myself ; }
public S hasLeft ( int left ) { isNotNull ( ) ; int actualLeft = actual . getLeft ( ) ; assertThat ( actualLeft ) . overridingErrorMessage ( "Expected left <%s> but was <%s>" , left , actualLeft ) . isEqualTo ( left ) ; return myself ; }
public S hasMeasuredHeight ( int height ) { isNotNull ( ) ; int actualHeight = actual . getMeasuredHeight ( ) ; assertThat ( actualHeight ) . overridingErrorMessage ( "Expected measured height <%s> but was <%s>" , height , actualHeight ) . isEqualTo ( height ) ; return myself ; }
@ TargetApi ( HONEYCOMB ) public S hasMeasuredHeightAndState ( int heightAndState ) { isNotNull ( ) ; int actualHeightAndState = actual . getMeasuredHeightAndState ( ) ; assertThat ( actualHeightAndState ) . overridingErrorMessage ( "Expected measured height and state <%s> but was <%s>" , heightAndState , actualHeightAndState ) . isEqualTo ( heightAndState ) ; return myself ; }
@ TargetApi ( HONEYCOMB ) public S hasMeasuredState ( int state ) { isNotNull ( ) ; int actualState = actual . getMeasuredState ( ) ; assertThat ( actualState ) . overridingErrorMessage ( "Expected measured state <%s> but was <%s>" , state , actualState ) . isEqualTo ( state ) ; return myself ; }
public S hasMeasuredWidth ( int width ) { isNotNull ( ) ; int actualWidth = actual . getMeasuredWidth ( ) ; assertThat ( actualWidth ) . overridingErrorMessage ( "Expected measured width <%s> but was <%s>" , width , actualWidth ) . isEqualTo ( width ) ; return myself ; }
@ TargetApi ( HONEYCOMB ) public S hasMeasuredWidthAndState ( int widthAndState ) { isNotNull ( ) ; int actualWidthAndState = actual . getMeasuredWidthAndState ( ) ; assertThat ( actualWidthAndState ) . overridingErrorMessage ( "Expected measured width and state <%s> but was <%s>" , widthAndState , actualWidthAndState ) . isEqualTo ( widthAndState ) ; return myself ; }
@ TargetApi ( JELLY_BEAN ) public S hasMinimumHeight ( int height ) { isNotNull ( ) ; int actualHeight = actual . getMinimumHeight ( ) ; assertThat ( actualHeight ) . overridingErrorMessage ( "Expected minimum height <%s> but was <%s>" , height , actualHeight ) . isEqualTo ( height ) ; return myself ; }
@ TargetApi ( JELLY_BEAN ) public S hasMinimumWidth ( int width ) { isNotNull ( ) ; int actualWidth = actual . getMinimumWidth ( ) ; assertThat ( actualWidth ) . overridingErrorMessage ( "Expected minimum width <%s> but was <%s>" , width , actualWidth ) . isEqualTo ( width ) ; return myself ; }
public S hasNextFocusDownId ( int id ) { isNotNull ( ) ; int actualId = actual . getNextFocusDownId ( ) ; assertThat ( actualId ) . overridingErrorMessage ( "Expected next focus down ID <%s> but was <%s>" , id , actualId ) . isEqualTo ( id ) ; return myself ; }
@ TargetApi ( HONEYCOMB ) public S hasNextFocusForwardId ( int id ) { isNotNull ( ) ; int actualId = actual . getNextFocusForwardId ( ) ; assertThat ( actualId ) . overridingErrorMessage ( "Expected next focus forward ID <%s> but was <%s>" , id , actualId ) . isEqualTo ( id ) ; return myself ; }
public S hasNextFocusLeftId ( int id ) { isNotNull ( ) ; int actualId = actual . getNextFocusLeftId ( ) ; assertThat ( actualId ) . overridingErrorMessage ( "Expected next focus left ID <%s> but was <%s>" , id , actualId ) . isEqualTo ( id ) ; return myself ; }
public S hasNextFocusRightId ( int id ) { isNotNull ( ) ; int actualId = actual . getNextFocusRightId ( ) ; assertThat ( actualId ) . overridingErrorMessage ( "Expected next focus right ID <%s> but was <%s>" , id , actualId ) . isEqualTo ( id ) ; return myself ; }
public S hasNextFocusUpId ( int id ) { isNotNull ( ) ; int actualId = actual . getNextFocusUpId ( ) ; assertThat ( actualId ) . overridingErrorMessage ( "Expected next focus up ID <%s> but was <%s>" , id , actualId ) . isEqualTo ( id ) ; return myself ; }
@ TargetApi ( GINGERBREAD ) public S hasOverScrollMode ( @ ViewOverscrollMode int mode ) { isNotNull ( ) ; int actualMode = actual . getOverScrollMode ( ) ; assertThat ( actualMode ) . overridingErrorMessage ( "Expected over scroll mode <%s> but was <%s>" , overScrollModeToString ( mode ) , overScrollModeToString ( actualMode ) ) . isEqualTo ( mode ) ; return myself ; }
public S hasPaddingBottom ( int padding ) { isNotNull ( ) ; int actualPadding = actual . getPaddingBottom ( ) ; assertThat ( actualPadding ) . overridingErrorMessage ( "Expected padding bottom <%s> but was <%s>" , padding , actualPadding ) . isEqualTo ( padding ) ; return myself ; }
@ TargetApi ( JELLY_BEAN_MR1 ) public S hasPaddingEnd ( int padding ) { isNotNull ( ) ; int actualPadding = actual . getPaddingEnd ( ) ; assertThat ( actualPadding ) . overridingErrorMessage ( "Expected padding end <%s> but was <%s>" , padding , actualPadding ) . isEqualTo ( padding ) ; return myself ; }
public S hasPaddingLeft ( int padding ) { isNotNull ( ) ; int actualPadding = actual . getPaddingLeft ( ) ; assertThat ( actualPadding ) . overridingErrorMessage ( "Expected padding left <%s> but was <%s>" , padding , actualPadding ) . isEqualTo ( padding ) ; return myself ; }
public S hasPaddingRight ( int padding ) { isNotNull ( ) ; int actualPadding = actual . getPaddingRight ( ) ; assertThat ( actualPadding ) . overridingErrorMessage ( "Expected padding right <%s> but was <%s>" , padding , actualPadding ) . isEqualTo ( padding ) ; return myself ; }
@ TargetApi ( JELLY_BEAN_MR1 ) public S hasPaddingStart ( int padding ) { isNotNull ( ) ; int actualPadding = actual . getPaddingStart ( ) ; assertThat ( actualPadding ) . overridingErrorMessage ( "Expected padding start <%s> but was <%s>" , padding , actualPadding ) . isEqualTo ( padding ) ; return myself ; }
public S hasPaddingTop ( int padding ) { isNotNull ( ) ; int actualPadding = actual . getPaddingTop ( ) ; assertThat ( actualPadding ) . overridingErrorMessage ( "Expected padding top <%s> but was <%s>" , padding , actualPadding ) . isEqualTo ( padding ) ; return myself ; }
public S hasParent ( ViewParent parent ) { isNotNull ( ) ; ViewParent actualParent = actual . getParent ( ) ; assertThat ( actualParent ) . overridingErrorMessage ( "Expected parent <%s> but was <%s>" , parent , actualParent ) . isSameAs ( parent ) ; return myself ; }
@ TargetApi ( JELLY_BEAN ) public S hasParentForAccessibility ( ViewParent parent ) { isNotNull ( ) ; ViewParent actualParent = actual . getParentForAccessibility ( ) ; assertThat ( actualParent ) . overridingErrorMessage ( "Expected parent for accessibility <%s> but was <%s>" , parent , actualParent ) . isSameAs ( parent ) ; return myself ; }
@ TargetApi ( HONEYCOMB ) public S hasPivotX ( float pivotX ) { isNotNull ( ) ; float actualPivotX = actual . getPivotX ( ) ; assertThat ( actualPivotX ) . overridingErrorMessage ( "Expected x pivot <%s> but was <%s>" , pivotX , actualPivotX ) . isEqualTo ( pivotX ) ; return myself ; }
@ TargetApi ( HONEYCOMB ) public S hasPivotY ( float pivotY ) { isNotNull ( ) ; float actualPivotY = actual . getPivotY ( ) ; assertThat ( actualPivotY ) . overridingErrorMessage ( "Expected y pivot <s> but was <%s>" , pivotY , actualPivotY ) . isEqualTo ( pivotY ) ; return myself ; }
public S hasRight ( int right ) { isNotNull ( ) ; int actualRight = actual . getRight ( ) ; assertThat ( actualRight ) . overridingErrorMessage ( "Expected right <%s> but was <%s>" , right , actualRight ) . isEqualTo ( right ) ; return myself ; }
public S hasRootView ( View view ) { isNotNull ( ) ; View actualView = actual . getRootView ( ) ; assertThat ( actualView ) . overridingErrorMessage ( "Expected root view <%s> but was <%s>" , view , actualView ) . isSameAs ( view ) ; return myself ; }
@ TargetApi ( HONEYCOMB ) public S hasRotation ( float rotation ) { isNotNull ( ) ; float actualRotation = actual . getRotation ( ) ; assertThat ( actualRotation ) . overridingErrorMessage ( "Expected rotation <%s> but was <%s>" , rotation , actualRotation ) . isEqualTo ( rotation ) ; return myself ; }
@ TargetApi ( HONEYCOMB ) public S hasRotationX ( float rotation ) { isNotNull ( ) ; float actualRotation = actual . getRotationX ( ) ; assertThat ( actualRotation ) . overridingErrorMessage ( "Expected x rotation <%s> but was <%s>" , rotation , actualRotation ) . isEqualTo ( rotation ) ; return myself ; }
@ TargetApi ( HONEYCOMB ) public S hasRotationY ( float rotation ) { isNotNull ( ) ; float actualRotation = actual . getRotationY ( ) ; assertThat ( actualRotation ) . overridingErrorMessage ( "Expected y rotation <%s> but was <%s>" , rotation , actualRotation ) . isEqualTo ( rotation ) ; return myself ; }
@ TargetApi ( HONEYCOMB ) public S hasScaleX ( float scale ) { isNotNull ( ) ; float actualScale = actual . getScaleX ( ) ; assertThat ( actualScale ) . overridingErrorMessage ( "Expected x scale <%s> but was <%s>" , scale , actualScale ) . isEqualTo ( scale ) ; return myself ; }
@ TargetApi ( HONEYCOMB ) public S hasScaleY ( float scale ) { isNotNull ( ) ; float actualScale = actual . getScaleY ( ) ; assertThat ( actualScale ) . overridingErrorMessage ( "Expected y scale <%s> but was <%s>" , scale , actualScale ) . isEqualTo ( scale ) ; return myself ; }
@ TargetApi ( JELLY_BEAN ) public S hasScrollBarDefaultDelayBeforeFade ( int fade ) { isNotNull ( ) ; int actualFade = actual . getScrollBarDefaultDelayBeforeFade ( ) ; assertThat ( actualFade ) . overridingErrorMessage ( "Expected scroll bar default delay before fade <%s> but was <%s>" , fade , actualFade ) . isEqualTo ( fade ) ; return myself ; }
@ TargetApi ( JELLY_BEAN ) public S hasScrollBarFadeDuration ( int fade ) { isNotNull ( ) ; int actualFade = actual . getScrollBarFadeDuration ( ) ; assertThat ( actualFade ) . overridingErrorMessage ( "Expected scroll bar fade duration <%s> but was <%s>" , fade , actualFade ) . isEqualTo ( fade ) ; return myself ; }
@ TargetApi ( JELLY_BEAN ) public S hasScrollBarSize ( int size ) { isNotNull ( ) ; int actualSize = actual . getScrollBarSize ( ) ; assertThat ( actualSize ) . overridingErrorMessage ( "Expected scroll bar size <%s> but was <%s>" , size , actualSize ) . isEqualTo ( size ) ; return myself ; }
public S hasScrollBarStyle ( @ ViewScrollBarStyle int style ) { isNotNull ( ) ; int actualStyle = actual . getScrollBarStyle ( ) ; assertThat ( actualStyle ) . overridingErrorMessage ( "Expected scroll bar style <%s> but was <%s>" , scrollBarStyleToString ( style ) , scrollBarStyleToString ( actualStyle ) ) . isEqualTo ( style ) ; return myself ; }
public S hasScrollX ( int scroll ) { isNotNull ( ) ; int actualScroll = actual . getScrollX ( ) ; assertThat ( actualScroll ) . overridingErrorMessage ( "Expected x scroll <%s> but was <%s>" , scroll , actualScroll ) . isEqualTo ( scroll ) ; return myself ; }
public S hasScrollY ( int scroll ) { isNotNull ( ) ; int actualScroll = actual . getScrollY ( ) ; assertThat ( actualScroll ) . overridingErrorMessage ( "Expected y scroll <%s> but was <%s>" , scroll , actualScroll ) . isEqualTo ( scroll ) ; return myself ; }
public S hasSolidColor ( int color ) { isNotNull ( ) ; int actualColor = actual . getSolidColor ( ) ; assertThat ( actualColor ) . overridingErrorMessage ( "Expected solid color <%s> but was <%s>" , Integer . toHexString ( color ) , Integer . toHexString ( actualColor ) ) . isEqualTo ( color ) ; return myself ; }
@ TargetApi ( HONEYCOMB ) public S hasSystemUiVisibility ( int visibility ) { isNotNull ( ) ; int actualVisibility = actual . getSystemUiVisibility ( ) ; assertThat ( actualVisibility ) . overridingErrorMessage ( "Expected system UI visibility <%s> but was <%s>" , visibility , actualVisibility ) . isEqualTo ( visibility ) ; return myself ; }
public S hasTag ( int key , Object tag ) { isNotNull ( ) ; Object actualTag = actual . getTag ( key ) ; assertThat ( actualTag ) . overridingErrorMessage ( "Expected tag <%s> at key %s but was <%s>" , tag , key , actualTag ) . isEqualTo ( tag ) ; return myself ; }
public S hasTag ( Object tag ) { isNotNull ( ) ; Object actualTag = actual . getTag ( ) ; assertThat ( actualTag ) . overridingErrorMessage ( "Expected tag <%s> but was <%s>" , tag , actualTag ) . isEqualTo ( tag ) ; return myself ; }
@ TargetApi ( JELLY_BEAN_MR1 ) public S hasTextAlignment ( @ ViewTextAlignment int alignment ) { isNotNull ( ) ; int actualAlignment = actual . getTextAlignment ( ) ; assertThat ( actualAlignment ) . overridingErrorMessage ( "Expected text alignment <%s> but was <%s>" , textAlignmentToString ( alignment ) , textAlignmentToString ( actualAlignment ) ) . isEqualTo ( alignment ) ; return myself ; }
@ TargetApi ( JELLY_BEAN_MR1 ) public S hasTextDirection ( @ ViewTextDirection int direction ) { isNotNull ( ) ; int actualDirection = actual . getTextDirection ( ) ; assertThat ( actualDirection ) . overridingErrorMessage ( "Expected text direction <%s> but was <%s>" , textDirectionToString ( direction ) , textDirectionToString ( actualDirection ) ) . isEqualTo ( direction ) ; return myself ; }
public S hasTop ( int top ) { isNotNull ( ) ; int actualTop = actual . getTop ( ) ; assertThat ( actualTop ) . overridingErrorMessage ( "Expected top <%s> but was <%s>" , top , actualTop ) . isEqualTo ( top ) ; return myself ; }
@ TargetApi ( HONEYCOMB ) public S hasTranslationX ( float translation ) { isNotNull ( ) ; float actualTranslation = actual . getTranslationX ( ) ; assertThat ( actualTranslation ) . overridingErrorMessage ( "Expected x translation <%s> but was <%s>" , translation , actualTranslation ) . isEqualTo ( translation ) ; return myself ; }
@ TargetApi ( HONEYCOMB ) public S hasTranslationY ( float translation ) { isNotNull ( ) ; float actualTranslation = actual . getTranslationY ( ) ; assertThat ( actualTranslation ) . overridingErrorMessage ( "Expected y translation <%s> but was <%s>" , translation , actualTranslation ) . isEqualTo ( translation ) ; return myself ; }
@ TargetApi ( LOLLIPOP ) public S hasTranslationZ ( float translation ) { isNotNull ( ) ; float actualTranslation = actual . getTranslationZ ( ) ; assertThat ( actualTranslation ) . overridingErrorMessage ( "Expected z translation <%s> but was <%s>" , translation , actualTranslation ) . isEqualTo ( translation ) ; return myself ; }
public S hasVerticalFadingEdgeLength ( int length ) { isNotNull ( ) ; int actualLength = actual . getVerticalFadingEdgeLength ( ) ; assertThat ( actualLength ) . overridingErrorMessage ( "Expected vertical fading edge length <%s> but was <%s>" , length , actualLength ) . isEqualTo ( length ) ; return myself ; }
@ TargetApi ( HONEYCOMB ) public S hasVerticalScrollbarPosition ( int position ) { isNotNull ( ) ; int actualPosition = actual . getVerticalScrollbarPosition ( ) ; assertThat ( actualPosition ) . overridingErrorMessage ( "Expected vertical scroll bar position <%s> but was <%s>" , verticalScrollBarPositionToString ( position ) , verticalScrollBarPositionToString ( actualPosition ) ) . isEqualTo ( position ) ; return myself ; }
public S hasVerticalScrollbarWidth ( int width ) { isNotNull ( ) ; int actualWidth = actual . getVerticalScrollbarWidth ( ) ; assertThat ( actualWidth ) . overridingErrorMessage ( "Expected vertical scroll bar width <%s> but was <%s>" , width , actualWidth ) . isEqualTo ( width ) ; return myself ; }
public S hasVisibility ( @ ViewVisibility int visibility ) { isNotNull ( ) ; int actualVisibility = actual . getVisibility ( ) ; assertThat ( actualVisibility ) . overridingErrorMessage ( "Expected visibility <%s> but was <%s>." , visibilityToString ( visibility ) , visibilityToString ( actualVisibility ) ) . isEqualTo ( visibility ) ; return myself ; }
public S isVisible ( ) { isNotNull ( ) ; int actualVisibility = actual . getVisibility ( ) ; assertThat ( actualVisibility ) . overridingErrorMessage ( "Expected to be visible but was %s" , visibilityToString ( actualVisibility ) ) . isEqualTo ( VISIBLE ) ; return myself ; }
public S isNotVisible ( ) { isNotNull ( ) ; int actualVisibility = actual . getVisibility ( ) ; assertThat ( actualVisibility ) . overridingErrorMessage ( "Expected to be not visible but was visible" ) . isNotEqualTo ( VISIBLE ) ; return myself ; }
public S isInvisible ( ) { isNotNull ( ) ; int actualVisibility = actual . getVisibility ( ) ; assertThat ( actualVisibility ) . overridingErrorMessage ( "Expected to be invisible but was %s" , visibilityToString ( actualVisibility ) ) . isEqualTo ( INVISIBLE ) ; return myself ; }
public S isNotInvisible ( ) { isNotNull ( ) ; int actualVisibility = actual . getVisibility ( ) ; assertThat ( actualVisibility ) . overridingErrorMessage ( "Expected to be not invisible but was invisible" ) . isNotEqualTo ( INVISIBLE ) ; return myself ; }
public S isGone ( ) { isNotNull ( ) ; int actualVisibility = actual . getVisibility ( ) ; assertThat ( actualVisibility ) . overridingErrorMessage ( "Expected to be gone but was %s" , visibilityToString ( actualVisibility ) ) . isEqualTo ( GONE ) ; return myself ; }
public S isNotGone ( ) { isNotNull ( ) ; int actualVisibility = actual . getVisibility ( ) ; assertThat ( actualVisibility ) . overridingErrorMessage ( "Expected to be not gone but was gone" ) . isNotEqualTo ( GONE ) ; return myself ; }
public S hasWidth ( int width ) { isNotNull ( ) ; int actualWidth = actual . getWidth ( ) ; assertThat ( actualWidth ) . overridingErrorMessage ( "Expected width <%s> but was <%s>" , width , actualWidth ) . isEqualTo ( width ) ; return myself ; }
public S hasWindowVisibility ( int visibility ) { isNotNull ( ) ; int actualVisibility = actual . getWindowVisibility ( ) ; assertThat ( actualVisibility ) . overridingErrorMessage ( "Expected window visibility <%s> but was <%s>" , visibilityToString ( visibility ) , visibilityToString ( actualVisibility ) ) . isEqualTo ( visibility ) ; return myself ; }
@ TargetApi ( HONEYCOMB ) public S hasX ( float x ) { isNotNull ( ) ; float actualX = actual . getX ( ) ; assertThat ( actualX ) . overridingErrorMessage ( "Expected x <%s> but was <%s>" , x , actualX ) . isEqualTo ( x ) ; return myself ; }
@ TargetApi ( HONEYCOMB ) public S hasY ( float y ) { isNotNull ( ) ; float actualY = actual . getY ( ) ; assertThat ( actualY ) . overridingErrorMessage ( "Expected y <%s> but was <%s>" , y , actualY ) . isEqualTo ( y ) ; return myself ; }
@ TargetApi ( LOLLIPOP ) public S hasZ ( float z ) { isNotNull ( ) ; float actualZ = actual . getZ ( ) ; assertThat ( actualZ ) . overridingErrorMessage ( "Expected z <%s> but was <%s>" , z , actualZ ) . isEqualTo ( z ) ; return myself ; }
public S hasFocus ( ) { isNotNull ( ) ; assertThat ( actual . hasFocus ( ) ) . overridingErrorMessage ( "Expected to have focus but was not focused" ) . isTrue ( ) ; return myself ; }
public S hasNoFocus ( ) { isNotNull ( ) ; assertThat ( actual . hasFocus ( ) ) . overridingErrorMessage ( "Expected to not have focus but was focused" ) . isFalse ( ) ; return myself ; }
public S hasFocusable ( ) { isNotNull ( ) ; assertThat ( actual . hasFocusable ( ) ) . overridingErrorMessage ( "Expected to have focusable but was not" ) . isTrue ( ) ; return myself ; }
public S isInFocusedWindow ( ) { isNotNull ( ) ; assertThat ( actual . hasWindowFocus ( ) ) . overridingErrorMessage ( "Expected to be in a focused window but was not" ) . isTrue ( ) ; return myself ; }
public S isNotInFocusedWindow ( ) { isNotNull ( ) ; assertThat ( actual . hasWindowFocus ( ) ) . overridingErrorMessage ( "Expected to not be in a focused window but was" ) . isFalse ( ) ; return myself ; }
@ TargetApi ( HONEYCOMB ) public S isActivated ( ) { isNotNull ( ) ; assertThat ( actual . isActivated ( ) ) . overridingErrorMessage ( "Expected to be activated but was not" ) . isTrue ( ) ; return myself ; }
@ TargetApi ( HONEYCOMB ) public S isNotActivated ( ) { isNotNull ( ) ; assertThat ( actual . isActivated ( ) ) . overridingErrorMessage ( "Expected to not be activated but was" ) . isFalse ( ) ; return myself ; }
public S isClickable ( ) { isNotNull ( ) ; assertThat ( actual . isClickable ( ) ) . overridingErrorMessage ( "Expected to be clickable but was not" ) . isTrue ( ) ; return myself ; }
public S isNotClickable ( ) { isNotNull ( ) ; assertThat ( actual . isClickable ( ) ) . overridingErrorMessage ( "Expected to not be clickable but was" ) . isFalse ( ) ; return myself ; }
@ TargetApi ( HONEYCOMB ) public S isDirty ( ) { isNotNull ( ) ; assertThat ( actual . isDirty ( ) ) . overridingErrorMessage ( "Expected to be dirty but was not" ) . isTrue ( ) ; return myself ; }
@ TargetApi ( HONEYCOMB ) public S isNotDirty ( ) { isNotNull ( ) ; assertThat ( actual . isDirty ( ) ) . overridingErrorMessage ( "Expected to not be dirty but was" ) . isFalse ( ) ; return myself ; }
public S isUsingDrawingCache ( ) { isNotNull ( ) ; assertThat ( actual . isDrawingCacheEnabled ( ) ) . overridingErrorMessage ( "Expected to use drawing cache but was not" ) . isTrue ( ) ; return myself ; }
public S isNotUsingDrawingCache ( ) { isNotNull ( ) ; assertThat ( actual . isDrawingCacheEnabled ( ) ) . overridingErrorMessage ( "Expected to not be using drawing cache but was" ) . isFalse ( ) ; return myself ; }
public S isDuplicatingParentState ( ) { isNotNull ( ) ; assertThat ( actual . isDuplicateParentStateEnabled ( ) ) . overridingErrorMessage ( "Expected to be duplicating parent state but was not" ) . isTrue ( ) ; return myself ; }
public S isNotDuplicatingParentState ( ) { isNotNull ( ) ; assertThat ( actual . isDuplicateParentStateEnabled ( ) ) . overridingErrorMessage ( "Expected to not be duplicated parent state but was" ) . isFalse ( ) ; return myself ; }
public S isEnabled ( ) { isNotNull ( ) ; assertThat ( actual . isEnabled ( ) ) . overridingErrorMessage ( "Expected to be enabled but was disabled" ) . isTrue ( ) ; return myself ; }
public S isDisabled ( ) { isNotNull ( ) ; assertThat ( actual . isEnabled ( ) ) . overridingErrorMessage ( "Expected to be disabled but was enabled" ) . isFalse ( ) ; return myself ; }
public S isFocusable ( ) { isNotNull ( ) ; assertThat ( actual . isFocusable ( ) ) . overridingErrorMessage ( "Expected to be focusable but was not" ) . isTrue ( ) ; return myself ; }
public S isNotFocusable ( ) { isNotNull ( ) ; assertThat ( actual . isFocusable ( ) ) . overridingErrorMessage ( "Expected to not be focusable but was" ) . isFalse ( ) ; return myself ; }
public S isFocusableInTouchMode ( ) { isNotNull ( ) ; assertThat ( actual . isFocusableInTouchMode ( ) ) . overridingErrorMessage ( "Expected to be focusable in touch mode but was not" ) . isTrue ( ) ; return myself ; }
public S isNotFocusableInTouchMode ( ) { isNotNull ( ) ; assertThat ( actual . isFocusableInTouchMode ( ) ) . overridingErrorMessage ( "Expected to not be focusable in touch mode but was" ) . isFalse ( ) ; return myself ; }
public S isFocused ( ) { isNotNull ( ) ; assertThat ( actual . isFocused ( ) ) . overridingErrorMessage ( "Expected to be focused but was not" ) . isTrue ( ) ; return myself ; }
public S isNotFocused ( ) { isNotNull ( ) ; assertThat ( actual . isFocused ( ) ) . overridingErrorMessage ( "Expected to not be focused but was" ) . isFalse ( ) ; return myself ; }
public S hasHapticFeedbackEnabled ( ) { isNotNull ( ) ; assertThat ( actual . isHapticFeedbackEnabled ( ) ) . overridingErrorMessage ( "Expected to have haptic feedback enabled but was disabled" ) . isTrue ( ) ; return myself ; }
public S hasHapticFeedbackDisabled ( ) { isNotNull ( ) ; assertThat ( actual . isHapticFeedbackEnabled ( ) ) . overridingErrorMessage ( "Expected to have haptic feedback disabled but was enabled" ) . isFalse ( ) ; return myself ; }
@ TargetApi ( HONEYCOMB ) public S isHardwareAccelerated ( ) { isNotNull ( ) ; assertThat ( actual . isHardwareAccelerated ( ) ) . overridingErrorMessage ( "Expected to be hardware accelerated but was not" ) . isTrue ( ) ; return myself ; }
@ TargetApi ( HONEYCOMB ) public S isNotHardwareAccelerated ( ) { isNotNull ( ) ; assertThat ( actual . isHardwareAccelerated ( ) ) . overridingErrorMessage ( "Expected to not be hardware accelerated but was" ) . isFalse ( ) ; return myself ; }
public S hasHorizontalFadingEdgesEnabled ( ) { isNotNull ( ) ; assertThat ( actual . isHorizontalFadingEdgeEnabled ( ) ) . overridingErrorMessage ( "Expected to be fading horizontal edges but was not" ) . isTrue ( ) ; return myself ; }
public S hasHorizontalFadingEdgesDisabled ( ) { isNotNull ( ) ; assertThat ( actual . isHorizontalFadingEdgeEnabled ( ) ) . overridingErrorMessage ( "Expected to not be fading horizontal edges but was" ) . isFalse ( ) ; return myself ; }
public S hasHorizontalScrollbarEnabled ( ) { isNotNull ( ) ; assertThat ( actual . isHorizontalScrollBarEnabled ( ) ) . overridingErrorMessage ( "Expected to have horizontal scroll bar enabled but was disabled" ) . isTrue ( ) ; return myself ; }
public S hasHorizontalScrollbarDisabled ( ) { isNotNull ( ) ; assertThat ( actual . isHorizontalScrollBarEnabled ( ) ) . overridingErrorMessage ( "Expected to have horizontal scroll bar disabled but was enabled" ) . isFalse ( ) ; return myself ; }
@ TargetApi ( ICE_CREAM_SANDWICH ) public S isHovered ( ) { isNotNull ( ) ; assertThat ( actual . isHovered ( ) ) . overridingErrorMessage ( "Expected to be hovered but was not" ) . isTrue ( ) ; return myself ; }
@ TargetApi ( ICE_CREAM_SANDWICH ) public S isNotHovered ( ) { isNotNull ( ) ; assertThat ( actual . isHovered ( ) ) . overridingErrorMessage ( "Expected to not be hoevered but was" ) . isFalse ( ) ; return myself ; }
public S isInEditMode ( ) { isNotNull ( ) ; assertThat ( actual . isInEditMode ( ) ) . overridingErrorMessage ( "Expected to be in edit mode but was not" ) . isTrue ( ) ; return myself ; }
public S isNotInEditMode ( ) { isNotNull ( ) ; assertThat ( actual . isInEditMode ( ) ) . overridingErrorMessage ( "Expected to not be in edit mode but was" ) . isFalse ( ) ; return myself ; }
@ TargetApi ( JELLY_BEAN_MR2 ) public S isInLayout ( ) { isNotNull ( ) ; assertThat ( actual . isInLayout ( ) ) . overridingErrorMessage ( "Expected to be in layout but was not." ) . isTrue ( ) ; return myself ; }
@ TargetApi ( JELLY_BEAN_MR2 ) public S isNotInLayout ( ) { isNotNull ( ) ; assertThat ( actual . isInLayout ( ) ) . overridingErrorMessage ( "Expect to not be in layout but was." ) . isFalse ( ) ; return myself ; }
public S isInTouchMode ( ) { isNotNull ( ) ; assertThat ( actual . isInTouchMode ( ) ) . overridingErrorMessage ( "Expected to be in touch mode but was not" ) . isTrue ( ) ; return myself ; }
public S isNotInTouchMode ( ) { isNotNull ( ) ; assertThat ( actual . isInTouchMode ( ) ) . overridingErrorMessage ( "Expected to not be in touch mode but was" ) . isFalse ( ) ; return myself ; }
public S hasLayoutRequested ( ) { isNotNull ( ) ; assertThat ( actual . isLayoutRequested ( ) ) . overridingErrorMessage ( "Expected to have layout requested but was not" ) . isTrue ( ) ; return myself ; }
public S hasNoLayoutRequested ( ) { isNotNull ( ) ; assertThat ( actual . isLayoutRequested ( ) ) . overridingErrorMessage ( "Expected to not have layout requested but had" ) . isFalse ( ) ; return myself ; }
public S isLongClickable ( ) { isNotNull ( ) ; assertThat ( actual . isLongClickable ( ) ) . overridingErrorMessage ( "Expected to be long-clickable but was not" ) . isTrue ( ) ; return myself ; }
public S isNotLongClickable ( ) { isNotNull ( ) ; assertThat ( actual . isLongClickable ( ) ) . overridingErrorMessage ( "Expected to not be long-clickable but was" ) . isFalse ( ) ; return myself ; }
public S isOpaque ( ) { isNotNull ( ) ; assertThat ( actual . isOpaque ( ) ) . overridingErrorMessage ( "Expected to be opaque but was not" ) . isTrue ( ) ; return myself ; }
public S isNotOpaque ( ) { isNotNull ( ) ; assertThat ( actual . isOpaque ( ) ) . overridingErrorMessage ( "Expected to not be opaque but was" ) . isFalse ( ) ; return myself ; }
public S isPressed ( ) { isNotNull ( ) ; assertThat ( actual . isPressed ( ) ) . overridingErrorMessage ( "Expected to be pressed but was not" ) . isTrue ( ) ; return myself ; }
public S isNotPressed ( ) { isNotNull ( ) ; assertThat ( actual . isPressed ( ) ) . overridingErrorMessage ( "Expected to not be pressed but was" ) . isFalse ( ) ; return myself ; }
public S hasSaveEnabled ( ) { isNotNull ( ) ; assertThat ( actual . isSaveEnabled ( ) ) . overridingErrorMessage ( "Expected to have save enabled but was disabled" ) . isTrue ( ) ; return myself ; }
public S hasSaveDisabled ( ) { isNotNull ( ) ; assertThat ( actual . isSaveEnabled ( ) ) . overridingErrorMessage ( "Expected to have save disabled but was enabled" ) . isFalse ( ) ; return myself ; }
@ TargetApi ( HONEYCOMB ) public S hasSaveFromParentEnabled ( ) { isNotNull ( ) ; assertThat ( actual . isSaveFromParentEnabled ( ) ) . overridingErrorMessage ( "Expected to have save from parent enabled but was disabled" ) . isTrue ( ) ; return myself ; }
@ TargetApi ( HONEYCOMB ) public S hasSaveFromParentDisabled ( ) { isNotNull ( ) ; assertThat ( actual . isSaveFromParentEnabled ( ) ) . overridingErrorMessage ( "Expected to have save from parent disabled but was enabled" ) . isFalse ( ) ; return myself ; }
@ TargetApi ( JELLY_BEAN ) public S isScrollContainer ( ) { isNotNull ( ) ; assertThat ( actual . isScrollContainer ( ) ) . overridingErrorMessage ( "Expected to be a scroll container but was not" ) . isTrue ( ) ; return myself ; }
@ TargetApi ( JELLY_BEAN ) public S isNotScrollContainer ( ) { isNotNull ( ) ; assertThat ( actual . isScrollContainer ( ) ) . overridingErrorMessage ( "Expected to not be a scroll container but was" ) . isFalse ( ) ; return myself ; }
public S hasScrollbarFadingEnabled ( ) { isNotNull ( ) ; assertThat ( actual . isScrollbarFadingEnabled ( ) ) . overridingErrorMessage ( "Expected to have scroll bar fading enabled but was disabled" ) . isTrue ( ) ; return myself ; }
public S hasScrollbarFadingDisabled ( ) { isNotNull ( ) ; assertThat ( actual . isScrollbarFadingEnabled ( ) ) . overridingErrorMessage ( "Expected to have scroll bar fading disabled but was enabled" ) . isFalse ( ) ; return myself ; }
public S isSelected ( ) { isNotNull ( ) ; assertThat ( actual . isSelected ( ) ) . overridingErrorMessage ( "Expected to be selected but was not" ) . isTrue ( ) ; return myself ; }
public S isNotSelected ( ) { isNotNull ( ) ; assertThat ( actual . isSelected ( ) ) . overridingErrorMessage ( "Expected to not be selected but was" ) . isFalse ( ) ; return myself ; }
public S isShown ( ) { isNotNull ( ) ; assertThat ( actual . isShown ( ) ) . overridingErrorMessage ( "Expected to be shown but was not" ) . isTrue ( ) ; return myself ; }
public S isNotShown ( ) { isNotNull ( ) ; assertThat ( actual . isShown ( ) ) . overridingErrorMessage ( "Expected to not be shown but was" ) . isFalse ( ) ; return myself ; }
public S hasSoundEffectsEnabled ( ) { isNotNull ( ) ; assertThat ( actual . isSoundEffectsEnabled ( ) ) . overridingErrorMessage ( "Expected sound effects to be enabled but was disabled" ) . isTrue ( ) ; return myself ; }
public S hasSoundEffectsDisabled ( ) { isNotNull ( ) ; assertThat ( actual . isSoundEffectsEnabled ( ) ) . overridingErrorMessage ( "Expected sound effects to be disabled but was enabled" ) . isFalse ( ) ; return myself ; }
public S hasVerticalFadingEdgeEnabled ( ) { isNotNull ( ) ; assertThat ( actual . isVerticalFadingEdgeEnabled ( ) ) . overridingErrorMessage ( "Expected to have vertical fading edge enabled but was disabled" ) . isTrue ( ) ; return myself ; }
public S hasVerticalFadingEdgeDisabled ( ) { isNotNull ( ) ; assertThat ( actual . isVerticalFadingEdgeEnabled ( ) ) . overridingErrorMessage ( "Expected to have vertical fading edge disabled but was enabled" ) . isFalse ( ) ; return myself ; }
public S hasVerticalScrollBarEnabled ( ) { isNotNull ( ) ; assertThat ( actual . isVerticalScrollBarEnabled ( ) ) . overridingErrorMessage ( "Expected to have vertical scroll bar enabled but was disabled" ) . isTrue ( ) ; return myself ; }
public S hasVerticalScrollBarDisabled ( ) { isNotNull ( ) ; assertThat ( actual . isVerticalScrollBarEnabled ( ) ) . overridingErrorMessage ( "Expected to have vertical scroll bar disabled but was enabled" ) . isFalse ( ) ; return myself ; }
@ TargetApi ( KITKAT ) public S canResolveLayoutDirection ( ) { isNotNull ( ) ; assertThat ( actual . canResolveLayoutDirection ( ) ) . overridingErrorMessage ( "Expected to be able to resolve layout direction but cannot." ) . isTrue ( ) ; return myself ; }
@ TargetApi ( KITKAT ) public S canNotResolveLayoutDirection ( ) { isNotNull ( ) ; assertThat ( actual . canResolveLayoutDirection ( ) ) . overridingErrorMessage ( "Expected to not be able to resolve layout direction but can." ) . isFalse ( ) ; return myself ; }
@ TargetApi ( KITKAT ) public S canResolveTextAlignment ( ) { isNotNull ( ) ; assertThat ( actual . canResolveTextAlignment ( ) ) . overridingErrorMessage ( "Expected to  be able to resolve text alignment but cannot." ) . isTrue ( ) ; return myself ; }
@ TargetApi ( KITKAT ) public S canNotResolveTextAlignment ( ) { isNotNull ( ) ; assertThat ( actual . canResolveTextAlignment ( ) ) . overridingErrorMessage ( "Expected to not be able to resolve text alignment but can." ) . isFalse ( ) ; return myself ; }
@ TargetApi ( KITKAT ) public S canResolveTextDirection ( ) { isNotNull ( ) ; assertThat ( actual . canResolveTextDirection ( ) ) . overridingErrorMessage ( "Expected to be able to resolve text direction but cannot." ) . isTrue ( ) ; return myself ; }
@ TargetApi ( KITKAT ) public S canNotResolveTextDirection ( ) { isNotNull ( ) ; assertThat ( actual . canResolveTextDirection ( ) ) . overridingErrorMessage ( "Expected to not be able to resolve text direction but can." ) . isFalse ( ) ; return myself ; }
@ TargetApi ( KITKAT ) public S isAttachedToWindow ( ) { isNotNull ( ) ; assertThat ( actual . isAttachedToWindow ( ) ) . overridingErrorMessage ( "Expected to be attached to window but was not." ) . isTrue ( ) ; return myself ; }
@ TargetApi ( KITKAT ) public S isNotAttachedToWindow ( ) { isNotNull ( ) ; assertThat ( actual . isAttachedToWindow ( ) ) . overridingErrorMessage ( "Expected to be not attached to window but was." ) . isFalse ( ) ; return myself ; }
@ TargetApi ( KITKAT ) public S isLaidOut ( ) { isNotNull ( ) ; assertThat ( actual . isLaidOut ( ) ) . overridingErrorMessage ( "Expected to be laid out but was not." ) . isTrue ( ) ; return myself ; }
@ TargetApi ( KITKAT ) public S isNotLaidOut ( ) { isNotNull ( ) ; assertThat ( actual . isLaidOut ( ) ) . overridingErrorMessage ( "Expected to be not laid out but was." ) . isFalse ( ) ; return myself ; }
@ TargetApi ( KITKAT ) public S hasResolvedLayoutDirection ( ) { isNotNull ( ) ; assertThat ( actual . isLayoutDirectionResolved ( ) ) . overridingErrorMessage ( "Expected layout direction to be resolved but was not." ) . isTrue ( ) ; return myself ; }
@ TargetApi ( KITKAT ) public S hasNotResolvedLayoutDirection ( ) { isNotNull ( ) ; assertThat ( actual . isLayoutDirectionResolved ( ) ) . overridingErrorMessage ( "Expected layout direction to not be resolved but was." ) . isFalse ( ) ; return myself ; }
@ TargetApi ( KITKAT ) public S hasResolvedTextAlignment ( ) { isNotNull ( ) ; assertThat ( actual . isTextAlignmentResolved ( ) ) . overridingErrorMessage ( "Expected text alignment to be resolved but was not." ) . isTrue ( ) ; return myself ; }
@ TargetApi ( KITKAT ) public S hasNotResolvedTextAlignment ( ) { isNotNull ( ) ; assertThat ( actual . isTextAlignmentResolved ( ) ) . overridingErrorMessage ( "Expected text alignment to not be resolved but was." ) . isFalse ( ) ; return myself ; }
@ TargetApi ( KITKAT ) public S hasResolvedTextDirection ( ) { isNotNull ( ) ; assertThat ( actual . isTextDirectionResolved ( ) ) . overridingErrorMessage ( "Expected text direction to be resolved but was not." ) . isTrue ( ) ; return myself ; }
@ TargetApi ( KITKAT ) public S hasNotResolvedTextDirection ( ) { isNotNull ( ) ; assertThat ( actual . isTextDirectionResolved ( ) ) . overridingErrorMessage ( "Expected text direction to not be resolved but was." ) . isFalse ( ) ; return myself ; }
public static String visibilityToString ( @ ViewVisibility int visibility ) { return buildNamedValueString ( visibility ) . value ( VISIBLE , "visible" ) . value ( INVISIBLE , "invisible" ) . value ( GONE , "gone" ) . get ( ) ; }
@ TargetApi ( HONEYCOMB ) public static String layerTypeToString ( @ ViewLayerType int type ) { return buildNamedValueString ( type ) . value ( LAYER_TYPE_NONE , "none" ) . value ( LAYER_TYPE_SOFTWARE , "software" ) . value ( LAYER_TYPE_HARDWARE , "hardware" ) . get ( ) ; }
@ TargetApi ( JELLY_BEAN_MR1 ) public static String layoutDirectionToString ( @ ViewLayoutDirection int direction ) { return buildNamedValueString ( direction ) . value ( LAYOUT_DIRECTION_RTL , "right_to_left" ) . value ( LAYOUT_DIRECTION_LTR , "left_to_right" ) . value ( LAYOUT_DIRECTION_INHERIT , "inherit" ) . value ( LAYOUT_DIRECTION_LOCALE , "locale" ) . get ( ) ; }
@ TargetApi ( GINGERBREAD ) public static String overScrollModeToString ( @ ViewOverscrollMode int mode ) { return buildNamedValueString ( mode ) . value ( OVER_SCROLL_ALWAYS , "always" ) . value ( OVER_SCROLL_IF_CONTENT_SCROLLS , "ifContentScrolls" ) . value ( OVER_SCROLL_NEVER , "never" ) . get ( ) ; }
public static String scrollBarStyleToString ( @ ViewScrollBarStyle int style ) { return buildNamedValueString ( style ) . value ( SCROLLBARS_INSIDE_INSET , "insideInset" ) . value ( SCROLLBARS_INSIDE_OVERLAY , "insideOverlay" ) . value ( SCROLLBARS_OUTSIDE_INSET , "outsideInset" ) . value ( SCROLLBARS_OUTSIDE_OVERLAY , "outsideOverlay" ) . get ( ) ; }
@ TargetApi ( HONEYCOMB ) public static String verticalScrollBarPositionToString ( @ ViewScrollBarPosition int position ) { return buildNamedValueString ( position ) . value ( SCROLLBAR_POSITION_DEFAULT , "default" ) . value ( SCROLLBAR_POSITION_LEFT , "left" ) . value ( SCROLLBAR_POSITION_RIGHT , "right" ) . get ( ) ; }
public static String textAlignmentToString ( @ ViewTextAlignment int alignment ) { return buildNamedValueString ( alignment ) . value ( TEXT_ALIGNMENT_INHERIT , "inherit" ) . value ( TEXT_ALIGNMENT_GRAVITY , "gravity" ) . value ( TEXT_ALIGNMENT_TEXT_START , "text_start" ) . value ( TEXT_ALIGNMENT_TEXT_END , "text_end" ) . value ( TEXT_ALIGNMENT_CENTER , "center" ) . value ( TEXT_ALIGNMENT_VIEW_START , "view_start" ) . value ( TEXT_ALIGNMENT_VIEW_END , "view_end" ) . get ( ) ; }
public static String textDirectionToString ( @ ViewTextDirection int direction ) { return buildNamedValueString ( direction ) . value ( TEXT_DIRECTION_INHERIT , "inherit" ) . value ( TEXT_DIRECTION_FIRST_STRONG , "first_strong" ) . value ( TEXT_DIRECTION_ANY_RTL , "any_right_to_left" ) . value ( TEXT_DIRECTION_LTR , "left_to_right" ) . value ( TEXT_DIRECTION_RTL , "right_to_left" ) . value ( TEXT_DIRECTION_LOCALE , "locale" ) . get ( ) ; }
@ Override protected void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; setContentView ( R . layout . fragment_tabs ) ; mTabHost = ( TabHost ) findViewById ( android . R . id . tabhost ) ; mTabHost . setup ( ) ; mTabManager = new TabManager ( this , mTabHost , R . id . realtabcontent ) ; mTabManager . addTab ( mTabHost . newTabSpec ( "simple" ) . setIndicator ( "Simple" ) , FragmentStackSupport . CountingFragment .class , null ) ; mTabManager . addTab ( mTabHost . newTabSpec ( "contacts" ) . setIndicator ( "Contacts" ) , LoaderCursorSupport . CursorLoaderListFragment .class , null ) ; mTabManager . addTab ( mTabHost . newTabSpec ( "custom" ) . setIndicator ( "Custom" ) , LoaderCustomSupport . AppListFragment .class , null ) ; mTabManager . addTab ( mTabHost . newTabSpec ( "throttle" ) . setIndicator ( "Throttle" ) , LoaderThrottleSupport . ThrottledLoaderListFragment .class , null ) ; if ( savedInstanceState != null ) { mTabHost . setCurrentTabByTag ( savedInstanceState . getString ( "tab" ) ) ; } }
@ Override protected void onSaveInstanceState ( Bundle outState ) { super. onSaveInstanceState ( outState ) ; outState . putString ( "tab" , mTabHost . getCurrentTabTag ( ) ) ; }
TabInfo ( String _tag , Class < ? > _class , Bundle _args ) { tag = _tag ; clss = _class ; args = _args ; }
public DummyTabFactory ( Context context ) { mContext = context ; }
@ Override public View createTabContent ( String tag ) { View v = new View ( mContext ) ; v . setMinimumWidth ( 0 ) ; v . setMinimumHeight ( 0 ) ; return v ; }
public TabManager ( FragmentActivity activity , TabHost tabHost , int containerId ) { mActivity = activity ; mTabHost = tabHost ; mContainerId = containerId ; mTabHost . setOnTabChangedListener ( this ) ; }
public void addTab ( TabHost . TabSpec tabSpec , Class < ? > clss , Bundle args ) { tabSpec . setContent ( new DummyTabFactory ( mActivity ) ) ; String tag = tabSpec . getTag ( ) ; TabInfo info = new TabInfo ( tag , clss , args ) ; info . fragment = mActivity . getSupportFragmentManager ( ) . findFragmentByTag ( tag ) ; if ( info . fragment != null && ! info . fragment . isDetached ( ) ) { FragmentTransaction ft = mActivity . getSupportFragmentManager ( ) . beginTransaction ( ) ; ft . detach ( info . fragment ) ; ft . commit ( ) ; } mTabs . put ( tag , info ) ; mTabHost . addTab ( tabSpec ) ; }
@ Override public void onTabChanged ( String tabId ) { TabInfo newTab = mTabs . get ( tabId ) ; if ( mLastTab != newTab ) { FragmentTransaction ft = mActivity . getSupportFragmentManager ( ) . beginTransaction ( ) ; if ( mLastTab != null ) { if ( mLastTab . fragment != null ) { ft . detach ( mLastTab . fragment ) ; } } if ( newTab != null ) { if ( newTab . fragment == null ) { newTab . fragment = Fragment . instantiate ( mActivity , newTab . clss . getName ( ) , newTab . args ) ; ft . add ( mContainerId , newTab . fragment , newTab . tag ) ; } else { ft . attach ( newTab . fragment ) ; } } mLastTab = newTab ; ft . commit ( ) ; mActivity . getSupportFragmentManager ( ) . executePendingTransactions ( ) ; } }
public PushOperation ( File fileDir , Activity callingActivity ) { super( fileDir , callingActivity ); }
public PushOperation setCommand ( ) { this . command = new Git ( repository ) . push ( ) . setPushAll ( ) . setRemote ( "origin" ) ; return this ; }
@ Override public void execute ( ) { if ( this . provider != null ) { ( ( PushCommand ) this . command ) . setCredentialsProvider ( this . provider ) ; } new GitAsyncTask ( callingActivity , true , false , this ) . execute ( this . command ) ; }
@ Override public void onTaskEnded ( String result ) { new AlertDialog . Builder ( callingActivity ) . setTitle ( callingActivity . getResources ( ) . getString ( R . string . jgit_error_dialog_title ) ) . setMessage ( "Error occured during the push operation, " + callingActivity . getResources ( ) . getString ( R . string . jgit_error_dialog_text ) + result + "\nPlease check the FAQ for possible reasons why this error might occur." ) . setPositiveButton ( callingActivity . getResources ( ) . getString ( R . string . dialog_ok ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialogInterface , int i ) { callingActivity . finish ( ) ; } } ) . show ( ) ; }
@ Override public void onClick ( DialogInterface dialogInterface , int i ) { callingActivity . finish ( ) ; }
protected AbstractAnimationAssert ( A actual , Class < S > selfType ) { super( actual , selfType ); }
@ TargetApi ( HONEYCOMB_MR1 ) public S hasBackgroundColor ( int color ) { isNotNull ( ) ; int actualColor = actual . getBackgroundColor ( ) ; assertThat ( actualColor ) . overridingErrorMessage ( "Expected background color <%s> but was <%s>." , Integer . toHexString ( color ) , Integer . toHexString ( actualColor ) ) . isEqualTo ( color ) ; return myself ; }
public S hasDuration ( long duration ) { isNotNull ( ) ; long actualDuration = actual . getDuration ( ) ; assertThat ( actualDuration ) . overridingErrorMessage ( "Expected duration <%s> but was <%s>." , duration , actualDuration ) . isEqualTo ( duration ) ; return myself ; }
public S isFillingAfter ( ) { isNotNull ( ) ; assertThat ( actual . getFillAfter ( ) ) . overridingErrorMessage ( "Expected to be filling after but was not." ) . isTrue ( ) ; return myself ; }
public S isNotFillingAfter ( ) { isNotNull ( ) ; assertThat ( actual . getFillAfter ( ) ) . overridingErrorMessage ( "Expected to not be filling after but was." ) . isFalse ( ) ; return myself ; }
public S isFillingBefore ( ) { isNotNull ( ) ; assertThat ( actual . getFillBefore ( ) ) . overridingErrorMessage ( "Expected to be filling before but was not." ) . isTrue ( ) ; return myself ; }
public S isNotFillingBefore ( ) { isNotNull ( ) ; assertThat ( actual . getFillBefore ( ) ) . overridingErrorMessage ( "Expected to not be filling before but was." ) . isFalse ( ) ; return myself ; }
public S hasInterpolator ( Interpolator interpolator ) { isNotNull ( ) ; Interpolator actualInterpolator = actual . getInterpolator ( ) ; assertThat ( actualInterpolator ) . overridingErrorMessage ( "Expected interpolator <%s> but was <%s>." , interpolator , actualInterpolator ) . isSameAs ( interpolator ) ; return myself ; }
public S hasRepeatCount ( int count ) { isNotNull ( ) ; int actualCount = actual . getRepeatCount ( ) ; assertThat ( actualCount ) . overridingErrorMessage ( "Expected repeat count <%s> but was <%s>." , repeatCountToString ( count ) , repeatCountToString ( actualCount ) ) . isEqualTo ( count ) ; return myself ; }
public S hasRepeatMode ( @ AnimationRepeatMode int mode ) { isNotNull ( ) ; int actualMode = actual . getRepeatMode ( ) ; assertThat ( actualMode ) . overridingErrorMessage ( "Expected repeat mode <%s> but was <%s>." , repeatModeToString ( mode ) , repeatModeToString ( actualMode ) ) . isEqualTo ( mode ) ; return myself ; }
public S hasStartOffset ( long offset ) { isNotNull ( ) ; long actualOffset = actual . getStartOffset ( ) ; assertThat ( actualOffset ) . overridingErrorMessage ( "Expected start offset <%s> but was <%s>." , offset , actualOffset ) . isEqualTo ( offset ) ; return myself ; }
public S hasStartTime ( long time ) { isNotNull ( ) ; long actualTime = actual . getStartTime ( ) ; assertThat ( actualTime ) . overridingErrorMessage ( "Expected start time <%s> but was <%s>." , time , actualTime ) . isEqualTo ( time ) ; return myself ; }
public S hasZAdjustment ( int adjustment ) { isNotNull ( ) ; int actualAdjustment = actual . getZAdjustment ( ) ; assertThat ( actualAdjustment ) . overridingErrorMessage ( "Expected Z adjustment <%s> but was <%s>." , adjustment , actualAdjustment ) . isEqualTo ( adjustment ) ; return myself ; }
public S isEnded ( ) { isNotNull ( ) ; assertThat ( actual . hasEnded ( ) ) . overridingErrorMessage ( "Expected to be ended but was not." ) . isTrue ( ) ; return myself ; }
public S isNotEnded ( ) { isNotNull ( ) ; assertThat ( actual . hasEnded ( ) ) . overridingErrorMessage ( "Expected to not be ended but was." ) . isFalse ( ) ; return myself ; }
public S isStarted ( ) { isNotNull ( ) ; assertThat ( actual . hasStarted ( ) ) . overridingErrorMessage ( "Expected to be started but was not." ) . isTrue ( ) ; return myself ; }
public S isNotStarted ( ) { isNotNull ( ) ; assertThat ( actual . hasStarted ( ) ) . overridingErrorMessage ( "Expected to not be started but was." ) . isFalse ( ) ; return myself ; }
public S isFillEnabled ( ) { isNotNull ( ) ; assertThat ( actual . isFillEnabled ( ) ) . overridingErrorMessage ( "Expected fill to be enabled but was disabled." ) . isTrue ( ) ; return myself ; }
public S isFillDisabled ( ) { isNotNull ( ) ; assertThat ( actual . isFillEnabled ( ) ) . overridingErrorMessage ( "Expected fill to be disabled but was enabled." ) . isFalse ( ) ; return myself ; }
public S isInitialized ( ) { isNotNull ( ) ; assertThat ( actual . isInitialized ( ) ) . overridingErrorMessage ( "Expected to be initialized but was not." ) . isTrue ( ) ; return myself ; }
public S isNotInitialized ( ) { isNotNull ( ) ; assertThat ( actual . isInitialized ( ) ) . overridingErrorMessage ( "Expected to not be initialized but was." ) . isFalse ( ) ; return myself ; }
public S isChangingBounds ( ) { isNotNull ( ) ; assertThat ( actual . willChangeBounds ( ) ) . overridingErrorMessage ( "Expected to be changing bounds but was not." ) . isTrue ( ) ; return myself ; }
public S isNotChangingBounds ( ) { isNotNull ( ) ; assertThat ( actual . willChangeBounds ( ) ) . overridingErrorMessage ( "Expected to not be changing bounds but was." ) . isFalse ( ) ; return myself ; }
public S isChangingTransformationMatrix ( ) { isNotNull ( ) ; assertThat ( actual . willChangeTransformationMatrix ( ) ) . overridingErrorMessage ( "Expected to be changing transformation matrix but was not." ) . isTrue ( ) ; return myself ; }
public S isNotChangingTransformationMatrix ( ) { isNotNull ( ) ; assertThat ( actual . willChangeTransformationMatrix ( ) ) . overridingErrorMessage ( "Expected to not be changing transformation matrix but was." ) . isFalse ( ) ; return myself ; }
public static String repeatCountToString ( int count ) { return buildNamedValueString ( count ) . value ( INFINITE , "infinite" ) . getOrValue ( ) ; }
public static String repeatModeToString ( @ AnimationRepeatMode int mode ) { return buildNamedValueString ( mode ) . value ( RESTART , "restart" ) . value ( REVERSE , "reverse" ) . get ( ) ; }
@ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View view = inflater . inflate ( R . layout . fragment_scrollview_noheader , container , false ) ; final ObservableScrollView scrollView = ( ObservableScrollView ) view . findViewById ( R . id . scroll ) ; Activity parentActivity = getActivity ( ) ; scrollView . setTouchInterceptionViewGroup ( ( ViewGroup ) parentActivity . findViewById ( R . id . container ) ) ; if ( parentActivity instanceof ObservableScrollViewCallbacks ) { scrollView . setScrollViewCallbacks ( ( ObservableScrollViewCallbacks ) parentActivity ) ; } return view ; }
protected ObaStopIdsForAgencyRequest ( Uri uri ) { super( uri ); }
public Builder ( Context context , String agencyId ) { super( context , getPathWithId ( "/stop-ids-for-agency/" , agencyId ) ); }
public ObaStopIdsForAgencyRequest build ( ) { return new ObaStopIdsForAgencyRequest ( buildUri ( ) ) ; }
public static ObaStopIdsForAgencyRequest newRequest ( Context context , String agencyId ) { return new Builder ( context , agencyId ) . build ( ) ; }
@ Override public ObaStopIdsForAgencyResponse call ( ) { return call ( ObaStopIdsForAgencyResponse .class ) ; }
@ Override public String toString ( ) { return "ObaStopIdsForAgencyRequest [mUri=" + mUri + "]" ; }
public String getDirectionId ( )
public String getStopId ( )
public String getTripId ( )
public String getApplicationId ( )
public String getRouteId ( )
public String getAgencyId ( )
public List < String > getDiversionStopIds ( )
public ObaShape getDiversionPath ( )
public String getCondition ( )
public ConditionDetails getDetails ( )
public long getFrom ( )
public long getTo ( )
public String getSummary ( )
public String getDescription ( )
public String getAdvice ( )
public String getReason ( )
public long getCreationTime ( )
public AllAffects [] getAllAffects ( )
public Consequence [] getConsequences ( )
public String getSeverity ( )
public ActiveWindow [] getActiveWindows ( )
public String getUrl ( )
int getIndicatorColor ( int position );
public SlidingTabLayout ( Context context ) { this( context , null ); }
public SlidingTabLayout ( Context context , AttributeSet attrs ) { this( context , attrs , 0 ); }
public SlidingTabLayout ( Context context , AttributeSet attrs , int defStyle ) { super( context , attrs , defStyle ); setHorizontalScrollBarEnabled ( false ) ; setFillViewport ( true ) ; mTitleOffset = ( int ) ( TITLE_OFFSET_DIPS * getResources ( ) . getDisplayMetrics ( ) . density ) ; mTabStrip = new SlidingTabStrip ( context ) ; addView ( mTabStrip , LayoutParams . MATCH_PARENT , LayoutParams . WRAP_CONTENT ) ; }
public void setCustomTabColorizer ( TabColorizer tabColorizer ) { mTabStrip . setCustomTabColorizer ( tabColorizer ) ; }
public void setDistributeEvenly ( boolean distributeEvenly ) { mDistributeEvenly = distributeEvenly ; }
public void setSelectedIndicatorColors ( int ... colors ) { mTabStrip . setSelectedIndicatorColors ( colors ) ; }
public void setOnPageChangeListener ( ViewPager . OnPageChangeListener listener ) { mViewPagerPageChangeListener = listener ; }
public void setCustomTabView ( int layoutResId , int textViewId ) { mTabViewLayoutId = layoutResId ; mTabViewTextViewId = textViewId ; }
public void setViewPager ( ViewPager viewPager ) { mTabStrip . removeAllViews ( ) ; mViewPager = viewPager ; if ( viewPager != null ) { viewPager . setOnPageChangeListener ( new InternalViewPagerListener ( ) ) ; populateTabStrip ( ) ; } }
protected TextView createDefaultTabView ( Context context ) { TextView textView = new TextView ( context ) ; textView . setGravity ( Gravity . CENTER ) ; textView . setTextSize ( TypedValue . COMPLEX_UNIT_SP , TAB_VIEW_TEXT_SIZE_SP ) ; textView . setTypeface ( Typeface . DEFAULT_BOLD ) ; textView . setLayoutParams ( new LinearLayout . LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ) ; TypedValue outValue = new TypedValue ( ) ; getContext ( ) . getTheme ( ) . resolveAttribute ( android . R . attr . selectableItemBackground , outValue , true ) ; textView . setBackgroundResource ( outValue . resourceId ) ; textView . setAllCaps ( true ) ; int padding = ( int ) ( TAB_VIEW_PADDING_DIPS * getResources ( ) . getDisplayMetrics ( ) . density ) ; textView . setPadding ( padding , padding , padding , padding ) ; return textView ; }
private void populateTabStrip ( ) { final PagerAdapter adapter = mViewPager . getAdapter ( ) ; final OnClickListener tabClickListener = new TabClickListener ( ) ; for ( int i = 0 ; i < adapter . getCount ( ) ; i ++ ) { View tabView = null ; TextView tabTitleView = null ; if ( mTabViewLayoutId != 0 ) { tabView = LayoutInflater . from ( getContext ( ) ) . inflate ( mTabViewLayoutId , mTabStrip , false ) ; tabTitleView = ( TextView ) tabView . findViewById ( mTabViewTextViewId ) ; } if ( tabView == null ) { tabView = createDefaultTabView ( getContext ( ) ) ; } if ( tabTitleView == null && TextView .class . isInstance ( tabView ) ) { tabTitleView = ( TextView ) tabView ; } if ( mDistributeEvenly ) { LinearLayout . LayoutParams lp = ( LinearLayout . LayoutParams ) tabView . getLayoutParams ( ) ; lp . width = 0 ; lp . weight = 1 ; } tabTitleView . setText ( adapter . getPageTitle ( i ) ) ; tabView . setOnClickListener ( tabClickListener ) ; String desc = mContentDescriptions . get ( i , null ) ; if ( desc != null ) { tabView . setContentDescription ( desc ) ; } mTabStrip . addView ( tabView ) ; if ( i == mViewPager . getCurrentItem ( ) ) { tabView . setSelected ( true ) ; } } }
public void setContentDescription ( int i , String desc ) { mContentDescriptions . put ( i , desc ) ; }
@ Override protected void onAttachedToWindow ( ) { super. onAttachedToWindow ( ) ; if ( mViewPager != null ) { scrollToTab ( mViewPager . getCurrentItem ( ) , 0 ) ; } }
private void scrollToTab ( int tabIndex , int positionOffset ) { final int tabStripChildCount = mTabStrip . getChildCount ( ) ; if ( tabStripChildCount == 0 || tabIndex < 0 || tabIndex >= tabStripChildCount ) { return; } View selectedChild = mTabStrip . getChildAt ( tabIndex ) ; if ( selectedChild != null ) { int targetScrollX = selectedChild . getLeft ( ) + positionOffset ; if ( tabIndex > 0 || positionOffset > 0 ) { targetScrollX -= mTitleOffset ; } scrollTo ( targetScrollX , 0 ) ; } }
@ Override public void onPageScrolled ( int position , float positionOffset , int positionOffsetPixels ) { int tabStripChildCount = mTabStrip . getChildCount ( ) ; if ( ( tabStripChildCount == 0 ) || ( position < 0 ) || ( position >= tabStripChildCount ) ) { return; } mTabStrip . onViewPagerPageChanged ( position , positionOffset ) ; View selectedTitle = mTabStrip . getChildAt ( position ) ; int extraOffset = ( selectedTitle != null ) ? ( int ) ( positionOffset * selectedTitle . getWidth ( ) ) : 0 ; scrollToTab ( position , extraOffset ) ; if ( mViewPagerPageChangeListener != null ) { mViewPagerPageChangeListener . onPageScrolled ( position , positionOffset , positionOffsetPixels ) ; } }
@ Override public void onPageScrollStateChanged ( int state ) { mScrollState = state ; if ( mViewPagerPageChangeListener != null ) { mViewPagerPageChangeListener . onPageScrollStateChanged ( state ) ; } }
@ Override public void onPageSelected ( int position ) { if ( mScrollState == ViewPager . SCROLL_STATE_IDLE ) { mTabStrip . onViewPagerPageChanged ( position , 0f ) ; scrollToTab ( position , 0 ) ; } for ( int i = 0 ; i < mTabStrip . getChildCount ( ) ; i ++ ) { mTabStrip . getChildAt ( i ) . setSelected ( position == i ) ; } if ( mViewPagerPageChangeListener != null ) { mViewPagerPageChangeListener . onPageSelected ( position ) ; } }
@ Override public void onClick ( View v ) { for ( int i = 0 ; i < mTabStrip . getChildCount ( ) ; i ++ ) { if ( v == mTabStrip . getChildAt ( i ) ) { mViewPager . setCurrentItem ( i ) ; return; } } }
@ Override protected int getLayoutResId ( ) { return R . layout . activity_toolbarcontrollistview ; }
@ Override protected ObservableListView createScrollable ( ) { ObservableListView listView = ( ObservableListView ) findViewById ( R . id . scrollable ) ; setDummyData ( listView ) ; listView . setOnScrollListener ( new AbsListView . OnScrollListener ( ) { @ Override public void onScrollStateChanged ( AbsListView view , int scrollState ) { Log . v ( TAG , "onScrollStateChanged: " + scrollState ) ; } @ Override public void onScroll ( AbsListView view , int firstVisibleItem , int visibleItemCount , int totalItemCount ) { Log . v ( TAG , "onScroll: firstVisibleItem: " + firstVisibleItem + " visibleItemCount: " + visibleItemCount + " totalItemCount: " + totalItemCount ) ; } } ) ; return listView ; }
@ Override public void onScrollStateChanged ( AbsListView view , int scrollState ) { Log . v ( TAG , "onScrollStateChanged: " + scrollState ) ; }
@ Override public void onScroll ( AbsListView view , int firstVisibleItem , int visibleItemCount , int totalItemCount ) { Log . v ( TAG , "onScroll: firstVisibleItem: " + firstVisibleItem + " visibleItemCount: " + visibleItemCount + " totalItemCount: " + totalItemCount ) ; }
public TicTacToeSampleIT ( MavenRuntimeBuilder builder ) throws Exception { this . mavenRuntime = builder . build ( ) ; }
@ Test public void buildDeployAndRun ( ) Exception { File basedir = resources . getBasedir ( "tictactoe" ) ; MavenExecutionResult result = mavenRuntime . forProject ( basedir ) . execute ( "clean" , PluginInfo . getQualifiedGoal ( "undeploy" ) , "install" , PluginInfo . getQualifiedGoal ( "deploy" ) , PluginInfo . getQualifiedGoal ( "run" ) ) ; result . assertErrorFreeLog ( ) ; result . assertLogText ( "Successfully installed" ) ; result . assertLogText ( "Attempting to start com.example.android.tictactoe/com.example.android.tictactoe.MainActivity" ) ; }
public BluetoothGattDescriptorAssert ( BluetoothGattDescriptor actual ) { super( actual , BluetoothGattDescriptorAssert .class ); }
public BluetoothGattDescriptorAssert hasPermissions ( @ BluetoothGattDescriptorPermissions int permissions ) { isNotNull ( ) ; int actualPermissions = actual . getPermissions ( ) ; assertThat ( actualPermissions ) . overridingErrorMessage ( "Expected permissions <%s> but was <%s>." , permissionsToString ( permissions ) , permissionsToString ( actualPermissions ) ) . isEqualTo ( permissions ) ; return this ; }
public BluetoothGattDescriptorAssert hasUuid ( UUID uuid ) { isNotNull ( ) ; UUID actualUuid = actual . getUuid ( ) ; assertThat ( actualUuid ) . overridingErrorMessage ( "Expected UUID <%s> but was <%s>." , uuid , actualUuid ) . isEqualTo ( uuid ) ; return this ; }
public BluetoothGattDescriptorAssert hasValue ( byte [] value ) { isNotNull ( ) ; byte [] actualValue = actual . getValue ( ) ; assertThat ( actualValue ) . overridingErrorMessage ( "Expected value <%s> but was <%s>." , Arrays . toString ( value ) , Arrays . toString ( actualValue ) ) . isEqualTo ( value ) ; return this ; }
public static String permissionsToString ( @ BluetoothGattDescriptorPermissions int permissions ) { return buildBitMaskString ( permissions ) . flag ( PERMISSION_READ , "read" ) . flag ( PERMISSION_READ_ENCRYPTED , "read_encrypted" ) . flag ( PERMISSION_READ_ENCRYPTED_MITM , "read_encrypted_mitm" ) . flag ( PERMISSION_WRITE , "write" ) . flag ( PERMISSION_WRITE_ENCRYPTED , "write_encrypted" ) . flag ( PERMISSION_WRITE_ENCRYPTED_MITM , "write_encrypted_mitm" ) . flag ( PERMISSION_WRITE_SIGNED , "write_signed" ) . flag ( PERMISSION_WRITE_SIGNED_MITM , "write_signed_mitm" ) . get ( ) ; }
public void setNotification ( int id , Notification notification );
public void cancelNotification ( int id );
public void taskComplete ( )
private ObaApi ( ) { throw new AssertionError ( ) ; }
public static ObaContext getDefaultContext ( ) { return mDefaultContext ; }
< T > T deserialize ( Reader reader , Class < T > cls );
< T > T deserializeFromResponse ( String response , Class < T > cls );
String serialize ( Object obj );
< T > T createFromError ( Class < T > cls , int code , String error );
public static < T > SerializationHandler getSerializer ( Class < T > cls ) { return JacksonSerializer . getInstance ( ) ; }
public static void start ( Context context ) { Intent intent = new Intent ( context , RegionsActivity .class ) ; context . startActivity ( intent ) ; }
@ Override public void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; UIUtils . setupActionBar ( this ) ; FragmentManager fm = getSupportFragmentManager ( ) ; if ( fm . findFragmentById ( android . R . id . content ) == null ) { RegionsFragment list = new RegionsFragment ( ) ; fm . beginTransaction ( ) . add ( android . R . id . content , list ) . commit ( ) ; } }
@ Override protected void onStart ( ) { super. onStart ( ) ; ObaAnalytics . reportActivityStart ( this ) ; }
@ Override public boolean onOptionsItemSelected ( MenuItem item ) { if ( item . getItemId ( ) == android . R . id . home ) { NavHelp . goHome ( this , false ) ; return true ; } return false ; }
public static ObaStop getMockStop ( ) { return stop26 ; }
public static HashMap < String , ObaRoute > getMockRoutes ( ) { HashMap < String , ObaRoute > routes = new HashMap < String , ObaRoute > ( ) ; routes . put ( route1 . getId ( ) , route1 ) ; routes . put ( route5 . getId ( ) , route5 ) ; return routes ; }
@ Override public String getStopCode ( ) { return "26" ; }
@ Override public String getName ( ) { return "Nebraska Av @ Columbus Dr" ; }
@ Override public Location getLocation ( ) { return LocationUtils . makeLocation ( getLatitude ( ) , getLongitude ( ) ) ; }
@ Override public double getLatitude ( ) { return 27.966904 ; }
@ Override public double getLongitude ( ) { return - 82.451178 ; }
@ Override public String getDirection ( ) { return "N" ; }
@ Override public int getLocationType ( ) { return ObaStop . LOCATION_STOP ; }
@ Override public String [] getRouteIds ( ) { String [] routes = new String [ 2 ] ; routes [ 0 ] = "Hillsborough Area Regional Transit_1" ; routes [ 1 ] = "Hillsborough Area Regional Transit_5" ; return routes ; }
@ Override public String getId ( ) { return "Hillsborough Area Regional Transit_26" ; }
@ Override public String getShortName ( ) { return "1" ; }
@ Override public String getLongName ( ) { return "Florida Avenue" ; }
@ Override public String getDescription ( ) { return "" ; }
@ Override public int getType ( ) { return ObaRoute . TYPE_BUS ; }
@ Override public String getUrl ( ) { return "http: ; }
@ Override public Integer getColor ( ) { return 0 ; }
@ Override public Integer getTextColor ( ) { return 0 ; }
@ Override public String getAgencyId ( ) { return "Hillsborough Area Regional Transit" ; }
@ Override public String getId ( ) { return "Hillsborough Area Regional Transit_1" ; }
@ Override public String getShortName ( ) { return "5" ; }
@ Override public String getLongName ( ) { return "40th Street" ; }
@ Override public String getDescription ( ) { return "" ; }
@ Override public int getType ( ) { return ObaRoute . TYPE_BUS ; }
@ Override public String getUrl ( ) { return "http: ; }
@ Override public Integer getColor ( ) { return 0 ; }
@ Override public Integer getTextColor ( ) { return 0 ; }
@ Override public String getAgencyId ( ) { return "Hillsborough Area Regional Transit" ; }
@ Override public String getId ( ) { return "Hillsborough Area Regional Transit_5" ; }
public void onMapCenterChanging ( )
public void onMapCenterChanged ( )
public void onMapZoomChanging ( )
public void onMapZoomChanged ( )
@ Override public void run ( ) { Location newCenter = mObaMapView . getMapCenterAsLocation ( ) ; float newZoom = mObaMapView . getZoomLevelAsFloat ( ) ; final boolean centerChanged = ! LocationUtils . fuzzyEquals ( newCenter , mCurrentCenter ) ; final boolean zoomChanged = newZoom != mCurrentZoom ; final long now = System . currentTimeMillis ( ) ; if ( centerChanged ) { mCurrentCenterMillis = now ; mListener . onMapCenterChanging ( ) ; mCurrentCenter = newCenter ; } else if ( mCurrentCenterMillis != 0 && ( now - mCurrentCenterMillis ) > WAIT_TIME ) { mListener . onMapCenterChanged ( ) ; mCurrentCenterMillis = 0 ; } if ( zoomChanged ) { mCurrentZoomMillis = now ; mListener . onMapZoomChanging ( ) ; mCurrentZoom = newZoom ; } else if ( mCurrentZoomMillis != 0 && ( now - mCurrentZoomMillis ) > WAIT_TIME ) { mListener . onMapZoomChanged ( ) ; mCurrentZoomMillis = 0 ; } mHandler . postDelayed ( mChecker , POLL_TIME ) ; }
public MapWatcher ( MapModeController . ObaMapView view , Listener listener ) { mObaMapView = view ; mHandler = new Handler ( ) ; mListener = listener ; }
public void start ( ) { mCurrentCenter = mObaMapView . getMapCenterAsLocation ( ) ; mCurrentZoom = mObaMapView . getZoomLevelAsFloat ( ) ; mHandler . postDelayed ( mChecker , POLL_TIME ) ; }
public void stop ( ) { mHandler . removeCallbacks ( mChecker ) ; }
public void checkNow ( ) { mHandler . removeCallbacks ( mChecker ) ; mChecker . run ( ) ; }
protected ObaRouteRequest ( Uri uri ) { super( uri ); }
public Builder ( Context context , String routeId ) { super( context , getPathWithId ( "/route/" , routeId ) ); }
public ObaRouteRequest build ( ) { return new ObaRouteRequest ( buildUri ( ) ) ; }
public static ObaRouteRequest newRequest ( Context context , String routeId ) { return new Builder ( context , routeId ) . build ( ) ; }
@ Override public ObaRouteResponse call ( ) { return call ( ObaRouteResponse .class ) ; }
@ Override public String toString ( ) { return "ObaRouteRequest [mUri=" + mUri + "]" ; }
void onOrientationChanged ( float heading , float pitch , float deltaHeading , float deltaPitch );
public OrientationHelper ( Context context ) { mContext = context ; mSensorManager = ( SensorManager ) mContext . getSystemService ( Context . SENSOR_SERVICE ) ; }
public synchronized void registerListener ( Listener listener ) { if ( ! mListeners . contains ( listener ) ) { mListeners . add ( listener ) ; } if ( mListeners . size ( ) == 1 ) { mSensorManager . registerListener ( this , mSensorManager . getDefaultSensor ( Sensor . TYPE_ROTATION_VECTOR ) , SensorManager . SENSOR_DELAY_UI ) ; } }
public synchronized void unregisterListener ( Listener listener ) { if ( mListeners . contains ( listener ) ) { mListeners . remove ( listener ) ; } if ( mListeners . size ( ) == 0 ) { mSensorManager . unregisterListener ( this ) ; } }
public synchronized void onResume ( ) { mSensorManager . registerListener ( this , mSensorManager . getDefaultSensor ( Sensor . TYPE_ROTATION_VECTOR ) , SensorManager . SENSOR_DELAY_UI ) ; }
public synchronized void onPause ( ) { mSensorManager . unregisterListener ( this ) ; }
@ TargetApi ( Build . VERSION_CODES . GINGERBREAD ) @ Override public void onSensorChanged ( SensorEvent event ) { float xDelta = 0f ; float yDelta = 0f ; switch ( event . sensor . getType ( ) ) { case Sensor . TYPE_ROTATION_VECTOR : if ( ! mTruncateVector ) { try { SensorManager . getRotationMatrixFromVector ( mRotationMatrix , event . values ) ; } catch ( IllegalArgumentException e ) { Log . e ( TAG , "Samsung device error? Will truncate vectors - " + e ) ; mTruncateVector = true ; getRotationMatrixFromTruncatedVector ( event . values ) ; } } else { getRotationMatrixFromTruncatedVector ( event . values ) ; } WindowManager windowManager = ( WindowManager ) mContext . getSystemService ( Context . WINDOW_SERVICE ) ; int rot = windowManager . getDefaultDisplay ( ) . getRotation ( ) ; switch ( rot ) { case Surface . ROTATION_0 : SensorManager . getOrientation ( mRotationMatrix , mOrientation ) ; break; case Surface . ROTATION_90 : SensorManager . remapCoordinateSystem ( mRotationMatrix , SensorManager . AXIS_Y , SensorManager . AXIS_MINUS_X , mRemappedMatrix ) ; SensorManager . getOrientation ( mRemappedMatrix , mOrientation ) ; break; case Surface . ROTATION_180 : SensorManager . remapCoordinateSystem ( mRotationMatrix , SensorManager . AXIS_MINUS_X , SensorManager . AXIS_MINUS_Y , mRemappedMatrix ) ; SensorManager . getOrientation ( mRemappedMatrix , mOrientation ) ; break; case Surface . ROTATION_270 : SensorManager . remapCoordinateSystem ( mRotationMatrix , SensorManager . AXIS_MINUS_Y , SensorManager . AXIS_X , mRemappedMatrix ) ; SensorManager . getOrientation ( mRemappedMatrix , mOrientation ) ; break; default: SensorManager . getOrientation ( mRotationMatrix , mOrientation ) ; break; } mHeading = ( float ) Math . toDegrees ( mOrientation [ 0 ] ) ; mPitch = ( float ) Math . toDegrees ( mOrientation [ 1 ] ) ; xDelta = history [ 0 ] - mHeading ; yDelta = history [ 1 ] - mPitch ; history [ 0 ] = mHeading ; history [ 1 ] = mPitch ; break; case Sensor . TYPE_ORIENTATION : mHeading = event . values [ 0 ] ; xDelta = history [ 0 ] - mHeading ; break; default: return; } Float magneticDeclination = Application . getMagneticDeclination ( ) ; if ( magneticDeclination != null ) { mHeading += magneticDeclination ; } mHeading = MathUtils . mod ( mHeading , 360.0f ) ; for ( Listener l : mListeners ) { l . onOrientationChanged ( mHeading , mPitch , xDelta , yDelta ) ; } }
@ Override public void onAccuracyChanged ( Sensor sensor , int accuracy ) {    }
@ TargetApi ( Build . VERSION_CODES . GINGERBREAD ) private void getRotationMatrixFromTruncatedVector ( float [] vector ) { System . arraycopy ( vector , 0 , mTruncatedRotationVector , 0 , 4 ) ; SensorManager . getRotationMatrixFromVector ( mRotationMatrix , mTruncatedRotationVector ) ; }
public FileCache ( @ Nonnull Context context , @ Nonnull String cacheFileName ) { if ( getExternalStorageState ( ) . equals ( MEDIA_MOUNTED ) ) { cacheDir = new File ( createExternalCachePath ( context ) , cacheFileName ) ; } else { cacheDir = new File ( createInternalCachePath ( context ) , cacheFileName ) ; } if ( ! cacheDir . exists ( ) ) { cacheDir . mkdirs ( ) ; } }
@ Nullable private String createExternalCachePath ( @ Nonnull Context context ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . FROYO ) { final File cacheDir = context . getExternalCacheDir ( ) ; return cacheDir != null ? cacheDir . getPath ( ) : createInternalCachePath ( context ) ; } else { return getExternalStorageDirectory ( ) . getPath ( ) + "/Android/data/" + context . getPackageName ( ) + "/cache" ; } }
@ Nullable private String createInternalCachePath ( @ Nonnull Context context ) { final File cacheDir = context . getCacheDir ( ) ; return cacheDir != null ? cacheDir . getPath ( ) : null ; }
@ Nonnull public File getFile ( @ Nonnull String filename ) { return new File ( cacheDir , filename ) ; }
public void clear ( ) { final File [] files = cacheDir . listFiles ( ) ; if ( files != null ) { for ( File file : files ) { file . delete ( ) ; } } }
@ Override protected void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; setContentView ( R . layout . send_result ) ; Button button = ( Button ) findViewById ( R . id . corky ) ; button . setOnClickListener ( mCorkyListener ) ; button = ( Button ) findViewById ( R . id . violet ) ; button . setOnClickListener ( mVioletListener ) ; }
public void onClick ( View v ) { setResult ( RESULT_OK , ( new Intent ( ) ) . setAction ( "Corky!" ) ) ; finish ( ) ; }
public void onClick ( View v ) { setResult ( RESULT_OK , ( new Intent ( ) ) . setAction ( "Violet!" ) ) ; finish ( ) ; }
@ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View view = inflater . inflate ( R . layout . fragment_gridview , container , false ) ; Activity parentActivity = getActivity ( ) ; final ObservableGridView gridView = ( ObservableGridView ) view . findViewById ( R . id . scroll ) ; setDummyData ( gridView ) ; gridView . setTouchInterceptionViewGroup ( ( ViewGroup ) parentActivity . findViewById ( R . id . container ) ) ; if ( parentActivity instanceof ObservableScrollViewCallbacks ) { gridView . setScrollViewCallbacks ( ( ObservableScrollViewCallbacks ) parentActivity ) ; } return view ; }
public CameraPositionAssert ( CameraPosition actual ) { super( actual , CameraPositionAssert .class ); }
public CameraPositionAssert hasBearing ( float bearing ) { isNotNull ( ) ; float actualBearing = actual . bearing ; assertThat ( actualBearing ) . overridingErrorMessage ( "Expected bearing <%s> but was <%s>." , bearing , actualBearing ) . isEqualTo ( bearing ) ; return this ; }
public CameraPositionAssert hasTarget ( LatLng target ) { isNotNull ( ) ; LatLng actualTarget = actual . target ; assertThat ( actualTarget ) . overridingErrorMessage ( "Expected target <%s> but was <%s>." , target , actualTarget ) . isEqualTo ( target ) ; return this ; }
public CameraPositionAssert hasTilt ( float tilt ) { isNotNull ( ) ; float actualTilt = actual . tilt ; assertThat ( actualTilt ) . overridingErrorMessage ( "Expected tilt <%s> but was <%s>." , tilt , actualTilt ) . isEqualTo ( tilt ) ; return this ; }
public CameraPositionAssert hasZoom ( float zoom ) { isNotNull ( ) ; float actualZoom = actual . zoom ; assertThat ( actualZoom ) . overridingErrorMessage ( "Expected zoom <%s> but was <%s>." , zoom , actualZoom ) . isEqualTo ( zoom ) ; return this ; }
Observer ( ) { super( mHandler ); }
@ Override public boolean deliverSelfNotifications ( ) { return false ; }
public void onChange ( boolean selfChange ) { if ( isAdded ( ) ) { getLoaderManager ( ) . restartLoader ( 0 , null , MyListFragmentBase .this ) ; } }
@ Override public void onActivityCreated ( Bundle savedInstanceState ) { super. onActivityCreated ( savedInstanceState ) ; setEmptyText ( getString ( getEmptyText ( ) ) ) ; registerForContextMenu ( getListView ( ) ) ; mAdapter = newAdapter ( ) ; setListAdapter ( mAdapter ) ; ContentResolver cr = getActivity ( ) . getContentResolver ( ) ; mObserver = new Observer ( ) ; cr . registerContentObserver ( getContentUri ( ) , true , mObserver ) ; getLoaderManager ( ) . initLoader ( 0 , null , this ) ; }
@ Override public void onViewCreated ( View view , Bundle savedInstanceState ) { super. onViewCreated ( view , savedInstanceState ) ; ListView listView = getListView ( ) ; listView . setBackgroundColor ( getResources ( ) . getColor ( R . color . listview_background ) ) ; }
@ Override public void onDestroy ( ) { if ( mObserver != null ) { ContentResolver cr = getActivity ( ) . getContentResolver ( ) ; cr . unregisterContentObserver ( mObserver ) ; mObserver = null ; } super. onDestroy ( ) ; }
@ Override public void onLoadFinished ( Loader < Cursor > loader , Cursor data ) { mAdapter . swapCursor ( data ) ; }
@ Override public void onLoaderReset ( Loader < Cursor > loader ) { mAdapter . swapCursor ( null ) ; }
protected boolean isShortcutMode ( ) { Activity act = getActivity ( ) ; if ( act instanceof MyTabActivityBase ) { MyTabActivityBase base = ( MyTabActivityBase ) act ; return base . isShortcutMode ( ) ; } return false ; }
@ Override public Dialog onCreateDialog ( Bundle savedInstanceState ) { return new AlertDialog . Builder ( getActivity ( ) ) . setMessage ( R . string . my_option_clear_confirm ) . setTitle ( R . string . my_option_clear_confirm_title ) . setIcon ( android . R . drawable . ic_dialog_alert ) . setPositiveButton ( android . R . string . yes , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { doClear ( ) ; } } ) . setNegativeButton ( android . R . string . no , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { dialog . dismiss ( ) ; } } ) . create ( ) ; }
@ Override public void onClick ( DialogInterface dialog , int which ) { doClear ( ) ; }
@ Override public void onClick ( DialogInterface dialog , int which ) { dialog . dismiss ( ) ; }
abstract protected void doClear ( )
abstract protected SimpleCursorAdapter newAdapter ( )
abstract protected Uri getContentUri ( )
abstract protected int getEmptyText ( )
public CheckableFrameLayout ( Context context ) { super( context ); }
public CheckableFrameLayout ( Context context , AttributeSet attrs ) { super( context , attrs ); }
public void setChecked ( boolean checked ) { mChecked = checked ; setBackgroundDrawable ( checked ? new ColorDrawable ( 0xff0000a0 ) : null ) ; }
public boolean isChecked ( ) { return mChecked ; }
public void toggle ( ) { setChecked ( ! mChecked ) ; }
public HorizontalScrollViewAssert ( HorizontalScrollView actual ) { super( actual , HorizontalScrollViewAssert .class ); }
public static boolean init ( FragmentActivity context ) { final boolean isGooglePlayServicesAvailable = GooglePlayServicesUtil . isGooglePlayServicesAvailable ( context ) == ConnectionResult . SUCCESS ; if ( ! isGooglePlayServicesAvailable ) { return false ; } FragmentTransaction ft = context . getSupportFragmentManager ( ) . beginTransaction ( ) ; LocationsMapFragment locationsMapFragment = new LocationsMapFragment ( ) ; locationsMapFragment . click_to_fullscreen = true ; ft . replace ( R . id . map_container , locationsMapFragment ) ; ft . commit ( ) ; return true ; }
public static void startFullscreenMap ( Context context , Pass pass ) { App . getPassStore ( ) . setCurrentPass ( pass ) ; AXT . at ( context ) . startCommonIntent ( ) . activityFromClass ( FullscreenMapActivity .class ) ; }
public LoaderManagerAssert ( LoaderManager actual ) { super( actual , LoaderManagerAssert .class ); }
public LoaderManagerAssert hasLoader ( int id ) { isNotNull ( ) ; assertThat ( actual . getLoader ( id ) ) . overridingErrorMessage ( "Expected loader with ID <%s> but was not present." , id ) . isNotNull ( ) ; return this ; }
public static void goUp ( Activity activity ) { String mode = activity . getIntent ( ) . getStringExtra ( UP_MODE ) ; if ( UP_MODE_BACK . equals ( mode ) ) { activity . finish ( ) ; } else { goHome ( activity , false ) ; } }
public static void goHome ( Context context , boolean showTutorial ) { Intent intent = new Intent ( context , HomeActivity .class ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_TOP ) ; if ( showTutorial ) { intent . putExtra ( ShowcaseViewUtils . TUTORIAL_WELCOME , true ) ; } context . startActivity ( intent ) ; }
@ Override protected void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; final String url ; if ( getIntent ( ) . getData ( ) . toString ( ) . endsWith ( "/" ) ) { url = getIntent ( ) . getData ( ) . toString ( ) . substring ( 0 , getIntent ( ) . getData ( ) . toString ( ) . length ( ) - 1 ) ; } else { url = getIntent ( ) . getData ( ) . toString ( ) ; } final String [] split = url . split ( "/" ) ; final String passId = split [ split . length - 2 ] + "/" + split [ split . length - 1 ] ; final String redirectUrl = "http: + passId + "/passbook" ; tracker . trackEvent ( "quirk_fix" , "redirect" , "usairways" , null ) ; final Intent intent = new Intent ( this , PassImportActivity .class ) ; intent . setData ( Uri . parse ( redirectUrl ) ) ; startActivity ( intent ) ; finish ( ) ; }
@ Override public void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; final Intent intent = getIntent ( ) ; final Uri data = intent . getData ( ) ; if ( data != null ) { ArrivalsListActivity . start ( this , data . getLastPathSegment ( ) ) ; } else { Log . e ( TAG , "No stop ID!" ) ; finish ( ) ; } finish ( ) ; }
Observer ( ) { super( mHandler ); }
@ Override public boolean deliverSelfNotifications ( ) { return false ; }
public void onChange ( boolean selfChange ) { if ( isAdded ( ) ) { getLoaderManager ( ) . restartLoader ( 0 , null , MyRemindersFragment .this ) ; } }
@ Override public void onActivityCreated ( Bundle savedInstanceState ) { super. onActivityCreated ( savedInstanceState ) ; setEmptyText ( getString ( R . string . trip_list_notrips ) ) ; registerForContextMenu ( getListView ( ) ) ; mAdapter = newAdapter ( ) ; setListAdapter ( mAdapter ) ; ContentResolver cr = getActivity ( ) . getContentResolver ( ) ; mObserver = new Observer ( ) ; cr . registerContentObserver ( ObaContract . Trips . CONTENT_URI , true , mObserver ) ; getLoaderManager ( ) . initLoader ( 0 , null , this ) ; }
@ Override public void onStart ( ) { ObaAnalytics . reportFragmentStart ( this ) ; super. onStart ( ) ; }
@ Override public void onViewCreated ( View view , Bundle savedInstanceState ) { super. onViewCreated ( view , savedInstanceState ) ; ListView listView = getListView ( ) ; listView . setBackgroundColor ( getResources ( ) . getColor ( R . color . listview_background ) ) ; }
@ Override public void onDestroy ( ) { if ( mObserver != null ) { ContentResolver cr = getActivity ( ) . getContentResolver ( ) ; cr . unregisterContentObserver ( mObserver ) ; mObserver = null ; } super. onDestroy ( ) ; }
@ Override public Loader < Cursor > onCreateLoader ( int id , Bundle args ) { return new CursorLoader ( getActivity ( ) , ObaContract . Trips . CONTENT_URI , PROJECTION , null , null , ObaContract . Trips . NAME + " asc" ) ; }
@ Override public void onLoadFinished ( Loader < Cursor > loader , Cursor data ) { mAdapter . swapCursor ( data ) ; }
@ Override public void onLoaderReset ( Loader < Cursor > loader ) { mAdapter . swapCursor ( null ) ; }
private SimpleCursorAdapter newAdapter ( ) { final String [] from = { ObaContract . Trips . NAME , ObaContract . Trips . HEADSIGN , ObaContract . Trips . DEPARTURE , ObaContract . Trips . ROUTE_ID } ; final int [] to = { R . id . name , R . id . headsign , R . id . departure_time , R . id . route_name } ; SimpleCursorAdapter simpleAdapter = new SimpleCursorAdapter ( getActivity ( ) , R . layout . trip_list_listitem , null , from , to , 0 ) ; simpleAdapter . setViewBinder ( new SimpleCursorAdapter . ViewBinder ( ) { public boolean setViewValue ( View view , Cursor cursor , int columnIndex ) { if ( columnIndex == COL_NAME ) { TextView text = ( TextView ) view ; String name = cursor . getString ( columnIndex ) ; if ( name . length ( ) == 0 ) { name = getString ( R . string . trip_info_noname ) ; } text . setText ( name ) ; return true ; } else if ( columnIndex == COL_HEADSIGN ) { String headSign = cursor . getString ( columnIndex ) ; TextView text = ( TextView ) view ; text . setText ( UIUtils . formatDisplayText ( headSign ) ) ; return true ; } else if ( columnIndex == COL_DEPARTURE ) { TextView text = ( TextView ) view ; text . setText ( TripInfoActivity . getDepartureTime ( getActivity ( ) , ObaContract . Trips . convertDBToTime ( cursor . getInt ( columnIndex ) ) ) ) ; return true ; } else if ( columnIndex == COL_ROUTE_ID ) { TextView text = ( TextView ) view ; final String routeId = cursor . getString ( columnIndex ) ; final String routeName = TripService . getRouteShortName ( getActivity ( ) , routeId ) ; if ( routeName != null ) { text . setText ( getString ( R . string . trip_info_route , routeName ) ) ; } return true ; } return false ; } } ) ; return simpleAdapter ; }
public boolean setViewValue ( View view , Cursor cursor , int columnIndex ) { if ( columnIndex == COL_NAME ) { TextView text = ( TextView ) view ; String name = cursor . getString ( columnIndex ) ; if ( name . length ( ) == 0 ) { name = getString ( R . string . trip_info_noname ) ; } text . setText ( name ) ; return true ; } else if ( columnIndex == COL_HEADSIGN ) { String headSign = cursor . getString ( columnIndex ) ; TextView text = ( TextView ) view ; text . setText ( UIUtils . formatDisplayText ( headSign ) ) ; return true ; } else if ( columnIndex == COL_DEPARTURE ) { TextView text = ( TextView ) view ; text . setText ( TripInfoActivity . getDepartureTime ( getActivity ( ) , ObaContract . Trips . convertDBToTime ( cursor . getInt ( columnIndex ) ) ) ) ; return true ; } else if ( columnIndex == COL_ROUTE_ID ) { TextView text = ( TextView ) view ; final String routeId = cursor . getString ( columnIndex ) ; final String routeName = TripService . getRouteShortName ( getActivity ( ) , routeId ) ; if ( routeName != null ) { text . setText ( getString ( R . string . trip_info_route , routeName ) ) ; } return true ; } return false ; }
@ Override public void onListItemClick ( ListView l , View v , int position , long id ) { String [] ids = getIds ( l , position ) ; TripInfoActivity . start ( getActivity ( ) , ids [ 0 ] , ids [ 1 ] ) ; }
@ Override public void onCreateContextMenu ( ContextMenu menu , View v , ContextMenu . ContextMenuInfo menuInfo ) { super. onCreateContextMenu ( menu , v , menuInfo ) ; AdapterView . AdapterContextMenuInfo info = ( AdapterView . AdapterContextMenuInfo ) menuInfo ; final TextView text = ( TextView ) info . targetView . findViewById ( R . id . name ) ; menu . setHeaderTitle ( text . getText ( ) ) ; menu . add ( 0 , CONTEXT_MENU_DEFAULT , 0 , R . string . trip_list_context_edit ) ; menu . add ( 0 , CONTEXT_MENU_DELETE , 0 , R . string . trip_list_context_delete ) ; menu . add ( 0 , CONTEXT_MENU_SHOWSTOP , 0 , R . string . trip_list_context_showstop ) ; menu . add ( 0 , CONTEXT_MENU_SHOWROUTE , 0 , R . string . trip_list_context_showroute ) ; }
@ Override public boolean onContextItemSelected ( android . view . MenuItem item ) { AdapterView . AdapterContextMenuInfo info = ( AdapterView . AdapterContextMenuInfo ) item . getMenuInfo ( ) ; switch ( item . getItemId ( ) ) { case CONTEXT_MENU_DEFAULT : onListItemClick ( getListView ( ) , info . targetView , info . position , info . id ) ; return true ; case CONTEXT_MENU_DELETE : deleteTrip ( getListView ( ) , info . position ) ; return true ; case CONTEXT_MENU_SHOWSTOP : goToStop ( getListView ( ) , info . position ) ; return true ; case CONTEXT_MENU_SHOWROUTE : goToRoute ( getListView ( ) , info . position ) ; return true ; default: return super. onContextItemSelected ( item ) ; } }
private void deleteTrip ( ListView l , int position ) { String [] ids = getIds ( l , position ) ; ContentResolver cr = getActivity ( ) . getContentResolver ( ) ; cr . delete ( ObaContract . Trips . buildUri ( ids [ 0 ] , ids [ 1 ] ) , null , null ) ; TripService . scheduleAll ( getActivity ( ) ) ; getLoaderManager ( ) . getLoader ( 0 ) . onContentChanged ( ) ; }
private void goToStop ( ListView l , int position ) { String [] ids = getIds ( l , position ) ; ArrivalsListActivity . start ( getActivity ( ) , ids [ 1 ] ) ; }
private void goToRoute ( ListView l , int position ) { String [] ids = getIds ( l , position ) ; RouteInfoActivity . start ( getActivity ( ) , ids [ 2 ] ) ; }
private String [] getIds ( ListView l , int position ) { SimpleCursorAdapter cursorAdapter = ( SimpleCursorAdapter ) l . getAdapter ( ) ; final Cursor c = cursorAdapter . getCursor ( ) ; c . moveToPosition ( position - l . getHeaderViewsCount ( ) ) ; final String [] result = new String [] { c . getString ( COL_ID ) , c . getString ( COL_STOP_ID ) , c . getString ( COL_ROUTE_ID ) } ; return result ; }
public SavePreference ( Context context ) { super( context ); }
public SavePreference ( Context context , AttributeSet attrs ) { super( context , attrs ); }
public SavePreference ( Context context , AttributeSet attrs , int defStyle ) { super( context , attrs , defStyle ); }
@ Override public boolean isPersistent ( ) { return false ; }
@ Override public boolean isEnabled ( ) { return Environment . MEDIA_MOUNTED . equals ( Environment . getExternalStorageState ( ) ) ; }
@ Override protected void onClick ( ) { Context context = Application . get ( ) . getApplicationContext ( ) ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , context . getString ( R . string . analytics_action_button_press ) , context . getString ( R . string . analytics_label_button_press_save_preference ) ) ; try { Backup . backup ( context ) ; Toast . makeText ( context , context . getString ( R . string . preferences_db_saved ) , Toast . LENGTH_LONG ) . show ( ) ; } catch ( IOException e ) { Toast . makeText ( context , context . getString ( R . string . preferences_db_save_error , e . getMessage ( ) ) , Toast . LENGTH_LONG ) . show ( ) ; } }
@ Override protected void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; final Resources res = getResources ( ) ; final ActionBar bar = getSupportActionBar ( ) ; bar . setNavigationMode ( ActionBar . NAVIGATION_MODE_TABS ) ; bar . setDisplayOptions ( 0 , ActionBar . DISPLAY_SHOW_TITLE ) ; bar . addTab ( bar . newTab ( ) . setTag ( MyRecentRoutesFragment . TAB_NAME ) . setText ( res . getString ( R . string . my_recent_title ) ) . setIcon ( res . getDrawable ( R . drawable . ic_tab_recent ) ) . setTabListener ( new TabListener < MyRecentRoutesFragment > ( this , MyRecentRoutesFragment . TAB_NAME , MyRecentRoutesFragment .class ) ) ) ; bar . addTab ( bar . newTab ( ) . setTag ( MySearchRoutesFragment . TAB_NAME ) . setText ( res . getString ( R . string . my_search_title ) ) . setIcon ( res . getDrawable ( R . drawable . ic_tab_search ) ) . setTabListener ( new TabListener < MySearchRoutesFragment > ( this , MySearchRoutesFragment . TAB_NAME , MySearchRoutesFragment .class ) ) ) ; restoreDefaultTab ( ) ; UIUtils . setupActionBar ( this ) ; }
@ Override protected String getLastTabPref ( ) { return "MyRoutesActivity.LastTab" ; }
@ Override protected void onStart ( ) { super. onStart ( ) ; ObaAnalytics . reportActivityStart ( this ) ; }
public void testTitleCase ( ) { assertEquals ( null , MyTextUtils . toTitleCase ( null ) ) ; assertEquals ( "E John St & 13th Ave E" , MyTextUtils . toTitleCase ( "E JOHN ST & 13th AVE E" ) ) ; assertEquals ( "Seattle" , MyTextUtils . toTitleCase ( "SEATTLE" ) ) ; assertEquals ( "Seattle" , MyTextUtils . toTitleCase ( "Seattle" ) ) ; }
public void testSentenceCase ( ) { assertEquals ( "Testing sentence case" , MyTextUtils . toSentenceCase ( "Testing sentence case" ) ) ; assertEquals ( "Testing sentence case again" , MyTextUtils . toSentenceCase ( "TESTING SENTENCE CASE AGAIN" ) ) ; assertEquals ( "Another test" , MyTextUtils . toSentenceCase ( "Another Test" ) ) ; assertEquals ( "Another test" , MyTextUtils . toSentenceCase ( "Another TEST" ) ) ; }
public void testIsAllCaps ( ) { assertTrue ( MyTextUtils . isAllCaps ( "THIS IS ALL CAPS" ) ) ; assertFalse ( MyTextUtils . isAllCaps ( "THIS IS not ALL CAPS" ) ) ; }
public ObaAgencyWithCoverage ( ) { agencyId = "" ; lat = 0 ; lon = 0 ; latSpan = 0 ; lonSpan = 0 ; }
@ Override public String getId ( ) { return agencyId ; }
public Location getPoint ( ) { return LocationUtils . makeLocation ( lat , lon ) ; }
public double getLatitude ( ) { return lat ; }
public double getLongitude ( ) { return lon ; }
public double getLatitudeSpan ( ) { return latSpan ; }
public double getLongitudeSpan ( ) { return lonSpan ; }
@ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( agencyId == null ) ? 0 : agencyId . hashCode ( ) ) ; return result ; }
@ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( ! ( obj instanceof ObaAgencyWithCoverage ) ) { return false ; } ObaAgencyWithCoverage other = ( ObaAgencyWithCoverage ) obj ; if ( agencyId == null ) { if ( other . agencyId != null ) { return false ; } } else if ( ! agencyId . equals ( other . agencyId ) ) { return false ; } return true ; }
@ Override public String toString ( ) { return "ObaAgencyWithCoverage [agencyId=" + agencyId + "]" ; }
public ImportAsyncTask ( Activity passImportActivity , Uri uri ) { this . passImportActivity = passImportActivity ; this . uri = uri ; }
@ Override protected InputStreamWithSource doInBackground ( Void ... params ) { Tracker . get ( ) . trackEvent ( "protocol" , "to_inputstream" , uri . getScheme ( ) , null ) ; switch ( uri . getScheme ( ) ) { case "content" : return InputStreamProvider . fromContent ( passImportActivity , uri ) ; case "http" : case "https" : return InputStreamProvider . fromOKHttp ( uri ) ; default: Tracker . get ( ) . trackException ( "unknown scheme in ImportAsyncTask" + uri . getScheme ( ) , false ) ; case "file" : return InputStreamProvider . getDefaultHttpInputStreamForUri ( uri ) ; } }
public static float mod ( float a , float b ) { return ( a % b + b ) % b ; }
public static int getHalfWindIndex ( float heading ) { return getHalfWindIndex ( heading , NUMBER_OF_HALF_WINDS ) ; }
public static int getHalfWindIndex ( float heading , int numHalfWinds ) { float partitionSize = 360.0f / numHalfWinds ; float displacedHeading = MathUtils . mod ( heading + partitionSize / 2 , 360.0f ) ; return ( int ) ( displacedHeading / partitionSize ) ; }
public static double toDirection ( double orientation ) { double direction = ( - orientation + 90 ) % 360 ; if ( direction < 0 ) { direction += 360 ; } return direction ; }
@ Override protected void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_viewpagertab ) ; setSupportActionBar ( ( Toolbar ) findViewById ( R . id . toolbar ) ) ; mHeaderView = findViewById ( R . id . header ) ; ViewCompat . setElevation ( mHeaderView , getResources ( ) . getDimension ( R . dimen . toolbar_elevation ) ) ; mToolbarView = findViewById ( R . id . toolbar ) ; mPagerAdapter = new NavigationAdapter ( getSupportFragmentManager ( ) ) ; mPager = ( ViewPager ) findViewById ( R . id . pager ) ; mPager . setAdapter ( mPagerAdapter ) ; SlidingTabLayout slidingTabLayout = ( SlidingTabLayout ) findViewById ( R . id . sliding_tabs ) ; slidingTabLayout . setCustomTabView ( R . layout . tab_indicator , android . R . id . text1 ) ; slidingTabLayout . setSelectedIndicatorColors ( getResources ( ) . getColor ( R . color . accent ) ) ; slidingTabLayout . setDistributeEvenly ( true ) ; slidingTabLayout . setViewPager ( mPager ) ; slidingTabLayout . setOnPageChangeListener ( new ViewPager . OnPageChangeListener ( ) { @ Override public void onPageScrolled ( int i , float v , int i2 ) {            } @ Override public void onPageSelected ( int i ) { propagateToolbarState ( toolbarIsShown ( ) ) ; } @ Override public void onPageScrollStateChanged ( int i ) {            } } ) ; propagateToolbarState ( toolbarIsShown ( ) ) ; }
@ Override public void onPageScrolled ( int i , float v , int i2 ) {            }
@ Override public void onPageSelected ( int i ) { propagateToolbarState ( toolbarIsShown ( ) ) ; }
@ Override public void onPageScrollStateChanged ( int i ) {            }
@ Override public void onScrollChanged ( int scrollY , boolean firstScroll , boolean dragging ) { if ( dragging ) { int toolbarHeight = mToolbarView . getHeight ( ) ; float currentHeaderTranslationY = ViewHelper . getTranslationY ( mHeaderView ) ; if ( firstScroll ) { if ( - toolbarHeight < currentHeaderTranslationY ) { mBaseTranslationY = scrollY ; } } float headerTranslationY = ScrollUtils . getFloat ( - ( scrollY - mBaseTranslationY ) , - toolbarHeight , 0 ) ; ViewPropertyAnimator . animate ( mHeaderView ) . cancel ( ) ; ViewHelper . setTranslationY ( mHeaderView , headerTranslationY ) ; } }
@ Override public void onDownMotionEvent ( ) {    }
@ Override public void onUpOrCancelMotionEvent ( ScrollState scrollState ) { mBaseTranslationY = 0 ; Fragment fragment = getCurrentFragment ( ) ; if ( fragment == null ) { return; } View view = fragment . getView ( ) ; if ( view == null ) { return; } adjustToolbar ( scrollState , view ) ; }
private void adjustToolbar ( ScrollState scrollState , View view ) { int toolbarHeight = mToolbarView . getHeight ( ) ; final Scrollable scrollView = ( Scrollable ) view . findViewById ( R . id . scroll ) ; if ( scrollView == null ) { return; } int scrollY = scrollView . getCurrentScrollY ( ) ; if ( scrollState == ScrollState . DOWN ) { showToolbar ( ) ; } else if ( scrollState == ScrollState . UP ) { if ( toolbarHeight <= scrollY ) { hideToolbar ( ) ; } else { showToolbar ( ) ; } } else { if ( toolbarIsShown ( ) || toolbarIsHidden ( ) ) { propagateToolbarState ( toolbarIsShown ( ) ) ; } else { showToolbar ( ) ; } } }
private Fragment getCurrentFragment ( ) { return mPagerAdapter . getItemAt ( mPager . getCurrentItem ( ) ) ; }
private void propagateToolbarState ( boolean isShown ) { int toolbarHeight = mToolbarView . getHeight ( ) ; mPagerAdapter . setScrollY ( isShown ? 0 : toolbarHeight ) ; for ( int i = 0 ; i < mPagerAdapter . getCount ( ) ; i ++ ) { if ( i == mPager . getCurrentItem ( ) ) { continue; } Fragment f = mPagerAdapter . getItemAt ( i ) ; if ( f == null ) { continue; } View view = f . getView ( ) ; if ( view == null ) { continue; } propagateToolbarState ( isShown , view , toolbarHeight ) ; } }
private void propagateToolbarState ( boolean isShown , View view , int toolbarHeight ) { Scrollable scrollView = ( Scrollable ) view . findViewById ( R . id . scroll ) ; if ( scrollView == null ) { return; } if ( isShown ) { if ( 0 < scrollView . getCurrentScrollY ( ) ) { scrollView . scrollVerticallyTo ( 0 ) ; } } else { if ( scrollView . getCurrentScrollY ( ) < toolbarHeight ) { scrollView . scrollVerticallyTo ( toolbarHeight ) ; } } }
private boolean toolbarIsShown ( ) { return ViewHelper . getTranslationY ( mHeaderView ) == 0 ; }
private boolean toolbarIsHidden ( ) { return ViewHelper . getTranslationY ( mHeaderView ) == - mToolbarView . getHeight ( ) ; }
private void showToolbar ( ) { float headerTranslationY = ViewHelper . getTranslationY ( mHeaderView ) ; if ( headerTranslationY != 0 ) { ViewPropertyAnimator . animate ( mHeaderView ) . cancel ( ) ; ViewPropertyAnimator . animate ( mHeaderView ) . translationY ( 0 ) . setDuration ( 200 ) . start ( ) ; } propagateToolbarState ( true ) ; }
private void hideToolbar ( ) { float headerTranslationY = ViewHelper . getTranslationY ( mHeaderView ) ; int toolbarHeight = mToolbarView . getHeight ( ) ; if ( headerTranslationY != - toolbarHeight ) { ViewPropertyAnimator . animate ( mHeaderView ) . cancel ( ) ; ViewPropertyAnimator . animate ( mHeaderView ) . translationY ( - toolbarHeight ) . setDuration ( 200 ) . start ( ) ; } propagateToolbarState ( false ) ; }
public NavigationAdapter ( FragmentManager fm ) { super( fm ); }
public void setScrollY ( int scrollY ) { mScrollY = scrollY ; }
@ Override protected Fragment createItem ( int position ) { Fragment f ; final int pattern = position % 4 ; switch ( pattern ) { case 0 : { f = new ViewPagerTabScrollViewFragment ( ) ; if ( 0 <= mScrollY ) { Bundle args = new Bundle ( ) ; args . putInt ( ViewPagerTabScrollViewFragment . ARG_SCROLL_Y , mScrollY ) ; f . setArguments ( args ) ; } break; } case 1 : { f = new ViewPagerTabListViewFragment ( ) ; if ( 0 < mScrollY ) { Bundle args = new Bundle ( ) ; args . putInt ( ViewPagerTabListViewFragment . ARG_INITIAL_POSITION , 1 ) ; f . setArguments ( args ) ; } break; } case 2 : { f = new ViewPagerTabRecyclerViewFragment ( ) ; if ( 0 < mScrollY ) { Bundle args = new Bundle ( ) ; args . putInt ( ViewPagerTabRecyclerViewFragment . ARG_INITIAL_POSITION , 1 ) ; f . setArguments ( args ) ; } break; } case 3 : default: { f = new ViewPagerTabGridViewFragment ( ) ; if ( 0 < mScrollY ) { Bundle args = new Bundle ( ) ; args . putInt ( ViewPagerTabGridViewFragment . ARG_INITIAL_POSITION , 1 ) ; f . setArguments ( args ) ; } break; } } return f ; }
@ Override public int getCount ( ) { return TITLES . length ; }
@ Override public CharSequence getPageTitle ( int position ) { return TITLES [ position ] ; }
public GPUImageView ( Context context ) { super( context ); init ( context , null ) ; }
public GPUImageView ( Context context , AttributeSet attrs ) { super( context , attrs ); init ( context , attrs ) ; }
private void init ( Context context , AttributeSet attrs ) { mGLSurfaceView = new GPUImageGLSurfaceView ( context , attrs ) ; addView ( mGLSurfaceView ) ; mGPUImage = new GPUImage ( getContext ( ) ) ; mGPUImage . setGLSurfaceView ( mGLSurfaceView ) ; }
@ Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { if ( mRatio != 0.0f ) { int width = MeasureSpec . getSize ( widthMeasureSpec ) ; int height = MeasureSpec . getSize ( heightMeasureSpec ) ; int newHeight ; int newWidth ; if ( width / mRatio < height ) { newWidth = width ; newHeight = Math . round ( width / mRatio ) ; } else { newHeight = height ; newWidth = Math . round ( height * mRatio ) ; } int newWidthSpec = MeasureSpec . makeMeasureSpec ( newWidth , MeasureSpec . EXACTLY ) ; int newHeightSpec = MeasureSpec . makeMeasureSpec ( newHeight , MeasureSpec . EXACTLY ) ; super. onMeasure ( newWidthSpec , newHeightSpec ) ; } else { super. onMeasure ( widthMeasureSpec , heightMeasureSpec ) ; } }
public GPUImage getGPUImage ( ) { return mGPUImage ; }
public void setBackgroundColor ( float red , float green , float blue ) { mGPUImage . setBackgroundColor ( red , green , blue ) ; }
public void setRatio ( float ratio ) { mRatio = ratio ; mGLSurfaceView . requestLayout ( ) ; mGPUImage . deleteImage ( ) ; }
public void setScaleType ( GPUImage . ScaleType scaleType ) { mGPUImage . setScaleType ( scaleType ) ; }
public void setRotation ( Rotation rotation ) { mGPUImage . setRotation ( rotation ) ; requestRender ( ) ; }
public void setFilter ( GPUImageFilter filter ) { mFilter = filter ; mGPUImage . setFilter ( filter ) ; requestRender ( ) ; }
public GPUImageFilter getFilter ( ) { return mFilter ; }
public void setImage ( final Bitmap bitmap ) { mGPUImage . setImage ( bitmap ) ; }
public void setImage ( final Uri uri ) { mGPUImage . setImage ( uri ) ; }
public void setImage ( final File file ) { mGPUImage . setImage ( file ) ; }
public void requestRender ( ) { mGLSurfaceView . requestRender ( ) ; }
public void saveToPictures ( final String folderName , final String fileName , final OnPictureSavedListener listener ) { new SaveTask ( folderName , fileName , listener ) . execute ( ) ; }
public void saveToPictures ( final String folderName , final String fileName , int width , int height , final OnPictureSavedListener listener ) { new SaveTask ( folderName , fileName , width , height , listener ) . execute ( ) ; }
public Bitmap capture ( final int width , final int height ) throws InterruptedException { if ( Looper . myLooper ( ) == Looper . getMainLooper ( ) ) { throw new IllegalStateException ( "Do not call this method from the UI thread!" ) ; } mForceSize = new Size ( width , height ) ; final Semaphore waiter = new Semaphore ( 0 ) ; getViewTreeObserver ( ) . addOnGlobalLayoutListener ( new ViewTreeObserver . OnGlobalLayoutListener ( ) { @ Override public void onGlobalLayout ( ) { if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . JELLY_BEAN ) { getViewTreeObserver ( ) . removeGlobalOnLayoutListener ( this ) ; } else { getViewTreeObserver ( ) . removeOnGlobalLayoutListener ( this ) ; } waiter . release ( ) ; } } ) ; post ( new Runnable ( ) { @ Override public void run ( ) { addView ( new LoadingView ( getContext ( ) ) ) ; mGLSurfaceView . requestLayout ( ) ; } } ) ; waiter . acquire ( ) ; mGPUImage . runOnGLThread ( new Runnable ( ) { @ Override public void run ( ) { waiter . release ( ) ; } } ) ; requestRender ( ) ; waiter . acquire ( ) ; Bitmap bitmap = capture ( ) ; mForceSize = null ; post ( new Runnable ( ) { @ Override public void run ( ) { mGLSurfaceView . requestLayout ( ) ; } } ) ; requestRender ( ) ; postDelayed ( new Runnable ( ) { @ Override public void run ( ) { removeViewAt ( 1 ) ; } } , 300 ) ; return bitmap ; }
@ Override public void onGlobalLayout ( ) { if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . JELLY_BEAN ) { getViewTreeObserver ( ) . removeGlobalOnLayoutListener ( this ) ; } else { getViewTreeObserver ( ) . removeOnGlobalLayoutListener ( this ) ; } waiter . release ( ) ; }
@ Override public void run ( ) { addView ( new LoadingView ( getContext ( ) ) ) ; mGLSurfaceView . requestLayout ( ) ; }
@ Override public void run ( ) { waiter . release ( ) ; }
@ Override public void run ( ) { mGLSurfaceView . requestLayout ( ) ; }
@ Override public void run ( ) { removeViewAt ( 1 ) ; }
public Bitmap capture ( ) InterruptedException { final Semaphore waiter = new Semaphore ( 0 ) ; final int width = mGLSurfaceView . getMeasuredWidth ( ) ; final int height = mGLSurfaceView . getMeasuredHeight ( ) ; final int [] pixelMirroredArray = new int [ width * height ] ; mGPUImage . runOnGLThread ( new Runnable ( ) { @ Override public void run ( ) { final IntBuffer pixelBuffer = IntBuffer . allocate ( width * height ) ; GLES20 . glReadPixels ( 0 , 0 , width , height , GLES20 . GL_RGBA , GLES20 . GL_UNSIGNED_BYTE , pixelBuffer ) ; int [] pixelArray = pixelBuffer . array ( ) ; for ( int i = 0 ; i < height ; i ++ ) { for ( int j = 0 ; j < width ; j ++ ) { pixelMirroredArray [ ( height - i - 1 ) * width + j ] = pixelArray [ i * width + j ] ; } } waiter . release ( ) ; } } ) ; requestRender ( ) ; waiter . acquire ( ) ; Bitmap bitmap = Bitmap . createBitmap ( width , height , Bitmap . Config . ARGB_8888 ) ; bitmap . copyPixelsFromBuffer ( IntBuffer . wrap ( pixelMirroredArray ) ) ; return bitmap ; }
@ Override public void run ( ) { final IntBuffer pixelBuffer = IntBuffer . allocate ( width * height ) ; GLES20 . glReadPixels ( 0 , 0 , width , height , GLES20 . GL_RGBA , GLES20 . GL_UNSIGNED_BYTE , pixelBuffer ) ; int [] pixelArray = pixelBuffer . array ( ) ; for ( int i = 0 ; i < height ; i ++ ) { for ( int j = 0 ; j < width ; j ++ ) { pixelMirroredArray [ ( height - i - 1 ) * width + j ] = pixelArray [ i * width + j ] ; } } waiter . release ( ) ; }
public void onPause ( ) { mGLSurfaceView . onPause ( ) ; }
public void onResume ( ) { mGLSurfaceView . onResume ( ) ; }
public Size ( int width , int height ) { this . width = width ; this . height = height ; }
public GPUImageGLSurfaceView ( Context context ) { super( context ); }
public GPUImageGLSurfaceView ( Context context , AttributeSet attrs ) { super( context , attrs ); }
@ Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { if ( mForceSize != null ) { super. onMeasure ( MeasureSpec . makeMeasureSpec ( mForceSize . width , MeasureSpec . EXACTLY ) , MeasureSpec . makeMeasureSpec ( mForceSize . height , MeasureSpec . EXACTLY ) ) ; } else { super. onMeasure ( widthMeasureSpec , heightMeasureSpec ) ; } }
public LoadingView ( Context context ) { super( context ); init ( ) ; }
public LoadingView ( Context context , AttributeSet attrs ) { super( context , attrs ); init ( ) ; }
public LoadingView ( Context context , AttributeSet attrs , int defStyle ) { super( context , attrs , defStyle ); init ( ) ; }
private void init ( ) { ProgressBar view = new ProgressBar ( getContext ( ) ) ; view . setLayoutParams ( new LayoutParams ( LayoutParams . WRAP_CONTENT , LayoutParams . WRAP_CONTENT , Gravity . CENTER ) ) ; addView ( view ) ; setBackgroundColor ( Color . BLACK ) ; }
public SaveTask ( final String folderName , final String fileName , final OnPictureSavedListener listener ) { this( folderName , fileName , 0 , 0 , listener ); }
public SaveTask ( final String folderName , final String fileName , int width , int height , final OnPictureSavedListener listener ) { mFolderName = folderName ; mFileName = fileName ; mWidth = width ; mHeight = height ; mListener = listener ; mHandler = new Handler ( ) ; }
@ Override protected Void doInBackground ( final Void ... params ) { try { Bitmap result = mWidth != 0 ? capture ( mWidth , mHeight ) : capture ( ) ; saveImage ( mFolderName , mFileName , result ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } return null ; }
private void saveImage ( final String folderName , final String fileName , final Bitmap image ) { File path = Environment . getExternalStoragePublicDirectory ( Environment . DIRECTORY_PICTURES ) ; File file = new File ( path , folderName + "/" + fileName ) ; try { file . getParentFile ( ) . mkdirs ( ) ; image . compress ( Bitmap . CompressFormat . JPEG , 80 , new FileOutputStream ( file ) ) ; MediaScannerConnection . scanFile ( getContext ( ) , new String [] { file . toString ( ) } , null , new MediaScannerConnection . OnScanCompletedListener ( ) { @ Override public void onScanCompleted ( final String path , final Uri uri ) { if ( mListener != null ) { mHandler . post ( new Runnable ( ) { @ Override public void run ( ) { mListener . onPictureSaved ( uri ) ; } } ) ; } } } ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } }
@ Override public void onScanCompleted ( final String path , final Uri uri ) { if ( mListener != null ) { mHandler . post ( new Runnable ( ) { @ Override public void run ( ) { mListener . onPictureSaved ( uri ) ; } } ) ; } }
@ Override public void run ( ) { mListener . onPictureSaved ( uri ) ; }
void onPictureSaved ( Uri uri );
public static void animateMarkerTo ( final Marker marker , final LatLng finalPosition ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . ICE_CREAM_SANDWICH ) { animateMarkerToICS ( marker , finalPosition ) ; } else if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . HONEYCOMB_MR1 ) { animateMarkerToHC ( marker , finalPosition ) ; } else { animateMarkerToGB ( marker , finalPosition ) ; } }
private static void animateMarkerToGB ( final Marker marker , final LatLng finalPosition ) { final LatLngInterpolator latLngInterpolator = new LatLngInterpolator . Linear ( ) ; final LatLng startPosition = marker . getPosition ( ) ; final Handler handler = new Handler ( ) ; final long start = SystemClock . uptimeMillis ( ) ; final Interpolator interpolator = new AccelerateDecelerateInterpolator ( ) ; final float durationInMs = 3000 ; handler . post ( new Runnable ( ) { long elapsed ; float t ; float v ; @ Override public void run ( ) { elapsed = SystemClock . uptimeMillis ( ) - start ; t = elapsed / durationInMs ; v = interpolator . getInterpolation ( t ) ; marker . setPosition ( latLngInterpolator . interpolate ( v , startPosition , finalPosition ) ) ; if ( t < 1 ) { handler . postDelayed ( this , 16 ) ; } } } ) ; }
@ Override public void run ( ) { elapsed = SystemClock . uptimeMillis ( ) - start ; t = elapsed / durationInMs ; v = interpolator . getInterpolation ( t ) ; marker . setPosition ( latLngInterpolator . interpolate ( v , startPosition , finalPosition ) ) ; if ( t < 1 ) { handler . postDelayed ( this , 16 ) ; } }
@ TargetApi ( Build . VERSION_CODES . HONEYCOMB_MR1 ) private static void animateMarkerToHC ( final Marker marker , final LatLng finalPosition ) { final LatLngInterpolator latLngInterpolator = new LatLngInterpolator . Linear ( ) ; final LatLng startPosition = marker . getPosition ( ) ; ValueAnimator valueAnimator = new ValueAnimator ( ) ; valueAnimator . addUpdateListener ( new ValueAnimator . AnimatorUpdateListener ( ) { @ Override public void onAnimationUpdate ( ValueAnimator animation ) { float v = animation . getAnimatedFraction ( ) ; LatLng newPosition = latLngInterpolator . interpolate ( v , startPosition , finalPosition ) ; marker . setPosition ( newPosition ) ; } } ) ; valueAnimator . setFloatValues ( 0 , 1 ) ; valueAnimator . setDuration ( 3000 ) ; valueAnimator . start ( ) ; }
@ Override public void onAnimationUpdate ( ValueAnimator animation ) { float v = animation . getAnimatedFraction ( ) ; LatLng newPosition = latLngInterpolator . interpolate ( v , startPosition , finalPosition ) ; marker . setPosition ( newPosition ) ; }
@ TargetApi ( Build . VERSION_CODES . ICE_CREAM_SANDWICH ) private static void animateMarkerToICS ( Marker marker , LatLng finalPosition ) { final LatLngInterpolator latLngInterpolator = new LatLngInterpolator . Linear ( ) ; TypeEvaluator < LatLng > typeEvaluator = new TypeEvaluator < LatLng > ( ) { @ Override public LatLng evaluate ( float fraction , LatLng startValue , LatLng endValue ) { return latLngInterpolator . interpolate ( fraction , startValue , endValue ) ; } } ; Property < Marker , LatLng > property = Property . of ( Marker .class , LatLng .class , "position" ) ; ObjectAnimator animator = ObjectAnimator . ofObject ( marker , property , typeEvaluator , finalPosition ) ; animator . setDuration ( 3000 ) ; animator . start ( ) ; }
@ Override public LatLng evaluate ( float fraction , LatLng startValue , LatLng endValue ) { return latLngInterpolator . interpolate ( fraction , startValue , endValue ) ; }
LatLng interpolate ( float fraction , LatLng a , LatLng b );
@ Override public LatLng interpolate ( float fraction , LatLng a , LatLng b ) { double lat = ( b . latitude - a . latitude ) * fraction + a . latitude ; double lngDelta = b . longitude - a . longitude ; if ( Math . abs ( lngDelta ) > 180 ) { lngDelta -= Math . signum ( lngDelta ) * 360 ; } double lng = lngDelta * fraction + a . longitude ; return new LatLng ( lat , lng ) ; }
private Data ( ) { references = ObaReferencesElement . EMPTY_OBJECT ; list = ObaRouteElement . EMPTY_ARRAY ; outOfRange = false ; limitExceeded = false ; }
private ObaRoutesForLocationResponse ( ) { data = Data . EMPTY_OBJECT ; }
public ObaRoute [] getRoutesForLocation ( ) { if ( data != null ) { if ( data . list != null ) { return data . list ; } } return new ObaRouteElement [] {} ; }
public boolean getOutOfRange ( ) { return data . outOfRange ; }
public boolean getLimitExceeded ( ) { return data . limitExceeded ; }
@ Override protected ObaReferences getRefs ( ) { return data . references ; }
protected void showProgress ( boolean showProgress ) { if( getActivity ( ) == null ) { return; } if( Build . VERSION . SDK_INT >= Build . VERSION_CODES . LOLLIPOP ) { ObjectAnimator fadeIn = ( ObjectAnimator ) AnimatorInflater . loadAnimator ( getActivity ( ) , R . animator . fadein ) ; ObjectAnimator fadeOut = ( ObjectAnimator ) AnimatorInflater . loadAnimator ( getActivity ( ) , R . animator . fadeout ) ; if ( showProgress ) { FadeListener fadeInListener = new FadeListener ( mContainer , mProgressBar ) ; fadeIn . addListener ( fadeInListener ) ; fadeIn . start ( ) ; } else { FadeListener fadeOutListener = new FadeListener ( mProgressBar , mContainer ) ; fadeOut . addListener ( fadeOutListener ) ; fadeOut . start ( ) ; } } else { mProgressBar . setVisibility ( showProgress ? View . VISIBLE : View . GONE ) ; mContainer . setVisibility ( showProgress ? View . GONE : View . VISIBLE ) ; } }
FadeListener ( View fromView , View toView ) { mFromView = fromView ; mToView = toView ; }
@ Override public void onAnimationStart ( Animator animation ) {        }
@ Override public void onAnimationEnd ( Animator animation ) { mFromView . setVisibility ( View . GONE ) ; mToView . setVisibility ( View . VISIBLE ) ; }
@ Override public void onAnimationCancel ( Animator animation ) {        }
@ Override public void onAnimationRepeat ( Animator animation ) {        }
public ArrivalsListAdapterStyleA ( Context context ) { super( context , R . layout . arrivals_list_item ); }
public void setData ( ObaArrivalInfo [] arrivals , ArrayList < String > routesFilter , long currentTime ) { if ( arrivals != null ) { ArrayList < ArrivalInfo > list = ArrivalInfoUtils . convertObaArrivalInfo ( getContext ( ) , arrivals , routesFilter , currentTime , false ) ; setData ( list ) ; } else { setData ( null ) ; } }
@ Override protected void initView ( View view , ArrivalInfo stopInfo ) { final Context context = getContext ( ) ; final ObaArrivalInfo arrivalInfo = stopInfo . getInfo ( ) ; TextView route = ( TextView ) view . findViewById ( R . id . route ) ; TextView destination = ( TextView ) view . findViewById ( R . id . destination ) ; TextView time = ( TextView ) view . findViewById ( R . id . time ) ; TextView status = ( TextView ) view . findViewById ( R . id . status ) ; TextView etaView = ( TextView ) view . findViewById ( R . id . eta ) ; TextView minView = ( TextView ) view . findViewById ( R . id . eta_min ) ; ViewGroup realtimeView = ( ViewGroup ) view . findViewById ( R . id . eta_realtime_indicator ) ; ImageView moreView = ( ImageView ) view . findViewById ( R . id . more_horizontal ) ; moreView . setColorFilter ( context . getResources ( ) . getColor ( R . color . switch_thumb_normal_material_dark ) ) ; ImageView starView = ( ImageView ) view . findViewById ( R . id . route_favorite ) ; starView . setColorFilter ( context . getResources ( ) . getColor ( R . color . navdrawer_icon_tint ) ) ; starView . setImageResource ( stopInfo . isRouteAndHeadsignFavorite ( ) ? R . drawable . focus_star_on : R . drawable . focus_star_off ) ; String shortName = arrivalInfo . getShortName ( ) ; route . setText ( shortName ) ; UIUtils . maybeShrinkRouteName ( getContext ( ) , route , shortName ) ; destination . setText ( UIUtils . formatDisplayText ( arrivalInfo . getHeadsign ( ) ) ) ; status . setText ( stopInfo . getStatusText ( ) ) ; long eta = stopInfo . getEta ( ) ; if ( eta == 0 ) { etaView . setText ( R . string . stop_info_eta_now ) ; minView . setVisibility ( View . GONE ) ; } else { etaView . setText ( String . valueOf ( eta ) ) ; minView . setVisibility ( View . VISIBLE ) ; } status . setBackgroundResource ( R . drawable . round_corners_style_b_status ) ; GradientDrawable d = ( GradientDrawable ) status . getBackground ( ) ; Integer colorCode = stopInfo . getColor ( ) ; int color = context . getResources ( ) . getColor ( colorCode ) ; if ( stopInfo . getPredicted ( ) ) { UIUtils . setRealtimeIndicatorColorByResourceCode ( realtimeView , colorCode , android . R . color . transparent ) ; realtimeView . setVisibility ( View . VISIBLE ) ; } else { realtimeView . setVisibility ( View . INVISIBLE ) ; } etaView . setTextColor ( color ) ; minView . setTextColor ( color ) ; d . setColor ( color ) ; int pSides = UIUtils . dpToPixels ( context , 5 ) ; int pTopBottom = UIUtils . dpToPixels ( context , 2 ) ; status . setPadding ( pSides , pTopBottom , pSides , pTopBottom ) ; time . setText ( stopInfo . getTimeText ( ) ) ; ContentValues values = null ; if ( mTripsForStop != null ) { values = mTripsForStop . getValues ( arrivalInfo . getTripId ( ) ) ; } if ( values != null ) { String reminderName = values . getAsString ( ObaContract . Trips . NAME ) ; TextView reminder = ( TextView ) view . findViewById ( R . id . reminder ) ; if ( reminderName . length ( ) == 0 ) { reminderName = context . getString ( R . string . trip_info_noname ) ; } reminder . setText ( reminderName ) ; Drawable d2 = reminder . getCompoundDrawables ( ) [ 0 ] ; d2 = DrawableCompat . wrap ( d2 ) ; DrawableCompat . setTint ( d2 . mutate ( ) , view . getResources ( ) . getColor ( R . color . button_material_dark ) ) ; reminder . setCompoundDrawables ( d2 , null , null , null ) ; reminder . setVisibility ( View . VISIBLE ) ; } else { View reminder = view . findViewById ( R . id . reminder ) ; reminder . setVisibility ( View . GONE ) ; } }
public DividerItemDecoration ( Context context , int orientation ) { final TypedArray a = context . obtainStyledAttributes ( ATTRS ) ; mDivider = a . getDrawable ( 0 ) ; a . recycle ( ) ; setOrientation ( orientation ) ; }
public void setOrientation ( int orientation ) { if ( orientation != HORIZONTAL_LIST && orientation != VERTICAL_LIST ) { throw new IllegalArgumentException ( "invalid orientation" ) ; } mOrientation = orientation ; }
@ Override public void onDraw ( Canvas c , RecyclerView parent , RecyclerView . State state ) { if ( mOrientation == VERTICAL_LIST ) { drawVertical ( c , parent ) ; } else { drawHorizontal ( c , parent ) ; } }
public void drawVertical ( Canvas c , RecyclerView parent ) { final int left = parent . getPaddingLeft ( ) ; final int right = parent . getWidth ( ) - parent . getPaddingRight ( ) ; final int childCount = parent . getChildCount ( ) ; for ( int i = 0 ; i < childCount ; i ++ ) { final View child = parent . getChildAt ( i ) ; final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) child . getLayoutParams ( ) ; final int top = child . getBottom ( ) + params . bottomMargin ; final int bottom = top + mDivider . getIntrinsicHeight ( ) ; mDivider . setBounds ( left , top , right , bottom ) ; mDivider . draw ( c ) ; } }
public void drawHorizontal ( Canvas c , RecyclerView parent ) { final int top = parent . getPaddingTop ( ) ; final int bottom = parent . getHeight ( ) - parent . getPaddingBottom ( ) ; final int childCount = parent . getChildCount ( ) ; for ( int i = 0 ; i < childCount ; i ++ ) { final View child = parent . getChildAt ( i ) ; final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) child . getLayoutParams ( ) ; final int left = child . getRight ( ) + params . rightMargin ; final int right = left + mDivider . getIntrinsicHeight ( ) ; mDivider . setBounds ( left , top , right , bottom ) ; mDivider . draw ( c ) ; } }
@ Override public void getItemOffsets ( Rect outRect , View view , RecyclerView parent , RecyclerView . State state ) { if ( mOrientation == VERTICAL_LIST ) { outRect . set ( 0 , 0 , 0 , mDivider . getIntrinsicHeight ( ) ) ; } else { outRect . set ( 0 , 0 , mDivider . getIntrinsicWidth ( ) , 0 ) ; } }
public AbstractSlideExpandableListAdapter ( ListAdapter wrapped ) { super( wrapped ); }
@ Override public View getView ( int position , View view , ViewGroup viewGroup ) { view = wrapped . getView ( position , view , viewGroup ) ; enableFor ( view , position ) ; return view ; }
public abstract View getExpandToggleButton ( View parent );
public abstract View getExpandableView ( View parent );
public int getAnimationDuration ( ) { return animationDuration ; }
public void setAnimationDuration ( int duration ) { if( duration < 0 ) { throw new IllegalArgumentException ( "Duration is less than zero" ) ; } animationDuration = duration ; }
public boolean isAnyItemExpanded ( ) { return ( lastOpenPosition != - 1 ) ? true : false ; }
public void enableFor ( View parent , int position ) { View more = getExpandToggleButton ( parent ) ; View itemToolbar = getExpandableView ( parent ) ; itemToolbar . measure ( parent . getWidth ( ) , parent . getHeight ( ) ) ; enableFor ( more , itemToolbar , position ) ; itemToolbar . requestLayout ( ) ; }
private void enableFor ( final View button , final View target , final int position ) { if( target == lastOpen && position != lastOpenPosition ) { lastOpen = null ; } if( position == lastOpenPosition ) { lastOpen = target ; } int height = viewHeights . get ( position , - 1 ) ; if( height == - 1 ) { viewHeights . put ( position , target . getMeasuredHeight ( ) ) ; updateExpandable ( target , position ) ; } else { updateExpandable ( target , position ) ; } button . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( final View view ) { Animation a = target . getAnimation ( ) ; if ( a != null && a . hasStarted ( ) && ! a . hasEnded ( ) ) { a . setAnimationListener ( new Animation . AnimationListener ( ) { @ Override public void onAnimationStart ( Animation animation ) {						} @ Override public void onAnimationEnd ( Animation animation ) { view . performClick ( ) ; } @ Override public void onAnimationRepeat ( Animation animation ) {						} } ) ; } else { target . setAnimation ( null ) ; int type = target . getVisibility ( ) == View . VISIBLE ? ExpandCollapseAnimation . COLLAPSE : ExpandCollapseAnimation . EXPAND ; if ( type == ExpandCollapseAnimation . EXPAND ) { openItems . set ( position , true ) ; } else { openItems . set ( position , false ) ; } if ( type == ExpandCollapseAnimation . EXPAND ) { if ( lastOpenPosition != - 1 && lastOpenPosition != position ) { if ( lastOpen != null ) { animateView ( lastOpen , ExpandCollapseAnimation . COLLAPSE ) ; } openItems . set ( lastOpenPosition , false ) ; } lastOpen = target ; lastOpenPosition = position ; } else if ( lastOpenPosition == position ) { lastOpenPosition = - 1 ; } animateView ( target , type ) ; } } } ) ; }
@ Override public void onClick ( final View view ) { Animation a = target . getAnimation ( ) ; if ( a != null && a . hasStarted ( ) && ! a . hasEnded ( ) ) { a . setAnimationListener ( new Animation . AnimationListener ( ) { @ Override public void onAnimationStart ( Animation animation ) {						} @ Override public void onAnimationEnd ( Animation animation ) { view . performClick ( ) ; } @ Override public void onAnimationRepeat ( Animation animation ) {						} } ) ; } else { target . setAnimation ( null ) ; int type = target . getVisibility ( ) == View . VISIBLE ? ExpandCollapseAnimation . COLLAPSE : ExpandCollapseAnimation . EXPAND ; if ( type == ExpandCollapseAnimation . EXPAND ) { openItems . set ( position , true ) ; } else { openItems . set ( position , false ) ; } if ( type == ExpandCollapseAnimation . EXPAND ) { if ( lastOpenPosition != - 1 && lastOpenPosition != position ) { if ( lastOpen != null ) { animateView ( lastOpen , ExpandCollapseAnimation . COLLAPSE ) ; } openItems . set ( lastOpenPosition , false ) ; } lastOpen = target ; lastOpenPosition = position ; } else if ( lastOpenPosition == position ) { lastOpenPosition = - 1 ; } animateView ( target , type ) ; } }
@ Override public void onAnimationStart ( Animation animation ) {						}
@ Override public void onAnimationEnd ( Animation animation ) { view . performClick ( ) ; }
@ Override public void onAnimationRepeat ( Animation animation ) {						}
private void updateExpandable ( View target , int position ) { final LinearLayout . LayoutParams params = ( LinearLayout . LayoutParams ) target . getLayoutParams ( ) ; if( openItems . get ( position ) ) { target . setVisibility ( View . VISIBLE ) ; params . bottomMargin = 0 ; } else { target . setVisibility ( View . GONE ) ; params . bottomMargin = 0 - viewHeights . get ( position ) ; } }
private void animateView ( final View target , final int type ) { Animation anim = new ExpandCollapseAnimation ( target , type ) ; anim . setDuration ( getAnimationDuration ( ) ) ; target . startAnimation ( anim ) ; }
public boolean collapseLastOpen ( ) { if( isAnyItemExpanded ( ) ) { if( lastOpen != null ) { animateView ( lastOpen , ExpandCollapseAnimation . COLLAPSE ) ; } openItems . set ( lastOpenPosition , false ) ; lastOpenPosition = - 1 ; return true ; } return false ; }
public Parcelable onSaveInstanceState ( Parcelable parcelable ) { SavedState ss = new SavedState ( parcelable ) ; ss . lastOpenPosition = this . lastOpenPosition ; ss . openItems = this . openItems ; return ss ; }
public void onRestoreInstanceState ( SavedState state ) { this . lastOpenPosition = state . lastOpenPosition ; this . openItems = state . openItems ; }
private static BitSet readBitSet ( Parcel src ) { int cardinality = src . readInt ( ) ; BitSet set = new BitSet ( ) ; for ( int i = 0 ; i < cardinality ; i ++ ) { set . set ( src . readInt ( ) ) ; } return set ; }
private static void writeBitSet ( Parcel dest , BitSet set ) { int nextSetBit = - 1 ; dest . writeInt ( set . cardinality ( ) ) ; while ( ( nextSetBit = set . nextSetBit ( nextSetBit + 1 ) ) != - 1 ) { dest . writeInt ( nextSetBit ) ; } }
SavedState ( Parcelable superState ) { super( superState ); }
private SavedState ( Parcel in ) { super( in ); in . writeInt ( lastOpenPosition ) ; writeBitSet ( in , openItems ) ; }
@ Override public void writeToParcel ( Parcel out , int flags ) { super. writeToParcel ( out , flags ) ; lastOpenPosition = out . readInt ( ) ; openItems = readBitSet ( out ) ; }
public SavedState createFromParcel ( Parcel in ) { return new SavedState ( in ) ; }
public SavedState [] newArray ( int size ) { return new SavedState [ size ] ; }
public ScalaSampleIT ( MavenRuntimeBuilder builder ) throws Exception { this . mavenRuntime = builder . build ( ) ; }
@ Test public void buildDeployAndRun ( ) Exception { File basedir = resources . getBasedir ( "scala" ) ; MavenExecutionResult result = mavenRuntime . forProject ( basedir ) . execute ( "clean" , PluginInfo . getQualifiedGoal ( "undeploy" ) , "install" , PluginInfo . getQualifiedGoal ( "deploy" ) , PluginInfo . getQualifiedGoal ( "run" ) ) ; result . assertErrorFreeLog ( ) ; result . assertLogText ( "Successfully installed" ) ; }
public OpenHelper ( Context context ) { super( context , DATABASE_NAME , null , DATABASE_VERSION ); }
@ Override public void onCreate ( SQLiteDatabase db ) { bootstrapDatabase ( db ) ; onUpgrade ( db , 12 , DATABASE_VERSION ) ; }
@ Override public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { Log . d ( TAG , "Upgrading database from version " + oldVersion + " to " + newVersion ) ; if ( oldVersion < 12 ) { dropTables ( db ) ; bootstrapDatabase ( db ) ; oldVersion = 12 ; } if ( oldVersion == 12 ) { db . execSQL ( "CREATE TABLE " + ObaContract . StopRouteFilters . PATH + " (" + ObaContract . StopRouteFilters . STOP_ID + " VARCHAR NOT NULL, " + ObaContract . StopRouteFilters . ROUTE_ID + " VARCHAR NOT NULL" + ");" ) ; ++ oldVersion ; } if ( oldVersion == 13 ) { db . execSQL ( "ALTER TABLE " + ObaContract . Stops . PATH + " ADD COLUMN " + ObaContract . Stops . USER_NAME ) ; db . execSQL ( "ALTER TABLE " + ObaContract . Stops . PATH + " ADD COLUMN " + ObaContract . Stops . ACCESS_TIME ) ; db . execSQL ( "ALTER TABLE " + ObaContract . Stops . PATH + " ADD COLUMN " + ObaContract . Stops . FAVORITE ) ; db . execSQL ( "ALTER TABLE " + ObaContract . Routes . PATH + " ADD COLUMN " + ObaContract . Routes . USER_NAME ) ; db . execSQL ( "ALTER TABLE " + ObaContract . Routes . PATH + " ADD COLUMN " + ObaContract . Routes . ACCESS_TIME ) ; db . execSQL ( "ALTER TABLE " + ObaContract . Routes . PATH + " ADD COLUMN " + ObaContract . Routes . FAVORITE ) ; ++ oldVersion ; } if ( oldVersion == 14 ) { db . execSQL ( "ALTER TABLE " + ObaContract . Routes . PATH + " ADD COLUMN " + ObaContract . Routes . URL ) ; ++ oldVersion ; } if ( oldVersion == 15 ) { db . execSQL ( "CREATE TABLE " + ObaContract . TripAlerts . PATH + " (" + ObaContract . TripAlerts . _ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " + ObaContract . TripAlerts . TRIP_ID + " VARCHAR NOT NULL, " + ObaContract . TripAlerts . STOP_ID + " VARCHAR NOT NULL, " + ObaContract . TripAlerts . START_TIME + " INTEGER NOT NULL, " + ObaContract . TripAlerts . STATE + " INTEGER NOT NULL DEFAULT " + ObaContract . TripAlerts . STATE_SCHEDULED + ");" ) ; db . execSQL ( "DROP TRIGGER IF EXISTS trip_alerts_cleanup" ) ; db . execSQL ( "CREATE TRIGGER trip_alerts_cleanup DELETE ON " + ObaContract . Trips . PATH + " BEGIN " + "DELETE FROM " + ObaContract . TripAlerts . PATH + " WHERE " + ObaContract . TripAlerts . TRIP_ID + " = old." + ObaContract . Trips . _ID + " AND " + ObaContract . TripAlerts . STOP_ID + " = old." + ObaContract . Trips . STOP_ID + ";" + "END" ) ; ++ oldVersion ; } if ( oldVersion == 16 ) { db . execSQL ( "CREATE TABLE " + ObaContract . ServiceAlerts . PATH + " (" + ObaContract . ServiceAlerts . _ID + " VARCHAR PRIMARY KEY, " + ObaContract . ServiceAlerts . MARKED_READ_TIME + " INTEGER " + ");" ) ; ++ oldVersion ; } if ( oldVersion == 17 ) { db . execSQL ( "CREATE TABLE " + ObaContract . Regions . PATH + " (" + ObaContract . Regions . _ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " + ObaContract . Regions . NAME + " VARCHAR NOT NULL, " + ObaContract . Regions . OBA_BASE_URL + " VARCHAR NOT NULL, " + ObaContract . Regions . SIRI_BASE_URL + " VARCHAR NOT NULL, " + ObaContract . Regions . LANGUAGE + " VARCHAR NOT NULL, " + ObaContract . Regions . CONTACT_EMAIL + " VARCHAR NOT NULL, " + ObaContract . Regions . SUPPORTS_OBA_DISCOVERY + " INTEGER NOT NULL, " + ObaContract . Regions . SUPPORTS_OBA_REALTIME + " INTEGER NOT NULL, " + ObaContract . Regions . SUPPORTS_SIRI_REALTIME + " INTEGER NOT NULL " + ");" ) ; db . execSQL ( "CREATE TABLE " + ObaContract . RegionBounds . PATH + " (" + ObaContract . RegionBounds . _ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " + ObaContract . RegionBounds . REGION_ID + " INTEGER NOT NULL, " + ObaContract . RegionBounds . LATITUDE + " REAL NOT NULL, " + ObaContract . RegionBounds . LONGITUDE + " REAL NOT NULL, " + ObaContract . RegionBounds . LAT_SPAN + " REAL NOT NULL, " + ObaContract . RegionBounds . LON_SPAN + " REAL NOT NULL " + ");" ) ; db . execSQL ( "DROP TRIGGER IF EXISTS region_bounds_cleanup" ) ; db . execSQL ( "CREATE TRIGGER region_bounds_cleanup DELETE ON " + ObaContract . Regions . PATH + " BEGIN " + "DELETE FROM " + ObaContract . RegionBounds . PATH + " WHERE " + ObaContract . RegionBounds . REGION_ID + " = old." + ObaContract . Regions . _ID + ";" + "END" ) ; db . execSQL ( "ALTER TABLE " + ObaContract . Stops . PATH + " ADD COLUMN " + ObaContract . Stops . REGION_ID + " INTEGER" ) ; db . execSQL ( "ALTER TABLE " + ObaContract . Routes . PATH + " ADD COLUMN " + ObaContract . Routes . REGION_ID + " INTEGER" ) ; ++ oldVersion ; } if ( oldVersion == 18 ) { db . execSQL ( "ALTER TABLE " + ObaContract . Regions . PATH + " ADD COLUMN " + ObaContract . Regions . TWITTER_URL + " VARCHAR" ) ; ++ oldVersion ; } if ( oldVersion == 19 ) { db . execSQL ( "ALTER TABLE " + ObaContract . Regions . PATH + " ADD COLUMN " + ObaContract . Regions . EXPERIMENTAL + " INTEGER" ) ; ++ oldVersion ; } if ( oldVersion == 20 ) { db . execSQL ( "ALTER TABLE " + ObaContract . Regions . PATH + " ADD COLUMN " + ObaContract . Regions . STOP_INFO_URL + " VARCHAR" ) ; ++ oldVersion ; } if ( oldVersion == 21 ) { db . execSQL ( "CREATE TABLE " + ObaContract . RouteHeadsignFavorites . PATH + " (" + ObaContract . RouteHeadsignFavorites . ROUTE_ID + " VARCHAR NOT NULL, " + ObaContract . RouteHeadsignFavorites . HEADSIGN + " VARCHAR NOT NULL, " + ObaContract . RouteHeadsignFavorites . STOP_ID + " VARCHAR NOT NULL, " + ObaContract . RouteHeadsignFavorites . EXCLUDE + " INTEGER NOT NULL " + ");" ) ; ++ oldVersion ; } if ( oldVersion == 22 ) { db . execSQL ( "CREATE TABLE " + ObaContract . RegionOpen311Servers . PATH + " (" + ObaContract . RegionOpen311Servers . _ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " + ObaContract . RegionOpen311Servers . REGION_ID + " INTEGER NOT NULL, " + ObaContract . RegionOpen311Servers . JURISDICTION + " VARCHAR, " + ObaContract . RegionOpen311Servers . API_KEY + " VARCHAR NOT NULL, " + ObaContract . RegionOpen311Servers . BASE_URL + " VARCHAR NOT NULL " + ");" ) ; ++ oldVersion ; } if ( oldVersion == 23 ) { db . execSQL ( "ALTER TABLE " + ObaContract . Regions . PATH + " ADD COLUMN " + ObaContract . Regions . OTP_BASE_URL + " VARCHAR" ) ; db . execSQL ( "ALTER TABLE " + ObaContract . Regions . PATH + " ADD COLUMN " + ObaContract . Regions . OTP_CONTACT_EMAIL + " VARCHAR" ) ; ++ oldVersion ; } if ( oldVersion == 24 ) { db . execSQL ( "ALTER TABLE " + ObaContract . ServiceAlerts . PATH + " ADD COLUMN " + ObaContract . ServiceAlerts . HIDDEN + " INTEGER" ) ; } }
@ Override public void onDowngrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { Log . d ( TAG , "Downgrading database from version " + oldVersion + " to " + newVersion ) ; onUpgrade ( db , newVersion , newVersion ) ; }
private void bootstrapDatabase ( SQLiteDatabase db ) { db . execSQL ( "CREATE TABLE " + ObaContract . Stops . PATH + " (" + ObaContract . Stops . _ID + " VARCHAR PRIMARY KEY, " + ObaContract . Stops . CODE + " VARCHAR NOT NULL, " + ObaContract . Stops . NAME + " VARCHAR NOT NULL, " + ObaContract . Stops . DIRECTION + " CHAR[2] NOT NULL," + ObaContract . Stops . USE_COUNT + " INTEGER NOT NULL," + ObaContract . Stops . LATITUDE + " DOUBLE NOT NULL," + ObaContract . Stops . LONGITUDE + " DOUBLE NOT NULL" + ");" ) ; db . execSQL ( "CREATE TABLE " + ObaContract . Routes . PATH + " (" + ObaContract . Routes . _ID + " VARCHAR PRIMARY KEY, " + ObaContract . Routes . SHORTNAME + " VARCHAR NOT NULL, " + ObaContract . Routes . LONGNAME + " VARCHAR, " + ObaContract . Routes . USE_COUNT + " INTEGER NOT NULL" + ");" ) ; db . execSQL ( "CREATE TABLE " + ObaContract . Trips . PATH + " (" + ObaContract . Trips . _ID + " VARCHAR NOT NULL, " + ObaContract . Trips . STOP_ID + " VARCHAR NOT NULL, " + ObaContract . Trips . ROUTE_ID + " VARCHAR NOT NULL, " + ObaContract . Trips . DEPARTURE + " INTEGER NOT NULL, " + ObaContract . Trips . HEADSIGN + " VARCHAR NOT NULL, " + ObaContract . Trips . NAME + " VARCHAR NOT NULL, " + ObaContract . Trips . REMINDER + " INTEGER NOT NULL, " + ObaContract . Trips . DAYS + " INTEGER NOT NULL" + ");" ) ; }
private void dropTables ( SQLiteDatabase db ) { db . execSQL ( "DROP TABLE IF EXISTS " + ObaContract . StopRouteFilters . PATH ) ; db . execSQL ( "DROP TABLE IF EXISTS " + ObaContract . Routes . PATH ) ; db . execSQL ( "DROP TABLE IF EXISTS " + ObaContract . Stops . PATH ) ; db . execSQL ( "DROP TABLE IF EXISTS " + ObaContract . Trips . PATH ) ; db . execSQL ( "DROP TABLE IF EXISTS " + ObaContract . TripAlerts . PATH ) ; db . execSQL ( "DROP TABLE IF EXISTS " + ObaContract . ServiceAlerts . PATH ) ; db . execSQL ( "DROP TABLE IF EXISTS " + ObaContract . Regions . PATH ) ; db . execSQL ( "DROP TABLE IF EXISTS " + ObaContract . RegionBounds . PATH ) ; db . execSQL ( "DROP TABLE IF EXISTS " + ObaContract . RegionOpen311Servers . PATH ) ; db . execSQL ( "DROP TABLE IF EXISTS " + ObaContract . RouteHeadsignFavorites . PATH ) ; }
public static File getDatabasePath ( Context context ) { return context . getDatabasePath ( DATABASE_NAME ) ; }
@ Override public boolean onCreate ( ) { mOpenHelper = new OpenHelper ( getContext ( ) ) ; return true ; }
@ Override public String getType ( Uri uri ) { int match = sUriMatcher . match ( uri ) ; switch ( match ) { case STOPS : return ObaContract . Stops . CONTENT_DIR_TYPE ; case STOPS_ID : return ObaContract . Stops . CONTENT_TYPE ; case ROUTES : return ObaContract . Routes . CONTENT_DIR_TYPE ; case ROUTES_ID : return ObaContract . Routes . CONTENT_TYPE ; case TRIPS : return ObaContract . Trips . CONTENT_DIR_TYPE ; case TRIPS_ID : return ObaContract . Trips . CONTENT_TYPE ; case TRIP_ALERTS : return ObaContract . TripAlerts . CONTENT_DIR_TYPE ; case TRIP_ALERTS_ID : return ObaContract . TripAlerts . CONTENT_TYPE ; case STOP_ROUTE_FILTERS : return ObaContract . StopRouteFilters . CONTENT_DIR_TYPE ; case SERVICE_ALERTS : return ObaContract . ServiceAlerts . CONTENT_DIR_TYPE ; case SERVICE_ALERTS_ID : return ObaContract . ServiceAlerts . CONTENT_TYPE ; case REGIONS : return ObaContract . Regions . CONTENT_DIR_TYPE ; case REGIONS_ID : return ObaContract . Regions . CONTENT_TYPE ; case REGION_BOUNDS : return ObaContract . RegionBounds . CONTENT_DIR_TYPE ; case REGION_BOUNDS_ID : return ObaContract . RegionBounds . CONTENT_TYPE ; case REGION_OPEN311_SERVERS : return ObaContract . RegionOpen311Servers . CONTENT_DIR_TYPE ; case REGION_OPEN311_SERVERS_ID : return ObaContract . RegionOpen311Servers . CONTENT_TYPE ; case ROUTE_HEADSIGN_FAVORITES : return ObaContract . RouteHeadsignFavorites . CONTENT_DIR_TYPE ; default: throw new IllegalArgumentException ( "Unknown URI: " + uri ) ; } }
@ Override public Uri insert ( Uri uri , ContentValues values ) { final SQLiteDatabase db = getDatabase ( ) ; db . beginTransaction ( ) ; try { Uri result = insertInternal ( db , uri , values ) ; getContext ( ) . getContentResolver ( ) . notifyChange ( uri , null ) ; db . setTransactionSuccessful ( ) ; return result ; } finally { db . endTransaction ( ) ; } }
@ Override public Cursor query ( Uri uri , String [] projection , String selection , String [] selectionArgs , String sortOrder ) { final SQLiteDatabase db = getDatabase ( ) ; return queryInternal ( db , uri , projection , selection , selectionArgs , sortOrder ) ; }
@ Override public int update ( Uri uri , ContentValues values , String selection , String [] selectionArgs ) { final SQLiteDatabase db = getDatabase ( ) ; db . beginTransaction ( ) ; try { int result = updateInternal ( db , uri , values , selection , selectionArgs ) ; if ( result > 0 ) { getContext ( ) . getContentResolver ( ) . notifyChange ( uri , null ) ; } db . setTransactionSuccessful ( ) ; return result ; } finally { db . endTransaction ( ) ; } }
@ Override public int delete ( Uri uri , String selection , String [] selectionArgs ) { final SQLiteDatabase db = getDatabase ( ) ; db . beginTransaction ( ) ; try { int result = deleteInternal ( db , uri , selection , selectionArgs ) ; if ( result > 0 ) { getContext ( ) . getContentResolver ( ) . notifyChange ( uri , null ) ; } db . setTransactionSuccessful ( ) ; return result ; } finally { db . endTransaction ( ) ; } }
private Uri insertInternal ( SQLiteDatabase db , Uri uri , ContentValues values ) { final int match = sUriMatcher . match ( uri ) ; String id ; Uri result ; long longId ; switch ( match ) { case STOPS : id = values . getAsString ( ObaContract . Stops . _ID ) ; if ( id == null ) { throw new IllegalArgumentException ( "Need a stop ID to insert! " + uri ) ; } result = Uri . withAppendedPath ( ObaContract . Stops . CONTENT_URI , id ) ; mStopsInserter . insert ( values ) ; return result ; case ROUTES : id = values . getAsString ( ObaContract . Routes . _ID ) ; if ( id == null ) { throw new IllegalArgumentException ( "Need a routes ID to insert! " + uri ) ; } result = Uri . withAppendedPath ( ObaContract . Routes . CONTENT_URI , id ) ; mRoutesInserter . insert ( values ) ; return result ; case TRIPS : id = values . getAsString ( ObaContract . Trips . _ID ) ; if ( id == null ) { throw new IllegalArgumentException ( "Need a trip ID to insert! " + uri ) ; } result = Uri . withAppendedPath ( ObaContract . Trips . CONTENT_URI , id ) ; mTripsInserter . insert ( values ) ; return result ; case TRIP_ALERTS : longId = mTripAlertsInserter . insert ( values ) ; result = ContentUris . withAppendedId ( ObaContract . TripAlerts . CONTENT_URI , longId ) ; return result ; case STOP_ROUTE_FILTERS : id = values . getAsString ( ObaContract . StopRouteFilters . STOP_ID ) ; if ( id == null ) { throw new IllegalArgumentException ( "Need a stop ID to insert! " + uri ) ; } result = Uri . withAppendedPath ( ObaContract . StopRouteFilters . CONTENT_URI , id ) ; mFilterInserter . insert ( values ) ; return result ; case SERVICE_ALERTS : id = values . getAsString ( ObaContract . ServiceAlerts . _ID ) ; if ( id == null ) { throw new IllegalArgumentException ( "Need a situation ID to insert! " + uri ) ; } result = Uri . withAppendedPath ( ObaContract . ServiceAlerts . CONTENT_URI , id ) ; mServiceAlertsInserter . insert ( values ) ; return result ; case REGIONS : longId = mRegionsInserter . insert ( values ) ; result = ContentUris . withAppendedId ( ObaContract . Regions . CONTENT_URI , longId ) ; return result ; case REGION_BOUNDS : longId = mRegionBoundsInserter . insert ( values ) ; result = ContentUris . withAppendedId ( ObaContract . RegionBounds . CONTENT_URI , longId ) ; return result ; case REGION_OPEN311_SERVERS : longId = mRegionOpen311ServersInserter . insert ( values ) ; result = ContentUris . withAppendedId ( ObaContract . RegionOpen311Servers . CONTENT_URI , longId ) ; return result ; case ROUTE_HEADSIGN_FAVORITES : id = values . getAsString ( ObaContract . RouteHeadsignFavorites . ROUTE_ID ) ; if ( id == null ) { throw new IllegalArgumentException ( "Need a route ID to insert! " + uri ) ; } result = Uri . withAppendedPath ( ObaContract . RouteHeadsignFavorites . CONTENT_URI , id ) ; mRouteHeadsignFavoritesInserter . insert ( values ) ; return result ; case STOPS_ID : case ROUTES_ID : case TRIPS_ID : case TRIP_ALERTS_ID : case SERVICE_ALERTS_ID : case REGIONS_ID : case REGION_BOUNDS_ID : throw new UnsupportedOperationException ( "Cannot insert to this URI: " + uri ) ; default: throw new IllegalArgumentException ( "Unknown URI: " + uri ) ; } }
private Cursor queryInternal ( SQLiteDatabase db , Uri uri , String [] projection , String selection , String [] selectionArgs , String sortOrder ) { final int match = sUriMatcher . match ( uri ) ; final String limit = uri . getQueryParameter ( "limit" ) ; SQLiteQueryBuilder qb = new SQLiteQueryBuilder ( ) ; switch ( match ) { case STOPS : qb . setTables ( ObaContract . Stops . PATH ) ; qb . setProjectionMap ( sStopsProjectionMap ) ; return qb . query ( mDb , projection , selection , selectionArgs , null , null , sortOrder , limit ) ; case STOPS_ID : qb . setTables ( ObaContract . Stops . PATH ) ; qb . setProjectionMap ( sStopsProjectionMap ) ; qb . appendWhere ( ObaContract . Stops . _ID ) ; qb . appendWhere ( "=" ) ; qb . appendWhereEscapeString ( uri . getLastPathSegment ( ) ) ; return qb . query ( mDb , projection , selection , selectionArgs , null , null , sortOrder , limit ) ; case ROUTES : qb . setTables ( ObaContract . Routes . PATH ) ; qb . setProjectionMap ( sRoutesProjectionMap ) ; return qb . query ( mDb , projection , selection , selectionArgs , null , null , sortOrder , limit ) ; case ROUTES_ID : qb . setTables ( ObaContract . Routes . PATH ) ; qb . setProjectionMap ( sRoutesProjectionMap ) ; qb . appendWhere ( ObaContract . Routes . _ID ) ; qb . appendWhere ( "=" ) ; qb . appendWhereEscapeString ( uri . getLastPathSegment ( ) ) ; return qb . query ( mDb , projection , selection , selectionArgs , null , null , sortOrder , limit ) ; case TRIPS : qb . setTables ( ObaContract . Trips . PATH ) ; qb . setProjectionMap ( sTripsProjectionMap ) ; return qb . query ( mDb , projection , selection , selectionArgs , null , null , sortOrder , limit ) ; case TRIPS_ID : qb . setTables ( ObaContract . Trips . PATH ) ; qb . setProjectionMap ( sTripsProjectionMap ) ; qb . appendWhere ( tripWhere ( uri ) ) ; return qb . query ( mDb , projection , selection , selectionArgs , null , null , sortOrder , limit ) ; case TRIP_ALERTS : qb . setTables ( ObaContract . TripAlerts . PATH ) ; qb . setProjectionMap ( sTripAlertsProjectionMap ) ; return qb . query ( mDb , projection , selection , selectionArgs , null , null , sortOrder , limit ) ; case TRIP_ALERTS_ID : qb . setTables ( ObaContract . TripAlerts . PATH ) ; qb . setProjectionMap ( sTripAlertsProjectionMap ) ; qb . appendWhere ( ObaContract . TripAlerts . _ID ) ; qb . appendWhere ( "=" ) ; qb . appendWhere ( String . valueOf ( ContentUris . parseId ( uri ) ) ) ; return qb . query ( mDb , projection , selection , selectionArgs , null , null , sortOrder , limit ) ; case STOP_ROUTE_FILTERS : qb . setTables ( ObaContract . StopRouteFilters . PATH ) ; return qb . query ( mDb , projection , selection , selectionArgs , null , null , sortOrder , limit ) ; case SERVICE_ALERTS : qb . setTables ( ObaContract . ServiceAlerts . PATH ) ; qb . setProjectionMap ( sServiceAlertsProjectionMap ) ; return qb . query ( mDb , projection , selection , selectionArgs , null , null , sortOrder , limit ) ; case SERVICE_ALERTS_ID : qb . setTables ( ObaContract . ServiceAlerts . PATH ) ; qb . setProjectionMap ( sServiceAlertsProjectionMap ) ; qb . appendWhere ( ObaContract . ServiceAlerts . _ID ) ; qb . appendWhere ( "=" ) ; qb . appendWhereEscapeString ( uri . getLastPathSegment ( ) ) ; return qb . query ( mDb , projection , selection , selectionArgs , null , null , sortOrder , limit ) ; case REGIONS : qb . setTables ( ObaContract . Regions . PATH ) ; qb . setProjectionMap ( sRegionsProjectionMap ) ; return qb . query ( mDb , projection , selection , selectionArgs , null , null , sortOrder , limit ) ; case REGIONS_ID : qb . setTables ( ObaContract . Regions . PATH ) ; qb . setProjectionMap ( sRegionsProjectionMap ) ; qb . appendWhere ( ObaContract . Regions . _ID ) ; qb . appendWhere ( "=" ) ; qb . appendWhere ( String . valueOf ( ContentUris . parseId ( uri ) ) ) ; return qb . query ( mDb , projection , selection , selectionArgs , null , null , sortOrder , limit ) ; case REGION_BOUNDS : qb . setTables ( ObaContract . RegionBounds . PATH ) ; qb . setProjectionMap ( sRegionBoundsProjectionMap ) ; return qb . query ( mDb , projection , selection , selectionArgs , null , null , sortOrder , limit ) ; case REGION_BOUNDS_ID : qb . setTables ( ObaContract . RegionBounds . PATH ) ; qb . setProjectionMap ( sRegionBoundsProjectionMap ) ; qb . appendWhere ( ObaContract . RegionBounds . _ID ) ; qb . appendWhere ( "=" ) ; qb . appendWhere ( String . valueOf ( ContentUris . parseId ( uri ) ) ) ; return qb . query ( mDb , projection , selection , selectionArgs , null , null , sortOrder , limit ) ; case REGION_OPEN311_SERVERS : qb . setTables ( ObaContract . RegionOpen311Servers . PATH ) ; qb . setProjectionMap ( sRegionOpen311ProjectionMap ) ; return qb . query ( mDb , projection , selection , selectionArgs , null , null , sortOrder , limit ) ; case REGION_OPEN311_SERVERS_ID : qb . setTables ( ObaContract . RegionOpen311Servers . PATH ) ; qb . setProjectionMap ( sRegionOpen311ProjectionMap ) ; qb . appendWhere ( ObaContract . RegionOpen311Servers . _ID ) ; qb . appendWhere ( "=" ) ; qb . appendWhere ( String . valueOf ( ContentUris . parseId ( uri ) ) ) ; return qb . query ( mDb , projection , selection , selectionArgs , null , null , sortOrder , limit ) ; case ROUTE_HEADSIGN_FAVORITES : qb . setTables ( ObaContract . RouteHeadsignFavorites . PATH ) ; return qb . query ( mDb , projection , selection , selectionArgs , null , null , sortOrder , limit ) ; default: throw new IllegalArgumentException ( "Unknown URI: " + uri ) ; } }
private int updateInternal ( SQLiteDatabase db , Uri uri , ContentValues values , String selection , String [] selectionArgs ) { final int match = sUriMatcher . match ( uri ) ; switch ( match ) { case STOPS : return db . update ( ObaContract . Stops . PATH , values , selection , selectionArgs ) ; case STOPS_ID : return db . update ( ObaContract . Stops . PATH , values , where ( ObaContract . Stops . _ID , uri ) , selectionArgs ) ; case ROUTES : return db . update ( ObaContract . Routes . PATH , values , selection , selectionArgs ) ; case ROUTES_ID : return db . update ( ObaContract . Routes . PATH , values , where ( ObaContract . Routes . _ID , uri ) , selectionArgs ) ; case TRIPS : return db . update ( ObaContract . Trips . PATH , values , selection , selectionArgs ) ; case TRIPS_ID : return db . update ( ObaContract . Trips . PATH , values , tripWhere ( uri ) , selectionArgs ) ; case TRIP_ALERTS : return db . update ( ObaContract . TripAlerts . PATH , values , selection , selectionArgs ) ; case TRIP_ALERTS_ID : return db . update ( ObaContract . TripAlerts . PATH , values , whereLong ( ObaContract . TripAlerts . _ID , uri ) , selectionArgs ) ; case STOP_ROUTE_FILTERS : return 0 ; case SERVICE_ALERTS : return db . update ( ObaContract . ServiceAlerts . PATH , values , selection , selectionArgs ) ; case SERVICE_ALERTS_ID : return db . update ( ObaContract . ServiceAlerts . PATH , values , where ( ObaContract . ServiceAlerts . _ID , uri ) , selectionArgs ) ; case REGIONS : return db . update ( ObaContract . Regions . PATH , values , selection , selectionArgs ) ; case REGIONS_ID : return db . update ( ObaContract . Regions . PATH , values , whereLong ( ObaContract . Regions . _ID , uri ) , selectionArgs ) ; case REGION_BOUNDS : return db . update ( ObaContract . RegionBounds . PATH , values , selection , selectionArgs ) ; case REGION_BOUNDS_ID : return db . update ( ObaContract . RegionBounds . PATH , values , whereLong ( ObaContract . RegionBounds . _ID , uri ) , selectionArgs ) ; case REGION_OPEN311_SERVERS : return db . update ( ObaContract . RegionOpen311Servers . PATH , values , selection , selectionArgs ) ; case REGION_OPEN311_SERVERS_ID : return db . update ( ObaContract . RegionOpen311Servers . PATH , values , whereLong ( ObaContract . RegionOpen311Servers . _ID , uri ) , selectionArgs ) ; case ROUTE_HEADSIGN_FAVORITES : return 0 ; default: throw new IllegalArgumentException ( "Unknown URI: " + uri ) ; } }
private int deleteInternal ( SQLiteDatabase db , Uri uri , String selection , String [] selectionArgs ) { final int match = sUriMatcher . match ( uri ) ; switch ( match ) { case STOPS : return db . delete ( ObaContract . Stops . PATH , selection , selectionArgs ) ; case STOPS_ID : return db . delete ( ObaContract . Stops . PATH , where ( ObaContract . Stops . _ID , uri ) , selectionArgs ) ; case ROUTES : return db . delete ( ObaContract . Routes . PATH , selection , selectionArgs ) ; case ROUTES_ID : return db . delete ( ObaContract . Routes . PATH , where ( ObaContract . Routes . _ID , uri ) , selectionArgs ) ; case TRIPS : return db . delete ( ObaContract . Trips . PATH , selection , selectionArgs ) ; case TRIPS_ID : return db . delete ( ObaContract . Trips . PATH , tripWhere ( uri ) , selectionArgs ) ; case TRIP_ALERTS : return db . delete ( ObaContract . TripAlerts . PATH , selection , selectionArgs ) ; case TRIP_ALERTS_ID : return db . delete ( ObaContract . TripAlerts . PATH , whereLong ( ObaContract . TripAlerts . _ID , uri ) , selectionArgs ) ; case STOP_ROUTE_FILTERS : return db . delete ( ObaContract . StopRouteFilters . PATH , selection , selectionArgs ) ; case SERVICE_ALERTS : return db . delete ( ObaContract . ServiceAlerts . PATH , selection , selectionArgs ) ; case SERVICE_ALERTS_ID : return db . delete ( ObaContract . ServiceAlerts . PATH , where ( ObaContract . ServiceAlerts . _ID , uri ) , selectionArgs ) ; case REGIONS : return db . delete ( ObaContract . Regions . PATH , selection , selectionArgs ) ; case REGIONS_ID : return db . delete ( ObaContract . Regions . PATH , whereLong ( ObaContract . Regions . _ID , uri ) , selectionArgs ) ; case REGION_BOUNDS : return db . delete ( ObaContract . RegionBounds . PATH , selection , selectionArgs ) ; case REGION_BOUNDS_ID : return db . delete ( ObaContract . RegionBounds . PATH , whereLong ( ObaContract . RegionBounds . _ID , uri ) , selectionArgs ) ; case REGION_OPEN311_SERVERS : return db . delete ( ObaContract . RegionOpen311Servers . PATH , selection , selectionArgs ) ; case REGION_OPEN311_SERVERS_ID : return db . delete ( ObaContract . RegionOpen311Servers . PATH , whereLong ( ObaContract . RegionOpen311Servers . _ID , uri ) , selectionArgs ) ; case ROUTE_HEADSIGN_FAVORITES : return db . delete ( ObaContract . RouteHeadsignFavorites . PATH , selection , selectionArgs ) ; default: throw new IllegalArgumentException ( "Unknown URI: " + uri ) ; } }
private String where ( String column , Uri uri ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( column ) ; sb . append ( '=' ) ; DatabaseUtils . appendValueToSql ( sb , uri . getLastPathSegment ( ) ) ; return sb . toString ( ) ; }
private String whereLong ( String column , Uri uri ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( column ) ; sb . append ( '=' ) ; sb . append ( String . valueOf ( ContentUris . parseId ( uri ) ) ) ; return sb . toString ( ) ; }
private String tripWhere ( Uri uri ) { List < String > segments = uri . getPathSegments ( ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( "(" ) ; sb . append ( ObaContract . Trips . _ID ) ; sb . append ( "=" ) ; DatabaseUtils . appendValueToSql ( sb , segments . get ( 1 ) ) ; sb . append ( " AND " ) ; sb . append ( ObaContract . Trips . STOP_ID ) ; sb . append ( "=" ) ; DatabaseUtils . appendValueToSql ( sb , segments . get ( 2 ) ) ; sb . append ( ")" ) ; return sb . toString ( ) ; }
private SQLiteDatabase getDatabase ( ) { if ( mDb == null ) { mDb = mOpenHelper . getWritableDatabase ( ) ; mStopsInserter = new DatabaseUtils . InsertHelper ( mDb , ObaContract . Stops . PATH ) ; mRoutesInserter = new DatabaseUtils . InsertHelper ( mDb , ObaContract . Routes . PATH ) ; mTripsInserter = new DatabaseUtils . InsertHelper ( mDb , ObaContract . Trips . PATH ) ; mTripAlertsInserter = new DatabaseUtils . InsertHelper ( mDb , ObaContract . TripAlerts . PATH ) ; mFilterInserter = new DatabaseUtils . InsertHelper ( mDb , ObaContract . StopRouteFilters . PATH ) ; mServiceAlertsInserter = new DatabaseUtils . InsertHelper ( mDb , ObaContract . ServiceAlerts . PATH ) ; mRegionsInserter = new DatabaseUtils . InsertHelper ( mDb , ObaContract . Regions . PATH ) ; mRegionBoundsInserter = new DatabaseUtils . InsertHelper ( mDb , ObaContract . RegionBounds . PATH ) ; mRegionOpen311ServersInserter = new DatabaseUtils . InsertHelper ( mDb , ObaContract . RegionOpen311Servers . PATH ) ; mRouteHeadsignFavoritesInserter = new DatabaseUtils . InsertHelper ( mDb , ObaContract . RouteHeadsignFavorites . PATH ) ; } return mDb ; }
public void closeDB ( ) { mOpenHelper . close ( ) ; mDb = null ; }
StopsRequest ( MapModeController . ObaMapView view ) { mCenter = view . getMapCenterAsLocation ( ) ; mLatSpan = view . getLatitudeSpanInDecDegrees ( ) ; mLonSpan = view . getLongitudeSpanInDecDegrees ( ) ; mZoomLevel = view . getZoomLevelAsFloat ( ) ; }
Location getCenter ( ) { return mCenter ; }
double getLatSpan ( ) { return mLatSpan ; }
double getLonSpan ( ) { return mLonSpan ; }
double getZoomLevel ( ) { return mZoomLevel ; }
StopsResponse ( StopsRequest req , ObaStopsForLocationResponse response ) { mRequest = req ; mResponse = response ; }
StopsRequest getRequest ( ) { return mRequest ; }
ObaStopsForLocationResponse getResponse ( ) { return mResponse ; }
boolean fulfills ( StopsRequest newReq ) { if ( mRequest . getCenter ( ) == null ) { return false ; } if ( ! mRequest . getCenter ( ) . equals ( newReq . getCenter ( ) ) ) { return false ; } if ( mResponse != null ) { if ( ( newReq . getZoomLevel ( ) > mRequest . getZoomLevel ( ) ) && mResponse . getLimitExceeded ( ) ) { return false ; } else if ( newReq . getZoomLevel ( ) < mRequest . getZoomLevel ( ) ) { return false ; } } return true ; }
public StopMapController ( Callback callback ) { mCallback = callback ; GoogleApiAvailability api = GoogleApiAvailability . getInstance ( ) ; if ( api . isGooglePlayServicesAvailable ( mCallback . getActivity ( ) ) == ConnectionResult . SUCCESS ) { Context context = mCallback . getActivity ( ) ; mGoogleApiClient = LocationUtils . getGoogleApiClientWithCallbacks ( context ) ; mGoogleApiClient . connect ( ) ; } mLoader = onCreateLoader ( STOPS_LOADER , null ) ; mLoader . registerListener ( 0 , this ) ; mLoader . startLoading ( ) ; }
@ Override public void setState ( Bundle args ) { if ( args != null ) { Location center = UIUtils . getMapCenter ( args ) ; String stopId = args . getString ( MapParams . STOP_ID ) ; if ( stopId != null && center != null ) { mCallback . getMapView ( ) . setZoom ( MapParams . DEFAULT_ZOOM ) ; setMapCenter ( center ) ; return; } boolean dontCenterOnLocation = args . getBoolean ( MapParams . DO_N0T_CENTER_ON_LOCATION ) ; if ( ! dontCenterOnLocation ) { boolean setLocation = mCallback . setMyLocation ( true , false ) ; if ( setLocation ) { return; } } if ( center != null ) { float mapZoom = args . getFloat ( MapParams . ZOOM , MapParams . DEFAULT_ZOOM ) ; mCallback . getMapView ( ) . setZoom ( mapZoom ) ; setMapCenter ( center ) ; return; } } else { boolean setLocation = mCallback . setMyLocation ( false , false ) ; if ( setLocation ) { return; } } mCallback . zoomToRegion ( ) ; }
private void setMapCenter ( Location center ) { mCallback . getMapView ( ) . setMapCenter ( center , false , false ) ; onLocation ( ) ; }
@ Override public String getMode ( ) { return MapParams . MODE_STOP ; }
@ Override public void destroy ( ) { getLoader ( ) . reset ( ) ; watchMap ( false ) ; }
@ Override public void onPause ( ) { watchMap ( false ) ; if ( mGoogleApiClient != null && mGoogleApiClient . isConnected ( ) ) { mGoogleApiClient . disconnect ( ) ; } }
@ Override public void onHidden ( boolean hidden ) { }
@ Override public void onResume ( ) { watchMap ( true ) ; if ( mGoogleApiClient != null && ! mGoogleApiClient . isConnected ( ) ) { mGoogleApiClient . connect ( ) ; } }
@ Override public void onSaveInstanceState ( Bundle outState ) {    }
@ Override public void onViewStateRestored ( Bundle savedInstanceState ) { }
@ Override public void onLocation ( ) { refresh ( ) ; }
@ Override public void onNoLocation ( ) {    }
@ Override public Loader < StopsResponse > onCreateLoader ( int id , Bundle args ) { StopsLoader loader = new StopsLoader ( mCallback ) ; StopsRequest req = new StopsRequest ( mCallback . getMapView ( ) ) ; loader . update ( req ) ; return loader ; }
@ Override public void onLoadFinished ( Loader < StopsResponse > loader , StopsResponse _response ) { mCallback . showProgress ( false ) ; final ObaStopsForLocationResponse response = _response . getResponse ( ) ; if ( response == null ) { return; } if ( response . getCode ( ) != ObaApi . OBA_OK ) { BaseMapFragment . showMapError ( response ) ; return; } if ( response . getOutOfRange ( ) ) { mCallback . notifyOutOfRange ( ) ; return; } Location myLocation = Application . getLastKnownLocation ( mCallback . getActivity ( ) , mGoogleApiClient ) ; if ( myLocation != null && Application . get ( ) . getCurrentRegion ( ) != null ) { boolean inRegion = true ; try { inRegion = RegionUtils . isLocationWithinRegion ( myLocation , Application . get ( ) . getCurrentRegion ( ) ) ; } catch ( IllegalArgumentException e ) { Log . e ( TAG , "Invalid latitude or longitude - lat = " + myLocation . getLatitude ( ) + ", long = " + myLocation . getLongitude ( ) ) ; } if ( ! inRegion && Arrays . asList ( response . getStops ( ) ) . isEmpty ( ) ) { Log . d ( TAG , "Device location is outside region range, notifying..." ) ; mCallback . notifyOutOfRange ( ) ; return; } } List < ObaStop > stops = Arrays . asList ( response . getStops ( ) ) ; mCallback . showStops ( stops , response ) ; }
@ Override public void onLoaderReset ( Loader < StopsResponse > loader ) { mCallback . showStops ( null , null ) ; }
@ Override public void onLoadComplete ( Loader < StopsResponse > loader , StopsResponse response ) { onLoadFinished ( loader , response ) ; }
private StopsLoader getLoader ( ) { return ( StopsLoader ) mLoader ; }
private void refresh ( ) { if ( mCallback != null ) { Activity a = mCallback . getActivity ( ) ; if ( a != null ) { a . runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { StopsLoader loader = getLoader ( ) ; if ( loader != null ) { StopsRequest req = new StopsRequest ( mCallback . getMapView ( ) ) ; loader . update ( req ) ; } } } ) ; } } }
@ Override public void run ( ) { StopsLoader loader = getLoader ( ) ; if ( loader != null ) { StopsRequest req = new StopsRequest ( mCallback . getMapView ( ) ) ; loader . update ( req ) ; } }
public StopsLoader ( Callback fragment ) { super( fragment . getActivity ( ) ); mFragment = fragment ; }
@ Override public StopsResponse loadInBackground ( ) { StopsRequest req = mRequest ; if ( Application . get ( ) . getCurrentRegion ( ) == null && TextUtils . isEmpty ( Application . get ( ) . getCustomApiUrl ( ) ) ) { Log . d ( TAG , "Trying to load stops from server without " + "OBA REST API endpoint, aborting..." ) ; return new StopsResponse ( req , null ) ; } ObaStopsForLocationResponse response = new ObaStopsForLocationRequest . Builder ( getContext ( ) , req . getCenter ( ) ) . setSpan ( req . getLatSpan ( ) , req . getLonSpan ( ) ) . build ( ) . call ( ) ; return new StopsResponse ( req , response ) ; }
@ Override public void deliverResult ( StopsResponse data ) { mResponse = data ; super. deliverResult ( data ) ; }
@ Override public void onStartLoading ( ) { if ( takeContentChanged ( ) ) { forceLoad ( ) ; } }
@ Override public void onForceLoad ( ) { mFragment . showProgress ( true ) ; super. onForceLoad ( ) ; }
public void update ( StopsRequest req ) { if ( mResponse == null || ! mResponse . fulfills ( req ) ) { mRequest = req ; onContentChanged ( ) ; } }
private void watchMap ( boolean watch ) { if ( watch && ! mCallback . getMapView ( ) . canWatchMapChanges ( ) ) { if ( mMapWatcher == null ) { mMapWatcher = new MapWatcher ( mCallback . getMapView ( ) , this ) ; } mMapWatcher . start ( ) ; } else { if ( mMapWatcher != null ) { mMapWatcher . stop ( ) ; } mMapWatcher = null ; } }
@ Override public void onMapZoomChanging ( ) { }
@ Override public void onMapZoomChanged ( ) { refresh ( ) ; }
@ Override public void onMapCenterChanging ( ) { }
@ Override public void onMapCenterChanged ( ) { refresh ( ) ; }
@ Override public void notifyMapChanged ( ) { Log . d ( TAG , "Map changed (called by MapView)" ) ; refresh ( ) ; }
public GPUImagePosterizeFilter ( ) { this( 10 ); }
public GPUImagePosterizeFilter ( final int colorLevels ) { super( GPUImageFilter . NO_FILTER_VERTEX_SHADER , POSTERIZE_FRAGMENT_SHADER ); mColorLevels = colorLevels ; }
@ Override public void onInit ( ) { super. onInit ( ) ; mGLUniformColorLevels = GLES20 . glGetUniformLocation ( getProgram ( ) , "colorLevels" ) ; setColorLevels ( mColorLevels ) ; }
public void setColorLevels ( final int colorLevels ) { mColorLevels = colorLevels ; setFloat ( mGLUniformColorLevels , colorLevels ) ; }
protected ObaReportProblemWithStopRequest ( Uri uri ) { super( uri ); }
public Builder ( Context context , String stopId ) { super( context , BASE_PATH + "/report-problem-with-stop.json" ); mBuilder . appendQueryParameter ( "stopId" , stopId ) ; }
public Builder setCode ( String code ) { mBuilder . appendQueryParameter ( "code" , code ) ; String data = String . format ( "{\"code\":\"%s\"}" , code ) ; mBuilder . appendQueryParameter ( "data" , data ) ; return this ; }
public Builder setUserComment ( String comment ) { mBuilder . appendQueryParameter ( "userComment" , comment ) ; return this ; }
public Builder setUserLocation ( double lat , double lon ) { mBuilder . appendQueryParameter ( "userLat" , String . valueOf ( lat ) ) ; mBuilder . appendQueryParameter ( "userLon" , String . valueOf ( lon ) ) ; return this ; }
public Builder setUserLocationAccuracy ( int meters ) { mBuilder . appendQueryParameter ( "userLocationAccuracy" , String . valueOf ( meters ) ) ; return this ; }
public ObaReportProblemWithStopRequest build ( ) { return new ObaReportProblemWithStopRequest ( buildUri ( ) ) ; }
@ Override public ObaReportProblemWithStopResponse call ( ) { return call ( ObaReportProblemWithStopResponse .class ) ; }
@ Override public String toString ( ) { return "ObaReportProblemWithStopRequest [mUri=" + mUri + "]" ; }
@ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View view = inflater . inflate ( R . layout . fragment_webview , container , false ) ; final ObservableWebView webView = ( ObservableWebView ) view . findViewById ( R . id . scroll ) ; webView . loadUrl ( "file: ) ; Activity parentActivity = getActivity ( ) ; webView . setTouchInterceptionViewGroup ( ( ViewGroup ) parentActivity . findViewById ( R . id . container ) ) ; if ( parentActivity instanceof ObservableScrollViewCallbacks ) { webView . setScrollViewCallbacks ( ( ObservableScrollViewCallbacks ) parentActivity ) ; } return view ; }
private ObaTripResponse ( ) { data = Data . EMPTY_OBJECT ; }
@ Override public String getId ( ) { return data . entry . getId ( ) ; }
@ Override public String getShortName ( ) { return data . entry . getShortName ( ) ; }
@ Override public int getDirectionId ( ) { return data . entry . getDirectionId ( ) ; }
@ Override public String getHeadsign ( ) { return data . entry . getHeadsign ( ) ; }
@ Override public String getServiceId ( ) { return data . entry . getServiceId ( ) ; }
@ Override public String getShapeId ( ) { return data . entry . getShapeId ( ) ; }
@ Override public String getTimezone ( ) { return data . entry . getTimezone ( ) ; }
@ Override public String getRouteId ( ) { return data . entry . getRouteId ( ) ; }
@ Override public String getBlockId ( ) { return data . entry . getBlockId ( ) ; }
public ObaRoute getRoute ( ) { return data . references . getRoute ( data . entry . getRouteId ( ) ) ; }
@ Override protected ObaReferences getRefs ( ) { return data . references ; }
public ProviderTest ( ) { super( ObaProvider .class , ObaContract . AUTHORITY ); }
public void testStops ( ) { ContentResolver cr = getMockContentResolver ( ) ; final String stopId = "1_11060-TEST" ; ContentValues values = new ContentValues ( ) ; values . put ( ObaContract . Stops . _ID , stopId ) ; values . put ( ObaContract . Stops . CODE , "11060" ) ; values . put ( ObaContract . Stops . NAME , "Broadway & E Denny Way" ) ; values . put ( ObaContract . Stops . DIRECTION , "S" ) ; values . put ( ObaContract . Stops . USE_COUNT , 0 ) ; values . put ( ObaContract . Stops . LATITUDE , 47.617676 ) ; values . put ( ObaContract . Stops . LONGITUDE , - 122.314523 ) ; Uri uri = cr . insert ( ObaContract . Stops . CONTENT_URI , values ) ; assertNotNull ( uri ) ; assertEquals ( uri , Uri . withAppendedPath ( ObaContract . Stops . CONTENT_URI , stopId ) ) ; Cursor c = cr . query ( ObaContract . Stops . CONTENT_URI , new String [] { ObaContract . Stops . _ID , ObaContract . Stops . DIRECTION } , null , null , null ) ; assertNotNull ( c ) ; assertTrue ( c . getCount ( ) == 1 ) ; c . moveToNext ( ) ; assertEquals ( c . getString ( 0 ) , stopId ) ; c . close ( ) ; c = cr . query ( ObaContract . Stops . CONTENT_URI , new String [] { ObaContract . Stops . _COUNT } , null , null , null ) ; assertNotNull ( c ) ; assertEquals ( c . getCount ( ) , 1 ) ; c . moveToNext ( ) ; assertTrue ( c . getInt ( 0 ) == 1 ) ; c . close ( ) ; c = cr . query ( uri , new String [] { ObaContract . Stops . CODE } , null , null , null ) ; assertNotNull ( c ) ; assertEquals ( c . getCount ( ) , 1 ) ; c . moveToNext ( ) ; assertEquals ( c . getString ( 0 ) , "11060" ) ; c . close ( ) ; values = new ContentValues ( ) ; values . put ( ObaContract . Stops . USE_COUNT , 1 ) ; int result = cr . update ( uri , values , null , null ) ; assertEquals ( result , 1 ) ; result = cr . delete ( uri , null , null ) ; assertEquals ( result , 1 ) ; result = cr . delete ( uri , null , null ) ; assertEquals ( result , 0 ) ; }
public void testLimit ( ) { ContentResolver cr = getMockContentResolver ( ) ; final String stopId = "1_11060-TEST" ; ContentValues values = new ContentValues ( ) ; values . put ( ObaContract . Stops . _ID , stopId ) ; values . put ( ObaContract . Stops . CODE , "11060" ) ; values . put ( ObaContract . Stops . NAME , "Broadway & E Denny Way" ) ; values . put ( ObaContract . Stops . DIRECTION , "S" ) ; values . put ( ObaContract . Stops . USE_COUNT , 0 ) ; values . put ( ObaContract . Stops . LATITUDE , 47.617676 ) ; values . put ( ObaContract . Stops . LONGITUDE , - 122.314523 ) ; Uri uri = cr . insert ( ObaContract . Stops . CONTENT_URI , values ) ; assertNotNull ( uri ) ; final String stopId2 = "1_1010101" ; values . put ( ObaContract . Stops . _ID , stopId2 ) ; uri = cr . insert ( ObaContract . Stops . CONTENT_URI , values ) ; assertNotNull ( uri ) ; Cursor c = cr . query ( ObaContract . Stops . CONTENT_URI , new String [] { ObaContract . Stops . _COUNT } , null , null , null ) ; assertNotNull ( c ) ; assertEquals ( c . getCount ( ) , 1 ) ; c . moveToNext ( ) ; assertTrue ( c . getInt ( 0 ) == 2 ) ; c . close ( ) ; c = cr . query ( ObaContract . Stops . CONTENT_URI . buildUpon ( ) . appendQueryParameter ( "limit" , "1" ) . build ( ) , new String [] { ObaContract . Stops . _ID } , null , null , null ) ; assertNotNull ( c ) ; assertEquals ( c . getCount ( ) , 1 ) ; c . close ( ) ; }
String getFocusedStopId ( )
public VehicleOverlay ( Activity activity , GoogleMap map ) { mActivity = activity ; mMap = map ; loadIcons ( ) ; mMap . setOnInfoWindowClickListener ( this ) ; mCustomInfoWindowAdapter = new CustomInfoWindowAdapter ( mActivity ) ; mMap . setInfoWindowAdapter ( mCustomInfoWindowAdapter ) ; }
public void setController ( Controller controller ) { mController = controller ; }
public void updateVehicles ( HashSet < String > routeIds , ObaTripsForRouteResponse response ) { setupMarkerData ( ) ; mLastResponse = response ; mMarkerData . populate ( routeIds , response ) ; }
public synchronized int size ( ) { if ( mMarkerData != null ) { return mMarkerData . size ( ) ; } else { return 0 ; } }
public synchronized void clear ( ) { if ( mMarkerData != null ) { mMarkerData . clear ( ) ; mMarkerData = null ; } if ( mCustomInfoWindowAdapter != null ) { mCustomInfoWindowAdapter . cancelUpdates ( ) ; } }
private static final void loadIcons ( ) { final int MAX_CACHE_SIZE = 15 ; if ( mVehicleUncoloredIcons == null ) { mVehicleUncoloredIcons = new LruCache <> ( MAX_CACHE_SIZE ) ; } if ( mVehicleColoredIconCache == null ) { mVehicleColoredIconCache = new LruCache <> ( MAX_CACHE_SIZE ) ; } }
private static Bitmap getIcon ( int halfWind , int vehicleType ) { if ( ! supportedVehicleType ( vehicleType ) ) { vehicleType = DEFAULT_VEHICLE_TYPE ; } String cacheKey = String . format ( "%d %d" , halfWind , vehicleType ) ; Bitmap b = mVehicleUncoloredIcons . get ( cacheKey ) ; if ( b == null ) { switch ( vehicleType ) { case ObaRoute . TYPE_BUS : b = createBusIcon ( halfWind ) ; break; case ObaRoute . TYPE_FERRY : b = createFerryIcon ( halfWind ) ; break; case ObaRoute . TYPE_TRAM : b = createTramIcon ( halfWind ) ; break; case ObaRoute . TYPE_SUBWAY : b = createSubwayIcon ( halfWind ) ; break; case ObaRoute . TYPE_RAIL : b = createRailIcon ( halfWind ) ; break; } } mVehicleUncoloredIcons . put ( cacheKey , b ) ; return b ; }
private static boolean supportedVehicleType ( int vehicleType ) { return vehicleType == ObaRoute . TYPE_BUS || vehicleType == ObaRoute . TYPE_FERRY || vehicleType == ObaRoute . TYPE_TRAM || vehicleType == ObaRoute . TYPE_SUBWAY || vehicleType == ObaRoute . TYPE_RAIL ; }
private static Bitmap createBusIcon ( int halfWind ) { Resources r = Application . get ( ) . getResources ( ) ; switch ( halfWind ) { case NORTH : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_bus_smaller_north_inside ) ; case NORTH_EAST : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_bus_smaller_north_east_inside ) ; case EAST : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_bus_smaller_east_inside ) ; case SOUTH_EAST : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_bus_smaller_south_east_inside ) ; case SOUTH : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_bus_smaller_south_inside ) ; case SOUTH_WEST : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_bus_smaller_south_west_inside ) ; case WEST : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_bus_smaller_west_inside ) ; case NORTH_WEST : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_bus_smaller_north_west_inside ) ; default: return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_bus_smaller_none_inside ) ; } }
private static Bitmap createTramIcon ( int halfWind ) { Resources r = Application . get ( ) . getResources ( ) ; switch ( halfWind ) { case NORTH : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_tram_smaller_north_inside ) ; case NORTH_EAST : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_tram_smaller_north_east_inside ) ; case EAST : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_tram_smaller_east_inside ) ; case SOUTH_EAST : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_tram_smaller_south_east_inside ) ; case SOUTH : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_tram_smaller_south_inside ) ; case SOUTH_WEST : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_tram_smaller_south_west_inside ) ; case WEST : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_tram_smaller_west_inside ) ; case NORTH_WEST : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_tram_smaller_north_west_inside ) ; default: return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_tram_smaller_none_inside ) ; } }
private static Bitmap createRailIcon ( int halfWind ) { Resources r = Application . get ( ) . getResources ( ) ; switch ( halfWind ) { case NORTH : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_train_smaller_north_inside ) ; case NORTH_EAST : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_train_smaller_north_east_inside ) ; case EAST : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_train_smaller_east_inside ) ; case SOUTH_EAST : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_train_smaller_south_east_inside ) ; case SOUTH : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_train_smaller_south_inside ) ; case SOUTH_WEST : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_train_smaller_south_west_inside ) ; case WEST : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_train_smaller_west_inside ) ; case NORTH_WEST : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_train_smaller_north_west_inside ) ; default: return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_train_smaller_none_inside ) ; } }
private static Bitmap createFerryIcon ( int halfWind ) { Resources r = Application . get ( ) . getResources ( ) ; switch ( halfWind ) { case NORTH : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_boat_smaller_north_inside ) ; case NORTH_EAST : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_boat_smaller_north_east_inside ) ; case EAST : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_boat_smaller_east_inside ) ; case SOUTH_EAST : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_boat_smaller_south_east_inside ) ; case SOUTH : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_boat_smaller_south_inside ) ; case SOUTH_WEST : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_boat_smaller_south_west_inside ) ; case WEST : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_boat_smaller_west_inside ) ; case NORTH_WEST : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_boat_smaller_north_west_inside ) ; default: return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_boat_smaller_none_inside ) ; } }
private static Bitmap createSubwayIcon ( int halfWind ) { Resources r = Application . get ( ) . getResources ( ) ; switch ( halfWind ) { case NORTH : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_subway_smaller_north_inside ) ; case NORTH_EAST : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_subway_smaller_north_east_inside ) ; case EAST : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_subway_smaller_east_inside ) ; case SOUTH_EAST : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_subway_smaller_south_east_inside ) ; case SOUTH : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_subway_smaller_south_inside ) ; case SOUTH_WEST : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_subway_smaller_south_west_inside ) ; case WEST : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_subway_smaller_west_inside ) ; case NORTH_WEST : return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_subway_smaller_north_west_inside ) ; default: return BitmapFactory . decodeResource ( r , R . drawable . ic_marker_with_subway_smaller_none_inside ) ; } }
private void addBitmapToCache ( String key , Bitmap bitmap ) { if ( getBitmapFromCache ( key ) == null ) { mVehicleColoredIconCache . put ( key , bitmap ) ; } }
private Bitmap getBitmapFromCache ( String key ) { return mVehicleColoredIconCache . get ( key ) ; }
private String createBitmapCacheKey ( int vehicleType , int halfWind , int colorResource ) { if ( ! supportedVehicleType ( vehicleType ) ) { vehicleType = DEFAULT_VEHICLE_TYPE ; } return String . valueOf ( vehicleType ) + " " + String . valueOf ( halfWind ) + " " + String . valueOf ( colorResource ) ; }
private Bitmap getBitmap ( int vehicleType , int colorResource , int halfWind ) { int color = ContextCompat . getColor ( mActivity , colorResource ) ; if ( vehicleType == ObaRoute . TYPE_CABLECAR ) { vehicleType = ObaRoute . TYPE_TRAM ; } String key = createBitmapCacheKey ( vehicleType , halfWind , colorResource ) ; Bitmap b = getBitmapFromCache ( key ) ; if ( b == null ) { b = UIUtils . colorBitmap ( getIcon ( halfWind , vehicleType ) , color ) ; addBitmapToCache ( key , b ) ; } return b ; }
@ Override public void onInfoWindowClick ( Marker marker ) { mCustomInfoWindowAdapter . cancelUpdates ( ) ; ObaTripStatus status = mMarkerData . getStatusFromMarker ( marker ) ; if ( mController != null && mController . getFocusedStopId ( ) != null ) { TripDetailsActivity . start ( mActivity , status . getActiveTripId ( ) , mController . getFocusedStopId ( ) , TripDetailsListFragment . SCROLL_MODE_VEHICLE ) ; } else { TripDetailsActivity . start ( mActivity , status . getActiveTripId ( ) , TripDetailsListFragment . SCROLL_MODE_VEHICLE ) ; } }
private void setupMarkerData ( ) { if ( mMarkerData == null ) { mMarkerData = new MarkerData ( ) ; } }
MarkerData ( ) { mVehicles = new HashMap <> ( INITIAL_HASHMAP_SIZE ) ; mVehicleMarkers = new HashMap <> ( INITIAL_HASHMAP_SIZE ) ; }
synchronized void populate ( HashSet < String > routeIds , ObaTripsForRouteResponse response ) { int added = 0 ; int updated = 0 ; ObaTripDetails [] trips = response . getTrips ( ) ; HashSet < String > activeTripIds = new HashSet <> ( ) ; for ( ObaTripDetails trip : trips ) { ObaTripStatus status = trip . getStatus ( ) ; if ( status != null ) { String activeRoute = response . getTrip ( status . getActiveTripId ( ) ) . getRouteId ( ) ; if ( routeIds . contains ( activeRoute ) ) { Location l = status . getLastKnownLocation ( ) ; boolean isRealtime = true ; if ( l == null ) { l = status . getPosition ( ) ; isRealtime = false ; } if ( ! status . isPredicted ( ) ) { isRealtime = false ; } Marker m = mVehicleMarkers . get ( status . getActiveTripId ( ) ) ; if ( m == null ) { addMarkerToMap ( l , isRealtime , status , response ) ; added ++ ; } else { updateMarker ( m , l , isRealtime , status , response ) ; updated ++ ; } activeTripIds . add ( status . getActiveTripId ( ) ) ; } } } int removed = removeInactiveMarkers ( activeTripIds ) ; Log . d ( TAG , "Added " + added + ", updated " + updated + ", removed " + removed + ", total vehicle markers = " + mVehicleMarkers . size ( ) ) ; Log . d ( TAG , "Vehicle LRU cache size=" + mVehicleColoredIconCache . size ( ) + ", hits=" + mVehicleColoredIconCache . hitCount ( ) + ", misses=" + mVehicleColoredIconCache . missCount ( ) ) ; Log . d ( TAG , String . format ( "Raw uncolored vehicle LRU cache size=%d, hits=%d, misses=%d" , mVehicleUncoloredIcons . size ( ) , mVehicleUncoloredIcons . hitCount ( ) , mVehicleUncoloredIcons . missCount ( ) ) ) ; }
private void addMarkerToMap ( Location l , boolean isRealtime , ObaTripStatus status , ObaTripsForRouteResponse response ) { Marker m = mMap . addMarker ( new MarkerOptions ( ) . position ( MapHelpV2 . makeLatLng ( l ) ) . title ( status . getVehicleId ( ) ) . icon ( getVehicleIcon ( isRealtime , status , response ) ) ) ; ProprietaryMapHelpV2 . setZIndex ( m , VEHICLE_MARKER_Z_INDEX ) ; mVehicleMarkers . put ( status . getActiveTripId ( ) , m ) ; mVehicles . put ( m , status ) ; }
private void updateMarker ( Marker m , Location l , boolean isRealtime , ObaTripStatus status , ObaTripsForRouteResponse response ) { boolean showInfo = m . isInfoWindowShown ( ) ; m . setIcon ( getVehicleIcon ( isRealtime , status , response ) ) ; mVehicles . put ( m , status ) ; Location markerLoc = MapHelpV2 . makeLocation ( m . getPosition ( ) ) ; if ( l . distanceTo ( markerLoc ) < MAX_VEHICLE_ANIMATION_DISTANCE ) { AnimationUtil . animateMarkerTo ( m , MapHelpV2 . makeLatLng ( l ) ) ; } else { m . setPosition ( MapHelpV2 . makeLatLng ( l ) ) ; } if ( showInfo ) { m . showInfoWindow ( ) ; } }
private int removeInactiveMarkers ( HashSet < String > activeTripIds ) { int removed = 0 ; try { Iterator < Map . Entry < String , Marker > > iterator = mVehicleMarkers . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , Marker > entry = iterator . next ( ) ; String tripId = entry . getKey ( ) ; Marker m = entry . getValue ( ) ; if ( ! activeTripIds . contains ( tripId ) ) { entry . getValue ( ) . remove ( ) ; mVehicles . remove ( m ) ; iterator . remove ( ) ; removed ++ ; } } } catch ( UnsupportedOperationException e ) { Log . w ( TAG , "Problem removing vehicle from HashMap using iterator: " + e ) ; HashMap < String , Marker > copy = new HashMap <> ( mVehicleMarkers ) ; for ( Map . Entry < String , Marker > entry : copy . entrySet ( ) ) { String tripId = entry . getKey ( ) ; Marker m = entry . getValue ( ) ; if ( ! activeTripIds . contains ( tripId ) ) { entry . getValue ( ) . remove ( ) ; mVehicles . remove ( m ) ; mVehicleMarkers . remove ( tripId ) ; removed ++ ; } } } return removed ; }
private BitmapDescriptor getVehicleIcon ( boolean isRealtime , ObaTripStatus status , ObaTripsForRouteResponse response ) { String routeId = response . getTrip ( status . getActiveTripId ( ) ) . getRouteId ( ) ; ObaRoute route = response . getRoute ( routeId ) ; int vehicleType = route . getType ( ) ; int colorResource ; if ( isRealtime ) { long deviationMin = TimeUnit . SECONDS . toMinutes ( status . getScheduleDeviation ( ) ) ; colorResource = ArrivalInfoUtils . computeColorFromDeviation ( deviationMin ) ; } else { colorResource = R . color . stop_info_scheduled_time ; } double direction = MathUtils . toDirection ( status . getOrientation ( ) ) ; int halfWind = MathUtils . getHalfWindIndex ( ( float ) direction , NUM_DIRECTIONS - 1 ) ; Bitmap b = getBitmap ( vehicleType , colorResource , halfWind ) ; return BitmapDescriptorFactory . fromBitmap ( b ) ; }
synchronized ObaTripStatus getStatusFromMarker ( Marker marker ) { return mVehicles . get ( marker ) ; }
private void removeMarkersFromMap ( ) { for ( Map . Entry < String , Marker > entry : mVehicleMarkers . entrySet ( ) ) { entry . getValue ( ) . remove ( ) ; } }
synchronized void clear ( ) { if ( mVehicleMarkers != null ) { removeMarkersFromMap ( ) ; mVehicleMarkers . clear ( ) ; mVehicleMarkers = null ; } if ( mVehicles != null ) { mVehicles . clear ( ) ; mVehicles = null ; } }
synchronized int size ( ) { return mVehicleMarkers . size ( ) ; }
protected static boolean isLocationRealtime ( ObaTripStatus status ) { boolean isRealtime = true ; Location l = status . getLastKnownLocation ( ) ; if ( l == null ) { isRealtime = false ; } if ( ! status . isPredicted ( ) ) { isRealtime = false ; } return isRealtime ; }
public CustomInfoWindowAdapter ( Context context ) { this . mInflater = LayoutInflater . from ( context ) ; this . mContext = context ; }
@ Override public View getInfoWindow ( Marker marker ) { return null ; }
@ Override public View getInfoContents ( Marker marker ) { if ( mMarkerData == null ) { return null ; } ObaTripStatus status = mMarkerData . getStatusFromMarker ( marker ) ; if ( status == null ) { mCurrentFocusVehicleMarker = null ; return null ; } mCurrentFocusVehicleMarker = marker ; View view = mInflater . inflate ( R . layout . vehicle_info_window , null ) ; Resources r = mContext . getResources ( ) ; TextView routeView = ( TextView ) view . findViewById ( R . id . route_and_destination ) ; TextView statusView = ( TextView ) view . findViewById ( R . id . status ) ; TextView lastUpdatedView = ( TextView ) view . findViewById ( R . id . last_updated ) ; ImageView moreView = ( ImageView ) view . findViewById ( R . id . trip_more_info ) ; moreView . setColorFilter ( r . getColor ( R . color . switch_thumb_normal_material_dark ) ) ; ObaTrip trip = mLastResponse . getTrip ( status . getActiveTripId ( ) ) ; ObaRoute route = mLastResponse . getRoute ( trip . getRouteId ( ) ) ; routeView . setText ( UIUtils . getRouteDisplayName ( route ) + " " + mContext . getString ( R . string . trip_info_separator ) + " " + UIUtils . formatDisplayText ( trip . getHeadsign ( ) ) ) ; boolean isRealtime = isLocationRealtime ( status ) ; statusView . setBackgroundResource ( R . drawable . round_corners_style_b_status ) ; GradientDrawable d = ( GradientDrawable ) statusView . getBackground ( ) ; int pSides = UIUtils . dpToPixels ( mContext , 5 ) ; int pTopBottom = UIUtils . dpToPixels ( mContext , 2 ) ; int statusColor ; if ( isRealtime ) { long deviationMin = TimeUnit . SECONDS . toMinutes ( status . getScheduleDeviation ( ) ) ; String statusString = ArrivalInfoUtils . computeArrivalLabelFromDelay ( r , deviationMin ) ; statusView . setText ( statusString ) ; statusColor = ArrivalInfoUtils . computeColorFromDeviation ( deviationMin ) ; d . setColor ( r . getColor ( statusColor ) ) ; statusView . setPadding ( pSides , pTopBottom , pSides , pTopBottom ) ; } else { statusView . setText ( r . getString ( R . string . stop_info_scheduled ) ) ; statusColor = R . color . stop_info_scheduled_time ; d . setColor ( r . getColor ( statusColor ) ) ; lastUpdatedView . setText ( r . getString ( R . string . vehicle_last_updated_scheduled ) ) ; statusView . setPadding ( pSides , pTopBottom , pSides , pTopBottom ) ; return view ; } long now = System . currentTimeMillis ( ) ; long lastUpdateTime ; if ( status . getLastLocationUpdateTime ( ) != 0 ) { lastUpdateTime = status . getLastLocationUpdateTime ( ) ; } else { lastUpdateTime = status . getLastUpdateTime ( ) ; } long elapsedSec = TimeUnit . MILLISECONDS . toSeconds ( now - lastUpdateTime ) ; long elapsedMin = TimeUnit . SECONDS . toMinutes ( elapsedSec ) ; long secMod60 = elapsedSec % 60 ; String lastUpdated ; if ( elapsedSec < 60 ) { lastUpdated = r . getString ( R . string . vehicle_last_updated_sec , elapsedSec ) ; } else { lastUpdated = r . getString ( R . string . vehicle_last_updated_min_and_sec , elapsedMin , secMod60 ) ; } lastUpdatedView . setText ( lastUpdated ) ; if ( mMarkerRefreshHandler != null ) { mMarkerRefreshHandler . removeCallbacks ( mMarkerRefresh ) ; mMarkerRefreshHandler . postDelayed ( mMarkerRefresh , MARKER_REFRESH_PERIOD ) ; } return view ; }
public void run ( ) { if ( mCurrentFocusVehicleMarker != null && mCurrentFocusVehicleMarker . isInfoWindowShown ( ) ) { mCurrentFocusVehicleMarker . showInfoWindow ( ) ; } }
public void cancelUpdates ( ) { if ( mMarkerRefreshHandler != null ) { mMarkerRefreshHandler . removeCallbacks ( mMarkerRefresh ) ; } }
protected RequestBase ( Uri uri ) { mUri = uri ; mPostData = null ; }
protected RequestBase ( Uri uri , String postData ) { mUri = uri ; mPostData = postData ; }
protected BuilderBase ( Context context , String path ) { this( context , null , path ); }
protected BuilderBase ( Context context , ObaContext obaContext , String path ) { mContext = context ; mObaContext = obaContext ; mBuilder = new Uri . Builder ( ) ; mBuilder . path ( path ) ; }
protected static String getPathWithId ( String pathElement , String id ) { StringBuilder builder = new StringBuilder ( BASE_PATH ) ; builder . append ( pathElement ) ; builder . append ( Uri . encode ( id ) ) ; builder . append ( ".json" ) ; return builder . toString ( ) ; }
protected Uri buildUri ( ) { ObaContext context = ( mObaContext != null ) ? mObaContext : ObaApi . getDefaultContext ( ) ; context . setBaseUrl ( mContext , mBuilder ) ; context . setAppInfo ( mBuilder ) ; mBuilder . appendQueryParameter ( "version" , "2" ) ; mBuilder . appendQueryParameter ( "key" , context . getApiKey ( ) ) ; return mBuilder . build ( ) ; }
public ObaContext getObaContext ( ) { if ( mObaContext == null ) { mObaContext = ObaApi . getDefaultContext ( ) . clone ( ) ; } return mObaContext ; }
protected PostBuilderBase ( Context context , String path ) { super( context , path ); mPostData = new Uri . Builder ( ) ; }
public String buildPostData ( ) { return mPostData . build ( ) . getEncodedQuery ( ) ; }
protected < T > T call ( Class < T > cls ) { ObaApi . SerializationHandler handler = ObaApi . getSerializer ( cls ) ; ObaConnection conn = null ; try { conn = ObaApi . getDefaultContext ( ) . getConnectionFactory ( ) . newConnection ( mUri ) ; Reader reader ; if ( mPostData != null ) { reader = conn . post ( mPostData ) ; } else { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . GINGERBREAD ) { int responseCode = conn . getResponseCode ( ) ; if ( responseCode != HttpURLConnection . HTTP_OK ) { return handler . createFromError ( cls , responseCode , "" ) ; } } reader = conn . get ( ) ; } T t = handler . deserialize ( reader , cls ) ; if ( t == null ) { t = handler . createFromError ( cls , ObaApi . OBA_INTERNAL_ERROR , "Json error" ) ; } return t ; } catch ( FileNotFoundException e ) { Log . e ( TAG , e . toString ( ) ) ; return handler . createFromError ( cls , ObaApi . OBA_NOT_FOUND , e . toString ( ) ) ; } catch ( IOException e ) { Log . e ( TAG , e . toString ( ) ) ; return handler . createFromError ( cls , ObaApi . OBA_IO_EXCEPTION , e . toString ( ) ) ; } finally { if ( conn != null ) { conn . disconnect ( ) ; } } }
public CancelNotifyTask ( Context context , TaskContext taskContext , Uri uri ) { mContext = context ; mTaskContext = taskContext ; mUri = uri ; }
@ Override public void run ( ) { try { long alertId = ContentUris . parseId ( mUri ) ; mTaskContext . cancelNotification ( ( int ) alertId ) ; ContentResolver cr = mContext . getContentResolver ( ) ; ContentValues values = new ContentValues ( ) ; values . put ( ObaContract . TripAlerts . STATE , ObaContract . TripAlerts . STATE_CANCELLED ) ; cr . update ( mUri , values , null , null ) ; TripService . scheduleAll ( mContext ) ; } finally { mTaskContext . taskComplete ( ) ; } }
public ListFragmentAssert ( ListFragment actual ) { super( actual , ListFragmentAssert .class ); }
public ListFragmentAssert hasSelectedItemId ( long id ) { isNotNull ( ) ; long actualId = actual . getSelectedItemId ( ) ; assertThat ( actualId ) . overridingErrorMessage ( "Expected selected ID <%s> but was <%s>." , id , actualId ) . isEqualTo ( id ) ; return this ; }
public ListFragmentAssert hasSelectedItemPosition ( int position ) { isNotNull ( ) ; long actualPosition = actual . getSelectedItemPosition ( ) ; assertThat ( actualPosition ) . overridingErrorMessage ( "Expected selected position <%s> but was <%s>." , position , actualPosition ) . isEqualTo ( position ) ; return this ; }
public LongSparseArrayAssert ( LongSparseArray actual ) { super( actual , LongSparseArrayAssert .class ); }
public LongSparseArrayAssert hasKey ( int key ) { isNotNull ( ) ; assertThat ( actual . get ( key ) ) . overridingErrorMessage ( "Expected key <%s> to be present but was not present." , key ) . isNotNull ( ) ; return this ; }
public LongSparseArrayAssert hasSize ( int size ) { isNotNull ( ) ; int actualSize = actual . size ( ) ; assertThat ( actualSize ) . overridingErrorMessage ( "Expected size <%s> but was <%s>." , size , actualSize ) . isEqualTo ( size ) ; return this ; }
public LibraryProjectsSampleIT ( MavenRuntimeBuilder builder ) throws Exception { this . mavenRuntime = builder . build ( ) ; }
@ Test public void buildDeployAndRun ( ) Exception { File basedir = resources . getBasedir ( "libraryprojects" ) ; MavenExecutionResult result = mavenRuntime . forProject ( basedir ) . execute ( "clean" , PluginInfo . getQualifiedGoal ( "undeploy" ) , "install" ) ; result . assertErrorFreeLog ( ) ; }
@ Override public void trackException ( String s , Throwable e , boolean fatal ) { if ( fatal ) { Log . w ( "Fatal Exception " + s + " " + e ) ; } else { Log . w ( "Not Fatal Exception " + s + " " + e ) ; } }
@ Override public void trackException ( String s , boolean fatal ) { if ( fatal ) { Log . w ( "Fatal Exception " + s ) ; } else { Log . w ( "Not Fatal Exception " + s ) ; } }
@ Override public void trackEvent ( String category , String action , String label , Long val ) {    }
protected AbstractFragmentAssert ( A actual , Class < S > selfType ) { super( actual , selfType ); }
public S hasId ( int id ) { isNotNull ( ) ; int actualId = actual . getId ( ) ; assertThat ( actualId ) . overridingErrorMessage ( "Expected ID <%s> but was <%s>" , id , actualId ) . isEqualTo ( id ) ; return myself ; }
public S hasTag ( String tag ) { isNotNull ( ) ; String actualTag = actual . getTag ( ) ; assertThat ( actualTag ) . isEqualTo ( tag ) ; return myself ; }
public S isUserVisible ( ) { isNotNull ( ) ; assertThat ( actual . getUserVisibleHint ( ) ) . overridingErrorMessage ( "Expected user visible hint but was not set" ) . isTrue ( ) ; return myself ; }
public S isNotUserVisible ( ) { isNotNull ( ) ; assertThat ( actual . getUserVisibleHint ( ) ) . overridingErrorMessage ( "Expected no user visible hint but was set" ) . isFalse ( ) ; return myself ; }
public S isAdded ( ) { isNotNull ( ) ; assertThat ( actual . isAdded ( ) ) . overridingErrorMessage ( "Expected added but was not added" ) . isTrue ( ) ; return myself ; }
public S isNotAdded ( ) { isNotNull ( ) ; assertThat ( actual . isAdded ( ) ) . overridingErrorMessage ( "Expected not added but was added" ) . isFalse ( ) ; return myself ; }
public S isDetached ( ) { isNotNull ( ) ; assertThat ( actual . isDetached ( ) ) . overridingErrorMessage ( "Expected detached but was not detached" ) . isTrue ( ) ; return myself ; }
public S isNotDetached ( ) { isNotNull ( ) ; assertThat ( actual . isDetached ( ) ) . overridingErrorMessage ( "Expected not detached but was detached" ) . isFalse ( ) ; return myself ; }
public S isHidden ( ) { isNotNull ( ) ; assertThat ( actual . isHidden ( ) ) . overridingErrorMessage ( "Expected hidden but was not hidden" ) . isTrue ( ) ; return myself ; }
public S isNotHidden ( ) { isNotNull ( ) ; assertThat ( actual . isHidden ( ) ) . overridingErrorMessage ( "Expected not hidden but was hidden" ) . isFalse ( ) ; return myself ; }
public S isInLayout ( ) { isNotNull ( ) ; assertThat ( actual . isInLayout ( ) ) . overridingErrorMessage ( "Expected in layout but was not in layout" ) . isTrue ( ) ; return myself ; }
public S isNotInLayout ( ) { isNotNull ( ) ; assertThat ( actual . isInLayout ( ) ) . overridingErrorMessage ( "Expected not in layout but was in layout" ) . isFalse ( ) ; return myself ; }
public S isRemoving ( ) { isNotNull ( ) ; assertThat ( actual . isRemoving ( ) ) . overridingErrorMessage ( "Expected removing but was not removing" ) . isTrue ( ) ; return myself ; }
public S isNotRemoving ( ) { isNotNull ( ) ; assertThat ( actual . isRemoving ( ) ) . overridingErrorMessage ( "Expected not removing but was removing" ) . isFalse ( ) ; return myself ; }
public S isResumed ( ) { isNotNull ( ) ; assertThat ( actual . isResumed ( ) ) . overridingErrorMessage ( "Expected resumed but was not resumed" ) . isTrue ( ) ; return myself ; }
public S isNotResumed ( ) { isNotNull ( ) ; assertThat ( actual . isResumed ( ) ) . overridingErrorMessage ( "Expected not resumed but was resumed" ) . isFalse ( ) ; return myself ; }
public S isVisible ( ) { isNotNull ( ) ; assertThat ( actual . isVisible ( ) ) . overridingErrorMessage ( "Expected visible but was not visible" ) . isTrue ( ) ; return myself ; }
public S isNotVisible ( ) { isNotNull ( ) ; assertThat ( actual . isVisible ( ) ) . overridingErrorMessage ( "Expected not visible but was visible" ) . isFalse ( ) ; return myself ; }
@ Override public void onReceive ( Context context , Intent intent ) { TripService . scheduleAll ( context ) ; }
public SchedulerTask ( Context context , TaskContext taskContext , Uri uri ) { mContext = context ; mCR = mContext . getContentResolver ( ) ; mTaskContext = taskContext ; mUri = uri ; }
@ Override public void run ( ) { cleanupOldAlerts ( ) ; Cursor c = mCR . query ( mUri , PROJECTION , null , null , null ) ; try { Time tNow = new Time ( ) ; tNow . setToNow ( ) ; final long now = tNow . toMillis ( false ) ; if ( c != null ) { while ( c . moveToNext ( ) ) { schedule1 ( c , tNow , now ) ; } } } finally { if ( c != null ) { c . close ( ) ; } mTaskContext . taskComplete ( ) ; } }
private void schedule1 ( Cursor c , Time tNow , long now ) { final String tripId = c . getString ( COL_ID ) ; final String stopId = c . getString ( COL_STOP_ID ) ; final Uri tripUri = ObaContract . Trips . buildUri ( tripId , stopId ) ; final int departureMins = c . getInt ( COL_DEPARTURE ) ; final long reminderMS = c . getInt ( COL_REMINDER ) * ONE_MINUTE ; if ( reminderMS == 0 ) { return; } final int days = c . getInt ( COL_DAYS ) ; if ( days == 0 ) { Time tmp = new Time ( ) ; tmp . set ( 0 , departureMins , 0 , tNow . monthDay , tNow . month , tNow . year ) ; tmp . normalize ( false ) ; long remindTime = tmp . toMillis ( false ) - reminderMS ; long triggerTime = remindTime - LOOKAHEAD_DURATION_MS ; if ( ! scheduleAlert ( tripUri , tripId , stopId , triggerTime ) ) { mCR . delete ( tripUri , null , null ) ; } } else { final int currentWeekDay = tNow . weekDay ; for ( int i = 0 ; i < 7 ; ++ i ) { final int day = ( currentWeekDay + i ) % 7 ; final int bit = ObaContract . Trips . getDayBit ( day ) ; if ( ( days & bit ) == bit ) { Time tmp = new Time ( ) ; tmp . set ( 0 , departureMins , 0 , tNow . monthDay + i , tNow . month , tNow . year ) ; tmp . normalize ( false ) ; long remindTime = tmp . toMillis ( false ) - reminderMS ; long triggerTime = remindTime - LOOKAHEAD_DURATION_MS ; if ( scheduleAlert ( tripUri , tripId , stopId , triggerTime ) ) { return; } } } } }
private boolean scheduleAlert ( Uri uri , String tripId , String stopId , long triggerTime ) { Time tmp = new Time ( ) ; tmp . set ( triggerTime ) ; Uri alertUri = null ; Cursor cAlert = mCR . query ( ObaContract . TripAlerts . CONTENT_URI , new String [] { ObaContract . TripAlerts . _ID , ObaContract . TripAlerts . STATE } , String . format ( "%s=? AND %s=? AND %s=?" , ObaContract . TripAlerts . TRIP_ID , ObaContract . TripAlerts . STOP_ID , ObaContract . TripAlerts . START_TIME ) , new String [] { tripId , stopId , String . valueOf ( triggerTime ) } , null ) ; if ( cAlert != null ) { try { if ( cAlert . moveToNext ( ) ) { if ( cAlert . getInt ( 1 ) == ObaContract . TripAlerts . STATE_CANCELLED ) { return false ; } alertUri = ObaContract . TripAlerts . buildUri ( cAlert . getInt ( 0 ) ) ; } } finally { cAlert . close ( ) ; } } if ( alertUri == null ) { ContentValues values = new ContentValues ( ) ; values . put ( ObaContract . TripAlerts . TRIP_ID , tripId ) ; values . put ( ObaContract . TripAlerts . STOP_ID , stopId ) ; values . put ( ObaContract . TripAlerts . START_TIME , triggerTime ) ; alertUri = mCR . insert ( ObaContract . TripAlerts . CONTENT_URI , values ) ; } TripService . pollTrip ( mContext , alertUri , triggerTime ) ; return true ; }
private void cleanupOldAlerts ( ) { long then = System . currentTimeMillis ( ) - ONE_MINUTE * 60 * 24 ; mCR . delete ( ObaContract . TripAlerts . CONTENT_URI , ObaContract . TripAlerts . START_TIME + " < " + then , null ) ; }
private ObaTripDetailsResponse ( ) { data = Data . EMPTY_OBJECT ; }
@ Override public String getId ( ) { return data . entry . getId ( ) ; }
@ Override public ObaTripSchedule getSchedule ( ) { return data . entry . getSchedule ( ) ; }
@ Override public ObaTripStatus getStatus ( ) { return data . entry . getStatus ( ) ; }
@ Override public ObaReferences getRefs ( ) { return data . references ; }
@ Test @ LargeTest public void testAppearance ( ) Exception { onView ( withId ( R . id . message ) ) . perform ( typeText ( "s" ) ) ; onView ( withId ( R . id . message ) ) . perform ( typeText ( "o" ) ) ; onView ( withId ( R . id . message ) ) . perform ( typeText ( "s" ) ) ; }
public PullOperation ( File fileDir , Activity callingActivity ) { super( fileDir , callingActivity ); }
public PullOperation setCommand ( ) { this . command = new Git ( repository ) . pull ( ) . setRebase ( true ) . setRemote ( "origin" ) ; return this ; }
@ Override public void execute ( ) { if ( this . provider != null ) { ( ( PullCommand ) this . command ) . setCredentialsProvider ( this . provider ) ; } new GitAsyncTask ( callingActivity , true , false , this ) . execute ( this . command ) ; }
@ Override public void onTaskEnded ( String result ) { new AlertDialog . Builder ( callingActivity ) . setTitle ( callingActivity . getResources ( ) . getString ( R . string . jgit_error_dialog_title ) ) . setMessage ( "Error occured during the pull operation, " + callingActivity . getResources ( ) . getString ( R . string . jgit_error_dialog_text ) + result + "\nPlease check the FAQ for possible reasons why this error might occur." ) . setPositiveButton ( callingActivity . getResources ( ) . getString ( R . string . dialog_ok ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialogInterface , int i ) { callingActivity . finish ( ) ; } } ) . show ( ) ; }
@ Override public void onClick ( DialogInterface dialogInterface , int i ) { callingActivity . finish ( ) ; }
public Story ( ) {    }
private Story ( Long storyId , String title , String url , String domain , int points , String submitter , String publishedTime , int numComments , String type ) { mStoryId = storyId ; mTitle = title ; mUrl = url ; mDomain = domain ; mPoints = points ; mSubmitter = submitter ; mPublishedTime = publishedTime ; mNumComments = numComments ; mType = type ; }
public static Story fromNodeHNAPIStory ( NodeHNAPIStory nodeHNAPIStory ) { return new Story ( nodeHNAPIStory . id , nodeHNAPIStory . title , nodeHNAPIStory . url , nodeHNAPIStory . domain , nodeHNAPIStory . points , nodeHNAPIStory . user , nodeHNAPIStory . timeAgo , nodeHNAPIStory . commentsCount , nodeHNAPIStory . type ) ; }
public Long getStoryId ( ) { return mStoryId ; }
public String getTitle ( ) { return mTitle ; }
public String getUrl ( ) { return mUrl ; }
public String getDomain ( ) { return mDomain ; }
public int getPoints ( ) { return mPoints ; }
public String getSubmitter ( ) { return mSubmitter ; }
public String getPublishedTime ( ) { return mPublishedTime ; }
public int getNumComments ( ) { return mNumComments ; }
public String getType ( ) { return mType ; }
public void setStoryId ( Long storyId ) { mStoryId = storyId ; }
public void setTitle ( String title ) { mTitle = title ; }
public void setUrl ( String url ) { mUrl = url ; }
public void setDomain ( String domain ) { mDomain = domain ; }
public void setPoints ( int points ) { mPoints = points ; }
public void setSubmitter ( String submitter ) { mSubmitter = submitter ; }
public void setPublishedTime ( String publishedTime ) { mPublishedTime = publishedTime ; }
public void setNumComments ( int numComments ) { mNumComments = numComments ; }
public void setType ( String type ) { mType = type ; }
public boolean isSaved ( ) { return isSaved ; }
public void setIsSaved ( boolean isSaved ) { this . isSaved = isSaved ; }
@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Story story = ( Story ) o ; if ( mStoryId != null ? ! mStoryId . equals ( story . mStoryId ) : story . mStoryId != null ) return false ; return true ; }
@ Override public int hashCode ( ) { return mStoryId != null ? mStoryId . hashCode ( ) : 0 ; }
public boolean isRead ( ) { return mIsRead ; }
public void setIsRead ( boolean isRead ) { this . mIsRead = isRead ; }
@ Override public int describeContents ( ) { return 0 ; }
@ Override public void writeToParcel ( Parcel dest , int flags ) { dest . writeValue ( this . mStoryId ) ; dest . writeString ( this . mTitle ) ; dest . writeString ( this . mUrl ) ; dest . writeString ( this . mDomain ) ; dest . writeInt ( this . mPoints ) ; dest . writeString ( this . mSubmitter ) ; dest . writeString ( this . mPublishedTime ) ; dest . writeInt ( this . mNumComments ) ; dest . writeString ( this . mType ) ; dest . writeByte ( isSaved ? ( byte ) 1 : ( byte ) 0 ) ; dest . writeByte ( mIsRead ? ( byte ) 1 : ( byte ) 0 ) ; }
protected Story ( Parcel in ) { this . mStoryId = ( Long ) in . readValue ( Long .class . getClassLoader ( ) ) ; this . mTitle = in . readString ( ) ; this . mUrl = in . readString ( ) ; this . mDomain = in . readString ( ) ; this . mPoints = in . readInt ( ) ; this . mSubmitter = in . readString ( ) ; this . mPublishedTime = in . readString ( ) ; this . mNumComments = in . readInt ( ) ; this . mType = in . readString ( ) ; this . isSaved = in . readByte ( ) != 0 ; this . mIsRead = in . readByte ( ) != 0 ; }
public Story createFromParcel ( Parcel source ) { return new Story ( source ) ; }
public Story [] newArray ( int size ) { return new Story [ size ] ; }
@ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View view = inflater . inflate ( R . layout . fragment_listview , container , false ) ; Activity parentActivity = getActivity ( ) ; final ObservableListView listView = ( ObservableListView ) view . findViewById ( R . id . scroll ) ; setDummyData ( listView ) ; listView . setTouchInterceptionViewGroup ( ( ViewGroup ) parentActivity . findViewById ( R . id . container ) ) ; if ( parentActivity instanceof ObservableScrollViewCallbacks ) { listView . setScrollViewCallbacks ( ( ObservableScrollViewCallbacks ) parentActivity ) ; } return view ; }
@ Override public void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; Intent myIntent = getIntent ( ) ; if ( Intent . ACTION_CREATE_SHORTCUT . equals ( myIntent . getAction ( ) ) ) { setResult ( RESULT_OK , getShortcutIntent ( ) ) ; } finish ( ) ; }
private Intent getShortcutIntent ( ) { final Uri uri = MyTabActivityBase . getDefaultTabUri ( MyRecentStopsFragment . TAB_NAME ) ; return UIUtils . makeShortcut ( this , getString ( R . string . recent_stops_shortcut ) , new Intent ( this , MyStopsActivity .class ) . setData ( uri ) ) ; }
public PathAssert ( Path actual ) { super( actual , PathAssert .class ); }
public PathAssert hasFillType ( Path . FillType type ) { isNotNull ( ) ; Path . FillType actualType = actual . getFillType ( ) ; assertThat ( actualType ) . overridingErrorMessage ( "Expected fill type <%s> but was <%s>." , type , actualType ) . isEqualTo ( type ) ; return this ; }
public PathAssert isEmpty ( ) { isNotNull ( ) ; assertThat ( actual . isEmpty ( ) ) . overridingErrorMessage ( "Expected to be empty but was not." ) . isTrue ( ) ; return this ; }
public PathAssert isNotEmpty ( ) { isNotNull ( ) ; assertThat ( actual . isEmpty ( ) ) . overridingErrorMessage ( "Expected to not be empty but was." ) . isFalse ( ) ; return this ; }
@ Override protected SimpleCursorAdapter newAdapter ( ) { return QueryUtils . RouteList . newAdapter ( getActivity ( ) ) ; }
@ Override protected Uri getContentUri ( ) { return ObaContract . Routes . CONTENT_URI ; }
@ Override public void onListItemClick ( ListView l , View v , int position , long id ) { SimpleCursorAdapter cursorAdapter = ( SimpleCursorAdapter ) l . getAdapter ( ) ; Cursor c = cursorAdapter . getCursor ( ) ; c . moveToPosition ( position - l . getHeaderViewsCount ( ) ) ; final String routeId = c . getString ( COL_ID ) ; final String routeName = c . getString ( COL_SHORTNAME ) ; if ( isShortcutMode ( ) ) { final Intent shortcut = UIUtils . makeShortcut ( getActivity ( ) , routeName , RouteInfoActivity . makeIntent ( getActivity ( ) , routeId ) ) ; Activity activity = getActivity ( ) ; activity . setResult ( Activity . RESULT_OK , shortcut ) ; activity . finish ( ) ; } else { RouteInfoActivity . start ( getActivity ( ) , routeId ) ; } }
@ Override public void onCreateContextMenu ( ContextMenu menu , View v , ContextMenuInfo menuInfo ) { super. onCreateContextMenu ( menu , v , menuInfo ) ; AdapterContextMenuInfo info = ( AdapterContextMenuInfo ) menuInfo ; final TextView text = ( TextView ) info . targetView . findViewById ( R . id . short_name ) ; menu . setHeaderTitle ( getString ( R . string . route_name , text . getText ( ) ) ) ; if ( isShortcutMode ( ) ) { menu . add ( 0 , CONTEXT_MENU_DEFAULT , 0 , R . string . my_context_create_shortcut ) ; } else { menu . add ( 0 , CONTEXT_MENU_DEFAULT , 0 , R . string . my_context_get_route_info ) ; } menu . add ( 0 , CONTEXT_MENU_SHOW_ON_MAP , 0 , R . string . my_context_showonmap ) ; final String url = QueryUtils . RouteList . getUrl ( getListView ( ) , info . position ) ; if ( ! TextUtils . isEmpty ( url ) ) { menu . add ( 0 , CONTEXT_MENU_SHOW_URL , 0 , R . string . my_context_show_schedule ) ; } }
@ Override public boolean onContextItemSelected ( MenuItem item ) { AdapterContextMenuInfo info = ( AdapterContextMenuInfo ) item . getMenuInfo ( ) ; switch ( item . getItemId ( ) ) { case CONTEXT_MENU_DEFAULT : onListItemClick ( getListView ( ) , info . targetView , info . position , info . id ) ; return true ; case CONTEXT_MENU_SHOW_ON_MAP : HomeActivity . start ( getActivity ( ) , QueryUtils . RouteList . getId ( getListView ( ) , info . position ) ) ; return true ; case CONTEXT_MENU_SHOW_URL : UIUtils . goToUrl ( getActivity ( ) , QueryUtils . RouteList . getUrl ( getListView ( ) , info . position ) ) ; return true ; default: return super. onContextItemSelected ( item ) ; } }
abstract protected int getEmptyText ( )
public BluetoothGattServiceAssert ( BluetoothGattService actual ) { super( actual , BluetoothGattServiceAssert .class ); }
public BluetoothGattServiceAssert hasInstanceId ( int id ) { isNotNull ( ) ; int actualId = actual . getInstanceId ( ) ; assertThat ( actualId ) . overridingErrorMessage ( "Expected instance ID <%s> but was <%s>" , id , actualId ) . isEqualTo ( id ) ; return this ; }
public BluetoothGattServiceAssert hasType ( @ BluetoothGattServiceType int type ) { isNotNull ( ) ; int actualType = actual . getType ( ) ; assertThat ( actualType ) . overridingErrorMessage ( "Expected type <%s> but was <%s>." , typeToString ( type ) , typeToString ( actualType ) ) . isEqualTo ( type ) ; return this ; }
public BluetoothGattServiceAssert hasUuid ( UUID uuid ) { isNotNull ( ) ; UUID actualUuid = actual . getUuid ( ) ; assertThat ( actualUuid ) . overridingErrorMessage ( "Expected UUID <%s> but was <%s>." , uuid , actualUuid ) . isEqualTo ( uuid ) ; return this ; }
public static String typeToString ( @ BluetoothGattServiceType int type ) { return buildNamedValueString ( type ) . value ( SERVICE_TYPE_PRIMARY , "primary" ) . value ( SERVICE_TYPE_SECONDARY , "secondary" ) . get ( ) ; }
protected final DependencyResolver getDependencyResolver ( ) { return new DependencyResolver ( new MavenToPlexusLogAdapter ( getLog ( ) ) , dependencyGraphBuilder ) ; }
protected Set < Artifact > getRelevantCompileArtifacts ( ) { final List < Artifact > allArtifacts = project . getCompileArtifacts ( ) ; return getArtifactResolverHelper ( ) . getFilteredArtifacts ( allArtifacts ) ; }
protected Set < Artifact > getDirectDependencyArtifacts ( ) { final Set < Artifact > allArtifacts = project . getDependencyArtifacts ( ) ; return getArtifactResolverHelper ( ) . getFilteredArtifacts ( allArtifacts ) ; }
protected Set < Artifact > getTransitiveDependencyArtifacts ( String ... types ) { return getArtifactResolverHelper ( ) . getFilteredArtifacts ( project . getArtifacts ( ) , types ) ; }
protected Set < Artifact > getTransitiveDependencyArtifacts ( List < String > filteredScopes , String ... types ) { return getArtifactResolverHelper ( ) . getFilteredArtifacts ( filteredScopes , project . getArtifacts ( ) , types ) ; }
protected File resolveArtifactToFile ( Artifact artifact ) throws MojoExecutionException { return getArtifactResolverHelper ( ) . resolveArtifactToFile ( artifact ) ; }
protected AndroidDebugBridge initAndroidDebugBridge ( ) MojoExecutionException { synchronized ( ADB_LOCK ) { if ( ! adbInitialized ) { DdmPreferences . setTimeOut ( adbConnectionTimeout ) ; AndroidDebugBridge . init ( false ) ; adbInitialized = true ; } AndroidDebugBridge androidDebugBridge = AndroidDebugBridge . createBridge ( getAndroidSdk ( ) . getAdbPath ( ) , false ) ; waitUntilConnected ( androidDebugBridge ) ; return androidDebugBridge ; } }
private void waitUntilConnected ( AndroidDebugBridge adb ) { int trials = 10 ; final int connectionWaitTime = 50 ; while ( trials > 0 ) { try { Thread . sleep ( connectionWaitTime ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } if ( adb . isConnected ( ) ) { break; } trials -- ; } }
protected void waitForInitialDeviceList ( final AndroidDebugBridge androidDebugBridge ) throws MojoExecutionException { if ( ! androidDebugBridge . hasInitialDeviceList ( ) ) { getLog ( ) . info ( "Waiting for initial device list from the Android Debug Bridge" ) ; long limitTime = System . currentTimeMillis ( ) + ADB_TIMEOUT_MS ; while ( ! androidDebugBridge . hasInitialDeviceList ( ) && ( System . currentTimeMillis ( ) < limitTime ) ) { try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { throw new MojoExecutionException ( "Interrupted waiting for initial device list from Android Debug Bridge" ) ; } } if ( ! androidDebugBridge . hasInitialDeviceList ( ) ) { getLog ( ) . error ( "Did not receive initial device list from the Android Debug Bridge." ) ; } } }
protected void deployApk ( final File apkFile ) throws MojoExecutionException , MojoFailureException { if ( undeployBeforeDeploy ) { undeployApk ( apkFile ) ; } doWithDevices ( new DeviceCallback ( ) { public void doWithDevice ( final IDevice device ) throws MojoExecutionException { String deviceLogLinePrefix = DeviceHelper . getDeviceLogLinePrefix ( device ) ; try { device . installPackage ( apkFile . getAbsolutePath ( ) , true ) ; getLog ( ) . info ( deviceLogLinePrefix + "Successfully installed " + apkFile . getAbsolutePath ( ) ) ; getLog ( ) . debug ( " to " + DeviceHelper . getDescriptiveName ( device ) ) ; } catch ( InstallException e ) { throw new MojoExecutionException ( deviceLogLinePrefix + "Install of " + apkFile . getAbsolutePath ( ) + " failed." , e ) ; } } } ) ; }
public void doWithDevice ( final IDevice device ) throws MojoExecutionException { String deviceLogLinePrefix = DeviceHelper . getDeviceLogLinePrefix ( device ) ; try { device . installPackage ( apkFile . getAbsolutePath ( ) , true ) ; getLog ( ) . info ( deviceLogLinePrefix + "Successfully installed " + apkFile . getAbsolutePath ( ) ) ; getLog ( ) . debug ( " to " + DeviceHelper . getDescriptiveName ( device ) ) ; } catch ( InstallException e ) { throw new MojoExecutionException ( deviceLogLinePrefix + "Install of " + apkFile . getAbsolutePath ( ) + " failed." , e ) ; } }
protected void deployDependencies ( ) MojoExecutionException , MojoFailureException { Set < Artifact > directDependentArtifacts = project . getDependencyArtifacts ( ) ; if ( directDependentArtifacts != null ) { for ( Artifact artifact : directDependentArtifacts ) { String type = artifact . getType ( ) ; if ( type . equals ( APK ) ) { getLog ( ) . debug ( "Detected apk dependency " + artifact + ". Will resolve and deploy to device..." ) ; final File targetApkFile = resolveArtifactToFile ( artifact ) ; getLog ( ) . debug ( "Deploying " + targetApkFile + " to device..." ) ; deployApk ( targetApkFile ) ; } } } }
protected void deployBuiltApk ( ) MojoExecutionException , MojoFailureException { if ( project . getPackaging ( ) . equals ( APK ) ) { File apkFile = new File ( targetDirectory , finalName + "." + APK ) ; deployApk ( apkFile ) ; } else { getLog ( ) . info ( "Project packaging is not apk, skipping deployment." ) ; } }
protected void doWithDevices ( final DeviceCallback deviceCallback )            throws MojoExecutionException , MojoFailureException { final AndroidDebugBridge androidDebugBridge = initAndroidDebugBridge ( ) ; if ( ! androidDebugBridge . isConnected ( ) ) { throw new MojoExecutionException ( "Android Debug Bridge is not connected." ) ; } waitForInitialDeviceList ( androidDebugBridge ) ; List < IDevice > devices = Arrays . asList ( androidDebugBridge . getDevices ( ) ) ; int numberOfDevices = devices . size ( ) ; getLog ( ) . debug ( "Found " + numberOfDevices + " devices connected with the Android Debug Bridge" ) ; if ( devices . size ( ) == 0 ) { throw new MojoExecutionException ( "No online devices attached." ) ; } int threadCount = getDeviceThreads ( ) ; if ( getDeviceThreads ( ) == 0 ) { getLog ( ) . info ( "android.devicesThreads parameter not set, using a thread for each attached device" ) ; threadCount = numberOfDevices ; } else { getLog ( ) . info ( "android.devicesThreads parameter set to " + getDeviceThreads ( ) ) ; } boolean shouldRunOnAllDevices = getDevices ( ) . size ( ) == 0 ; if ( shouldRunOnAllDevices ) { getLog ( ) . info ( "android.devices parameter not set, using all attached devices" ) ; } else { getLog ( ) . info ( "android.devices parameter set to " + getDevices ( ) . toString ( ) ) ; } ArrayList < DoThread > doThreads = new ArrayList < DoThread > ( ) ; ExecutorService executor = Executors . newFixedThreadPool ( threadCount ) ; for ( final IDevice idevice : devices ) { if ( shouldRunOnAllDevices ) { String deviceType = idevice . isEmulator ( ) ? "Emulator " : "Device " ; getLog ( ) . info ( deviceType + DeviceHelper . getDescriptiveName ( idevice ) + " found." ) ; } if ( shouldRunOnAllDevices || shouldDoWithThisDevice ( idevice ) ) { DoThread deviceDoThread = new DoThread ( ) { public void runDo ( ) MojoFailureException , MojoExecutionException { deviceCallback . doWithDevice ( idevice ) ; } } ; doThreads . add ( deviceDoThread ) ; executor . execute ( deviceDoThread ) ; } } executor . shutdown ( ) ; while ( ! executor . isTerminated ( ) ) { } throwAnyDoThreadErrors ( doThreads ) ; if ( ! shouldRunOnAllDevices && doThreads . isEmpty ( ) ) { throw new MojoExecutionException ( "No device found for android.device=" + getDevices ( ) . toString ( ) ) ; } }
public void runDo ( ) MojoFailureException , MojoExecutionException { deviceCallback . doWithDevice ( idevice ) ; }
private void throwAnyDoThreadErrors ( ArrayList < DoThread > doThreads ) throws MojoExecutionException , MojoFailureException { for ( DoThread deviceDoThread : doThreads ) { if ( deviceDoThread . failure != null ) { throw deviceDoThread . failure ; } if ( deviceDoThread . execution != null ) { throw deviceDoThread . execution ; } } }
private boolean shouldDoWithThisDevice ( IDevice idevice ) throws MojoExecutionException , MojoFailureException { for ( String device : getDevices ( ) ) { if ( "emulator" . equals ( device ) && idevice . isEmulator ( ) ) { return true ; } if ( "usb" . equals ( device ) && ! idevice . isEmulator ( ) ) { return true ; } if ( idevice . isEmulator ( ) && ( device . equalsIgnoreCase ( idevice . getAvdName ( ) ) || device . equalsIgnoreCase ( idevice . getSerialNumber ( ) ) ) ) { return true ; } if ( ! idevice . isEmulator ( ) && device . equals ( idevice . getSerialNumber ( ) ) ) { return true ; } } return false ; }
protected boolean undeployApk ( File apkFile ) throws MojoExecutionException , MojoFailureException { final String packageName ; packageName = extractPackageNameFromApk ( apkFile ) ; return undeployApk ( packageName ) ; }
protected boolean undeployApk ( final String packageName ) throws MojoExecutionException , MojoFailureException { final AtomicBoolean result = new AtomicBoolean ( true ) ; doWithDevices ( new DeviceCallback ( ) { public void doWithDevice ( final IDevice device ) throws MojoExecutionException { String deviceLogLinePrefix = DeviceHelper . getDeviceLogLinePrefix ( device ) ; try { device . uninstallPackage ( packageName ) ; getLog ( ) . info ( deviceLogLinePrefix + "Successfully uninstalled " + packageName ) ; getLog ( ) . debug ( " from " + DeviceHelper . getDescriptiveName ( device ) ) ; result . set ( true ) ; } catch ( InstallException e ) { result . set ( false ) ; throw new MojoExecutionException ( deviceLogLinePrefix + "Uninstall of " + packageName + " failed." , e ) ; } } } ) ; return result . get ( ) ; }
public void doWithDevice ( final IDevice device ) throws MojoExecutionException { String deviceLogLinePrefix = DeviceHelper . getDeviceLogLinePrefix ( device ) ; try { device . uninstallPackage ( packageName ) ; getLog ( ) . info ( deviceLogLinePrefix + "Successfully uninstalled " + packageName ) ; getLog ( ) . debug ( " from " + DeviceHelper . getDescriptiveName ( device ) ) ; result . set ( true ) ; } catch ( InstallException e ) { result . set ( false ) ; throw new MojoExecutionException ( deviceLogLinePrefix + "Uninstall of " + packageName + " failed." , e ) ; } }
protected String extractPackageNameFromApk ( File apkFile ) throws MojoExecutionException { CommandExecutor executor = CommandExecutor . Factory . createDefaultCommmandExecutor ( ) ; executor . setLogger ( this . getLog ( ) ) ; executor . setCaptureStdOut ( true ) ; executor . setCaptureStdErr ( true ) ; AaptCommandBuilder commandBuilder = AaptCommandBuilder . dump ( getLog ( ) ) . xmlTree ( ) . setPathToApk ( apkFile . getAbsolutePath ( ) ) . addAssetFile ( "AndroidManifest.xml" ) ; getLog ( ) . info ( getAndroidSdk ( ) . getAaptPath ( ) + " " + commandBuilder . toString ( ) ) ; try { executor . executeCommand ( getAndroidSdk ( ) . getAaptPath ( ) , commandBuilder . build ( ) , false ) ; final String xmlTree = executor . getStandardOut ( ) ; return extractPackageNameFromAndroidManifestXmlTree ( xmlTree ) ; } catch ( ExecutionException e ) { throw new MojoExecutionException ( "Error while trying to figure out package name from inside apk file " + apkFile ) ; } finally { String errout = executor . getStandardError ( ) ; if ( ( errout != null ) && ( errout . trim ( ) . length ( ) > 0 ) ) { getLog ( ) . error ( errout ) ; } } }
protected String extractPackageNameFromAndroidManifestXmlTree ( String aaptDumpXmlTree ) { final Scanner scanner = new Scanner ( aaptDumpXmlTree ) ; scanner . findWithinHorizon ( "^E: manifest" , 0 ) ; scanner . findWithinHorizon ( "  A: package=\"" , 0 ) ; String packageName = scanner . next ( ".*?\"" ) ; packageName = packageName . substring ( 0 , packageName . length ( ) - 1 ) ; return packageName ; }
protected String extractPackageNameFromAndroidArtifact ( Artifact artifact ) throws MojoExecutionException { final File unpackedLibFolder = getUnpackedLibFolder ( artifact ) ; final File manifest = new File ( unpackedLibFolder , "AndroidManifest.xml" ) ; if ( ! manifest . exists ( ) ) { throw new MojoExecutionException ( "AndroidManifest.xml file wasn't found in next place: " + unpackedLibFolder ) ; } return extractPackageNameFromAndroidManifest ( manifest ) ; }
protected String extractPackageNameFromAndroidManifest ( File manifestFile ) { return new DefaultManifestParser ( manifestFile ) . getPackage ( ) ; }
protected final String getAndroidManifestPackageName ( ) { return extractPackageNameFromAndroidManifest ( destinationManifestFile ) ; }
protected String extractInstrumentationRunnerFromAndroidManifest ( File manifestFile )            throws MojoExecutionException { final URL xmlURL ; try { xmlURL = manifestFile . toURI ( ) . toURL ( ) ; } catch ( MalformedURLException e ) { throw new MojoExecutionException ( "Error while trying to figure out instrumentation runner from inside AndroidManifest.xml file " + manifestFile , e ) ; } final DocumentContainer documentContainer = new DocumentContainer ( xmlURL ) ; final Object instrumentationRunner ; try { instrumentationRunner = JXPathContext . newContext ( documentContainer ) . getValue ( "manifest , String .class ) ; } catch ( JXPathNotFoundException e ) { return null ; } return ( String ) instrumentationRunner ; }
protected final boolean isInstrumentationTest ( ) MojoExecutionException { return extractInstrumentationRunnerFromAndroidManifest ( destinationManifestFile ) != null ; }
protected AndroidSdk getAndroidSdk ( ) MojoExecutionException { File chosenSdkPath ; String chosenSdkPlatform ; String buildToolsVersion = null ; if ( sdk != null ) { buildToolsVersion = sdk . getBuildTools ( ) ; if ( sdk . getPath ( ) != null ) { chosenSdkPath = sdk . getPath ( ) ; } else { if ( sdkPath != null ) { chosenSdkPath = sdkPath ; } else { chosenSdkPath = new File ( getAndroidHomeOrThrow ( ) ) ; } } if ( ! isBlank ( sdk . getPlatform ( ) ) ) { chosenSdkPlatform = sdk . getPlatform ( ) ; } else { chosenSdkPlatform = sdkPlatform ; } } else { if ( sdkPath != null ) { chosenSdkPath = sdkPath ; } else { chosenSdkPath = new File ( getAndroidHomeOrThrow ( ) ) ; } chosenSdkPlatform = sdkPlatform ; } return new AndroidSdk ( chosenSdkPath , chosenSdkPlatform , buildToolsVersion ) ; }
protected Jack getJack ( ) { if ( jack == null ) { return new Jack ( super. getPluginContext ( ) ) ; } else { return jack ; } }
private String getAndroidHomeOrThrow ( ) MojoExecutionException { final String androidHome = System . getenv ( ENV_ANDROID_HOME ) ; if ( isBlank ( androidHome ) ) { throw new MojoExecutionException ( "No Android SDK path could be found. You may configure it in the " + "plugin configuration section in the pom file using <sdk><path>...</path></sdk> or " + "<properties><android.sdk.path>...</android.sdk.path></properties> or on command-line " + "using -Dandroid.sdk.path=... or by setting environment variable " + ENV_ANDROID_HOME ) ; } return androidHome ; }
protected final File getUnpackedLibsDirectory ( ) { return getUnpackedLibHelper ( ) . getUnpackedLibsFolder ( ) ; }
public final File getUnpackedLibFolder ( Artifact artifact ) { return getUnpackedLibHelper ( ) . getUnpackedLibFolder ( artifact ) ; }
protected final File getUnpackedAarClassesJar ( Artifact artifact ) { return getUnpackedLibHelper ( ) . getUnpackedClassesJar ( artifact ) ; }
protected final File getUnpackedApkLibSourceFolder ( Artifact artifact ) { return getUnpackedLibHelper ( ) . getUnpackedApkLibSourceFolder ( artifact ) ; }
protected final File getUnpackedLibResourceFolder ( Artifact artifact ) { return getUnpackedLibHelper ( ) . getUnpackedLibResourceFolder ( artifact ) ; }
protected final File getUnpackedLibAssetsFolder ( Artifact artifact ) { return getUnpackedLibHelper ( ) . getUnpackedLibAssetsFolder ( artifact ) ; }
public final File getUnpackedLibNativesFolder ( Artifact artifact ) { return getUnpackedLibHelper ( ) . getUnpackedLibNativesFolder ( artifact ) ; }
public static File getLibraryUnpackDirectory ( File unpackedApkLibsDirectory , Artifact artifact ) { return new File ( unpackedApkLibsDirectory . getAbsolutePath ( ) , artifact . getArtifactId ( ) ) ; }
protected AndroidNdk getAndroidNdk ( ) MojoExecutionException { File chosenNdkPath ; if ( ndkPath != null ) { chosenNdkPath = ndkPath ; } else if ( ndk != null && ndk . getPath ( ) != null ) { chosenNdkPath = ndk . getPath ( ) ; } else { chosenNdkPath = new File ( getAndroidNdkHomeOrThrow ( ) ) ; } return new AndroidNdk ( chosenNdkPath ) ; }
private String getAndroidNdkHomeOrThrow ( ) MojoExecutionException { final String androidHome = System . getenv ( ENV_ANDROID_NDK_HOME ) ; if ( isBlank ( androidHome ) ) { throw new MojoExecutionException ( "No Android NDK path could be found. You may configure it in the pom " + "using <ndk><path>...</path></ndk> or <properties><ndk.path>...</ndk.path></properties> or on " + "command-line using -Dandroid.ndk.path=... or by setting environment variable " + ENV_ANDROID_NDK_HOME ) ; } return androidHome ; }
public File [] getResourceOverlayDirectories ( ) { File [] overlayDirectories ; if ( resourceOverlayDirectories == null || resourceOverlayDirectories . length == 0 ) { overlayDirectories = new File [] { resourceOverlayDirectory } ; } else { overlayDirectories = resourceOverlayDirectories ; } return overlayDirectories ; }
private Set < String > getDevices ( ) { Set < String > list = new HashSet < String > ( ) ; if ( StringUtils . isNotBlank ( device ) ) { list . add ( device ) ; } list . addAll ( Arrays . asList ( devices ) ) ; list . addAll ( Arrays . asList ( ips ) ) ; return list ; }
private int getDeviceThreads ( ) { return deviceThreads ; }
public final void run ( ) { try { runDo ( ) ; } catch ( MojoFailureException e ) { failure = e ; } catch ( MojoExecutionException e ) { execution = e ; } }
protected abstract void runDo ( ) MojoFailureException , MojoExecutionException ;
protected final boolean isAPKBuild ( ) { return getUnpackedLibHelper ( ) . isAPKBuild ( project ) ; }
protected final void copyFolder ( File sourceFolder , File targetFolder ) throws MojoExecutionException { copyFolder ( sourceFolder , targetFolder , TrueFileFilter . TRUE ) ; }
private void copyFolder ( File sourceFolder , File targetFolder , FileFilter filter ) throws MojoExecutionException { if ( ! sourceFolder . exists ( ) ) { return; } try { getLog ( ) . debug ( "Copying " + sourceFolder + " to " + targetFolder ) ; if ( ! targetFolder . exists ( ) ) { if ( ! targetFolder . mkdirs ( ) ) { throw new MojoExecutionException ( "Could not create target directory " + targetFolder ) ; } } FileUtils . copyDirectory ( sourceFolder , targetFolder , filter ) ; } catch ( IOException e ) { throw new MojoExecutionException ( "Could not copy source folder to target folder" , e ) ; } }
protected final UnpackedLibHelper getUnpackedLibHelper ( ) { if ( unpackedLibHelper == null ) { unpackedLibHelper = new UnpackedLibHelper ( getArtifactResolverHelper ( ) , project , new MavenToPlexusLogAdapter ( getLog ( ) ) , unpackedLibsFolder ) ; } return unpackedLibHelper ; }
protected final ArtifactResolverHelper getArtifactResolverHelper ( ) { if ( artifactResolverHelper == null ) { artifactResolverHelper = new ArtifactResolverHelper ( artifactResolver , new MavenToPlexusLogAdapter ( getLog ( ) ) , project . getRemoteArtifactRepositories ( ) ) ; } return artifactResolverHelper ; }
protected final NativeHelper getNativeHelper ( ) { if ( nativeHelper == null ) { nativeHelper = new NativeHelper ( project , dependencyGraphBuilder , getLog ( ) ) ; } return nativeHelper ; }
void onLocationChanged ( Location location );
public LocationHelper ( Context context ) { mContext = context ; mLocationManager = ( LocationManager ) Application . get ( ) . getBaseContext ( ) . getSystemService ( Context . LOCATION_SERVICE ) ; setupGooglePlayServices ( ) ; }
public synchronized void registerListener ( Listener listener ) { if ( ! mListeners . contains ( listener ) ) { mListeners . add ( listener ) ; } if ( mListeners . size ( ) == 1 ) { try { registerAllProviders ( ) ; } catch ( SecurityException e ) { Log . e ( TAG , "User may have denied location permission - " + e ) ; maybeShowSecurityDialog ( ) ; } } }
public synchronized void unregisterListener ( Listener listener ) { if ( mListeners . contains ( listener ) ) { mListeners . remove ( listener ) ; } if ( mListeners . size ( ) == 0 ) { mLocationManager . removeUpdates ( this ) ; } }
public GoogleApiClient getGoogleApiClient ( ) { return mGoogleApiClient ; }
public synchronized void onResume ( ) { try { registerAllProviders ( ) ; } catch ( SecurityException e ) { Log . e ( TAG , "User may have denied location permission - " + e ) ; maybeShowSecurityDialog ( ) ; } }
public synchronized void onPause ( ) { try { mLocationManager . removeUpdates ( this ) ; if ( mGoogleApiClient != null && mGoogleApiClient . isConnected ( ) ) { FusedLocationApi . removeLocationUpdates ( mGoogleApiClient , this ) ; mGoogleApiClient . disconnect ( ) ; } } catch ( SecurityException e ) { Log . e ( TAG , "User may have denied location permission - " + e ) ; maybeShowSecurityDialog ( ) ; } }
@ Override public void onLocationChanged ( Location location ) { Application . setLastKnownLocation ( location ) ; Location lastLocation = Application . getLastKnownLocation ( mContext , mGoogleApiClient ) ; if ( lastLocation != null ) { Location locationForListeners = new Location ( "for listeners" ) ; locationForListeners . set ( lastLocation ) ; for ( Listener l : mListeners ) { l . onLocationChanged ( locationForListeners ) ; } } }
@ Override public void onStatusChanged ( String provider , int status , Bundle extras ) {    }
@ Override public void onProviderEnabled ( String provider ) {    }
@ Override public void onProviderDisabled ( String provider ) {    }
private void registerAllProviders ( ) SecurityException { List < String > providers = mLocationManager . getProviders ( true ) ; for ( Iterator < String > i = providers . iterator ( ) ; i . hasNext ( ) ; ) { mLocationManager . requestLocationUpdates ( i . next ( ) , 0 , 0 , this ) ; } if ( mGoogleApiClient != null && ! mGoogleApiClient . isConnected ( ) ) { mGoogleApiClient . connect ( ) ; } }
private void setupGooglePlayServices ( ) { mLocationRequest = LocationRequest . create ( ) ; mLocationRequest . setPriority ( LocationRequest . PRIORITY_HIGH_ACCURACY ) ; mLocationRequest . setInterval ( UPDATE_INTERVAL ) ; mLocationRequest . setFastestInterval ( FASTEST_INTERVAL ) ; GoogleApiAvailability api = GoogleApiAvailability . getInstance ( ) ; if ( api . isGooglePlayServicesAvailable ( mContext ) == ConnectionResult . SUCCESS ) { mGoogleApiClient = new GoogleApiClient . Builder ( mContext ) . addApi ( LocationServices . API ) . addConnectionCallbacks ( this ) . addOnConnectionFailedListener ( this ) . build ( ) ; mGoogleApiClient . connect ( ) ; } }
private void maybeShowSecurityDialog ( ) { if ( mContext != null && UIUtils . canManageDialog ( mContext ) ) { final SharedPreferences sp = Application . getPrefs ( ) ; if ( ! sp . getBoolean ( PREFERENCE_SHOWED_DIALOG , false ) ) { final AlertDialog . Builder builder = new AlertDialog . Builder ( mContext ) ; builder . setTitle ( R . string . location_security_exception_title ) ; builder . setCancelable ( false ) ; builder . setPositiveButton ( R . string . ok , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int which ) { sp . edit ( ) . putBoolean ( PREFERENCE_SHOWED_DIALOG , true ) . commit ( ) ; } } ) ; builder . setMessage ( R . string . location_security_exception_message ) ; builder . create ( ) . show ( ) ; } } }
public void onClick ( DialogInterface dialog , int which ) { sp . edit ( ) . putBoolean ( PREFERENCE_SHOWED_DIALOG , true ) . commit ( ) ; }
@ Override public void onConnected ( Bundle bundle ) { Log . d ( TAG , "Location Services connected" ) ; try { FusedLocationApi . requestLocationUpdates ( mGoogleApiClient , mLocationRequest , this ) ; } catch ( SecurityException e ) { Log . e ( TAG , "User may have denied location permission - " + e ) ; maybeShowSecurityDialog ( ) ; } }
@ Override public void onConnectionSuspended ( int i ) {    }
@ Override public void onConnectionFailed ( ConnectionResult connectionResult ) {    }
public ActionModeAssert ( ActionMode actual ) { super( actual , ActionModeAssert .class ); }
public ActionModeAssert hasCustomView ( ) { isNotNull ( ) ; assertThat ( actual . getCustomView ( ) ) . overridingErrorMessage ( "Expected custom view but was not present." ) . isNotNull ( ) ; return this ; }
public ActionModeAssert hasCustomView ( View view ) { isNotNull ( ) ; View actualView = actual . getCustomView ( ) ; assertThat ( actualView ) . overridingErrorMessage ( "Expected custom view <%s> but was <%s>." , view , actualView ) . isEqualTo ( view ) ; return this ; }
public ActionModeAssert hasSubtitle ( CharSequence subtitle ) { isNotNull ( ) ; CharSequence actualSubtitle = actual . getSubtitle ( ) ; assertThat ( actualSubtitle ) . overridingErrorMessage ( "Expected subtitle <%s> but was <%s>." , subtitle , actualSubtitle ) . isEqualTo ( subtitle ) ; return this ; }
public ActionModeAssert hasTag ( Object tag ) { isNotNull ( ) ; Object actualTag = actual . getTag ( ) ; assertThat ( actualTag ) . overridingErrorMessage ( "Expected tag <%s> but was <%s>." , tag , actualTag ) . isEqualTo ( tag ) ; return this ; }
public ActionModeAssert hasTitle ( CharSequence title ) { isNotNull ( ) ; CharSequence actualTitle = actual . getTitle ( ) ; assertThat ( actualTitle ) . overridingErrorMessage ( "Expected title <%s> but was <%s>." , title , actualTitle ) . isEqualTo ( title ) ; return this ; }
public ActionModeAssert hasOptionalTitleHint ( ) { isNotNull ( ) ; assertThat ( actual . getTitleOptionalHint ( ) ) . overridingErrorMessage ( "Expected to have optional title hint but was not optional." ) . isTrue ( ) ; return this ; }
public ActionModeAssert hasNonOptionalTitleHint ( ) { isNotNull ( ) ; assertThat ( actual . getTitleOptionalHint ( ) ) . overridingErrorMessage ( "Expected to have non-optional title hint but was optional." ) . isFalse ( ) ; return this ; }
public ActionModeAssert hasOptionalTitle ( ) { isNotNull ( ) ; assertThat ( actual . isTitleOptional ( ) ) . overridingErrorMessage ( "Expected to have optional title but was not optional." ) . isTrue ( ) ; return this ; }
public ActionModeAssert hasNonOptionalTitle ( ) { isNotNull ( ) ; assertThat ( actual . isTitleOptional ( ) ) . overridingErrorMessage ( "Expected to have non-optional title but was optional." ) . isFalse ( ) ; return this ; }
public static void assertUriMatch ( Uri expectedUri , Map < String , String > expectedQuery , Uri actualUri ) { assertEquals ( expectedUri . getHost ( ) , actualUri . getHost ( ) ) ; assertEquals ( expectedUri . getScheme ( ) , actualUri . getScheme ( ) ) ; assertEquals ( expectedUri . getPath ( ) , actualUri . getPath ( ) ) ; if ( expectedQuery != null ) { for ( Map . Entry < String , String > entry : expectedQuery . entrySet ( ) ) { String expectedValue = entry . getValue ( ) ; String actualValue = actualUri . getQueryParameter ( entry . getKey ( ) ) ; if ( "*" . equals ( expectedValue ) ) { assertNotNull ( "URI missing key \"" + entry . getKey ( ) + "\"" , actualValue ) ; } else { assertEquals ( "URI mismatch on query key \"" + entry . getKey ( ) + "\"" , expectedValue , actualValue ) ; } } } }
public static void assertUriMatch ( Uri expectedUri , Map < String , String > expectedQuery , RequestBase actualRequest ) { Uri actualUri ; try { actualUri = getUriFromRequest ( actualRequest ) ; } catch ( Exception e ) { fail ( "Exception thrown reflecting on RequestBase: " + e . getMessage ( ) ) ; return; } assertUriMatch ( expectedUri , expectedQuery , actualUri ) ; }
public static void assertUriMatch ( Uri expectedUri , RequestBase actualRequest ) { assertUriMatch ( expectedUri , null , actualRequest ) ; }
public static void assertUriMatch ( String expectedUriString , RequestBase actualRequest ) { assertUriMatch ( Uri . parse ( expectedUriString ) , null , actualRequest ) ; }
public static void assertUriMatch ( String expectedUriString , Map < String , String > expectedQuery , RequestBase actualRequest ) { assertUriMatch ( Uri . parse ( expectedUriString ) , expectedQuery , actualRequest ) ; }
protected static Uri getUriFromRequest ( RequestBase actualRequest )            throws NoSuchFieldException , IllegalAccessException { Field uriField = RequestBase .class . getDeclaredField ( "mUri" ) ; uriField . setAccessible ( true ) ; Uri actualUri = ( Uri ) uriField . get ( actualRequest ) ; return actualUri ; }
public ApiDemosSampleIT ( MavenRuntimeBuilder builder ) throws Exception { this . mavenRuntime = builder . build ( ) ; }
@ Test public void buildDeployAndRun ( ) Exception { File basedir = resources . getBasedir ( "apidemos-android-16" ) ; MavenExecutionResult result = mavenRuntime . forProject ( basedir ) . execute ( "clean" , PluginInfo . getQualifiedGoal ( "undeploy" ) , "install" ) ; result . assertErrorFreeLog ( ) ; result . assertLogText ( "Successfully uninstalled" ) ; result . assertLogText ( "Successfully installed" ) ; result . assertLogText ( "Running instrumentation tests in com.example.android.apis.tests" ) ; result . assertLogText ( "Tests run: 7,  Failures: 0,  Errors: 0" ) ; }
@ Override public void onCreate ( ) { mThreadPool = Executors . newSingleThreadExecutor ( ) ; mNM = ( NotificationManager ) getSystemService ( NOTIFICATION_SERVICE ) ; mNotifications = new ConcurrentHashMap < Integer , Notification > ( ) ; }
@ Override public void onDestroy ( ) { if ( mThreadPool != null ) { mThreadPool . shutdownNow ( ) ; } }
@ Override public void onStart ( Intent intent , int startId ) { handleCommand ( intent , startId ) ; }
@ Override public int onStartCommand ( Intent intent , int flags , int startId ) { return handleCommand ( intent , startId ) ; }
public TaskContextImpl ( int startId ) { mStartId = startId ; }
@ Override public void taskComplete ( ) { if ( mNotifications . isEmpty ( ) ) { stopSelfResult ( mStartId ) ; } }
@ Override public void setNotification ( int id , Notification notification ) { mNotifications . put ( id , notification ) ; mNM . notify ( id , notification ) ; }
@ Override public void cancelNotification ( int id ) { mNM . cancel ( id ) ; mNotifications . remove ( id ) ; if ( mNotifications . isEmpty ( ) ) { stopSelf ( ) ; } }
private int handleCommand ( Intent intent , int startId ) { final String action = intent . getAction ( ) ; final TaskContextImpl taskContext = new TaskContextImpl ( startId ) ; final Uri uri = intent . getData ( ) ; if ( ACTION_SCHEDULE . equals ( action ) ) { mThreadPool . submit ( new SchedulerTask ( this , taskContext , uri ) ) ; return START_REDELIVER_INTENT ; } else if ( ACTION_POLL . equals ( action ) ) { mThreadPool . submit ( new PollerTask ( this , taskContext , uri ) ) ; return START_NOT_STICKY ; } else if ( ACTION_NOTIFY . equals ( action ) ) { String notifyText = intent . getStringExtra ( NOTIFY_TEXT ) ; mThreadPool . submit ( new NotifierTask ( this , taskContext , uri , notifyText ) ) ; return START_REDELIVER_INTENT ; } else if ( ACTION_CANCEL . equals ( action ) ) { mThreadPool . submit ( new CancelNotifyTask ( this , taskContext , uri ) ) ; return START_NOT_STICKY ; } else { Log . e ( TAG , "Unknown action: " + action ) ; return START_NOT_STICKY ; } }
@ Override public IBinder onBind ( Intent arg0 ) { return mBinder ; }
@ Override protected boolean onTransact ( int code , Parcel data , Parcel reply , int flags ) throws RemoteException { return super. onTransact ( code , data , reply , flags ) ; }
public static void scheduleAll ( Context context ) { final Intent intent = new Intent ( context , TripService .class ) ; intent . setAction ( TripService . ACTION_SCHEDULE ) ; intent . setData ( ObaContract . Trips . CONTENT_URI ) ; context . startService ( intent ) ; }
public static void pollTrip ( Context context , Uri alertUri , long triggerTime ) { Intent intent = new Intent ( TripService . ACTION_POLL , alertUri , context , AlarmReceiver .class ) ; PendingIntent alarmIntent = PendingIntent . getBroadcast ( context , 0 , intent , PendingIntent . FLAG_ONE_SHOT ) ; AlarmManager alarm = ( AlarmManager ) context . getSystemService ( Context . ALARM_SERVICE ) ; alarm . set ( AlarmManager . RTC_WAKEUP , triggerTime , alarmIntent ) ; }
public static void notifyTrip ( Context context , Uri alertUri , String notifyText ) { final Intent intent = new Intent ( context , TripService .class ) ; intent . setAction ( ACTION_NOTIFY ) ; intent . setData ( alertUri ) ; intent . putExtra ( NOTIFY_TEXT , notifyText ) ; context . startService ( intent ) ; }
public static String getRouteShortName ( Context context , String id ) { return UIUtils . stringForQuery ( context , Uri . withAppendedPath ( ObaContract . Routes . CONTENT_URI , id ) , ObaContract . Routes . SHORTNAME ) ; }
private Stops ( ) {        }
public static Uri insertOrUpdate ( String id , ContentValues values , boolean markAsUsed ) { ContentResolver cr = Application . get ( ) . getContentResolver ( ) ; final Uri uri = Uri . withAppendedPath ( CONTENT_URI , id ) ; Cursor c = cr . query ( uri , new String [] { USE_COUNT } , null , null , null ) ; Uri result ; if ( c != null && c . getCount ( ) > 0 ) { if ( markAsUsed ) { c . moveToFirst ( ) ; int count = c . getInt ( 0 ) ; values . put ( USE_COUNT , count + 1 ) ; values . put ( ACCESS_TIME , System . currentTimeMillis ( ) ) ; } cr . update ( uri , values , null , null ) ; result = uri ; } else { if ( markAsUsed ) { values . put ( USE_COUNT , 1 ) ; values . put ( ACCESS_TIME , System . currentTimeMillis ( ) ) ; } else { values . put ( USE_COUNT , 0 ) ; } values . put ( _ID , id ) ; result = cr . insert ( CONTENT_URI , values ) ; } if ( c != null ) { c . close ( ) ; } return result ; }
public static boolean markAsFavorite ( Context context , Uri uri , boolean favorite ) { ContentResolver cr = context . getContentResolver ( ) ; ContentValues values = new ContentValues ( ) ; values . put ( ObaContract . Stops . FAVORITE , favorite ? 1 : 0 ) ; return cr . update ( uri , values , null , null ) > 0 ; }
public static boolean markAsUnused ( Context context , Uri uri ) { ContentResolver cr = context . getContentResolver ( ) ; ContentValues values = new ContentValues ( ) ; values . put ( ObaContract . Stops . USE_COUNT , 0 ) ; values . putNull ( ObaContract . Stops . ACCESS_TIME ) ; return cr . update ( uri , values , null , null ) > 0 ; }
private Routes ( ) {        }
public static Uri insertOrUpdate ( Context context , String id , ContentValues values , boolean markAsUsed ) { ContentResolver cr = context . getContentResolver ( ) ; final Uri uri = Uri . withAppendedPath ( CONTENT_URI , id ) ; Cursor c = cr . query ( uri , new String [] { USE_COUNT } , null , null , null ) ; Uri result ; if ( c != null && c . getCount ( ) > 0 ) { if ( markAsUsed ) { c . moveToFirst ( ) ; int count = c . getInt ( 0 ) ; values . put ( USE_COUNT , count + 1 ) ; values . put ( ACCESS_TIME , System . currentTimeMillis ( ) ) ; } cr . update ( uri , values , null , null ) ; result = uri ; } else { if ( markAsUsed ) { values . put ( USE_COUNT , 1 ) ; values . put ( ACCESS_TIME , System . currentTimeMillis ( ) ) ; } else { values . put ( USE_COUNT , 0 ) ; } values . put ( _ID , id ) ; result = cr . insert ( CONTENT_URI , values ) ; } if ( c != null ) { c . close ( ) ; } return result ; }
protected static boolean markAsFavorite ( Context context , Uri uri , boolean favorite ) { ContentResolver cr = context . getContentResolver ( ) ; ContentValues values = new ContentValues ( ) ; values . put ( ObaContract . Routes . FAVORITE , favorite ? 1 : 0 ) ; return cr . update ( uri , values , null , null ) > 0 ; }
public static boolean markAsUnused ( Context context , Uri uri ) { ContentResolver cr = context . getContentResolver ( ) ; ContentValues values = new ContentValues ( ) ; values . put ( ObaContract . Routes . USE_COUNT , 0 ) ; values . putNull ( ObaContract . Routes . ACCESS_TIME ) ; return cr . update ( uri , values , null , null ) > 0 ; }
public static boolean isFavorite ( Context context , Uri routeUri ) { ContentResolver cr = context . getContentResolver ( ) ; String [] ROUTE_USER_PROJECTION = { ObaContract . Routes . FAVORITE } ; Cursor c = cr . query ( routeUri , ROUTE_USER_PROJECTION , null , null , null ) ; if ( c != null ) { try { if ( c . moveToNext ( ) ) { return ( c . getInt ( 0 ) == 1 ) ; } } finally { c . close ( ) ; } } return false ; }
private StopRouteFilters ( ) {        }
public static ArrayList < String > get ( Context context , String stopId ) { final String [] selection = { ROUTE_ID } ; final String [] selectionArgs = { stopId } ; ContentResolver cr = context . getContentResolver ( ) ; Cursor c = cr . query ( CONTENT_URI , selection , FILTER_WHERE , selectionArgs , null ) ; ArrayList < String > result = new ArrayList < String > ( ) ; if ( c != null ) { try { while ( c . moveToNext ( ) ) { result . add ( c . getString ( 0 ) ) ; } } finally { c . close ( ) ; } } return result ; }
public static void set ( Context context , String stopId , ArrayList < String > filter ) { if ( context == null ) { return; } final String [] selectionArgs = { stopId } ; ContentResolver cr = context . getContentResolver ( ) ; cr . delete ( CONTENT_URI , FILTER_WHERE , selectionArgs ) ; ContentValues args = new ContentValues ( ) ; args . put ( STOP_ID , stopId ) ; final int len = filter . size ( ) ; for ( int i = 0 ; i < len ; ++ i ) { args . put ( ROUTE_ID , filter . get ( i ) ) ; cr . insert ( CONTENT_URI , args ) ; } }
private Trips ( ) {        }
public static Uri buildUri ( String tripId , String stopId ) { return CONTENT_URI . buildUpon ( ) . appendPath ( tripId ) . appendPath ( stopId ) . build ( ) ; }
public static boolean [] daysToArray ( int days ) { final boolean [] result = { ( days & ObaContract . Trips . DAY_MON ) == ObaContract . Trips . DAY_MON , ( days & ObaContract . Trips . DAY_TUE ) == ObaContract . Trips . DAY_TUE , ( days & ObaContract . Trips . DAY_WED ) == ObaContract . Trips . DAY_WED , ( days & ObaContract . Trips . DAY_THU ) == ObaContract . Trips . DAY_THU , ( days & ObaContract . Trips . DAY_FRI ) == ObaContract . Trips . DAY_FRI , ( days & ObaContract . Trips . DAY_SAT ) == ObaContract . Trips . DAY_SAT , ( days & ObaContract . Trips . DAY_SUN ) == ObaContract . Trips . DAY_SUN ,} ; return result ; }
public static int arrayToDays ( boolean [] days ) { if ( days . length != 7 ) { throw new IllegalArgumentException ( "days.length must be 7" ) ; } int result = 0 ; for ( int i = 0 ; i < days . length ; ++ i ) { final int bit = days [ i ] ? 1 : 0 ; result |= bit << i ; } return result ; }
public static long convertDBToTime ( int minutes ) { Time t = new Time ( ) ; t . setToNow ( ) ; t . set ( 0 , minutes , 0 , t . monthDay , t . month , t . year ) ; return t . toMillis ( false ) ; }
public static int convertTimeToDB ( long departureTime ) { Time t = new Time ( ) ; t . set ( departureTime ) ; return t . hour * 60 + t . minute ; }
public static int getDayBit ( int weekday ) { switch ( weekday ) { case Time . MONDAY : return ObaContract . Trips . DAY_MON ; case Time . TUESDAY : return ObaContract . Trips . DAY_TUE ; case Time . WEDNESDAY : return ObaContract . Trips . DAY_WED ; case Time . THURSDAY : return ObaContract . Trips . DAY_THU ; case Time . FRIDAY : return ObaContract . Trips . DAY_FRI ; case Time . SATURDAY : return ObaContract . Trips . DAY_SAT ; case Time . SUNDAY : return ObaContract . Trips . DAY_SUN ; } return 0 ; }
private TripAlerts ( ) {        }
public static Uri buildUri ( int id ) { return CONTENT_URI . buildUpon ( ) . appendPath ( String . valueOf ( id ) ) . build ( ) ; }
public static Uri insertIfNotExists ( Context context , String tripId , String stopId , long startTime ) { return insertIfNotExists ( context . getContentResolver ( ) , tripId , stopId , startTime ) ; }
public static Uri insertIfNotExists ( ContentResolver cr , String tripId , String stopId , long startTime ) { Uri result ; Cursor c = cr . query ( CONTENT_URI , new String [] { _ID } , String . format ( "%s=? AND %s=? AND %s=?" , TRIP_ID , STOP_ID , START_TIME ) , new String [] { tripId , stopId , String . valueOf ( startTime ) } , null ) ; if ( c != null && c . moveToNext ( ) ) { result = buildUri ( c . getInt ( 0 ) ) ; } else { ContentValues values = new ContentValues ( ) ; values . put ( TRIP_ID , tripId ) ; values . put ( STOP_ID , stopId ) ; values . put ( START_TIME , startTime ) ; result = cr . insert ( CONTENT_URI , values ) ; } if ( c != null ) { c . close ( ) ; } return result ; }
public static void setState ( Context context , Uri uri , int state ) { setState ( context . getContentResolver ( ) , uri , state ) ; }
public static void setState ( ContentResolver cr , Uri uri , int state ) { ContentValues values = new ContentValues ( ) ; values . put ( STATE , state ) ; cr . update ( uri , values , null , null ) ; }
private ServiceAlerts ( ) {        }
public static Uri insertOrUpdate ( String id , ContentValues values , boolean markAsRead , Boolean hidden ) { if ( id == null ) { return null ; } if ( values == null ) { values = new ContentValues ( ) ; } ContentResolver cr = Application . get ( ) . getContentResolver ( ) ; final Uri uri = Uri . withAppendedPath ( CONTENT_URI , id ) ; Cursor c = cr . query ( uri , new String [] {} , null , null , null ) ; Uri result ; if ( c != null && c . getCount ( ) > 0 ) { if ( markAsRead ) { c . moveToFirst ( ) ; values . put ( MARKED_READ_TIME , System . currentTimeMillis ( ) ) ; } if ( hidden != null ) { c . moveToFirst ( ) ; if ( hidden ) { values . put ( HIDDEN , 1 ) ; } else { values . put ( HIDDEN , 0 ) ; } } if ( values . size ( ) != 0 ) { cr . update ( uri , values , null , null ) ; } result = uri ; } else { if ( markAsRead ) { values . put ( MARKED_READ_TIME , System . currentTimeMillis ( ) ) ; } if ( hidden != null ) { if ( hidden ) { values . put ( HIDDEN , 1 ) ; } else { values . put ( HIDDEN , 0 ) ; } } values . put ( _ID , id ) ; result = cr . insert ( CONTENT_URI , values ) ; } if ( c != null ) { c . close ( ) ; } return result ; }
public static boolean isHidden ( String situationId ) { final String [] selection = { _ID , HIDDEN } ; final String [] selectionArgs = { situationId , Integer . toString ( 1 ) } ; final String WHERE = _ID + "=? AND " + HIDDEN + "=?" ; ContentResolver cr = Application . get ( ) . getContentResolver ( ) ; Cursor c = cr . query ( CONTENT_URI , selection , WHERE , selectionArgs , null ) ; boolean hidden ; if ( c != null && c . getCount ( ) > 0 ) { hidden = true ; } else { hidden = false ; } if ( c != null ) { c . close ( ) ; } return hidden ; }
public static int showAllAlerts ( ) { ContentResolver cr = Application . get ( ) . getContentResolver ( ) ; ContentValues values = new ContentValues ( ) ; values . put ( HIDDEN , 0 ) ; return cr . update ( CONTENT_URI , values , null , null ) ; }
private Regions ( ) {        }
public static Uri buildUri ( int id ) { return ContentUris . withAppendedId ( CONTENT_URI , id ) ; }
public static Uri insertOrUpdate ( Context context , int id , ContentValues values ) { return insertOrUpdate ( context . getContentResolver ( ) , id , values ) ; }
public static Uri insertOrUpdate ( ContentResolver cr , int id , ContentValues values ) { final Uri uri = Uri . withAppendedPath ( CONTENT_URI , String . valueOf ( id ) ) ; Cursor c = cr . query ( uri , new String [] {} , null , null , null ) ; Uri result ; if ( c != null && c . getCount ( ) > 0 ) { cr . update ( uri , values , null , null ) ; result = uri ; } else { values . put ( _ID , id ) ; result = cr . insert ( CONTENT_URI , values ) ; } if ( c != null ) { c . close ( ) ; } return result ; }
public static ObaRegion get ( Context context , int id ) { return get ( context . getContentResolver ( ) , id ) ; }
public static ObaRegion get ( ContentResolver cr , int id ) { final String [] PROJECTION = { _ID , NAME , OBA_BASE_URL , SIRI_BASE_URL , LANGUAGE , CONTACT_EMAIL , SUPPORTS_OBA_DISCOVERY , SUPPORTS_OBA_REALTIME , SUPPORTS_SIRI_REALTIME , TWITTER_URL , EXPERIMENTAL , STOP_INFO_URL , OTP_BASE_URL , OTP_CONTACT_EMAIL } ; Cursor c = cr . query ( buildUri ( ( int ) id ) , PROJECTION , null , null , null ) ; if ( c != null ) { try { if ( c . getCount ( ) == 0 ) { return null ; } c . moveToFirst ( ) ; return new ObaRegionElement ( id , c . getString ( 1 ) , true , c . getString ( 2 ) , c . getString ( 3 ) , RegionBounds . getRegion ( cr , id ) , RegionOpen311Servers . getOpen311Server ( cr , id ) , c . getString ( 4 ) , c . getString ( 5 ) , c . getInt ( 6 ) > 0 , c . getInt ( 7 ) > 0 , c . getInt ( 8 ) > 0 , c . getString ( 9 ) , c . getInt ( 10 ) > 0 , c . getString ( 11 ) , c . getString ( 12 ) , c . getString ( 13 ) ) ; } finally { c . close ( ) ; } } return null ; }
private RegionBounds ( ) {        }
public static Uri buildUri ( int id ) { return ContentUris . withAppendedId ( CONTENT_URI , id ) ; }
public static ObaRegionElement . Bounds [] getRegion ( ContentResolver cr , int regionId ) { final String [] PROJECTION = { LATITUDE , LONGITUDE , LAT_SPAN , LON_SPAN } ; Cursor c = cr . query ( CONTENT_URI , PROJECTION , "(" + RegionBounds . REGION_ID + " = " + regionId + ")" , null , null ) ; if ( c != null ) { try { ObaRegionElement . Bounds [] results = new ObaRegionElement . Bounds [ c . getCount ( ) ] ; if ( c . getCount ( ) == 0 ) { return results ; } int i = 0 ; c . moveToFirst ( ) ; do { results [ i ] = new ObaRegionElement . Bounds ( c . getDouble ( 0 ) , c . getDouble ( 1 ) , c . getDouble ( 2 ) , c . getDouble ( 3 ) ) ; i ++ ; } while ( c . moveToNext ( ) ); return results ; } finally { c . close ( ) ; } } return null ; }
private RegionOpen311Servers ( ) {        }
public static Uri buildUri ( int id ) { return ContentUris . withAppendedId ( CONTENT_URI , id ) ; }
public static ObaRegionElement . Open311Server [] getOpen311Server ( ContentResolver cr , int regionId ) { final String [] PROJECTION = { JURISDICTION , API_KEY , BASE_URL } ; Cursor c = cr . query ( CONTENT_URI , PROJECTION , "(" + RegionOpen311Servers . REGION_ID + " = " + regionId + ")" , null , null ) ; if ( c != null ) { try { ObaRegionElement . Open311Server [] results = new ObaRegionElement . Open311Server [ c . getCount ( ) ] ; if ( c . getCount ( ) == 0 ) { return results ; } int i = 0 ; c . moveToFirst ( ) ; do { results [ i ] = new ObaRegionElement . Open311Server ( c . getString ( 0 ) , c . getString ( 1 ) , c . getString ( 2 ) ) ; i ++ ; } while ( c . moveToNext ( ) ); return results ; } finally { c . close ( ) ; } } return null ; }
private RouteHeadsignFavorites ( ) {        }
public static void markAsFavorite ( Context context , String routeId , String headsign , String stopId , boolean favorite ) { if ( context == null ) { return; } if ( headsign == null ) { headsign = "" ; } ContentResolver cr = context . getContentResolver ( ) ; Uri routeUri = Uri . withAppendedPath ( ObaContract . Routes . CONTENT_URI , routeId ) ; String stopIdInternal ; if ( stopId != null ) { stopIdInternal = stopId ; } else { stopIdInternal = ALL_STOPS ; } final String WHERE = ROUTE_ID + "=? AND " + HEADSIGN + "=? AND " + STOP_ID + "=?" ; final String [] selectionArgs = { routeId , headsign , stopIdInternal } ; if ( favorite ) { if ( stopIdInternal != ALL_STOPS ) { cr . delete ( CONTENT_URI , WHERE , selectionArgs ) ; } ContentValues values = new ContentValues ( ) ; values . put ( ROUTE_ID , routeId ) ; values . put ( HEADSIGN , headsign ) ; values . put ( STOP_ID , stopIdInternal ) ; values . put ( EXCLUDE , 0 ) ; cr . insert ( CONTENT_URI , values ) ; Routes . markAsFavorite ( context , routeUri , true ) ; } else { cr . delete ( CONTENT_URI , WHERE , selectionArgs ) ; if ( stopIdInternal == ALL_STOPS ) { final String [] selectionArgs2 = { routeId , headsign } ; final String WHERE2 = ROUTE_ID + "=? AND " + HEADSIGN + "=?" ; cr . delete ( CONTENT_URI , WHERE2 , selectionArgs2 ) ; } if ( ! isFavorite ( context , routeId ) ) { Routes . markAsFavorite ( context , routeUri , false ) ; } if ( stopIdInternal != ALL_STOPS && isFavorite ( routeId , headsign , stopId ) ) { ContentValues values = new ContentValues ( ) ; values . put ( ROUTE_ID , routeId ) ; values . put ( HEADSIGN , headsign ) ; values . put ( STOP_ID , stopIdInternal ) ; values . put ( EXCLUDE , 1 ) ; cr . insert ( CONTENT_URI , values ) ; } } StringBuilder analyicsLabel = new StringBuilder ( ) ; if ( favorite ) { analyicsLabel . append ( context . getString ( R . string . analytics_label_star_route ) ) ; } else { analyicsLabel . append ( context . getString ( R . string . analytics_label_unstar_route ) ) ; } analyicsLabel . append ( " " ) . append ( routeId ) . append ( "_" ) . append ( headsign ) . append ( " for " ) ; if ( stopId != null ) { analyicsLabel . append ( stopId ) ; } else { analyicsLabel . append ( "all stops" ) ; } ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , context . getString ( R . string . analytics_action_edit_field ) , analyicsLabel . toString ( ) ) ; }
public static boolean isFavorite ( String routeId , String headsign , String stopId ) { if ( headsign == null ) { headsign = "" ; } final String [] selection = { ROUTE_ID , HEADSIGN , STOP_ID , EXCLUDE } ; final String [] selectionArgs = { routeId , headsign , stopId , Integer . toString ( 0 ) } ; ContentResolver cr = Application . get ( ) . getContentResolver ( ) ; final String FILTER_WHERE_ALL_FIELDS = ROUTE_ID + "=? AND " + HEADSIGN + "=? AND " + STOP_ID + "=? AND " + EXCLUDE + "=?" ; Cursor c = cr . query ( CONTENT_URI , selection , FILTER_WHERE_ALL_FIELDS , selectionArgs , null ) ; boolean favorite ; if ( c != null && c . getCount ( ) > 0 ) { favorite = true ; } else { final String [] selectionArgs2 = { routeId , headsign , ALL_STOPS } ; String WHERE_PARTIAL = ROUTE_ID + "=? AND " + HEADSIGN + "=? AND " + STOP_ID + "=?" ; Cursor c2 = cr . query ( CONTENT_URI , selection , WHERE_PARTIAL , selectionArgs2 , null ) ; favorite = c2 != null && c2 . getCount ( ) > 0 ; if ( c2 != null ) { c2 . close ( ) ; } if ( favorite ) { final String [] selectionArgs3 = { routeId , headsign , stopId , Integer . toString ( 1 ) } ; Cursor c3 = cr . query ( CONTENT_URI , selection , FILTER_WHERE_ALL_FIELDS , selectionArgs3 , null ) ; boolean isStopExcluded = c3 != null && c3 . getCount ( ) > 0 ; favorite = ! isStopExcluded ; if ( c3 != null ) { c3 . close ( ) ; } } } if ( c != null ) { c . close ( ) ; } return favorite ; }
private static boolean isFavorite ( Context context , String routeId ) { final String [] selection = { ROUTE_ID , EXCLUDE } ; final String [] selectionArgs = { routeId , Integer . toString ( 0 ) } ; final String WHERE = ROUTE_ID + "=? AND " + EXCLUDE + "=?" ; ContentResolver cr = context . getContentResolver ( ) ; Cursor c = cr . query ( CONTENT_URI , selection , WHERE , selectionArgs , null ) ; boolean favorite = false ; if ( c != null && c . getCount ( ) > 0 ) { favorite = true ; } else { favorite = false ; } if ( c != null ) { c . close ( ) ; } return favorite ; }
public SimpleRecyclerAdapter ( Context context , ArrayList < String > items ) { mInflater = LayoutInflater . from ( context ) ; mItems = items ; }
@ Override public int getItemCount ( ) { return mItems . size ( ) ; }
@ Override public ViewHolder onCreateViewHolder ( ViewGroup parent , int viewType ) { return new ViewHolder ( mInflater . inflate ( android . R . layout . simple_list_item_1 , parent , false ) ) ; }
@ Override public void onBindViewHolder ( ViewHolder viewHolder , int position ) { viewHolder . textView . setText ( mItems . get ( position ) ) ; }
public ViewHolder ( View view ) { super( view ); textView = ( TextView ) view . findViewById ( android . R . id . text1 ) ; }
public void testDowntownSeattle1 ( ) { final Location pt = LocationUtils . makeLocation ( 47.610980 , - 122.33845 ) ; ObaStopsForLocationRequest . Builder builder = new ObaStopsForLocationRequest . Builder ( getContext ( ) , pt ) ; ObaStopsForLocationRequest request = builder . build ( ) ; ObaStopsForLocationResponse response = request . call ( ) ; assertOK ( response ) ; final ObaStop [] list = response . getStops ( ) ; assertTrue ( list . length > 0 ) ; final ObaStop first = list [ 0 ] ; assertEquals ( "1_1030" , first . getId ( ) ) ; final ObaRoute route = response . getRoute ( first . getRouteIds ( ) [ 0 ] ) ; assertEquals ( "1_25" , route . getId ( ) ) ; final ObaAgency agency = response . getAgency ( route . getAgencyId ( ) ) ; assertEquals ( "1" , agency . getId ( ) ) ; assertEquals ( "Metro Transit" , agency . getName ( ) ) ; }
public void testQuery ( ) { final Location pt = LocationUtils . makeLocation ( 47.25331 , - 122.44040 ) ; ObaStopsForLocationResponse response = new ObaStopsForLocationRequest . Builder ( getContext ( ) , pt ) . setQuery ( "26" ) . build ( ) . call ( ) ; assertOK ( response ) ; final ObaStop [] list = response . getStops ( ) ; assertTrue ( list . length > 0 ) ; assertFalse ( response . getLimitExceeded ( ) ) ; assertFalse ( response . getOutOfRange ( ) ) ; final ObaStop first = list [ 0 ] ; assertEquals ( "3_26" , first . getId ( ) ) ; final ObaRoute route = response . getRoute ( first . getRouteIds ( ) [ 0 ] ) ; assertEquals ( "3" , route . getAgencyId ( ) ) ; }
public void testQueryFail ( ) { final Location pt = LocationUtils . makeLocation ( 47.25331 , - 122.44040 ) ; ObaStopsForLocationResponse response = new ObaStopsForLocationRequest . Builder ( getContext ( ) , pt ) . setQuery ( "112423" ) . build ( ) . call ( ) ; assertOK ( response ) ; final ObaStop [] list = response . getStops ( ) ; assertEquals ( 0 , list . length ) ; assertFalse ( response . getLimitExceeded ( ) ) ; assertFalse ( response . getOutOfRange ( ) ) ; }
public void testOutOfRange ( ) { final Location pt = LocationUtils . makeLocation ( 48.85808 , 2.29498 ) ; ObaStopsForLocationRequest request = new ObaStopsForLocationRequest . Builder ( getContext ( ) , pt ) . build ( ) ; ObaStopsForLocationResponse response = request . call ( ) ; assertOK ( response ) ; assertTrue ( response . getOutOfRange ( ) ) ; }
public MorseflashSampleIT ( MavenRuntimeBuilder builder ) throws Exception { this . mavenRuntime = builder . build ( ) ; }
@ Test public void buildDeployAndRun ( ) Exception { File basedir = resources . getBasedir ( "morseflash" ) ; MavenExecutionResult result = mavenRuntime . forProject ( basedir ) . withCliOptions ( "-Psupport_test" ) . execute ( "clean" , PluginInfo . getQualifiedGoal ( "undeploy" ) , "install" ) ; result . assertErrorFreeLog ( ) ; result . assertLogText ( "Running instrumentation tests in com.simpligility.android.morseflash.tests" ) ; }
public FragmentAssert ( Fragment actual ) { super( actual , FragmentAssert .class ); }
ResourceClassGenerator ( final GenerateSourcesMojo mojo , final File targetDirectory , final File genDirectory ) { this . mojo = mojo ; this . targetDirectory = targetDirectory ; this . genDirectory = genDirectory ; this . log = mojo . getLog ( ) ; this . androidUtilsLog = new MavenILogger ( log ) ; }
public void generateLibraryRs ( final Set < Artifact > libraries ) throws MojoExecutionException { final List < SymbolTable > symbolTables = new ArrayList <> ( libraries . size ( ) ) ; for ( final Artifact lib : libraries ) { final File unpackedLibDirectory = mojo . getUnpackedLibFolder ( lib ) ; final File rFile = new File ( unpackedLibDirectory , "R.txt" ) ; if ( rFile . isFile ( ) ) { final File libManifestFile = new File ( unpackedLibDirectory , "AndroidManifest.xml" ) ; final String packageName = new DefaultManifestParser ( libManifestFile ) . getPackage ( ) ; log . info ( "Reading R for " + packageName + " at " + rFile ) ; SymbolTable libSymbols = SymbolIo . read ( rFile ) ; libSymbols = libSymbols . rename ( packageName , libSymbols . getTableName ( ) ) ; symbolTables . add ( libSymbols ) ; } } if ( symbolTables . isEmpty ( ) ) { return; } final File projectR = new File ( targetDirectory , "R.txt" ) ; final SymbolTable mainSymbols = SymbolIo . read ( projectR ) ; RGeneration . generateRForLibraries ( mainSymbols , symbolTables , genDirectory . getAbsoluteFile ( ) , false ) ; }
public AttributeSetAssert ( AttributeSet actual ) { super( actual , AttributeSetAssert .class ); }
public AttributeSetAssert hasAttributeCount ( int count ) { isNotNull ( ) ; int actualCount = actual . getAttributeCount ( ) ; assertThat ( actualCount ) . overridingErrorMessage ( "Expected attribute count <%s> but was <%s>." , count , actualCount ) . isEqualTo ( count ) ; return this ; }
public AttributeSetAssert hasClassAttribute ( String value ) { isNotNull ( ) ; String actualValue = actual . getClassAttribute ( ) ; assertThat ( actualValue ) . overridingErrorMessage ( "Expected class attribute value <%s> but was <%s>." , value , actualValue ) . isEqualTo ( value ) ; return this ; }
public AttributeSetAssert hasIdAttribute ( String value ) { isNotNull ( ) ; String actualValue = actual . getIdAttribute ( ) ; assertThat ( actualValue ) . overridingErrorMessage ( "Exepected ID attribute value <%s> but was <%s>." , value , actualValue ) . isEqualTo ( value ) ; return this ; }
public AttributeSetAssert hasPositionDescription ( String position ) { isNotNull ( ) ; String actualPosition = actual . getPositionDescription ( ) ; assertThat ( actualPosition ) . overridingErrorMessage ( "Expected position description <%s> but was <%s>." , position , actualPosition ) . isEqualTo ( position ) ; return this ; }
public AttributeSetAssert hasStyleAttribute ( int value ) { isNotNull ( ) ; int actualValue = actual . getStyleAttribute ( ) ; assertThat ( actualValue ) . overridingErrorMessage ( "Expected style attribute value <%s> but was <%s>." , value , actualValue ) . isEqualTo ( value ) ; return this ; }
public void run ( ) { mList . focusableViewAvailable ( mList ) ; }
public void onItemClick ( AdapterView < ? > parent , View v , int position , long id ) { onListItemClick ( ( ListView ) parent , v , position , id ) ; }
public ListFragment ( ) {    }
@ Override @ SuppressWarnings ( "deprecation" ) public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { final Context context = getActivity ( ) ; FrameLayout root = new FrameLayout ( context ) ; LinearLayout pframe = new LinearLayout ( context ) ; pframe . setId ( R . id . loading ) ; pframe . setOrientation ( LinearLayout . VERTICAL ) ; pframe . setVisibility ( View . GONE ) ; pframe . setGravity ( Gravity . CENTER ) ; ProgressBar progress = new ProgressBar ( context , null , android . R . attr . progressBarStyleLarge ) ; pframe . addView ( progress , new FrameLayout . LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ) ; root . addView ( pframe , new FrameLayout . LayoutParams ( ViewGroup . LayoutParams . FILL_PARENT , ViewGroup . LayoutParams . FILL_PARENT ) ) ; FrameLayout lframe = new FrameLayout ( context ) ; lframe . setId ( R . id . listContainer ) ; TextView tv = new TextView ( getActivity ( ) ) ; tv . setId ( R . id . internalEmpty ) ; tv . setGravity ( Gravity . CENTER ) ; lframe . addView ( tv , new FrameLayout . LayoutParams ( ViewGroup . LayoutParams . FILL_PARENT , ViewGroup . LayoutParams . FILL_PARENT ) ) ; ListView lv = new ListView ( getActivity ( ) ) ; lv . setId ( android . R . id . list ) ; lv . setDrawSelectorOnTop ( false ) ; lframe . addView ( lv , new FrameLayout . LayoutParams ( ViewGroup . LayoutParams . FILL_PARENT , ViewGroup . LayoutParams . FILL_PARENT ) ) ; root . addView ( lframe , new FrameLayout . LayoutParams ( ViewGroup . LayoutParams . FILL_PARENT , ViewGroup . LayoutParams . FILL_PARENT ) ) ; root . setLayoutParams ( new FrameLayout . LayoutParams ( ViewGroup . LayoutParams . FILL_PARENT , ViewGroup . LayoutParams . FILL_PARENT ) ) ; return root ; }
@ Override public void onViewCreated ( View view , Bundle savedInstanceState ) { super. onViewCreated ( view , savedInstanceState ) ; ensureList ( ) ; }
@ Override public void onDestroyView ( ) { mHandler . removeCallbacks ( mRequestFocus ) ; mList = null ; mListShown = false ; mEmptyView = mProgressContainer = mRefreshProgressContainer = mListContainer = null ; mStandardEmptyView = null ; super. onDestroyView ( ) ; }
public void onListItemClick ( ListView l , View v , int position , long id ) {    }
public void setListAdapter ( ListAdapter adapter ) { boolean hadAdapter = mAdapter != null ; mAdapter = adapter ; if ( mList != null ) { mList . setAdapter ( adapter ) ; if ( ! mListShown && ! hadAdapter ) { setListShown ( true , getView ( ) . getWindowToken ( ) != null ) ; } } }
public void setSelection ( int position ) { ensureList ( ) ; mList . setSelection ( position ) ; }
public int getSelectedItemPosition ( ) { ensureList ( ) ; return mList . getSelectedItemPosition ( ) ; }
public long getSelectedItemId ( ) { ensureList ( ) ; return mList . getSelectedItemId ( ) ; }
public ListView getListView ( ) { ensureList ( ) ; return mList ; }
public void setEmptyText ( CharSequence text ) { ensureList ( ) ; if ( mStandardEmptyView == null ) { throw new IllegalStateException ( "Can't be used with a custom content view" ) ; } mStandardEmptyView . setText ( text ) ; if ( mEmptyText == null ) { mList . setEmptyView ( mStandardEmptyView ) ; } mEmptyText = text ; }
public void setListShown ( boolean shown ) { setListShown ( shown , true ) ; }
public void setListShownNoAnimation ( boolean shown ) { setListShown ( shown , false ) ; }
private void setListShown ( boolean shown , boolean animate ) { ensureList ( ) ; if ( mProgressContainer == null ) { throw new IllegalStateException ( "Can't be used with a custom content view" ) ; } if ( mListShown == shown ) { return; } mListShown = shown ; if ( shown ) { if ( animate ) { mProgressContainer . startAnimation ( AnimationUtils . loadAnimation ( getActivity ( ) , android . R . anim . fade_out ) ) ; mListContainer . startAnimation ( AnimationUtils . loadAnimation ( getActivity ( ) , android . R . anim . fade_in ) ) ; } else { mProgressContainer . clearAnimation ( ) ; mListContainer . clearAnimation ( ) ; } mProgressContainer . setVisibility ( View . GONE ) ; mListContainer . setVisibility ( View . VISIBLE ) ; } else { if ( animate ) { mProgressContainer . startAnimation ( AnimationUtils . loadAnimation ( getActivity ( ) , android . R . anim . fade_in ) ) ; mListContainer . startAnimation ( AnimationUtils . loadAnimation ( getActivity ( ) , android . R . anim . fade_out ) ) ; } else { mProgressContainer . clearAnimation ( ) ; mListContainer . clearAnimation ( ) ; } mProgressContainer . setVisibility ( View . VISIBLE ) ; mListContainer . setVisibility ( View . GONE ) ; } }
public ListAdapter getListAdapter ( ) { return mAdapter ; }
private void ensureList ( ) { if ( mList != null ) { return; } View root = getView ( ) ; if ( root == null ) { throw new IllegalStateException ( "Content view not yet created" ) ; } if ( root instanceof ListView ) { mList = ( ListView ) root ; } else { mStandardEmptyView = ( TextView ) root . findViewById ( R . id . internalEmpty ) ; if ( mStandardEmptyView == null ) { mEmptyView = root . findViewById ( android . R . id . empty ) ; } else { mStandardEmptyView . setVisibility ( View . GONE ) ; } mProgressContainer = root . findViewById ( R . id . loading ) ; mRefreshProgressContainer = root . findViewById ( R . id . refresh_loading ) ; ProgressBar progressBar = ( ProgressBar ) root . findViewById ( R . id . refresh_progress_small ) ; if ( progressBar != null && progressBar . getIndeterminateDrawable ( ) != null ) { progressBar . getIndeterminateDrawable ( ) . setAlpha ( 128 ) ; } mListContainer = root . findViewById ( R . id . listContainer ) ; View rawListView = root . findViewById ( android . R . id . list ) ; if ( ! ( rawListView instanceof ListView ) ) { if ( rawListView == null ) { throw new RuntimeException ( "Your content must have a ListView whose id attribute is " + "'android.R.id.list'" ) ; } throw new RuntimeException ( "Content has view with id attribute 'android.R.id.list' " + "that is not a ListView class" ) ; } mList = ( ListView ) rawListView ; if ( mEmptyView != null ) { mList . setEmptyView ( mEmptyView ) ; } else if ( mEmptyText != null ) { mStandardEmptyView . setText ( mEmptyText ) ; mList . setEmptyView ( mStandardEmptyView ) ; } } mListShown = true ; mList . setOnItemClickListener ( mOnClickListener ) ; if ( mAdapter != null ) { ListAdapter adapter = mAdapter ; mAdapter = null ; setListAdapter ( adapter ) ; } else { if ( mProgressContainer != null ) { setListShown ( false , false ) ; } } mHandler . post ( mRequestFocus ) ; }
protected void showProgress ( boolean visibility ) { if ( mRefreshProgressContainer == null ) return; if ( visibility ) { mRefreshProgressContainer . setVisibility ( View . VISIBLE ) ; } else { mRefreshProgressContainer . setVisibility ( View . GONE ) ; } }
private SubType ( String name ) { this . name = name ; }
@ Override public String toString ( ) { return this . name ; }
public MimeTypeVnd ( SubType subType , ContentMimeTypeVndInfo providerSpecific ) { this . subType = subType ; this . providerSpecific = providerSpecific ; }
@ Override public boolean isValid ( ) { return isValid ( false ) ; }
@ Override public boolean isValid ( boolean throwException ) { boolean result = true ; if ( this . subType == null ) { result = false ; if ( throwException && ! result ) { throw new IllegalStateException ( "subType is null." ) ; } } else if ( ! this . providerSpecific . isValid ( ) ) { result = false ; if ( throwException && ! result ) { throw new IllegalStateException ( "providerSpecific is invalid." ) ; } } return result ; }
public SubType getSubType ( ) { return this . subType ; }
public void setSubType ( SubType subType ) { this . subType = subType ; }
public ContentMimeTypeVndInfo getProviderSpecific ( ) { return this . providerSpecific ; }
public void setProviderSpecific ( ContentMimeTypeVndInfo providerSpecific ) { this . providerSpecific = providerSpecific ; }
public String getMimeTypeString ( ) { return this . subType . toString ( ) + File . separator + this . providerSpecific . getVndProviderSpecificString ( ) ; }
@ Override public String toString ( ) { return getMimeTypeString ( ) ; }
String getId ( )
int getType ( )
int getFlags ( )
CharSequence getString ( )
void onClick ( )
public Adapter ( Context context ) { super( context , R . layout . alert_item ); }
@ Override protected void initView ( View view , final Alert alert ) { TextView alertView = ( TextView ) view . findViewById ( android . R . id . text1 ) ; View filterGroupView = view . findViewById ( R . id . filter_alert_group ) ; TextView filterTextView = ( TextView ) view . findViewById ( R . id . filter_alert_text ) ; TextView showAllView = ( TextView ) view . findViewById ( R . id . show_all_alerts ) ; alertView . setText ( alert . getString ( ) ) ; boolean clickable = ( alert . getFlags ( ) & Alert . FLAG_HASMORE ) == Alert . FLAG_HASMORE ; int type = alert . getType ( ) ; Resources r = Application . get ( ) . getResources ( ) ; int bg = R . color . alert_text_background_info ; int arrowColor = R . color . alert_text_color_info ; int alertColor = R . color . alert_icon_info ; int resourceIdAlert = 0 ; switch ( type ) { case Alert . TYPE_ERROR : bg = R . color . alert_text_background_error ; arrowColor = R . color . alert_text_color_error ; resourceIdAlert = R . drawable . ic_alert_warning ; alertColor = R . color . alert_icon_error ; alertView . setVisibility ( View . VISIBLE ) ; filterGroupView . setVisibility ( View . GONE ) ; break; case Alert . TYPE_WARNING : bg = R . color . alert_text_background_warning ; arrowColor = R . color . alert_text_color_warning ; resourceIdAlert = R . drawable . ic_alert_warning ; alertColor = R . color . alert_icon_warning ; alertView . setVisibility ( View . VISIBLE ) ; filterGroupView . setVisibility ( View . GONE ) ; break; case Alert . TYPE_SHOW_HIDDEN_ALERTS : alertView . setVisibility ( View . GONE ) ; filterGroupView . setVisibility ( View . VISIBLE ) ; filterTextView . setText ( alert . getString ( ) ) ; break; case Alert . TYPE_INFO : default: bg = R . color . alert_text_background_info ; arrowColor = R . color . alert_text_color_info ; alertView . setVisibility ( View . VISIBLE ) ; filterGroupView . setVisibility ( View . GONE ) ; break; } alertView . setTextColor ( r . getColor ( arrowColor ) ) ; Drawable dWarning ; Drawable wdWarning = null ; if ( resourceIdAlert != 0 ) { dWarning = ContextCompat . getDrawable ( Application . get ( ) . getApplicationContext ( ) , resourceIdAlert ) ; wdWarning = DrawableCompat . wrap ( dWarning ) ; wdWarning = wdWarning . mutate ( ) ; DrawableCompat . setTint ( wdWarning , r . getColor ( alertColor ) ) ; } Drawable dArrow ; Drawable wdArrow = null ; int resourceIdArrow = clickable ? R . drawable . ic_navigation_chevron_right : 0 ; if ( resourceIdArrow != 0 ) { dArrow = ContextCompat . getDrawable ( Application . get ( ) . getApplicationContext ( ) , resourceIdArrow ) ; wdArrow = DrawableCompat . wrap ( dArrow ) ; wdArrow = wdArrow . mutate ( ) ; DrawableCompat . setTint ( wdArrow , r . getColor ( arrowColor ) ) ; } alertView . setCompoundDrawablesWithIntrinsicBounds ( wdWarning , null , wdArrow , null ) ; view . setBackgroundResource ( bg ) ; View . OnClickListener listener = new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { alert . onClick ( ) ; } } ; view . setOnClickListener ( listener ) ; UIUtils . removeAllClickableSpans ( showAllView ) ; ClickableSpan showAllClick = new ClickableSpan ( ) { public void onClick ( View v ) { alert . onClick ( ) ; } } ; UIUtils . setClickableSpan ( showAllView , showAllClick ) ; }
@ Override public void onClick ( View v ) { alert . onClick ( ) ; }
public void onClick ( View v ) { alert . onClick ( ) ; }
AlertList ( Context context ) { mAdapter = new Adapter ( context ) ; }
void initView ( View view ) { mView = ( ListView ) view ; mView . setAdapter ( mAdapter ) ; }
void add ( Alert alert ) { mAdapter . add ( alert ) ; }
void addAll ( Collection < ? extends Alert > alerts ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . HONEYCOMB ) { mAdapter . addAll ( alerts ) ; } else { for ( Alert a : alerts ) { mAdapter . add ( a ) ; } } }
void insert ( Alert alert , int index ) { mAdapter . insert ( alert , index ) ; }
int getPosition ( Alert alert ) { return mAdapter . getPosition ( alert ) ; }
void remove ( Alert alert ) { mAdapter . remove ( alert ) ; }
int getCount ( ) { return mAdapter . getCount ( ) ; }
Alert getItem ( int position ) { return mAdapter . getItem ( position ) ; }
public boolean isAlertHidden ( ) { return mIsAlertHidden ; }
public void setAlertHidden ( boolean alertHidden ) { mIsAlertHidden = alertHidden ; }
public int getHiddenAlertCount ( ) { return mHiddenAlertCount ; }
public void setHiddenAlertCount ( int hiddenAlertCount ) { mHiddenAlertCount = hiddenAlertCount ; }
public MarkerAssert ( Marker actual ) { super( actual , MarkerAssert .class ); }
public MarkerAssert hasAlpha ( float alpha ) { isNotNull ( ) ; float actualAlpha = actual . getAlpha ( ) ; assertThat ( actualAlpha ) . overridingErrorMessage ( "Expected alpha <%s> but was <%s>." , alpha , actualAlpha ) . isEqualTo ( alpha ) ; return this ; }
public MarkerAssert hasId ( String id ) { isNotNull ( ) ; String actualId = actual . getId ( ) ; assertThat ( actualId ) . overridingErrorMessage ( "Expected id <%s> but was <%s>." , id , actualId ) . isEqualTo ( id ) ; return this ; }
public MarkerAssert hasPosition ( LatLng position ) { isNotNull ( ) ; LatLng actualLatLng = actual . getPosition ( ) ; assertThat ( actualLatLng ) . overridingErrorMessage ( "Expected position <%s> but was <%s>." , position , actualLatLng ) . isEqualTo ( position ) ; return this ; }
public MarkerAssert hasRotation ( float rotation ) { isNotNull ( ) ; float actualRotation = actual . getRotation ( ) ; assertThat ( actualRotation ) . overridingErrorMessage ( "Expected rotation <%s> but was <%s>." , rotation , actualRotation ) . isEqualTo ( rotation ) ; return this ; }
public MarkerAssert hasSnippet ( String snippet ) { isNotNull ( ) ; String actualSnippet = actual . getSnippet ( ) ; assertThat ( actualSnippet ) . overridingErrorMessage ( "Expected snippet <%s> but was <%s>." , snippet , actualSnippet ) . isEqualTo ( snippet ) ; return this ; }
public MarkerAssert hasTitle ( String title ) { isNotNull ( ) ; String actualTitle = actual . getTitle ( ) ; assertThat ( actualTitle ) . overridingErrorMessage ( "Expected title <%s> but was <%s>." , title , actualTitle ) . isEqualTo ( title ) ; return this ; }
public MarkerAssert isDraggable ( ) { isNotNull ( ) ; assertThat ( actual . isDraggable ( ) ) . overridingErrorMessage ( "Expected to be draggable but was not." ) . isTrue ( ) ; return this ; }
public MarkerAssert isNotDraggable ( ) { isNotNull ( ) ; assertThat ( actual . isDraggable ( ) ) . overridingErrorMessage ( "Expected to not be draggable but was." ) . isFalse ( ) ; return this ; }
public MarkerAssert isFlat ( ) { isNotNull ( ) ; assertThat ( actual . isFlat ( ) ) . overridingErrorMessage ( "Expected to be flat but was not." ) . isTrue ( ) ; return this ; }
public MarkerAssert isNotFlat ( ) { isNotNull ( ) ; assertThat ( actual . isFlat ( ) ) . overridingErrorMessage ( "Expected to not be flat but was." ) . isFalse ( ) ; return this ; }
public MarkerAssert hasInfoWindowShown ( ) { isNotNull ( ) ; assertThat ( actual . isInfoWindowShown ( ) ) . overridingErrorMessage ( "Expected info window to be shown but was not." ) . isTrue ( ) ; return this ; }
public MarkerAssert hasInfoWindowNotShown ( ) { isNotNull ( ) ; assertThat ( actual . isInfoWindowShown ( ) ) . overridingErrorMessage ( "Expected info window to not be shown but was." ) . isFalse ( ) ; return this ; }
public MarkerAssert isVisible ( ) { isNotNull ( ) ; assertThat ( actual . isVisible ( ) ) . overridingErrorMessage ( "Expected to be visible but was not." ) . isTrue ( ) ; return this ; }
public MarkerAssert isNotVisible ( ) { isNotNull ( ) ; assertThat ( actual . isVisible ( ) ) . overridingErrorMessage ( "Expected to not be visible but was." ) . isFalse ( ) ; return this ; }
RealMiddlewareChain ( int index , @ NonNull BasePayload payload , @ NonNull List < Middleware > middlewares , @ NonNull Analytics analytics ) { this . index = index ; this . payload = payload ; this . middlewares = middlewares ; this . analytics = analytics ; }
@ Override public BasePayload payload ( ) { return payload ; }
@ Override public void proceed ( BasePayload payload ) { if ( index < middlewares . size ( ) ) { Middleware . Chain chain = new RealMiddlewareChain ( index + 1 , payload , middlewares , analytics ) ; middlewares . get ( index ) . intercept ( chain ) ; return; } analytics . run ( payload ) ; }
void loadImage ( @ Nonnull String url , @ Nonnull ImageView imageView , @ Nullable Integer defaultImageId );
void loadImage ( @ Nonnull String url , @ Nonnull OnImageLoadedListener imageLoadedListener );
void loadImage ( @ Nonnull String url );
public Comment ( ) {    }
public Comment ( Long commentId , int level , boolean originalPoster , String user , String timeAgo , String content , StoryDetail storyDetail ) { mCommentId = commentId ; mLevel = level ; mOriginalPoster = originalPoster ; mUser = user ; mTimeAgo = timeAgo ; mContent = content ; mStoryDetail = storyDetail ; }
public long getCommentId ( ) { return mCommentId ; }
public int getLevel ( ) { return mLevel ; }
public String getUser ( ) { return mUser ; }
public String getTimeAgo ( ) { return mTimeAgo ; }
public String getContent ( ) { return mContent ; }
public void setCommentId ( Long commentId ) { mCommentId = commentId ; }
public void setLevel ( int level ) { mLevel = level ; }
public void setUser ( String user ) { mUser = user ; }
public void setTimeAgo ( String timeAgo ) { mTimeAgo = timeAgo ; }
public void setContent ( String content ) { mContent = content ; }
public boolean isOriginalPoster ( ) { return mOriginalPoster ; }
public void setOriginalPoster ( boolean originalPoster ) { mOriginalPoster = originalPoster ; }
public boolean isHidden ( ) { return mHidden ; }
public void setHidden ( boolean hidden ) { mHidden = hidden ; }
public TripAlertsTest ( ) { super( ObaProvider .class , ObaContract . AUTHORITY ); }
public void testInsertIfNotExists ( ) { ContentResolver cr = getMockContentResolver ( ) ; final Uri uri1 = TripAlerts . insertIfNotExists ( cr , "1_12345" , "1_STOP" , 1000 ) ; assertNotNull ( uri1 ) ; Cursor c1 = cr . query ( ObaContract . TripAlerts . CONTENT_URI , new String [] { ObaContract . TripAlerts . _ID } , null , null , null ) ; assertNotNull ( c1 ) ; assertEquals ( 1 , c1 . getCount ( ) ) ; final Uri uri2 = TripAlerts . insertIfNotExists ( cr , "1_12345" , "1_STOP" , 1000 ) ; assertNotNull ( uri2 ) ; c1 . close ( ) ; Cursor c2 = cr . query ( ObaContract . TripAlerts . CONTENT_URI , new String [] { ObaContract . TripAlerts . _ID } , null , null , null ) ; assertNotNull ( c2 ) ; assertEquals ( 1 , c2 . getCount ( ) ) ; assertEquals ( uri1 , uri2 ) ; c2 . close ( ) ; cr . delete ( uri1 , null , null ) ; }
public void testSetState ( ) { ContentResolver cr = getMockContentResolver ( ) ; final Uri uri = TripAlerts . insertIfNotExists ( cr , "1_12345" , "1_STOP" , 1000 ) ; assertNotNull ( uri ) ; final String [] PROJECTION = { TripAlerts . STATE } ; Cursor c = cr . query ( uri , PROJECTION , null , null , null ) ; assertNotNull ( c ) ; c . moveToNext ( ) ; assertEquals ( TripAlerts . STATE_SCHEDULED , c . getInt ( 0 ) ) ; c . close ( ) ; TripAlerts . setState ( cr , uri , TripAlerts . STATE_POLLING ) ; c = cr . query ( uri , PROJECTION , null , null , null ) ; assertNotNull ( c ) ; c . moveToNext ( ) ; assertEquals ( TripAlerts . STATE_POLLING , c . getInt ( 0 ) ) ; c . close ( ) ; cr . delete ( uri , null , null ) ; }
public AddressAssert ( Address actual ) { super( actual , AddressAssert .class ); }
public AddressAssert hasAddressLine ( int index , String line ) { isNotNull ( ) ; String actualLine = actual . getAddressLine ( index ) ; assertThat ( actualLine ) . overridingErrorMessage ( "Expected address line %s <%s> but was <%s>." , index , line , actualLine ) . isEqualTo ( line ) ; return this ; }
public AddressAssert hasAdminArea ( String area ) { isNotNull ( ) ; String actualArea = actual . getAdminArea ( ) ; assertThat ( actualArea ) . overridingErrorMessage ( "Expected admin area <%s> but was <%s>." , area , actualArea ) . isEqualTo ( area ) ; return this ; }
public AddressAssert hasCountryCode ( String code ) { isNotNull ( ) ; String actualCode = actual . getCountryCode ( ) ; assertThat ( actualCode ) . overridingErrorMessage ( "Expected country code <%s> but was <%s>." , code , actualCode ) . isEqualTo ( code ) ; return this ; }
public AddressAssert hasCountryName ( String name ) { isNotNull ( ) ; String actualName = actual . getCountryName ( ) ; assertThat ( actualName ) . overridingErrorMessage ( "Expected country name <%s> but was <%s>." , name , actualName ) . isEqualTo ( name ) ; return this ; }
public AddressAssert hasFeatureName ( String name ) { isNotNull ( ) ; String actualName = actual . getFeatureName ( ) ; assertThat ( actualName ) . overridingErrorMessage ( "Expected feature name <%s> but was <%s>." , name , actualName ) . isEqualTo ( name ) ; return this ; }
public AddressAssert hasLatitude ( double latitude ) { isNotNull ( ) ; double actualLatitude = actual . getLatitude ( ) ; assertThat ( actualLatitude ) . overridingErrorMessage ( "Expected latitude <%s> but was <%s>." , latitude , actualLatitude ) . isEqualTo ( latitude ) ; return this ; }
public AddressAssert hasLocale ( Locale locale ) { isNotNull ( ) ; Locale actualLocale = actual . getLocale ( ) ; assertThat ( actualLocale ) . overridingErrorMessage ( "Expected locale <%s> but was <%s>." , locale , actualLocale ) . isEqualTo ( locale ) ; return this ; }
public AddressAssert hasLocality ( String locality ) { isNotNull ( ) ; String actualLocality = actual . getLocality ( ) ; assertThat ( actualLocality ) . overridingErrorMessage ( "Expected locality <%s> but was <%s>." , locality , actualLocality ) . isEqualTo ( locality ) ; return this ; }
public AddressAssert hasLongitude ( double longitude ) { isNotNull ( ) ; double actualLongitude = actual . getLongitude ( ) ; assertThat ( actualLongitude ) . overridingErrorMessage ( "Expected longitude <%s> but was <%s>." , longitude , actualLongitude ) . isEqualTo ( longitude ) ; return this ; }
public AddressAssert hasMaximumAddressLineIndex ( int index ) { isNotNull ( ) ; int actualIndex = actual . getMaxAddressLineIndex ( ) ; assertThat ( actualIndex ) . overridingErrorMessage ( "Expected maximum address line index <%s> but was <%s>." , index , actualIndex ) . isEqualTo ( index ) ; return this ; }
public AddressAssert hasPhone ( String phone ) { isNotNull ( ) ; String actualPhone = actual . getPhone ( ) ; assertThat ( actualPhone ) . overridingErrorMessage ( "Expected phone <%s> but was <%s>." , phone , actualPhone ) . isEqualTo ( phone ) ; return this ; }
public AddressAssert hasPostalCode ( String code ) { isNotNull ( ) ; String actualCode = actual . getPostalCode ( ) ; assertThat ( actualCode ) . overridingErrorMessage ( "Expected postal code <%s> but was <%s>." , code , actualCode ) . isEqualTo ( code ) ; return this ; }
public AddressAssert hasPremises ( String premises ) { isNotNull ( ) ; String actualPremises = actual . getPremises ( ) ; assertThat ( actualPremises ) . overridingErrorMessage ( "Expected premises <%s> but was <%s>." , premises , actualPremises ) . isEqualTo ( premises ) ; return this ; }
public AddressAssert hasSubAdminArea ( String area ) { isNotNull ( ) ; String actualArea = actual . getSubAdminArea ( ) ; assertThat ( actualArea ) . overridingErrorMessage ( "Expected sub-admin area <%s> but was <%s>." , area , actualArea ) . isEqualTo ( area ) ; return this ; }
public AddressAssert hasSubLocality ( String locality ) { isNotNull ( ) ; String actualLocality = actual . getSubLocality ( ) ; assertThat ( actualLocality ) . overridingErrorMessage ( "Expected sub-locality <%s> but was <%s>." , locality , actualLocality ) . isEqualTo ( locality ) ; return this ; }
public AddressAssert hasThoroughfare ( String thoroughfare ) { isNotNull ( ) ; String actualThoroughfare = actual . getThoroughfare ( ) ; assertThat ( actualThoroughfare ) . overridingErrorMessage ( "Expected thoroughfare <%s> but was <%s>." , thoroughfare , actualThoroughfare ) . isEqualTo ( thoroughfare ) ; return this ; }
public AddressAssert hasUrl ( String url ) { isNotNull ( ) ; String actualUrl = actual . getUrl ( ) ; assertThat ( actualUrl ) . overridingErrorMessage ( "Expected url <%s> but was <%s>." , url , actualUrl ) . isEqualTo ( url ) ; return this ; }
public AddressAssert hasLatitude ( ) { isNotNull ( ) ; assertThat ( actual . hasLatitude ( ) ) . overridingErrorMessage ( "Expected to have latitude but did not." ) . isTrue ( ) ; return this ; }
public AddressAssert hasNoLatitude ( ) { isNotNull ( ) ; assertThat ( actual . hasLatitude ( ) ) . overridingErrorMessage ( "Expected to not have latitude but did." ) . isFalse ( ) ; return this ; }
public AddressAssert hasLongitude ( ) { isNotNull ( ) ; assertThat ( actual . hasLongitude ( ) ) . overridingErrorMessage ( "Expected to have longitude but did not." ) . isTrue ( ) ; return this ; }
public AddressAssert hasNoLongitude ( ) { isNotNull ( ) ; assertThat ( actual . hasLongitude ( ) ) . overridingErrorMessage ( "Expected to not have longitude but did." ) . isFalse ( ) ; return this ; }
public DialogFragmentAssert ( DialogFragment actual ) { super( actual , DialogFragmentAssert .class ); }
public DialogFragmentAssert isCancelable ( ) { isNotNull ( ) ; assertThat ( actual . isCancelable ( ) ) . overridingErrorMessage ( "Expected to be cancelable but was not cancelable." ) . isTrue ( ) ; return this ; }
public DialogFragmentAssert isNotCancelable ( ) { isNotNull ( ) ; assertThat ( actual . isCancelable ( ) ) . overridingErrorMessage ( "Expected to be not cancelable but was cancelable." ) . isFalse ( ) ; return this ; }
public static Bitmap generateBarCodeBitmap ( String dataNotNull , BarcodeFormat typeNotNull , int size ) { if ( dataNotNull == null ) { throw new IllegalArgumentException ( "date must not be null" ) ; } if ( typeNotNull == null ) { throw new IllegalArgumentException ( "type must not be null" ) ; } try { final BitMatrix matrix = getBitMatrix ( dataNotNull , typeNotNull , size ) ; int width = matrix . getWidth ( ) ; int height = matrix . getHeight ( ) ; final Bitmap barcode_image = Bitmap . createBitmap ( width , height , Bitmap . Config . RGB_565 ) ; for ( int y = 0 ; y < height ; y ++ ) { for ( int x = 0 ; x < width ; x ++ ) { barcode_image . setPixel ( x , y , matrix . get ( x , y ) ? 0 : 0xFFFFFF ) ; } } return barcode_image ; } catch ( com . google . zxing . WriterException e ) { Log . w ( "could not write image " + e ) ; return null ; } }
public static BitMatrix getBitMatrix ( String data , BarcodeFormat type , int size ) throws WriterException { final Writer writer = new MultiFormatWriter ( ) ; return writer . encode ( data , type , size , size ) ; }
protected ObaArrivalInfoRequest ( Uri uri ) { super( uri ); }
public Builder ( Context context , String stopId ) { super( context , getPathWithId ( "/arrivals-and-departures-for-stop/" , stopId ) ); }
public Builder ( Context context , String stopId , int minutesAfter ) { super( context , getPathWithId ( "/arrivals-and-departures-for-stop/" , stopId ) ); mBuilder . appendQueryParameter ( "minutesAfter" , String . valueOf ( minutesAfter ) ) ; }
public ObaArrivalInfoRequest build ( ) { return new ObaArrivalInfoRequest ( buildUri ( ) ) ; }
public static ObaArrivalInfoRequest newRequest ( Context context , String stopId ) { return new Builder ( context , stopId ) . build ( ) ; }
public static ObaArrivalInfoRequest newRequest ( Context context , String stopId , int minutesAfter ) { return new Builder ( context , stopId , minutesAfter ) . build ( ) ; }
@ Override public ObaArrivalInfoResponse call ( ) { return call ( ObaArrivalInfoResponse .class ) ; }
public NotificationAssert ( Notification actual ) { super( actual , NotificationAssert .class ); }
public NotificationAssert hasContentIntent ( PendingIntent intent ) { isNotNull ( ) ; assertThat ( actual . contentIntent ) . isEqualTo ( intent ) ; return this ; }
public NotificationAssert hasDefaults ( int defaults ) { isNotNull ( ) ; int actualDefaults = actual . defaults ; assertThat ( actualDefaults ) . overridingErrorMessage ( "Expected defaults <%s> but was <%s>." , defaults , actualDefaults ) . isEqualTo ( defaults ) ; return this ; }
public NotificationAssert hasDeleteIntent ( PendingIntent intent ) { isNotNull ( ) ; assertThat ( actual . deleteIntent ) . isEqualTo ( intent ) ; return this ; }
public NotificationAssert hasFlags ( @ NotificationFlags int flags ) { isNotNull ( ) ; int actualFlags = actual . flags ; assertThat ( actualFlags & flags ) . overridingErrorMessage ( "Expected flags <%s> but was <%s>." , flagsToString ( flags ) , flagsToString ( actualFlags & flags ) ) . isEqualTo ( flags ) ; return this ; }
public NotificationAssert hasOnlyFlags ( @ NotificationFlags int flags ) { isNotNull ( ) ; int actualFlags = actual . flags ; assertThat ( actualFlags ) . overridingErrorMessage ( "Expected flags <%s> but was <%s>." , flagsToString ( flags ) , flagsToString ( actualFlags ) ) . isEqualTo ( flags ) ; return this ; }
@ TargetApi ( GINGERBREAD ) public NotificationAssert hasFullScreenIntent ( PendingIntent intent ) { isNotNull ( ) ; assertThat ( actual . fullScreenIntent ) . isEqualTo ( intent ) ; return this ; }
@ TargetApi ( KITKAT_WATCH ) public NotificationAssert hasGroup ( String group ) { isNotNull ( ) ; String actualGroup = actual . getGroup ( ) ; assertThat ( actual . getGroup ( ) ) . overridingErrorMessage ( "Expected group <%s> but was <%s>." , group , actualGroup ) . isEqualTo ( group ) ; return this ; }
public NotificationAssert hasIcon ( int resId ) { isNotNull ( ) ; int actualId = actual . icon ; assertThat ( actualId ) . overridingErrorMessage ( "Expected icon with ID <%s> but was <%s>." , resId , actualId ) . isEqualTo ( resId ) ; return this ; }
public NotificationAssert hasIconLevel ( int level ) { isNotNull ( ) ; int actualLevel = actual . iconLevel ; assertThat ( actualLevel ) . overridingErrorMessage ( "Expected icon level <%s> but was <%s>." , level , actualLevel ) . isEqualTo ( level ) ; return this ; }
@ TargetApi ( HONEYCOMB ) public NotificationAssert hasLargeIcon ( Bitmap bitmap ) { isNotNull ( ) ; assertThat ( actual . largeIcon ) . isEqualTo ( bitmap ) ; return this ; }
public NotificationAssert hasLedColor ( int color ) { isNotNull ( ) ; int actualColor = actual . ledARGB ; assertThat ( actualColor ) . overridingErrorMessage ( "Expected LED color <%s> but was <%s>." , Integer . toHexString ( color ) , Integer . toHexString ( actualColor ) ) . isEqualTo ( color ) ; return this ; }
public NotificationAssert hasLedOffMs ( int length ) { isNotNull ( ) ; int actualLength = actual . ledOffMS ; assertThat ( actualLength ) . overridingErrorMessage ( "Expected LED off time (ms) <%s> but was <%s>." , length , actualLength ) . isEqualTo ( length ) ; return this ; }
public NotificationAssert hasLedOnMs ( int length ) { isNotNull ( ) ; int actualLength = actual . ledOnMS ; assertThat ( actualLength ) . overridingErrorMessage ( "Expected LED on time (ms) <%s> but was <%s>." , length , actualLength ) . isEqualTo ( length ) ; return this ; }
public NotificationAssert hasNumber ( int number ) { isNotNull ( ) ; int actualNumber = actual . number ; assertThat ( actualNumber ) . overridingErrorMessage ( "Expected number <%s> but was <%s>." , number , actualNumber ) . isEqualTo ( number ) ; return this ; }
@ TargetApi ( JELLY_BEAN ) public NotificationAssert hasPriority ( @ NotificationPriority int priority ) { isNotNull ( ) ; int actualPriority = actual . priority ; assertThat ( actualPriority ) . overridingErrorMessage ( "Expected priority <%s> but was <%s>." , priorityToString ( priority ) , priorityToString ( actualPriority ) ) . isEqualTo ( priority ) ; return this ; }
@ TargetApi ( KITKAT_WATCH ) public NotificationAssert hasSortKey ( String sortKey ) { isNotNull ( ) ; assertThat ( actual . getSortKey ( ) ) . overridingErrorMessage ( "Expected sortKey <%s> but was <%s>." , sortKey , actual . getSortKey ( ) ) . isEqualTo ( sortKey ) ; return this ; }
public NotificationAssert hasTickerText ( CharSequence text ) { isNotNull ( ) ; assertThat ( actual . tickerText ) . isEqualTo ( text ) ; return this ; }
public NotificationAssert hasVibration ( long [] vibration ) { isNotNull ( ) ; assertThat ( actual . vibrate ) . isEqualTo ( vibration ) ; return this ; }
public NotificationAssert hasWhen ( long when ) { isNotNull ( ) ; long actualWhen = actual . when ; assertThat ( actualWhen ) . overridingErrorMessage ( "Expected when <%s> but was <%s>." , when , actualWhen ) . isEqualTo ( when ) ; return this ; }
public static String flagsToString ( @ NotificationFlags int flags ) { return buildBitMaskString ( flags ) . flag ( FLAG_AUTO_CANCEL , "autoCancel" ) . flag ( FLAG_FOREGROUND_SERVICE , "foregroundService" ) . flag ( FLAG_INSISTENT , "insistent" ) . flag ( FLAG_NO_CLEAR , "noClear" ) . flag ( FLAG_ONGOING_EVENT , "ongoingEvent" ) . flag ( FLAG_ONLY_ALERT_ONCE , "onlyAlertOnce" ) . flag ( FLAG_SHOW_LIGHTS , "showLights" ) . flag ( FLAG_HIGH_PRIORITY , "highPriority" ) . get ( ) ; }
public static String priorityToString ( @ NotificationPriority int priority ) { return buildNamedValueString ( priority ) . value ( PRIORITY_MIN , "min" ) . value ( PRIORITY_LOW , "low" ) . value ( PRIORITY_DEFAULT , "default" ) . value ( PRIORITY_HIGH , "high" ) . value ( PRIORITY_MAX , "max" ) . get ( ) ; }
public static void showDialog ( final Context context , final OnGpuImageFilterChosenListener listener ) { final FilterList filters = new FilterList ( ) ; filters . addFilter ( "Contrast" , FilterType . CONTRAST ) ; filters . addFilter ( "Invert" , FilterType . INVERT ) ; filters . addFilter ( "Pixelation" , FilterType . PIXELATION ) ; filters . addFilter ( "Hue" , FilterType . HUE ) ; filters . addFilter ( "Gamma" , FilterType . GAMMA ) ; filters . addFilter ( "Brightness" , FilterType . BRIGHTNESS ) ; filters . addFilter ( "Sepia" , FilterType . SEPIA ) ; filters . addFilter ( "Grayscale" , FilterType . GRAYSCALE ) ; filters . addFilter ( "Sharpness" , FilterType . SHARPEN ) ; filters . addFilter ( "Sobel Edge Detection" , FilterType . SOBEL_EDGE_DETECTION ) ; filters . addFilter ( "3x3 Convolution" , FilterType . THREE_X_THREE_CONVOLUTION ) ; filters . addFilter ( "Emboss" , FilterType . EMBOSS ) ; filters . addFilter ( "Posterize" , FilterType . POSTERIZE ) ; filters . addFilter ( "Grouped filters" , FilterType . FILTER_GROUP ) ; filters . addFilter ( "Saturation" , FilterType . SATURATION ) ; filters . addFilter ( "Exposure" , FilterType . EXPOSURE ) ; filters . addFilter ( "Highlight Shadow" , FilterType . HIGHLIGHT_SHADOW ) ; filters . addFilter ( "Monochrome" , FilterType . MONOCHROME ) ; filters . addFilter ( "Opacity" , FilterType . OPACITY ) ; filters . addFilter ( "RGB" , FilterType . RGB ) ; filters . addFilter ( "White Balance" , FilterType . WHITE_BALANCE ) ; filters . addFilter ( "Vignette" , FilterType . VIGNETTE ) ; filters . addFilter ( "ToneCurve" , FilterType . TONE_CURVE ) ; filters . addFilter ( "Blend (Difference)" , FilterType . BLEND_DIFFERENCE ) ; filters . addFilter ( "Blend (Source Over)" , FilterType . BLEND_SOURCE_OVER ) ; filters . addFilter ( "Blend (Color Burn)" , FilterType . BLEND_COLOR_BURN ) ; filters . addFilter ( "Blend (Color Dodge)" , FilterType . BLEND_COLOR_DODGE ) ; filters . addFilter ( "Blend (Darken)" , FilterType . BLEND_DARKEN ) ; filters . addFilter ( "Blend (Dissolve)" , FilterType . BLEND_DISSOLVE ) ; filters . addFilter ( "Blend (Exclusion)" , FilterType . BLEND_EXCLUSION ) ; filters . addFilter ( "Blend (Hard Light)" , FilterType . BLEND_HARD_LIGHT ) ; filters . addFilter ( "Blend (Lighten)" , FilterType . BLEND_LIGHTEN ) ; filters . addFilter ( "Blend (Add)" , FilterType . BLEND_ADD ) ; filters . addFilter ( "Blend (Divide)" , FilterType . BLEND_DIVIDE ) ; filters . addFilter ( "Blend (Multiply)" , FilterType . BLEND_MULTIPLY ) ; filters . addFilter ( "Blend (Overlay)" , FilterType . BLEND_OVERLAY ) ; filters . addFilter ( "Blend (Screen)" , FilterType . BLEND_SCREEN ) ; filters . addFilter ( "Blend (Alpha)" , FilterType . BLEND_ALPHA ) ; filters . addFilter ( "Blend (Color)" , FilterType . BLEND_COLOR ) ; filters . addFilter ( "Blend (Hue)" , FilterType . BLEND_HUE ) ; filters . addFilter ( "Blend (Saturation)" , FilterType . BLEND_SATURATION ) ; filters . addFilter ( "Blend (Luminosity)" , FilterType . BLEND_LUMINOSITY ) ; filters . addFilter ( "Blend (Linear Burn)" , FilterType . BLEND_LINEAR_BURN ) ; filters . addFilter ( "Blend (Soft Light)" , FilterType . BLEND_SOFT_LIGHT ) ; filters . addFilter ( "Blend (Subtract)" , FilterType . BLEND_SUBTRACT ) ; filters . addFilter ( "Blend (Chroma Key)" , FilterType . BLEND_CHROMA_KEY ) ; filters . addFilter ( "Blend (Normal)" , FilterType . BLEND_NORMAL ) ; filters . addFilter ( "Lookup (Amatorka)" , FilterType . LOOKUP_AMATORKA ) ; filters . addFilter ( "Gaussian Blur" , FilterType . GAUSSIAN_BLUR ) ; filters . addFilter ( "Crosshatch" , FilterType . CROSSHATCH ) ; filters . addFilter ( "Box Blur" , FilterType . BOX_BLUR ) ; filters . addFilter ( "CGA Color Space" , FilterType . CGA_COLORSPACE ) ; filters . addFilter ( "Dilation" , FilterType . DILATION ) ; filters . addFilter ( "Kuwahara" , FilterType . KUWAHARA ) ; filters . addFilter ( "RGB Dilation" , FilterType . RGB_DILATION ) ; filters . addFilter ( "Sketch" , FilterType . SKETCH ) ; filters . addFilter ( "Toon" , FilterType . TOON ) ; filters . addFilter ( "Smooth Toon" , FilterType . SMOOTH_TOON ) ; filters . addFilter ( "Bulge Distortion" , FilterType . BULGE_DISTORTION ) ; filters . addFilter ( "Glass Sphere" , FilterType . GLASS_SPHERE ) ; filters . addFilter ( "Haze" , FilterType . HAZE ) ; filters . addFilter ( "Laplacian" , FilterType . LAPLACIAN ) ; filters . addFilter ( "Non Maximum Suppression" , FilterType . NON_MAXIMUM_SUPPRESSION ) ; filters . addFilter ( "Sphere Refraction" , FilterType . SPHERE_REFRACTION ) ; filters . addFilter ( "Swirl" , FilterType . SWIRL ) ; filters . addFilter ( "Weak Pixel Inclusion" , FilterType . WEAK_PIXEL_INCLUSION ) ; filters . addFilter ( "False Color" , FilterType . FALSE_COLOR ) ; filters . addFilter ( "Color Balance" , FilterType . COLOR_BALANCE ) ; filters . addFilter ( "Levels Min (Mid Adjust)" , FilterType . LEVELS_FILTER_MIN ) ; filters . addFilter ( "Bilateral Blur" , FilterType . BILATERAL_BLUR ) ; AlertDialog . Builder builder = new AlertDialog . Builder ( context ) ; builder . setTitle ( "Choose a filter" ) ; builder . setItems ( filters . names . toArray ( new String [ filters . names . size ( ) ] ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( final DialogInterface dialog , final int item ) { listener . onGpuImageFilterChosenListener ( createFilterForType ( context , filters . filters . get ( item ) ) ) ; } } ) ; builder . create ( ) . show ( ) ; }
@ Override public void onClick ( final DialogInterface dialog , final int item ) { listener . onGpuImageFilterChosenListener ( createFilterForType ( context , filters . filters . get ( item ) ) ) ; }
private static GPUImageFilter createFilterForType ( final Context context , final FilterType type ) { switch ( type ) { case CONTRAST : return new GPUImageContrastFilter ( 2.0f ) ; case GAMMA : return new GPUImageGammaFilter ( 2.0f ) ; case INVERT : return new GPUImageColorInvertFilter ( ) ; case PIXELATION : return new GPUImagePixelationFilter ( ) ; case HUE : return new GPUImageHueFilter ( 90.0f ) ; case BRIGHTNESS : return new GPUImageBrightnessFilter ( 1.5f ) ; case GRAYSCALE : return new GPUImageGrayscaleFilter ( ) ; case SEPIA : return new GPUImageSepiaFilter ( ) ; case SHARPEN : GPUImageSharpenFilter sharpness = new GPUImageSharpenFilter ( ) ; sharpness . setSharpness ( 2.0f ) ; return sharpness ; case SOBEL_EDGE_DETECTION : return new GPUImageSobelEdgeDetection ( ) ; case THREE_X_THREE_CONVOLUTION : GPUImage3x3ConvolutionFilter convolution = new GPUImage3x3ConvolutionFilter ( ) ; convolution . setConvolutionKernel ( new float [] { - 1.0f , 0.0f , 1.0f , - 2.0f , 0.0f , 2.0f , - 1.0f , 0.0f , 1.0f } ) ; return convolution ; case EMBOSS : return new GPUImageEmbossFilter ( ) ; case POSTERIZE : return new GPUImagePosterizeFilter ( ) ; case FILTER_GROUP : List < GPUImageFilter > filters = new LinkedList < GPUImageFilter > ( ) ; filters . add ( new GPUImageContrastFilter ( ) ) ; filters . add ( new GPUImageDirectionalSobelEdgeDetectionFilter ( ) ) ; filters . add ( new GPUImageGrayscaleFilter ( ) ) ; return new GPUImageFilterGroup ( filters ) ; case SATURATION : return new GPUImageSaturationFilter ( 1.0f ) ; case EXPOSURE : return new GPUImageExposureFilter ( 0.0f ) ; case HIGHLIGHT_SHADOW : return new GPUImageHighlightShadowFilter ( 0.0f , 1.0f ) ; case MONOCHROME : return new GPUImageMonochromeFilter ( 1.0f , new float [] { 0.6f , 0.45f , 0.3f , 1.0f } ) ; case OPACITY : return new GPUImageOpacityFilter ( 1.0f ) ; case RGB : return new GPUImageRGBFilter ( 1.0f , 1.0f , 1.0f ) ; case WHITE_BALANCE : return new GPUImageWhiteBalanceFilter ( 5000.0f , 0.0f ) ; case VIGNETTE : PointF centerPoint = new PointF ( ) ; centerPoint . x = 0.5f ; centerPoint . y = 0.5f ; return new GPUImageVignetteFilter ( centerPoint , new float [] { 0.0f , 0.0f , 0.0f } , 0.3f , 0.75f ) ; case TONE_CURVE : GPUImageToneCurveFilter toneCurveFilter = new GPUImageToneCurveFilter ( ) ; toneCurveFilter . setFromCurveFileInputStream ( context . getResources ( ) . openRawResource ( R . raw . tone_cuver_sample ) ) ; return toneCurveFilter ; case BLEND_DIFFERENCE : return createBlendFilter ( context , GPUImageDifferenceBlendFilter .class ) ; case BLEND_SOURCE_OVER : return createBlendFilter ( context , GPUImageSourceOverBlendFilter .class ) ; case BLEND_COLOR_BURN : return createBlendFilter ( context , GPUImageColorBurnBlendFilter .class ) ; case BLEND_COLOR_DODGE : return createBlendFilter ( context , GPUImageColorDodgeBlendFilter .class ) ; case BLEND_DARKEN : return createBlendFilter ( context , GPUImageDarkenBlendFilter .class ) ; case BLEND_DISSOLVE : return createBlendFilter ( context , GPUImageDissolveBlendFilter .class ) ; case BLEND_EXCLUSION : return createBlendFilter ( context , GPUImageExclusionBlendFilter .class ) ; case BLEND_HARD_LIGHT : return createBlendFilter ( context , GPUImageHardLightBlendFilter .class ) ; case BLEND_LIGHTEN : return createBlendFilter ( context , GPUImageLightenBlendFilter .class ) ; case BLEND_ADD : return createBlendFilter ( context , GPUImageAddBlendFilter .class ) ; case BLEND_DIVIDE : return createBlendFilter ( context , GPUImageDivideBlendFilter .class ) ; case BLEND_MULTIPLY : return createBlendFilter ( context , GPUImageMultiplyBlendFilter .class ) ; case BLEND_OVERLAY : return createBlendFilter ( context , GPUImageOverlayBlendFilter .class ) ; case BLEND_SCREEN : return createBlendFilter ( context , GPUImageScreenBlendFilter .class ) ; case BLEND_ALPHA : return createBlendFilter ( context , GPUImageAlphaBlendFilter .class ) ; case BLEND_COLOR : return createBlendFilter ( context , GPUImageColorBlendFilter .class ) ; case BLEND_HUE : return createBlendFilter ( context , GPUImageHueBlendFilter .class ) ; case BLEND_SATURATION : return createBlendFilter ( context , GPUImageSaturationBlendFilter .class ) ; case BLEND_LUMINOSITY : return createBlendFilter ( context , GPUImageLuminosityBlendFilter .class ) ; case BLEND_LINEAR_BURN : return createBlendFilter ( context , GPUImageLinearBurnBlendFilter .class ) ; case BLEND_SOFT_LIGHT : return createBlendFilter ( context , GPUImageSoftLightBlendFilter .class ) ; case BLEND_SUBTRACT : return createBlendFilter ( context , GPUImageSubtractBlendFilter .class ) ; case BLEND_CHROMA_KEY : return createBlendFilter ( context , GPUImageChromaKeyBlendFilter .class ) ; case BLEND_NORMAL : return createBlendFilter ( context , GPUImageNormalBlendFilter .class ) ; case LOOKUP_AMATORKA : GPUImageLookupFilter amatorka = new GPUImageLookupFilter ( ) ; amatorka . setBitmap ( BitmapFactory . decodeResource ( context . getResources ( ) , R . drawable . lookup_amatorka ) ) ; return amatorka ; case GAUSSIAN_BLUR : return new GPUImageGaussianBlurFilter ( ) ; case CROSSHATCH : return new GPUImageCrosshatchFilter ( ) ; case BOX_BLUR : return new GPUImageBoxBlurFilter ( ) ; case CGA_COLORSPACE : return new GPUImageCGAColorspaceFilter ( ) ; case DILATION : return new GPUImageDilationFilter ( ) ; case KUWAHARA : return new GPUImageKuwaharaFilter ( ) ; case RGB_DILATION : return new GPUImageRGBDilationFilter ( ) ; case SKETCH : return new GPUImageSketchFilter ( ) ; case TOON : return new GPUImageToonFilter ( ) ; case SMOOTH_TOON : return new GPUImageSmoothToonFilter ( ) ; case BULGE_DISTORTION : return new GPUImageBulgeDistortionFilter ( ) ; case GLASS_SPHERE : return new GPUImageGlassSphereFilter ( ) ; case HAZE : return new GPUImageHazeFilter ( ) ; case LAPLACIAN : return new GPUImageLaplacianFilter ( ) ; case NON_MAXIMUM_SUPPRESSION : return new GPUImageNonMaximumSuppressionFilter ( ) ; case SPHERE_REFRACTION : return new GPUImageSphereRefractionFilter ( ) ; case SWIRL : return new GPUImageSwirlFilter ( ) ; case WEAK_PIXEL_INCLUSION : return new GPUImageWeakPixelInclusionFilter ( ) ; case FALSE_COLOR : return new GPUImageFalseColorFilter ( ) ; case COLOR_BALANCE : return new GPUImageColorBalanceFilter ( ) ; case LEVELS_FILTER_MIN : GPUImageLevelsFilter levelsFilter = new GPUImageLevelsFilter ( ) ; levelsFilter . setMin ( 0.0f , 3.0f , 1.0f ) ; return levelsFilter ; case BILATERAL_BLUR : return new GPUImageBilateralFilter ( ) ; default: throw new IllegalStateException ( "No filter of that type!" ) ; } }
private static GPUImageFilter createBlendFilter ( Context context , Class < ? extends GPUImageTwoInputFilter > filterClass ) { try { GPUImageTwoInputFilter filter = filterClass . newInstance ( ) ; filter . setBitmap ( BitmapFactory . decodeResource ( context . getResources ( ) , R . drawable . ic_launcher ) ) ; return filter ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } }
void onGpuImageFilterChosenListener ( GPUImageFilter filter );
public void addFilter ( final String name , final FilterType filter ) { names . add ( name ) ; filters . add ( filter ) ; }
public FilterAdjuster ( final GPUImageFilter filter ) { if ( filter instanceof GPUImageSharpenFilter ) { adjuster = new SharpnessAdjuster ( ) . filter ( filter ) ; } else if ( filter instanceof GPUImageSepiaFilter ) { adjuster = new SepiaAdjuster ( ) . filter ( filter ) ; } else if ( filter instanceof GPUImageContrastFilter ) { adjuster = new ContrastAdjuster ( ) . filter ( filter ) ; } else if ( filter instanceof GPUImageGammaFilter ) { adjuster = new GammaAdjuster ( ) . filter ( filter ) ; } else if ( filter instanceof GPUImageBrightnessFilter ) { adjuster = new BrightnessAdjuster ( ) . filter ( filter ) ; } else if ( filter instanceof GPUImageSobelEdgeDetection ) { adjuster = new SobelAdjuster ( ) . filter ( filter ) ; } else if ( filter instanceof GPUImageEmbossFilter ) { adjuster = new EmbossAdjuster ( ) . filter ( filter ) ; } else if ( filter instanceof GPUImage3x3TextureSamplingFilter ) { adjuster = new GPU3x3TextureAdjuster ( ) . filter ( filter ) ; } else if ( filter instanceof GPUImageHueFilter ) { adjuster = new HueAdjuster ( ) . filter ( filter ) ; } else if ( filter instanceof GPUImagePosterizeFilter ) { adjuster = new PosterizeAdjuster ( ) . filter ( filter ) ; } else if ( filter instanceof GPUImagePixelationFilter ) { adjuster = new PixelationAdjuster ( ) . filter ( filter ) ; } else if ( filter instanceof GPUImageSaturationFilter ) { adjuster = new SaturationAdjuster ( ) . filter ( filter ) ; } else if ( filter instanceof GPUImageExposureFilter ) { adjuster = new ExposureAdjuster ( ) . filter ( filter ) ; } else if ( filter instanceof GPUImageHighlightShadowFilter ) { adjuster = new HighlightShadowAdjuster ( ) . filter ( filter ) ; } else if ( filter instanceof GPUImageMonochromeFilter ) { adjuster = new MonochromeAdjuster ( ) . filter ( filter ) ; } else if ( filter instanceof GPUImageOpacityFilter ) { adjuster = new OpacityAdjuster ( ) . filter ( filter ) ; } else if ( filter instanceof GPUImageRGBFilter ) { adjuster = new RGBAdjuster ( ) . filter ( filter ) ; } else if ( filter instanceof GPUImageWhiteBalanceFilter ) { adjuster = new WhiteBalanceAdjuster ( ) . filter ( filter ) ; } else if ( filter instanceof GPUImageVignetteFilter ) { adjuster = new VignetteAdjuster ( ) . filter ( filter ) ; } else if ( filter instanceof GPUImageDissolveBlendFilter ) { adjuster = new DissolveBlendAdjuster ( ) . filter ( filter ) ; } else if ( filter instanceof GPUImageGaussianBlurFilter ) { adjuster = new GaussianBlurAdjuster ( ) . filter ( filter ) ; } else if ( filter instanceof GPUImageCrosshatchFilter ) { adjuster = new CrosshatchBlurAdjuster ( ) . filter ( filter ) ; } else if ( filter instanceof GPUImageBulgeDistortionFilter ) { adjuster = new BulgeDistortionAdjuster ( ) . filter ( filter ) ; } else if ( filter instanceof GPUImageGlassSphereFilter ) { adjuster = new GlassSphereAdjuster ( ) . filter ( filter ) ; } else if ( filter instanceof GPUImageHazeFilter ) { adjuster = new HazeAdjuster ( ) . filter ( filter ) ; } else if ( filter instanceof GPUImageSphereRefractionFilter ) { adjuster = new SphereRefractionAdjuster ( ) . filter ( filter ) ; } else if ( filter instanceof GPUImageSwirlFilter ) { adjuster = new SwirlAdjuster ( ) . filter ( filter ) ; } else if ( filter instanceof GPUImageColorBalanceFilter ) { adjuster = new ColorBalanceAdjuster ( ) . filter ( filter ) ; } else if ( filter instanceof GPUImageLevelsFilter ) { adjuster = new LevelsMinMidAdjuster ( ) . filter ( filter ) ; } else if ( filter instanceof GPUImageBilateralFilter ) { adjuster = new BilateralAdjuster ( ) . filter ( filter ) ; } else { adjuster = null ; } }
public boolean canAdjust ( ) { return adjuster != null ; }
public void adjust ( final int percentage ) { if ( adjuster != null ) { adjuster . adjust ( percentage ) ; } }
@ SuppressWarnings ( "unchecked" ) public Adjuster < T > filter ( final GPUImageFilter filter ) { this . filter = ( T ) filter ; return this ; }
public T getFilter ( ) { return filter ; }
public abstract void adjust ( int percentage );
protected float range ( final int percentage , final float start , final float end ) { return ( end - start ) * percentage / 100.0f + start ; }
protected int range ( final int percentage , final int start , final int end ) { return ( end - start ) * percentage / 100 + start ; }
@ Override public void adjust ( final int percentage ) { getFilter ( ) . setSharpness ( range ( percentage , - 4.0f , 4.0f ) ) ; }
@ Override public void adjust ( final int percentage ) { getFilter ( ) . setPixel ( range ( percentage , 1.0f , 100.0f ) ) ; }
@ Override public void adjust ( final int percentage ) { getFilter ( ) . setHue ( range ( percentage , 0.0f , 360.0f ) ) ; }
@ Override public void adjust ( final int percentage ) { getFilter ( ) . setContrast ( range ( percentage , 0.0f , 2.0f ) ) ; }
@ Override public void adjust ( final int percentage ) { getFilter ( ) . setGamma ( range ( percentage , 0.0f , 3.0f ) ) ; }
@ Override public void adjust ( final int percentage ) { getFilter ( ) . setBrightness ( range ( percentage , - 1.0f , 1.0f ) ) ; }
@ Override public void adjust ( final int percentage ) { getFilter ( ) . setIntensity ( range ( percentage , 0.0f , 2.0f ) ) ; }
@ Override public void adjust ( final int percentage ) { getFilter ( ) . setLineSize ( range ( percentage , 0.0f , 5.0f ) ) ; }
@ Override public void adjust ( final int percentage ) { getFilter ( ) . setIntensity ( range ( percentage , 0.0f , 4.0f ) ) ; }
@ Override public void adjust ( final int percentage ) { getFilter ( ) . setColorLevels ( range ( percentage , 1 , 50 ) ) ; }
@ Override public void adjust ( final int percentage ) { getFilter ( ) . setLineSize ( range ( percentage , 0.0f , 5.0f ) ) ; }
@ Override public void adjust ( final int percentage ) { getFilter ( ) . setSaturation ( range ( percentage , 0.0f , 2.0f ) ) ; }
@ Override public void adjust ( final int percentage ) { getFilter ( ) . setExposure ( range ( percentage , - 10.0f , 10.0f ) ) ; }
@ Override public void adjust ( final int percentage ) { getFilter ( ) . setShadows ( range ( percentage , 0.0f , 1.0f ) ) ; getFilter ( ) . setHighlights ( range ( percentage , 0.0f , 1.0f ) ) ; }
@ Override public void adjust ( final int percentage ) { getFilter ( ) . setIntensity ( range ( percentage , 0.0f , 1.0f ) ) ; }
@ Override public void adjust ( final int percentage ) { getFilter ( ) . setOpacity ( range ( percentage , 0.0f , 1.0f ) ) ; }
@ Override public void adjust ( final int percentage ) { getFilter ( ) . setRed ( range ( percentage , 0.0f , 1.0f ) ) ; }
@ Override public void adjust ( final int percentage ) { getFilter ( ) . setTemperature ( range ( percentage , 2000.0f , 8000.0f ) ) ; }
@ Override public void adjust ( final int percentage ) { getFilter ( ) . setVignetteStart ( range ( percentage , 0.0f , 1.0f ) ) ; }
@ Override public void adjust ( final int percentage ) { getFilter ( ) . setMix ( range ( percentage , 0.0f , 1.0f ) ) ; }
@ Override public void adjust ( final int percentage ) { getFilter ( ) . setBlurSize ( range ( percentage , 0.0f , 1.0f ) ) ; }
@ Override public void adjust ( final int percentage ) { getFilter ( ) . setCrossHatchSpacing ( range ( percentage , 0.0f , 0.06f ) ) ; getFilter ( ) . setLineWidth ( range ( percentage , 0.0f , 0.006f ) ) ; }
@ Override public void adjust ( final int percentage ) { getFilter ( ) . setRadius ( range ( percentage , 0.0f , 1.0f ) ) ; getFilter ( ) . setScale ( range ( percentage , - 1.0f , 1.0f ) ) ; }
@ Override public void adjust ( final int percentage ) { getFilter ( ) . setRadius ( range ( percentage , 0.0f , 1.0f ) ) ; }
@ Override public void adjust ( final int percentage ) { getFilter ( ) . setDistance ( range ( percentage , - 0.3f , 0.3f ) ) ; getFilter ( ) . setSlope ( range ( percentage , - 0.3f , 0.3f ) ) ; }
@ Override public void adjust ( final int percentage ) { getFilter ( ) . setRadius ( range ( percentage , 0.0f , 1.0f ) ) ; }
@ Override public void adjust ( final int percentage ) { getFilter ( ) . setAngle ( range ( percentage , 0.0f , 2.0f ) ) ; }
@ Override public void adjust ( int percentage ) { getFilter ( ) . setMidtones ( new float [] { range ( percentage , 0.0f , 1.0f ) , range ( percentage / 2 , 0.0f , 1.0f ) , range ( percentage / 3 , 0.0f , 1.0f ) } ) ; }
@ Override public void adjust ( int percentage ) { getFilter ( ) . setMin ( 0.0f , range ( percentage , 0.0f , 1.0f ) , 1.0f ) ; }
@ Override public void adjust ( final int percentage ) { getFilter ( ) . setDistanceNormalizationFactor ( range ( percentage , 0.0f , 15.0f ) ) ; }
public ArrivalsListAdapterStyleB ( Context context ) { super( context , R . layout . arrivals_list_item_style_b ); }
public void setFragment ( ArrivalsListFragment fragment ) { mFragment = fragment ; }
public void setData ( ObaArrivalInfo [] arrivals , ArrayList < String > routesFilter , long currentTime ) { if ( arrivals != null ) { ArrayList < ArrivalInfo > list = ArrivalInfoUtils . convertObaArrivalInfo ( getContext ( ) , arrivals , routesFilter , currentTime , true ) ; Collections . sort ( list , new Comparator < ArrivalInfo > ( ) { @ Override public int compare ( ArrivalInfo s1 , ArrivalInfo s2 ) { int routeCompare = mAlphanumComparator . compare ( s1 . getInfo ( ) . getRouteId ( ) , s2 . getInfo ( ) . getRouteId ( ) ) ; if ( routeCompare != 0 ) { return routeCompare ; } else { return mAlphanumComparator . compare ( s1 . getInfo ( ) . getHeadsign ( ) , s2 . getInfo ( ) . getHeadsign ( ) ) ; } } } ) ; if ( list . size ( ) > 0 ) { ArrayList < CombinedArrivalInfoStyleB > newList = new ArrayList < CombinedArrivalInfoStyleB > ( ) ; String currentRouteName = null ; String currentHeadsign = null ; CombinedArrivalInfoStyleB cArrivalInfo = new CombinedArrivalInfoStyleB ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { if ( currentRouteName == null ) { currentRouteName = list . get ( i ) . getInfo ( ) . getRouteId ( ) ; currentHeadsign = list . get ( i ) . getInfo ( ) . getHeadsign ( ) ; } else { if ( ! currentRouteName . equals ( list . get ( i ) . getInfo ( ) . getRouteId ( ) ) || ! currentHeadsign . equals ( list . get ( i ) . getInfo ( ) . getHeadsign ( ) ) ) { newList . add ( cArrivalInfo ) ; cArrivalInfo = new CombinedArrivalInfoStyleB ( ) ; currentRouteName = list . get ( i ) . getInfo ( ) . getRouteId ( ) ; currentHeadsign = list . get ( i ) . getInfo ( ) . getHeadsign ( ) ; } } cArrivalInfo . getArrivalInfoList ( ) . add ( list . get ( i ) ) ; } if ( ! cArrivalInfo . getArrivalInfoList ( ) . isEmpty ( ) ) { newList . add ( cArrivalInfo ) ; setData ( newList ) ; return; } } } setData ( null ) ; }
@ Override public int compare ( ArrivalInfo s1 , ArrivalInfo s2 ) { int routeCompare = mAlphanumComparator . compare ( s1 . getInfo ( ) . getRouteId ( ) , s2 . getInfo ( ) . getRouteId ( ) ) ; if ( routeCompare != 0 ) { return routeCompare ; } else { return mAlphanumComparator . compare ( s1 . getInfo ( ) . getHeadsign ( ) , s2 . getInfo ( ) . getHeadsign ( ) ) ; } }
@ Override protected void initView ( final View view , CombinedArrivalInfoStyleB combinedArrivalInfoStyleB ) { final ArrivalInfo stopInfo = combinedArrivalInfoStyleB . getArrivalInfoList ( ) . get ( 0 ) ; final ObaArrivalInfo arrivalInfo = stopInfo . getInfo ( ) ; final Context context = getContext ( ) ; LayoutInflater inflater = LayoutInflater . from ( context ) ; TextView routeName = ( TextView ) view . findViewById ( R . id . routeName ) ; TextView destination = ( TextView ) view . findViewById ( R . id . routeDestination ) ; TableLayout arrivalTimesLayout = ( TableLayout ) view . findViewById ( R . id . arrivalTimeLayout ) ; arrivalTimesLayout . removeAllViews ( ) ; Resources r = view . getResources ( ) ; ImageButton starBtn = ( ImageButton ) view . findViewById ( R . id . route_star ) ; starBtn . setColorFilter ( r . getColor ( R . color . theme_primary ) ) ; ImageButton mapImageBtn = ( ImageButton ) view . findViewById ( R . id . mapImageBtn ) ; mapImageBtn . setColorFilter ( r . getColor ( R . color . theme_primary ) ) ; ImageButton routeMoreInfo = ( ImageButton ) view . findViewById ( R . id . route_more_info ) ; routeMoreInfo . setColorFilter ( r . getColor ( R . color . switch_thumb_normal_material_dark ) ) ; starBtn . setImageResource ( stopInfo . isRouteAndHeadsignFavorite ( ) ? R . drawable . focus_star_on : R . drawable . focus_star_off ) ; starBtn . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { RouteFavoriteDialogFragment dialog = new RouteFavoriteDialogFragment . Builder ( stopInfo . getInfo ( ) . getRouteId ( ) , stopInfo . getInfo ( ) . getHeadsign ( ) ) . setRouteShortName ( stopInfo . getInfo ( ) . getShortName ( ) ) . setRouteLongName ( stopInfo . getInfo ( ) . getRouteLongName ( ) ) . setStopId ( stopInfo . getInfo ( ) . getStopId ( ) ) . setFavorite ( ! stopInfo . isRouteAndHeadsignFavorite ( ) ) . build ( ) ; dialog . setCallback ( new RouteFavoriteDialogFragment . Callback ( ) { @ Override public void onSelectionComplete ( boolean savedFavorite ) { if ( savedFavorite ) { mFragment . refreshLocal ( ) ; } } } ) ; dialog . show ( mFragment . getFragmentManager ( ) , RouteFavoriteDialogFragment . TAG ) ; } } ) ; mapImageBtn . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { mFragment . showRouteOnMap ( stopInfo ) ; } } ) ; routeMoreInfo . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { mFragment . showListItemMenu ( view , stopInfo ) ; } } ) ; routeName . setText ( arrivalInfo . getShortName ( ) ) ; destination . setText ( UIUtils . formatDisplayText ( arrivalInfo . getHeadsign ( ) ) ) ; for ( int i = 0 ; i < combinedArrivalInfoStyleB . getArrivalInfoList ( ) . size ( ) ; i ++ ) { final ArrivalInfo arrivalRow = combinedArrivalInfoStyleB . getArrivalInfoList ( ) . get ( i ) ; final ObaArrivalInfo tempArrivalInfo = arrivalRow . getInfo ( ) ; long scheduledTime = tempArrivalInfo . getScheduledArrivalTime ( ) ; final TableRow tr = ( TableRow ) inflater . inflate ( R . layout . arrivals_list_tr_template_style_b , null ) ; RelativeLayout layout ; TextView scheduleView , estimatedView , statusView ; View divider ; if ( i == 0 ) { layout = ( RelativeLayout ) inflater . inflate ( R . layout . arrivals_list_rl_template_style_b_large , null ) ; scheduleView = ( TextView ) inflater . inflate ( R . layout . arrivals_list_tv_template_style_b_schedule_large , null ) ; estimatedView = ( TextView ) inflater . inflate ( R . layout . arrivals_list_tv_template_style_b_estimated_large , null ) ; statusView = ( TextView ) inflater . inflate ( R . layout . arrivals_list_tv_template_style_b_status_large , null ) ; } else { layout = ( RelativeLayout ) inflater . inflate ( R . layout . arrivals_list_rl_template_style_b_small , null ) ; scheduleView = ( TextView ) inflater . inflate ( R . layout . arrivals_list_tv_template_style_b_schedule_small , null ) ; estimatedView = ( TextView ) inflater . inflate ( R . layout . arrivals_list_tv_template_style_b_estimated_small , null ) ; statusView = ( TextView ) inflater . inflate ( R . layout . arrivals_list_tv_template_style_b_status_small , null ) ; } scheduleView . setText ( UIUtils . formatTime ( context , scheduledTime ) ) ; if ( arrivalRow . getPredicted ( ) ) { long eta = arrivalRow . getEta ( ) ; if ( eta == 0 ) { estimatedView . setText ( R . string . stop_info_eta_now ) ; } else { estimatedView . setText ( eta + " min" ) ; } } else { estimatedView . setText ( R . string . stop_info_eta_unknown ) ; } statusView . setText ( arrivalRow . getStatusText ( ) ) ; int colorCode = arrivalRow . getColor ( ) ; statusView . setBackgroundResource ( R . drawable . round_corners_style_b_status ) ; GradientDrawable d = ( GradientDrawable ) statusView . getBackground ( ) ; d . setColor ( context . getResources ( ) . getColor ( colorCode ) ) ; int alpha ; if ( i == 0 ) { alpha = ( int ) ( 1.0f * 255 ) ; } else { alpha = ( int ) ( .35f * 255 ) ; } d . setAlpha ( alpha ) ; estimatedView . setTextColor ( UIUtils . getTransparentColor ( context . getResources ( ) . getColor ( colorCode ) , alpha * 2 ) ) ; int pSides = UIUtils . dpToPixels ( context , 5 ) ; int pTopBottom = UIUtils . dpToPixels ( context , 2 ) ; statusView . setPadding ( pSides , pTopBottom , pSides , pTopBottom ) ; layout . addView ( scheduleView ) ; layout . addView ( statusView ) ; layout . addView ( estimatedView ) ; RelativeLayout . LayoutParams params1 = ( RelativeLayout . LayoutParams ) scheduleView . getLayoutParams ( ) ; params1 . addRule ( RelativeLayout . ALIGN_PARENT_LEFT ) ; params1 . addRule ( RelativeLayout . CENTER_VERTICAL ) ; scheduleView . setLayoutParams ( params1 ) ; RelativeLayout . LayoutParams params2 = ( RelativeLayout . LayoutParams ) statusView . getLayoutParams ( ) ; params2 . addRule ( RelativeLayout . CENTER_IN_PARENT ) ; int p = UIUtils . dpToPixels ( context , 3 ) ; params2 . setMargins ( p , p , p , p ) ; statusView . setLayoutParams ( params2 ) ; RelativeLayout . LayoutParams params3 = ( RelativeLayout . LayoutParams ) estimatedView . getLayoutParams ( ) ; params3 . addRule ( RelativeLayout . ALIGN_PARENT_RIGHT ) ; params3 . addRule ( RelativeLayout . CENTER_VERTICAL ) ; estimatedView . setLayoutParams ( params3 ) ; tr . addView ( layout ) ; if ( i != 0 ) { int dividerHeight = UIUtils . dpToPixels ( context , 1 ) ; divider = inflater . inflate ( R . layout . arrivals_list_divider_template_style_b , null ) ; divider . setLayoutParams ( new TableRow . LayoutParams ( TableRow . LayoutParams . MATCH_PARENT , dividerHeight ) ) ; arrivalTimesLayout . addView ( divider ) ; } tr . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { mFragment . showListItemMenu ( tr , arrivalRow ) ; } } ) ; arrivalTimesLayout . addView ( tr , new TableLayout . LayoutParams ( TableLayout . LayoutParams . MATCH_PARENT , TableLayout . LayoutParams . MATCH_PARENT ) ) ; } ContentValues values = null ; if ( mTripsForStop != null ) { values = mTripsForStop . getValues ( arrivalInfo . getTripId ( ) ) ; } if ( values != null ) { String reminderName = values . getAsString ( ObaContract . Trips . NAME ) ; TextView reminder = ( TextView ) view . findViewById ( R . id . reminder ) ; if ( reminderName . length ( ) == 0 ) { reminderName = context . getString ( R . string . trip_info_noname ) ; } reminder . setText ( reminderName ) ; Drawable d = reminder . getCompoundDrawables ( ) [ 0 ] ; d = DrawableCompat . wrap ( d ) ; DrawableCompat . setTint ( d . mutate ( ) , view . getResources ( ) . getColor ( R . color . theme_primary ) ) ; reminder . setCompoundDrawables ( d , null , null , null ) ; reminder . setVisibility ( View . VISIBLE ) ; } else { View reminder = view . findViewById ( R . id . reminder ) ; reminder . setVisibility ( View . GONE ) ; } }
@ Override public void onClick ( View v ) { RouteFavoriteDialogFragment dialog = new RouteFavoriteDialogFragment . Builder ( stopInfo . getInfo ( ) . getRouteId ( ) , stopInfo . getInfo ( ) . getHeadsign ( ) ) . setRouteShortName ( stopInfo . getInfo ( ) . getShortName ( ) ) . setRouteLongName ( stopInfo . getInfo ( ) . getRouteLongName ( ) ) . setStopId ( stopInfo . getInfo ( ) . getStopId ( ) ) . setFavorite ( ! stopInfo . isRouteAndHeadsignFavorite ( ) ) . build ( ) ; dialog . setCallback ( new RouteFavoriteDialogFragment . Callback ( ) { @ Override public void onSelectionComplete ( boolean savedFavorite ) { if ( savedFavorite ) { mFragment . refreshLocal ( ) ; } } } ) ; dialog . show ( mFragment . getFragmentManager ( ) , RouteFavoriteDialogFragment . TAG ) ; }
@ Override public void onSelectionComplete ( boolean savedFavorite ) { if ( savedFavorite ) { mFragment . refreshLocal ( ) ; } }
@ Override public void onClick ( View v ) { mFragment . showRouteOnMap ( stopInfo ) ; }
@ Override public void onClick ( View v ) { mFragment . showListItemMenu ( view , stopInfo ) ; }
@ Override public void onClick ( View v ) { mFragment . showListItemMenu ( tr , arrivalRow ) ; }
public String getName ( )
public String getUrl ( )
public String getTimezone ( )
public String getLang ( )
public String getPhone ( )
public String getDisclaimer ( )
public String getEmail ( )
public GPUImageWhiteBalanceFilter ( ) { this( 5000.0f , 0.0f ); }
public GPUImageWhiteBalanceFilter ( final float temperature , final float tint ) { super( NO_FILTER_VERTEX_SHADER , WHITE_BALANCE_FRAGMENT_SHADER ); mTemperature = temperature ; mTint = tint ; }
@ Override public void onInit ( ) { super. onInit ( ) ; mTemperatureLocation = GLES20 . glGetUniformLocation ( getProgram ( ) , "temperature" ) ; mTintLocation = GLES20 . glGetUniformLocation ( getProgram ( ) , "tint" ) ; setTemperature ( mTemperature ) ; setTint ( mTint ) ; }
public void setTemperature ( final float temperature ) { mTemperature = temperature ; setFloat ( mTemperatureLocation , mTemperature < 5000 ? ( float ) ( 0.0004 * ( mTemperature - 5000.0 ) ) : ( float ) ( 0.00006 * ( mTemperature - 5000.0 ) ) ) ; }
public void setTint ( final float tint ) { mTint = tint ; setFloat ( mTintLocation , ( float ) ( mTint / 100.0 ) ) ; }
ObaTripStatusElement ( ) { serviceDate = 0 ; predicted = false ; scheduleDeviation = 0 ; vehicleId = "" ; closestStop = "" ; closestStopTimeOffset = 0 ; position = null ; activeTripId = null ; distanceAlongTrip = null ; scheduledDistanceAlongTrip = null ; totalDistanceAlongTrip = null ; orientation = null ; nextStop = null ; nextStopTimeOffset = 0 ; phase = null ; status = null ; lastUpdateTime = null ; lastKnownLocation = null ; lastLocationUpdateTime = null ; lastKnownOrientation = null ; blockTripSequence = 0 ; }
@ Override public long getServiceDate ( ) { return serviceDate ; }
@ Override public boolean isPredicted ( ) { return predicted ; }
@ Override public long getScheduleDeviation ( ) { return scheduleDeviation ; }
@ Override public String getVehicleId ( ) { return vehicleId ; }
@ Override public String getClosestStop ( ) { return closestStop ; }
@ Override public long getClosestStopTimeOffset ( ) { return closestStopTimeOffset ; }
@ Override public Location getPosition ( ) { return ( position != null ) ? position . getLocation ( ) : null ; }
@ Override public String getActiveTripId ( ) { return activeTripId ; }
@ Override public Double getDistanceAlongTrip ( ) { return distanceAlongTrip ; }
@ Override public Double getScheduledDistanceAlongTrip ( ) { return scheduledDistanceAlongTrip ; }
@ Override public Double getTotalDistanceAlongTrip ( ) { return totalDistanceAlongTrip ; }
@ Override public Double getOrientation ( ) { return orientation ; }
@ Override public String getNextStop ( ) { return nextStop ; }
@ Override public Long getNextStopTimeOffset ( ) { return nextStopTimeOffset ; }
@ Override public String getPhase ( ) { return phase ; }
@ Override public String getStatus ( ) { return status ; }
@ Override public long getLastUpdateTime ( ) { return lastUpdateTime ; }
@ Override public Location getLastKnownLocation ( ) { return ( lastKnownLocation != null ) ? lastKnownLocation . getLocation ( ) : null ; }
@ Override public long getLastLocationUpdateTime ( ) { return lastLocationUpdateTime ; }
@ Override public Double getLastKnownOrientation ( ) { return lastKnownOrientation ; }
@ Override public int getBlockTripSequence ( ) { return blockTripSequence ; }
@ Override public void execute ( ) MojoExecutionException , MojoFailureException { ConfigHandler configHandler = new ConfigHandler ( this , this . session , this . execution ) ; configHandler . parseConfiguration ( ) ; getLog ( ) . debug ( "Parsed values for Android Lint invocation: " ) ; getLog ( ) . debug ( "failOnError:" + parsedFailOnError ) ; getLog ( ) . debug ( "skip:" + parsedSkip ) ; getLog ( ) . debug ( "legacy:" + parsedLegacy ) ; getLog ( ) . debug ( "quiet:" + parsedQuiet ) ; getLog ( ) . debug ( "ignoreWarnings:" + parsedIgnoreWarnings ) ; getLog ( ) . debug ( "warnAll:" + parsedWarnAll ) ; getLog ( ) . debug ( "warningsAsErrors:" + parsedWarningsAsErrors ) ; getLog ( ) . debug ( "config2:" + parsedConfig ) ; getLog ( ) . debug ( "fullPath:" + parsedFullPath ) ; getLog ( ) . debug ( "showAll:" + parsedShowAll ) ; getLog ( ) . debug ( "disableSourceLines:" + parsedDisableSourceLines ) ; getLog ( ) . debug ( "enablehtml: " + parsedEnableHtml ) ; getLog ( ) . debug ( "htmlOutputPath:" + parsedHtmlOutputPath ) ; getLog ( ) . debug ( "enableSimpleHtml: " + parsedEnableSimpleHtml ) ; getLog ( ) . debug ( "simpleHtmlOutputPath:" + parsedSimpleHtmlOutputPath ) ; getLog ( ) . debug ( "enableXml: " + parsedEnableXml ) ; getLog ( ) . debug ( "xmlOutputPath:" + parsedXmlOutputPath ) ; getLog ( ) . debug ( "sources:" + parsedSources ) ; getLog ( ) . debug ( "classpath:" + parsedClasspath ) ; getLog ( ) . debug ( "libraries:" + parsedLibraries ) ; if ( parsedSkip ) { getLog ( ) . info ( "Skipping lint analysis." ) ; } else { getLog ( ) . info ( "Performing lint analysis." ) ; if ( parsedLegacy ) { getLog ( ) . info ( "Using Lint from the Android SDK." ) ; executeWhenConfigured ( ) ; } else { getLog ( ) . info ( "Using Lint dependency library." ) ; runLint ( ) ; } } }
private void executeWhenConfigured ( ) MojoExecutionException { CommandExecutor executor = CommandExecutor . Factory . createDefaultCommmandExecutor ( ) ; executor . setLogger ( this . getLog ( ) ) ; String command = getAndroidSdk ( ) . getLintPath ( ) ; List < String > parameters = new ArrayList < String > ( ) ; if ( isNotNullAndTrue ( parsedIgnoreWarnings ) ) { parameters . add ( "-w" ) ; } if ( isNotNullAndTrue ( parsedWarnAll ) ) { parameters . add ( "-Wall" ) ; } if ( isNotNullAndTrue ( parsedWarningsAsErrors ) ) { parameters . add ( "-Werror" ) ; } if ( isNotNullAndNotEquals ( parsedConfig , "null" ) ) { parameters . add ( "--config" ) ; parameters . add ( parsedConfig ) ; } if ( isNotNullAndTrue ( parsedFullPath ) ) { parameters . add ( "--fullpath" ) ; } if ( isNotNullAndTrue ( parsedShowAll ) ) { parameters . add ( "--showall" ) ; } if ( isNotNullAndTrue ( parsedDisableSourceLines ) ) { parameters . add ( "--nolines" ) ; } if ( isNotNullAndTrue ( parsedEnableHtml ) ) { parameters . add ( "--html" ) ; parameters . add ( parsedHtmlOutputPath ) ; getLog ( ) . info ( "Writing Lint HTML report in " + parsedHtmlOutputPath ) ; } if ( isNotNullAndNotEquals ( parsedUrl , "none" ) ) { parameters . add ( "--url" ) ; parameters . add ( parsedUrl ) ; } if ( isNotNullAndTrue ( parsedEnableSimpleHtml ) ) { parameters . add ( "--simplehtml" ) ; parameters . add ( parsedSimpleHtmlOutputPath ) ; getLog ( ) . info ( "Writing Lint simple HTML report in " + parsedSimpleHtmlOutputPath ) ; } if ( isNotNullAndTrue ( parsedEnableXml ) ) { parameters . add ( "--xml" ) ; parameters . add ( parsedXmlOutputPath ) ; getLog ( ) . info ( "Writing Lint XML report in " + parsedXmlOutputPath ) ; } if ( isNotNullAndTrue ( parsedEnableSources ) ) { parameters . add ( "--sources" ) ; parameters . add ( parsedSources ) ; } if ( isNotNullAndTrue ( parsedEnableClasspath ) ) { parameters . add ( "--classpath" ) ; parameters . add ( parsedClasspath ) ; } if ( isNotNullAndTrue ( parsedEnableLibraries ) ) { parameters . add ( "--libraries" ) ; parameters . add ( parsedLibraries ) ; } parameters . add ( project . getBasedir ( ) . getAbsolutePath ( ) ) ; parameters . add ( "--exitcode" ) ; try { getLog ( ) . info ( "Running command: " + command ) ; getLog ( ) . info ( "with parameters: " + parameters ) ; executor . executeCommand ( command , parameters , false ) ; } catch ( ExecutionException e ) { if ( isNotNullAndTrue ( parsedFailOnError ) ) { getLog ( ) . info ( "Lint analysis produced errors and project is configured to fail on error." ) ; getLog ( ) . info ( "Inspect lint reports or re-run with -X to see lint errors in log" ) ; getLog ( ) . info ( "Failing build as configured. Ignore following error message." ) ; throw new MojoExecutionException ( "" , e ) ; } } getLog ( ) . info ( "Lint analysis completed successfully." ) ; }
private void runLint ( ) MojoExecutionException { IssueRegistry registry = new BuiltinIssueRegistry ( ) ; LintCliFlags flags = new LintCliFlags ( ) ; LintCliClient client = new LintCliClient ( flags , "AndroidMaven" ) ; try { if ( isNotNull ( parsedQuiet ) ) { flags . setQuiet ( parsedQuiet ) ; } if ( isNotNull ( parsedIgnoreWarnings ) ) { flags . setIgnoreWarnings ( parsedIgnoreWarnings ) ; } if ( isNotNull ( parsedWarnAll ) ) { flags . setCheckAllWarnings ( parsedWarnAll ) ; } if ( isNotNull ( parsedWarningsAsErrors ) ) { flags . setWarningsAsErrors ( parsedWarningsAsErrors ) ; } if ( isNotNullAndNotEquals ( parsedConfig , "null" ) ) { flags . setDefaultConfiguration ( new File ( parsedConfig ) ) ; } if ( isNotNull ( parsedFullPath ) ) { flags . setFullPath ( parsedFullPath ) ; } if ( isNotNull ( parsedShowAll ) ) { flags . setShowEverything ( parsedShowAll ) ; } if ( isNotNull ( parsedDisableSourceLines ) ) { flags . setShowSourceLines ( ! parsedDisableSourceLines ) ; } if ( isNotNullAndTrue ( parsedEnableHtml ) ) { File outHtml = new File ( parsedHtmlOutputPath ) ; flags . getReporters ( ) . add ( new MultiProjectHtmlReporter ( client , outHtml , flags ) ) ; getLog ( ) . info ( "Writing Lint HTML report in " + parsedHtmlOutputPath ) ; } if ( isNotNullAndNotEquals ( parsedUrl , "none" ) ) { } if ( isNotNullAndTrue ( parsedEnableSimpleHtml ) ) { File outSimpleHtml = new File ( parsedSimpleHtmlOutputPath ) ; flags . getReporters ( ) . add ( new MultiProjectHtmlReporter ( client , outSimpleHtml , flags ) ) ; getLog ( ) . info ( "Writing Lint simple HTML report in " + parsedSimpleHtmlOutputPath ) ; } if ( isNotNullAndTrue ( parsedEnableXml ) ) { flags . getReporters ( ) . add ( new XmlReporter ( client , new File ( parsedXmlOutputPath ) ) ) ; getLog ( ) . info ( "Writing Lint XML report in " + parsedXmlOutputPath ) ; } if ( isNotNullAndTrue ( parsedEnableSources ) ) { } if ( isNotNullAndTrue ( parsedEnableClasspath ) ) { } if ( isNotNullAndTrue ( parsedEnableLibraries ) ) { } List < File > files = new ArrayList < File > ( ) ; files . add ( resourceDirectory ) ; files . add ( destinationManifestFile ) ; files . add ( sourceDirectory ) ; files . add ( assetsDirectory ) ; client . run ( registry , files ) ; } catch ( IOException ex ) { throw new MojoExecutionException ( ex . getMessage ( ) , ex ) ; } }
private boolean isNotNull ( Boolean b ) { return b != null ; }
private boolean isNotNullAndTrue ( Boolean b ) { return b != null && b ; }
private boolean isNotNullAndNotEquals ( String underTest , String compared ) { return underTest != null && ! underTest . equals ( compared ) ; }
private String getHtmlOutputPath ( ) { if ( parsedHtmlOutputPath == null ) { File reportPath = new File ( targetDirectory , "lint-results/lint-results-html" ) ; createReportDirIfNeeded ( reportPath ) ; return reportPath . getAbsolutePath ( ) ; } return parsedHtmlOutputPath ; }
private String getSimpleHtmlOutputPath ( ) { if ( parsedSimpleHtmlOutputPath == null ) { File reportPath = new File ( targetDirectory , "lint-results/lint-results-simple-html" ) ; createReportDirIfNeeded ( reportPath ) ; return reportPath . getAbsolutePath ( ) ; } return parsedSimpleHtmlOutputPath ; }
private String getXmlOutputPath ( ) { getLog ( ) . debug ( "get parsed xml output path:" + parsedXmlOutputPath ) ; if ( parsedXmlOutputPath == null ) { File reportPath = new File ( targetDirectory , "lint-results/lint-results.xml" ) ; createReportDirIfNeeded ( reportPath ) ; return reportPath . getAbsolutePath ( ) ; } return parsedXmlOutputPath ; }
private void createReportDirIfNeeded ( File reportPath ) { if ( ! reportPath . getParentFile ( ) . exists ( ) ) { reportPath . getParentFile ( ) . mkdirs ( ) ; } }
private String getSources ( ) { if ( parsedSources == null ) { parsedSources = sourceDirectory . getAbsolutePath ( ) ; } return parsedSources ; }
private String getClasspath ( ) { if ( parsedClasspath == null ) { parsedClasspath = projectOutputDirectory . getAbsolutePath ( ) ; } return parsedClasspath ; }
private String getLibraries ( ) { if ( parsedLibraries == null ) { StringBuilder defaultClasspathBuilder = new StringBuilder ( ) ; Set < Artifact > artifacts = project . getDependencyArtifacts ( ) ; if ( artifacts != null ) { for ( Artifact artifact : artifacts ) { if ( ! Artifact . SCOPE_PROVIDED . equals ( artifact . getScope ( ) ) && artifact . isResolved ( ) ) { defaultClasspathBuilder . append ( artifact . getFile ( ) . getPath ( ) ) ; defaultClasspathBuilder . append ( File . pathSeparator ) ; } } if ( defaultClasspathBuilder . length ( ) > 0 ) { defaultClasspathBuilder . deleteCharAt ( defaultClasspathBuilder . length ( ) - 1 ) ; parsedLibraries = defaultClasspathBuilder . toString ( ) ; } } } return parsedLibraries ; }
public MediaRouteDiscoveryRequestAssert ( MediaRouteDiscoveryRequest actual ) { super( actual , MediaRouteDiscoveryRequestAssert .class ); }
public MediaRouteDiscoveryRequestAssert isActiveScan ( ) { isNotNull ( ) ; assertThat ( actual . isActiveScan ( ) ) . overridingErrorMessage ( "is performing active scanning" ) . isTrue ( ) ; return this ; }
public MediaRouteDiscoveryRequestAssert isNotActiveScan ( ) { isNotNull ( ) ; assertThat ( actual . isActiveScan ( ) ) . overridingErrorMessage ( "is not performing active scanning" ) . isFalse ( ) ; return this ; }
public MediaRouteDiscoveryRequestAssert isValid ( ) { isNotNull ( ) ; assertThat ( actual . isValid ( ) ) . overridingErrorMessage ( "Expected to be valid but was not." ) . isTrue ( ) ; return this ; }
public MediaRouteDiscoveryRequestAssert isNotValid ( ) { isNotNull ( ) ; assertThat ( actual . isValid ( ) ) . overridingErrorMessage ( "Expected to not be valid but was." ) . isFalse ( ) ; return this ; }
public SyncOperation ( File fileDir , Activity callingActivity ) { super( fileDir , callingActivity ); }
public SyncOperation setCommands ( ) { Git git = new Git ( repository ) ; this . addCommand = git . add ( ) . addFilepattern ( "." ) ; this . commitCommand = git . commit ( ) . setMessage ( "[Android Password Store] Sync" ) ; this . pullCommand = git . pull ( ) . setRebase ( true ) . setRemote ( "origin" ) ; this . pushCommand = git . push ( ) . setPushAll ( ) . setRemote ( "origin" ) ; return this ; }
@ Override public void execute ( ) { if ( this . provider != null ) { this . pullCommand . setCredentialsProvider ( this . provider ) ; this . pushCommand . setCredentialsProvider ( this . provider ) ; } new GitAsyncTask ( callingActivity , true , false , this ) . execute ( this . addCommand , this . commitCommand , this . pullCommand , this . pushCommand ) ; }
@ Override public void onTaskEnded ( String result ) { new AlertDialog . Builder ( callingActivity ) . setTitle ( callingActivity . getResources ( ) . getString ( R . string . jgit_error_dialog_title ) ) . setMessage ( "Error occured during the sync operation, " + callingActivity . getResources ( ) . getString ( R . string . jgit_error_dialog_text ) + result + "\nPlease check the FAQ for possible reasons why this error might occur." ) . setPositiveButton ( callingActivity . getResources ( ) . getString ( R . string . dialog_ok ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialogInterface , int i ) { callingActivity . finish ( ) ; } } ) . show ( ) ; }
@ Override public void onClick ( DialogInterface dialogInterface , int i ) { callingActivity . finish ( ) ; }
public static void start ( Context context , String routeId ) { context . startActivity ( makeIntent ( context , routeId ) ) ; }
public static Intent makeIntent ( Context context , String routeId ) { Intent myIntent = new Intent ( context , RouteInfoActivity .class ) ; myIntent . setData ( Uri . withAppendedPath ( ObaContract . Routes . CONTENT_URI , routeId ) ) ; return myIntent ; }
@ Override public void onCreate ( Bundle savedInstanceState ) { super. onCreate ( savedInstanceState ) ; UIUtils . setupActionBar ( this ) ; FragmentManager fm = getSupportFragmentManager ( ) ; if ( fm . findFragmentById ( android . R . id . content ) == null ) { RouteInfoListFragment list = new RouteInfoListFragment ( ) ; list . setArguments ( FragmentUtils . getIntentArgs ( getIntent ( ) ) ) ; fm . beginTransaction ( ) . add ( android . R . id . content , list ) . commit ( ) ; } }
@ Override protected void onStart ( ) { super. onStart ( ) ; ObaAnalytics . reportActivityStart ( this ) ; }
@ Override public boolean onOptionsItemSelected ( MenuItem item ) { if ( item . getItemId ( ) == android . R . id . home ) { NavHelp . goHome ( this , false ) ; return true ; } return false ; }
void onListViewCreated ( ListView listView );
void onArrivalTimesUpdated ( final ObaArrivalInfoResponse response );
boolean onShowRouteOnMapSelected ( ArrivalInfo arrivalInfo );
void onSortBySelected ( )
public IntentBuilder ( Context context , String stopId ) { mIntent = new Intent ( context , ArrivalsListFragment .class ) ; mIntent . setData ( Uri . withAppendedPath ( ObaContract . Stops . CONTENT_URI , stopId ) ) ; }
public IntentBuilder ( Context context , ObaStop stop , HashMap < String , ObaRoute > routes ) { mIntent = new Intent ( context , ArrivalsListFragment .class ) ; mIntent . setData ( Uri . withAppendedPath ( ObaContract . Stops . CONTENT_URI , stop . getId ( ) ) ) ; setStopName ( stop . getName ( ) ) ; setStopCode ( stop . getStopCode ( ) ) ; setStopDirection ( stop . getDirection ( ) ) ; setStopRoutes ( UIUtils . serializeRouteDisplayNames ( stop , routes ) ) ; setStopLocation ( stop . getLocation ( ) ) ; }
public IntentBuilder setStopName ( String stopName ) { mIntent . putExtra ( ArrivalsListFragment . STOP_NAME , stopName ) ; return this ; }
public IntentBuilder setStopCode ( String stopCode ) { mIntent . putExtra ( ArrivalsListFragment . STOP_CODE , stopCode ) ; return this ; }
public IntentBuilder setStopDirection ( String stopDir ) { mIntent . putExtra ( ArrivalsListFragment . STOP_DIRECTION , stopDir ) ; return this ; }
public IntentBuilder setStopLocation ( Location stopLocation ) { mIntent . putExtra ( ArrivalsListFragment . STOP_LAT , stopLocation . getLatitude ( ) ) ; mIntent . putExtra ( ArrivalsListFragment . STOP_LON , stopLocation . getLongitude ( ) ) ; return this ; }
public IntentBuilder setStopRoutes ( String routes ) { mIntent . putExtra ( ArrivalsListFragment . STOP_ROUTES , routes ) ; return this ; }
public Intent build ( ) { return mIntent ; }
@ Override public View onCreateView ( LayoutInflater inflater , ViewGroup root , Bundle savedInstanceState ) { if ( root == null ) { return null ; } initArrivalInfoViews ( BuildFlavorUtils . getArrivalInfoStyleFromPreferences ( ) , inflater ) ; return inflater . inflate ( R . layout . fragment_arrivals_list , null ) ; }
@ Override public void onViewStateRestored ( @ Nullable Bundle savedInstanceState ) { super. onViewStateRestored ( savedInstanceState ) ; RouteFavoriteDialogFragment dialogFragment = ( RouteFavoriteDialogFragment ) getFragmentManager ( ) . findFragmentByTag ( RouteFavoriteDialogFragment . TAG ) ; if ( dialogFragment != null ) { setCallbackToDialogFragment ( dialogFragment ) ; } }
@ Override public void onActivityCreated ( Bundle savedInstanceState ) { super. onActivityCreated ( savedInstanceState ) ; setListViewProperties ( BuildFlavorUtils . getArrivalInfoStyleFromPreferences ( ) ) ; setHasOptionsMenu ( true ) ; mAlertList = new AlertList ( getActivity ( ) ) ; mAlertList . initView ( getView ( ) . findViewById ( R . id . arrivals_alert_list ) ) ; setupHeader ( savedInstanceState ) ; setupFooter ( ) ; setupEmptyList ( null ) ; setStopId ( ) ; setUserInfo ( ) ; instantiateAdapter ( BuildFlavorUtils . getArrivalInfoStyleFromPreferences ( ) ) ; setListShown ( false ) ; mRoutesFilter = ObaContract . StopRouteFilters . get ( getActivity ( ) , mStopId ) ; mTripsForStopCallback = new TripsForStopCallback ( ) ; LoaderManager mgr = getLoaderManager ( ) ; mgr . initLoader ( TRIPS_FOR_STOP_LOADER , null , mTripsForStopCallback ) ; mgr . initLoader ( ARRIVALS_LIST_LOADER , getArguments ( ) , this ) ; setEmptyText ( UIUtils . getNoArrivalsMessage ( getActivity ( ) , getArrivalsLoader ( ) . getMinutesAfter ( ) , false , false ) ) ; }
@ Override public void onSaveInstanceState ( Bundle outState ) { super. onSaveInstanceState ( outState ) ; outState . putBoolean ( EXTERNAL_HEADER , mExternalHeader ) ; }
@ Override public void onPause ( ) { mRefreshHandler . removeCallbacks ( mRefresh ) ; if ( mHeader != null ) { mHeader . onPause ( ) ; } super. onPause ( ) ; }
@ Override public void onResume ( ) { checkAdapterStylePreference ( ) ; if ( mListener != null ) { mListener . onListViewCreated ( getListView ( ) ) ; } ArrivalsListLoader loader = getArrivalsLoader ( ) ; if ( loader != null ) { ObaArrivalInfoResponse lastGood = loader . getLastGoodResponse ( ) ; if ( lastGood != null ) { setResponseData ( lastGood . getArrivalInfo ( ) , UIUtils . getAllSituations ( lastGood ) , lastGood . getRefs ( ) ) ; } } getLoaderManager ( ) . restartLoader ( TRIPS_FOR_STOP_LOADER , null , mTripsForStopCallback ) ; long lastResponseTime = getArrivalsLoader ( ) . getLastResponseTime ( ) ; long newPeriod = Math . min ( RefreshPeriod , ( lastResponseTime + RefreshPeriod ) - System . currentTimeMillis ( ) ) ; if ( newPeriod <= 0 ) { refresh ( ) ; } else { mRefreshHandler . postDelayed ( mRefresh , newPeriod ) ; } setUserInfo ( ) ; if ( mHeader != null ) { mHeader . refresh ( ) ; } super. onResume ( ) ; }
@ Override public Loader < ObaArrivalInfoResponse > onCreateLoader ( int id , Bundle args ) { return new ArrivalsListLoader ( getActivity ( ) , mStopId ) ; }
@ Override public void onStart ( ) { super. onStart ( ) ; ObaAnalytics . reportFragmentStart ( this ) ; if ( Build . VERSION . SDK_INT >= 14 ) { AccessibilityManager am = ( AccessibilityManager ) getActivity ( ) . getSystemService ( Context . ACCESSIBILITY_SERVICE ) ; Boolean isTalkBackEnabled = am . isTouchExplorationEnabled ( ) ; if ( isTalkBackEnabled ) ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . ACCESSIBILITY . toString ( ) , getString ( R . string . analytics_action_touch_exploration ) , getString ( R . string . analytics_label_talkback ) + getClass ( ) . getSimpleName ( ) + " using TalkBack" ) ; } }
@ Override public void onLoadFinished ( Loader < ObaArrivalInfoResponse > loader , final ObaArrivalInfoResponse result ) { showProgress ( false ) ; ObaArrivalInfo [] info = null ; List < ObaSituation > situations = null ; ObaReferences refs = null ; if ( result . getCode ( ) == ObaApi . OBA_OK ) { if ( mStop == null ) { mStop = result . getStop ( ) ; addToDB ( mStop ) ; } info = result . getArrivalInfo ( ) ; situations = UIUtils . getAllSituations ( result ) ; refs = result . getRefs ( ) ; } else { ObaArrivalInfoResponse lastGood = getArrivalsLoader ( ) . getLastGoodResponse ( ) ; if ( lastGood != null ) { Toast . makeText ( getActivity ( ) , R . string . generic_comm_error_toast , Toast . LENGTH_LONG ) . show ( ) ; info = lastGood . getArrivalInfo ( ) ; situations = lastGood . getSituations ( ) ; } else { setEmptyText ( UIUtils . getStopErrorString ( getActivity ( ) , result . getCode ( ) ) ) ; } } setResponseData ( info , situations , refs ) ; if ( isResumed ( ) ) { setListShown ( true ) ; } else { if ( isAdded ( ) ) { setListShownNoAnimation ( true ) ; } } mRefreshHandler . removeCallbacks ( mRefresh ) ; mRefreshHandler . postDelayed ( mRefresh , RefreshPeriod ) ; if ( mLoadedMoreArrivals ) { if ( info == null || info . length == 0 || mLastResponseLength != info . length ) { mLoadedMoreArrivals = false ; } else if ( mLastResponseLength == info . length ) { Toast . makeText ( getActivity ( ) , UIUtils . getNoArrivalsMessage ( getActivity ( ) , getArrivalsLoader ( ) . getMinutesAfter ( ) , true , false ) , Toast . LENGTH_LONG ) . show ( ) ; mLoadedMoreArrivals = false ; } } ShowcaseViewUtils . showTutorial ( ShowcaseViewUtils . TUTORIAL_ARRIVAL_SORT , ( AppCompatActivity ) getActivity ( ) , null ) ; if ( mListener != null ) { mListener . onArrivalTimesUpdated ( result ) ; } }
@ Override protected void showProgress ( boolean visibility ) { super. showProgress ( visibility ) ; if ( mHeader != null ) { mHeader . showProgress ( visibility ) ; } }
public void setHeader ( ArrivalsListHeader header , View headerView ) { mHeader = header ; mHeaderView = headerView ; if ( header != null ) { mHeader . initView ( mHeaderView ) ; } mExternalHeader = true ; }
private void setResponseData ( ObaArrivalInfo [] info , List < ObaSituation > situations , ObaReferences refs ) { mArrivalInfo = info ; mObaReferences = refs ; if ( situations != null ) { refreshSituations ( situations ) ; } else { refreshSituations ( new ArrayList < ObaSituation > ( ) ) ; } if ( info != null ) { ArrivalsListLoader loader = getArrivalsLoader ( ) ; int minutesAfter ; if ( loader != null ) { minutesAfter = loader . getMinutesAfter ( ) ; } else { minutesAfter = ArrivalsListLoader . DEFAULT_MINUTES_AFTER ; } setEmptyText ( UIUtils . getNoArrivalsMessage ( Application . get ( ) . getApplicationContext ( ) , minutesAfter , false , false ) ) ; mAdapter . setData ( info , mRoutesFilter , System . currentTimeMillis ( ) ) ; } if ( mHeader != null ) { mHeader . refresh ( ) ; } }
@ Override public void onLoaderReset ( Loader < ObaArrivalInfoResponse > loader ) { showProgress ( false ) ; mAdapter . setData ( null , mRoutesFilter , System . currentTimeMillis ( ) ) ; mArrivalInfo = null ; if ( mHeader != null ) { mHeader . refresh ( ) ; } }
@ Override public void onCreateOptionsMenu ( Menu menu , MenuInflater inflater ) { inflater . inflate ( R . menu . arrivals_list , menu ) ; }
@ Override public void onPrepareOptionsMenu ( Menu menu ) { String title = mFavorite ? getString ( R . string . stop_info_option_removestar ) : getString ( R . string . stop_info_option_addstar ) ; menu . findItem ( R . id . toggle_favorite ) . setTitle ( title ) . setTitleCondensed ( title ) ; MenuItem menuItemHeaderArrivals = menu . findItem ( R . id . show_header_arrivals ) ; if ( mHeader != null ) { title = mHeader . isShowingArrivals ( ) ? getString ( R . string . stop_info_option_hide_header_arrivals ) : getString ( R . string . stop_info_option_show_header_arrivals ) ; menuItemHeaderArrivals . setTitle ( title ) ; menuItemHeaderArrivals . setTitleCondensed ( title ) ; } if ( mExternalHeader ) { menu . findItem ( R . id . show_on_map ) . setVisible ( false ) ; menuItemHeaderArrivals . setVisible ( false ) ; } }
@ Override public boolean onOptionsItemSelected ( MenuItem item ) { final int id = item . getItemId ( ) ; if ( id == R . id . show_on_map ) { if ( mStop != null ) { HomeActivity . start ( getActivity ( ) , mStop ) ; } return true ; } else if ( id == R . id . refresh ) { refresh ( ) ; return true ; } else if ( id == R . id . sort_arrivals ) { ShowcaseViewUtils . doNotShowTutorial ( ShowcaseViewUtils . TUTORIAL_ARRIVAL_SORT ) ; showSortByDialog ( ) ; } else if ( id == R . id . filter ) { if ( mStop != null ) { showRoutesFilterDialog ( ) ; } } else if ( id == R . id . show_header_arrivals ) { doShowHideHeaderArrivals ( ) ; } else if ( id == R . id . edit_name ) { if ( mHeader != null ) { mHeader . beginNameEdit ( null ) ; } } else if ( id == R . id . toggle_favorite ) { setFavoriteStop ( ! mFavorite ) ; if ( mHeader != null ) { mHeader . refresh ( ) ; } } else if ( id == R . id . show_stop_details ) { showStopDetailsDialog ( ) ; } else if ( id == R . id . report_stop_problem ) { if ( mStop != null ) { Intent intent = makeIntent ( getActivity ( ) , mStop . getId ( ) , mStop . getName ( ) , mStop . getStopCode ( ) , mStop . getLatitude ( ) , mStop . getLongitude ( ) ) ; InfrastructureIssueActivity . startWithService ( getActivity ( ) , intent , getString ( R . string . ri_selected_service_stop ) ) ; } } else if ( id == R . id . night_light ) { NightLightActivity . start ( getActivity ( ) ) ; } return false ; }
public static Intent makeIntent ( Context context , String focusId , String stopName , String stopCode , double lat , double lon ) { Intent myIntent = new Intent ( context , HomeActivity .class ) ; myIntent . putExtra ( MapParams . STOP_ID , focusId ) ; myIntent . putExtra ( MapParams . STOP_NAME , stopName ) ; myIntent . putExtra ( MapParams . STOP_CODE , stopCode ) ; myIntent . putExtra ( MapParams . CENTER_LAT , lat ) ; myIntent . putExtra ( MapParams . CENTER_LON , lon ) ; return myIntent ; }
@ Override public void onListItemClick ( ListView l , View v , int position , long id ) { final ArrivalInfo stop = ( ArrivalInfo ) getListView ( ) . getItemAtPosition ( position ) ; showListItemMenu ( v , stop ) ; }
public void showListItemMenu ( View v , final ArrivalInfo arrivalInfo ) { if ( arrivalInfo == null ) { return; } Log . d ( TAG , "Tapped on route=" + arrivalInfo . getInfo ( ) . getShortName ( ) + ", tripId=" + arrivalInfo . getInfo ( ) . getTripId ( ) + ", vehicleId=" + arrivalInfo . getInfo ( ) . getVehicleId ( ) ) ; ArrivalsListLoader loader = getArrivalsLoader ( ) ; if ( loader == null ) { return; } final ObaArrivalInfoResponse response = loader . getLastGoodResponse ( ) ; if ( response == null ) { return; } AlertDialog . Builder builder = new AlertDialog . Builder ( getActivity ( ) ) ; builder . setTitle ( R . string . stop_info_item_options_title ) ; final String routeId = arrivalInfo . getInfo ( ) . getRouteId ( ) ; final ObaRoute route = response . getRoute ( routeId ) ; final String url = route != null ? route . getUrl ( ) : null ; final boolean hasUrl = ! TextUtils . isEmpty ( url ) ; View tripView = v . findViewById ( R . id . reminder ) ; boolean isReminderVisible = tripView != null && tripView . getVisibility ( ) != View . GONE ; final boolean isRouteFavorite = ObaContract . RouteHeadsignFavorites . isFavorite ( routeId , arrivalInfo . getInfo ( ) . getHeadsign ( ) , arrivalInfo . getInfo ( ) . getStopId ( ) ) ; List < String > items = UIUtils . buildTripOptions ( getActivity ( ) , isRouteFavorite , hasUrl , isReminderVisible ) ; List < Integer > icons = UIUtils . buildTripOptionsIcons ( isRouteFavorite , hasUrl ) ; ListAdapter adapter = new ArrayAdapterWithIcon ( getActivity ( ) , items , icons ) ; builder . setAdapter ( adapter , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int which ) { if ( which == 0 ) { RouteFavoriteDialogFragment routeDialog = new RouteFavoriteDialogFragment . Builder ( route . getId ( ) , arrivalInfo . getInfo ( ) . getHeadsign ( ) ) . setRouteShortName ( route . getShortName ( ) ) . setRouteLongName ( arrivalInfo . getInfo ( ) . getRouteLongName ( ) ) . setRouteUrl ( route . getUrl ( ) ) . setStopId ( arrivalInfo . getInfo ( ) . getStopId ( ) ) . setFavorite ( ! isRouteFavorite ) . build ( ) ; setCallbackToDialogFragment ( routeDialog ) ; routeDialog . show ( getFragmentManager ( ) , RouteFavoriteDialogFragment . TAG ) ; } else if ( which == 1 ) { showRouteOnMap ( arrivalInfo ) ; } else if ( which == 2 ) { goToTripDetails ( arrivalInfo ) ; } else if ( which == 3 ) { goToTrip ( arrivalInfo ) ; } else if ( which == 4 ) { ArrayList < String > routes = new ArrayList < String > ( 1 ) ; routes . add ( arrivalInfo . getInfo ( ) . getRouteId ( ) ) ; setRoutesFilter ( routes ) ; if ( mHeader != null ) { mHeader . refresh ( ) ; } } else if ( hasUrl && which == 5 ) { UIUtils . goToUrl ( getActivity ( ) , url ) ; } else if ( ( ! hasUrl && which == 5 ) || ( hasUrl && which == 6 ) ) { String routeId = arrivalInfo . getInfo ( ) . getRouteId ( ) ; String agencyName = null ; String blockId = null ; if ( mObaReferences != null ) { String agencyId = mObaReferences . getRoute ( routeId ) . getAgencyId ( ) ; agencyName = mObaReferences . getAgency ( agencyId ) . getName ( ) ; ObaTrip trip = mObaReferences . getTrip ( arrivalInfo . getInfo ( ) . getTripId ( ) ) ; blockId = trip . getBlockId ( ) ; } Intent intent = makeIntent ( getActivity ( ) , mStop . getId ( ) , mStop . getName ( ) , mStop . getStopCode ( ) , mStop . getLatitude ( ) , mStop . getLongitude ( ) ) ; InfrastructureIssueActivity . startWithService ( getActivity ( ) , intent , getString ( R . string . ri_selected_service_trip ) , arrivalInfo . getInfo ( ) , agencyName , blockId ) ; } } } ) ; AlertDialog dialog = builder . create ( ) ; dialog . setOwnerActivity ( getActivity ( ) ) ; dialog . show ( ) ; }
public void onClick ( DialogInterface dialog , int which ) { if ( which == 0 ) { RouteFavoriteDialogFragment routeDialog = new RouteFavoriteDialogFragment . Builder ( route . getId ( ) , arrivalInfo . getInfo ( ) . getHeadsign ( ) ) . setRouteShortName ( route . getShortName ( ) ) . setRouteLongName ( arrivalInfo . getInfo ( ) . getRouteLongName ( ) ) . setRouteUrl ( route . getUrl ( ) ) . setStopId ( arrivalInfo . getInfo ( ) . getStopId ( ) ) . setFavorite ( ! isRouteFavorite ) . build ( ) ; setCallbackToDialogFragment ( routeDialog ) ; routeDialog . show ( getFragmentManager ( ) , RouteFavoriteDialogFragment . TAG ) ; } else if ( which == 1 ) { showRouteOnMap ( arrivalInfo ) ; } else if ( which == 2 ) { goToTripDetails ( arrivalInfo ) ; } else if ( which == 3 ) { goToTrip ( arrivalInfo ) ; } else if ( which == 4 ) { ArrayList < String > routes = new ArrayList < String > ( 1 ) ; routes . add ( arrivalInfo . getInfo ( ) . getRouteId ( ) ) ; setRoutesFilter ( routes ) ; if ( mHeader != null ) { mHeader . refresh ( ) ; } } else if ( hasUrl && which == 5 ) { UIUtils . goToUrl ( getActivity ( ) , url ) ; } else if ( ( ! hasUrl && which == 5 ) || ( hasUrl && which == 6 ) ) { String routeId = arrivalInfo . getInfo ( ) . getRouteId ( ) ; String agencyName = null ; String blockId = null ; if ( mObaReferences != null ) { String agencyId = mObaReferences . getRoute ( routeId ) . getAgencyId ( ) ; agencyName = mObaReferences . getAgency ( agencyId ) . getName ( ) ; ObaTrip trip = mObaReferences . getTrip ( arrivalInfo . getInfo ( ) . getTripId ( ) ) ; blockId = trip . getBlockId ( ) ; } Intent intent = makeIntent ( getActivity ( ) , mStop . getId ( ) , mStop . getName ( ) , mStop . getStopCode ( ) , mStop . getLatitude ( ) , mStop . getLongitude ( ) ) ; InfrastructureIssueActivity . startWithService ( getActivity ( ) , intent , getString ( R . string . ri_selected_service_trip ) , arrivalInfo . getInfo ( ) , agencyName , blockId ) ; } }
private void setCallbackToDialogFragment ( RouteFavoriteDialogFragment routeDialog ) { routeDialog . setCallback ( new RouteFavoriteDialogFragment . Callback ( ) { @ Override public void onSelectionComplete ( boolean savedFavorite ) { if ( savedFavorite ) { refreshLocal ( ) ; } } } ) ; }
@ Override public void onSelectionComplete ( boolean savedFavorite ) { if ( savedFavorite ) { refreshLocal ( ) ; } }
public void showRouteOnMap ( ArrivalInfo arrivalInfo ) { boolean handled = false ; if ( mListener != null ) { handled = mListener . onShowRouteOnMapSelected ( arrivalInfo ) ; } if ( ! handled ) { HomeActivity . start ( getActivity ( ) , arrivalInfo . getInfo ( ) . getRouteId ( ) ) ; } }
@ Override public String getStopId ( ) { return mStopId ; }
@ Override public Location getStopLocation ( ) { Location location = null ; if ( mStop != null ) { location = mStop . getLocation ( ) ; } else { Bundle args = getArguments ( ) ; double latitude = args . getDouble ( STOP_LAT ) ; double longitude = args . getDouble ( STOP_LON ) ; if ( latitude != 0 && longitude != 0 ) { location = LocationUtils . makeLocation ( latitude , longitude ) ; } } return location ; }
@ Override public String getStopName ( ) { String name ; if ( mStop != null ) { name = mStop . getName ( ) ; } else { Bundle args = getArguments ( ) ; name = args . getString ( STOP_NAME ) ; } return UIUtils . formatDisplayText ( name ) ; }
@ Override public String getStopDirection ( ) { if ( mStop != null ) { return mStop . getDirection ( ) ; } else { Bundle args = getArguments ( ) ; return args . getString ( STOP_DIRECTION ) ; } }
@ Override public ArrayList < ArrivalInfo > getArrivalInfo ( ) { ArrayList < ArrivalInfo > list = null ; if ( mArrivalInfo != null ) { list = ArrivalInfoUtils . convertObaArrivalInfo ( getActivity ( ) , mArrivalInfo , mRoutesFilter , System . currentTimeMillis ( ) , true ) ; } return list ; }
@ Override public int getMinutesAfter ( ) { ArrivalsListLoader loader = getArrivalsLoader ( ) ; if ( loader != null ) { return loader . getMinutesAfter ( ) ; } else { return - 1 ; } }
@ Override public String getUserStopName ( ) { return mStopUserName ; }
@ Override public void setUserStopName ( String name ) { ContentResolver cr = getActivity ( ) . getContentResolver ( ) ; ContentValues values = new ContentValues ( ) ; if ( TextUtils . isEmpty ( name ) ) { values . putNull ( ObaContract . Stops . USER_NAME ) ; mStopUserName = null ; } else { values . put ( ObaContract . Stops . USER_NAME , name ) ; mStopUserName = name ; } cr . update ( mStopUri , values , null , null ) ; }
@ Override public ArrayList < String > getRoutesFilter ( ) { if ( mStop != null ) { return mRoutesFilter ; } else { return null ; } }
@ Override public void setRoutesFilter ( ArrayList < String > routes ) { mRoutesFilter = routes ; ObaContract . StopRouteFilters . set ( getActivity ( ) , mStopId , mRoutesFilter ) ; refreshLocal ( ) ; }
@ Override public long getLastGoodResponseTime ( ) { ArrivalsListLoader loader = getArrivalsLoader ( ) ; if ( loader == null ) { return 0 ; } return loader . getLastGoodResponseTime ( ) ; }
@ Override public List < String > getRouteDisplayNames ( ) { if ( mStop != null && getArrivalsLoader ( ) != null ) { ObaArrivalInfoResponse response = getArrivalsLoader ( ) . getLastGoodResponse ( ) ; List < ObaRoute > routes = response . getRoutes ( mStop . getRouteIds ( ) ) ; ArrayList < String > displayNames = new ArrayList < String > ( ) ; for ( ObaRoute r : routes ) { displayNames . add ( UIUtils . getRouteDisplayName ( r ) ) ; } return displayNames ; } else { Bundle args = getArguments ( ) ; String serializedRoutes = args . getString ( STOP_ROUTES ) ; if ( serializedRoutes != null ) { return UIUtils . deserializeRouteDisplayNames ( serializedRoutes ) ; } } return null ; }
@ Override public int getNumRoutes ( ) { if ( mStop != null ) { return mStop . getRouteIds ( ) . length ; } else { return 0 ; } }
@ Override public boolean isFavoriteStop ( ) { return mFavorite ; }
@ Override public boolean setFavoriteStop ( boolean favorite ) { if ( ObaContract . Stops . markAsFavorite ( getActivity ( ) , mStopUri , favorite ) ) { mFavorite = favorite ; } getActivity ( ) . supportInvalidateOptionsMenu ( ) ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getString ( R . string . analytics_action_edit_field ) , getString ( R . string . analytics_label_edit_field ) ) ; return mFavorite ; }
@ Override public AlertList getAlertList ( ) { return mAlertList ; }
private void checkAdapterStylePreference ( ) { int currentArrivalInfoStyle = BuildFlavorUtils . getArrivalInfoStyleFromPreferences ( ) ; if ( currentArrivalInfoStyle == BuildFlavorUtils . ARRIVAL_INFO_STYLE_A && ! ( mAdapter instanceof ArrivalsListAdapterStyleA ) ) { reinitAdapterStyleOnPreferenceChange ( BuildFlavorUtils . ARRIVAL_INFO_STYLE_A ) ; } else if ( currentArrivalInfoStyle == BuildFlavorUtils . ARRIVAL_INFO_STYLE_B && ! ( mAdapter instanceof ArrivalsListAdapterStyleB ) ) { reinitAdapterStyleOnPreferenceChange ( BuildFlavorUtils . ARRIVAL_INFO_STYLE_B ) ; } }
private void reinitAdapterStyleOnPreferenceChange ( int arrivalInfoStyle ) { LayoutInflater inflater = LayoutInflater . from ( getActivity ( ) ) ; if ( mFooter != null ) { getListView ( ) . removeFooterView ( mFooter ) ; } CharSequence emptyText = null ; if ( mEmptyList != null ) { TextView noArrivals = ( TextView ) mEmptyList . findViewById ( R . id . noArrivals ) ; if ( noArrivals != null ) { emptyText = noArrivals . getText ( ) ; } ( ( ViewGroup ) getListView ( ) . getParent ( ) ) . removeView ( mEmptyList ) ; } initArrivalInfoViews ( arrivalInfoStyle , inflater ) ; setupFooter ( ) ; setupEmptyList ( emptyText ) ; setListViewProperties ( arrivalInfoStyle ) ; instantiateAdapter ( arrivalInfoStyle ) ; }
private void initArrivalInfoViews ( int arrivalInfoStyle , LayoutInflater inflater ) { mFooter = inflater . inflate ( R . layout . arrivals_list_footer_style_b , null ) ; mEmptyList = inflater . inflate ( R . layout . arrivals_list_empty_style_b , null ) ; }
private void setupFooter ( ) { Button loadMoreArrivals = ( Button ) mFooter . findViewById ( R . id . load_more_arrivals ) ; loadMoreArrivals . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { loadMoreArrivals ( ) ; } } ) ; getListView ( ) . addFooterView ( mFooter ) ; mFooter . requestLayout ( ) ; }
@ Override public void onClick ( View v ) { loadMoreArrivals ( ) ; }
private void setupEmptyList ( CharSequence currentText ) { Button loadMoreArrivalsEmptyList = ( Button ) mEmptyList . findViewById ( R . id . load_more_arrivals ) ; loadMoreArrivalsEmptyList . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { loadMoreArrivals ( ) ; } } ) ; getListView ( ) . setEmptyView ( mEmptyList ) ; ( ( ViewGroup ) getListView ( ) . getParent ( ) ) . addView ( mEmptyList ) ; if ( currentText != null ) { setEmptyText ( currentText ) ; } }
@ Override public void onClick ( View v ) { loadMoreArrivals ( ) ; }
private void setListViewProperties ( int arrivalInfoStyle ) { ListView . MarginLayoutParams listParam = ( ListView . MarginLayoutParams ) getListView ( ) . getLayoutParams ( ) ; listParam . bottomMargin = UIUtils . dpToPixels ( getActivity ( ) , 2 ) ; listParam . topMargin = UIUtils . dpToPixels ( getActivity ( ) , 3 ) ; listParam . leftMargin = UIUtils . dpToPixels ( getActivity ( ) , 5 ) ; listParam . rightMargin = UIUtils . dpToPixels ( getActivity ( ) , 5 ) ; getListView ( ) . setBackgroundColor ( getResources ( ) . getColor ( R . color . stop_info_arrival_list_background ) ) ; getListView ( ) . setLayoutParams ( listParam ) ; }
private void instantiateAdapter ( int arrivalInfoStyle ) { if ( UIUtils . canSupportArrivalInfoStyleB ( ) ) { switch ( arrivalInfoStyle ) { case BuildFlavorUtils . ARRIVAL_INFO_STYLE_A : mAdapter = new ArrivalsListAdapterStyleA ( getActivity ( ) ) ; break; case BuildFlavorUtils . ARRIVAL_INFO_STYLE_B : mAdapter = new ArrivalsListAdapterStyleB ( getActivity ( ) ) ; ( ( ArrivalsListAdapterStyleB ) mAdapter ) . setFragment ( this ) ; break; } } else { mAdapter = new ArrivalsListAdapterStyleA ( getActivity ( ) ) ; } getListView ( ) . setDivider ( null ) ; setListAdapter ( mAdapter ) ; }
private void showSortByDialog ( ) { if ( mListener != null ) { mListener . onSortBySelected ( ) ; } AlertDialog . Builder builder = new AlertDialog . Builder ( getActivity ( ) ) ; builder . setTitle ( R . string . menu_option_sort_by ) ; int currentArrivalInfoStyle = BuildFlavorUtils . getArrivalInfoStyleFromPreferences ( ) ; builder . setSingleChoiceItems ( R . array . sort_arrivals , currentArrivalInfoStyle , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int index ) { if ( index == 0 ) { Log . d ( TAG , "Sort by ETA" ) ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getActivity ( ) . getString ( R . string . analytics_action_button_press ) , getActivity ( ) . getString ( R . string . analytics_label_sort_by_eta_arrival ) ) ; } else if ( index == 1 ) { Log . d ( TAG , "Sort by route" ) ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getActivity ( ) . getString ( R . string . analytics_action_button_press ) , getActivity ( ) . getString ( R . string . analytics_label_sort_by_route_arrival ) ) ; } String [] styles = getResources ( ) . getStringArray ( R . array . arrival_info_style_options ) ; PreferenceUtils . saveString ( getResources ( ) . getString ( R . string . preference_key_arrival_info_style ) , styles [ index ] ) ; checkAdapterStylePreference ( ) ; refreshLocal ( ) ; getLoaderManager ( ) . restartLoader ( TRIPS_FOR_STOP_LOADER , null , mTripsForStopCallback ) ; dialog . dismiss ( ) ; } } ) ; AlertDialog dialog = builder . create ( ) ; dialog . setOwnerActivity ( getActivity ( ) ) ; dialog . show ( ) ; }
public void onClick ( DialogInterface dialog , int index ) { if ( index == 0 ) { Log . d ( TAG , "Sort by ETA" ) ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getActivity ( ) . getString ( R . string . analytics_action_button_press ) , getActivity ( ) . getString ( R . string . analytics_label_sort_by_eta_arrival ) ) ; } else if ( index == 1 ) { Log . d ( TAG , "Sort by route" ) ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getActivity ( ) . getString ( R . string . analytics_action_button_press ) , getActivity ( ) . getString ( R . string . analytics_label_sort_by_route_arrival ) ) ; } String [] styles = getResources ( ) . getStringArray ( R . array . arrival_info_style_options ) ; PreferenceUtils . saveString ( getResources ( ) . getString ( R . string . preference_key_arrival_info_style ) , styles [ index ] ) ; checkAdapterStylePreference ( ) ; refreshLocal ( ) ; getLoaderManager ( ) . restartLoader ( TRIPS_FOR_STOP_LOADER , null , mTripsForStopCallback ) ; dialog . dismiss ( ) ; }
private void doShowHideHeaderArrivals ( ) { if ( mHeader == null ) { return; } boolean showArrivals = Application . getPrefs ( ) . getBoolean ( getString ( R . string . preference_key_show_header_arrivals ) , false ) ; if ( showArrivals ) { mHeader . showArrivals ( false ) ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getString ( R . string . analytics_action_button_press ) , getString ( R . string . analytics_label_hide_arrivals_in_header ) ) ; } else { mHeader . showArrivals ( true ) ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getString ( R . string . analytics_action_button_press ) , getString ( R . string . analytics_label_show_arrivals_in_header ) ) ; } PreferenceUtils . saveBoolean ( getResources ( ) . getString ( R . string . preference_key_show_header_arrivals ) , ! showArrivals ) ; mHeader . refresh ( ) ; }
private void showRoutesFilterDialog ( ) { ObaArrivalInfoResponse response = getArrivalsLoader ( ) . getLastGoodResponse ( ) ; final List < ObaRoute > routes = response . getRoutes ( mStop . getRouteIds ( ) ) ; final int len = routes . size ( ) ; final ArrayList < String > filter = mRoutesFilter ; String [] items = new String [ len ] ; boolean [] checks = new boolean [ len ] ; for ( int i = 0 ; i < len ; ++ i ) { final ObaRoute route = routes . get ( i ) ; items [ i ] = UIUtils . getRouteDisplayName ( route ) ; if ( filter . contains ( route . getId ( ) ) ) { checks [ i ] = true ; } } Bundle args = new Bundle ( ) ; args . putStringArray ( RoutesFilterDialog . ITEMS , items ) ; args . putBooleanArray ( RoutesFilterDialog . CHECKS , checks ) ; RoutesFilterDialog frag = new RoutesFilterDialog ( ) ; frag . setArguments ( args ) ; frag . show ( getActivity ( ) . getSupportFragmentManager ( ) , ".RoutesFilterDialog" ) ; }
private void showStopDetailsDialog ( ) { String stopCode = null ; if ( mStop != null ) { stopCode = mStop . getStopCode ( ) ; } Pair stopDetails = UIUtils . createStopDetailsDialogText ( getContext ( ) , getStopName ( ) , getUserStopName ( ) , stopCode , getStopDirection ( ) , getRouteDisplayNames ( ) ) ; UIUtils . buildAlertDialog ( getContext ( ) , ( String ) stopDetails . first , ( String ) stopDetails . second ) . show ( ) ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getString ( R . string . analytics_action_button_press ) , getString ( R . string . analytics_label_button_press_stop_details ) ) ; }
public void setListener ( Listener listener ) { this . mListener = listener ; }
private void setupHeader ( Bundle bundle ) { if ( bundle != null ) { mExternalHeader = bundle . getBoolean ( EXTERNAL_HEADER ) ; } if ( mHeader == null && ! mExternalHeader ) { mHeader = new ArrivalsListHeader ( getActivity ( ) , this , getFragmentManager ( ) ) ; mHeaderView = getView ( ) . findViewById ( R . id . arrivals_list_header ) ; mHeader . initView ( mHeaderView ) ; mHeader . showExpandCollapseIndicator ( false ) ; mHeader . setSlidingPanelCollapsed ( false ) ; boolean showArrivals = Application . getPrefs ( ) . getBoolean ( getString ( R . string . preference_key_show_header_arrivals ) , false ) ; mHeader . showArrivals ( showArrivals ) ; } else { getView ( ) . findViewById ( R . id . arrivals_list_header ) . setVisibility ( View . GONE ) ; } if ( mHeader != null ) { mHeader . refresh ( ) ; } }
@ Override public Dialog onCreateDialog ( Bundle savedInstanceState ) { Bundle args = getArguments ( ) ; String [] items = args . getStringArray ( ITEMS ) ; mChecks = args . getBooleanArray ( CHECKS ) ; if ( savedInstanceState != null ) { mChecks = args . getBooleanArray ( CHECKS ) ; } AlertDialog . Builder builder = new AlertDialog . Builder ( getActivity ( ) ) ; return builder . setTitle ( R . string . stop_info_filter_title ) . setMultiChoiceItems ( items , mChecks , this ) . setPositiveButton ( R . string . stop_info_save , this ) . setNegativeButton ( R . string . stop_info_cancel , null ) . create ( ) ; }
@ Override public void onSaveInstanceState ( Bundle outState ) { outState . putBooleanArray ( CHECKS , mChecks ) ; }
@ Override public void onClick ( DialogInterface dialog , int which ) { Activity act = getActivity ( ) ; ArrivalsListFragment frag = null ; if ( act instanceof ArrivalsListActivity ) { frag = ( ( ArrivalsListActivity ) act ) . getArrivalsListFragment ( ) ; } else if ( act instanceof HomeActivity ) { frag = ( ( HomeActivity ) act ) . getArrivalsListFragment ( ) ; } frag . setRoutesFilter ( mChecks ) ; dialog . dismiss ( ) ; }
@ Override public void onClick ( DialogInterface arg0 , int which , boolean isChecked ) { mChecks [ which ] = isChecked ; }
private void setRoutesFilter ( boolean [] checks ) { final int len = checks . length ; final ArrayList < String > newFilter = new ArrayList < String > ( len ) ; ObaArrivalInfoResponse response = getArrivalsLoader ( ) . getLastGoodResponse ( ) ; final List < ObaRoute > routes = response . getRoutes ( mStop . getRouteIds ( ) ) ; if ( routes . size ( ) != len ) { throw new IllegalArgumentException ( "checks.length must be equal to routes.size()" ) ; } for ( int i = 0 ; i < len ; ++ i ) { final ObaRoute route = routes . get ( i ) ; if ( checks [ i ] ) { newFilter . add ( route . getId ( ) ) ; } } if ( newFilter . size ( ) == len ) { newFilter . clear ( ) ; } setRoutesFilter ( newFilter ) ; }
private void goToTrip ( ArrivalInfo stop ) { ObaArrivalInfo stopInfo = stop . getInfo ( ) ; TripInfoActivity . start ( getActivity ( ) , stopInfo . getTripId ( ) , mStopId , stopInfo . getRouteId ( ) , stopInfo . getShortName ( ) , mStop . getName ( ) , stopInfo . getScheduledDepartureTime ( ) , stopInfo . getHeadsign ( ) ) ; }
private void goToTripDetails ( ArrivalInfo stop ) { TripDetailsActivity . start ( getActivity ( ) , stop . getInfo ( ) . getTripId ( ) , stop . getInfo ( ) . getStopId ( ) , TripDetailsListFragment . SCROLL_MODE_STOP ) ; }
private void goToRoute ( ArrivalInfo stop ) { RouteInfoActivity . start ( getActivity ( ) , stop . getInfo ( ) . getRouteId ( ) ) ; }
private ArrivalsListLoader getArrivalsLoader ( ) { if ( ! isAdded ( ) ) { return null ; } Loader < ObaArrivalInfoResponse > l = getLoaderManager ( ) . getLoader ( ARRIVALS_LIST_LOADER ) ; return ( ArrivalsListLoader ) l ; }
@ Override public void setEmptyText ( CharSequence text ) { TextView noArrivals = ( TextView ) mEmptyList . findViewById ( R . id . noArrivals ) ; noArrivals . setText ( text ) ; }
private void loadMoreArrivals ( ) { getArrivalsLoader ( ) . incrementMinutesAfter ( ) ; mLoadedMoreArrivals = true ; refresh ( ) ; ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getActivity ( ) . getString ( R . string . analytics_action_button_press ) , getActivity ( ) . getString ( R . string . analytics_label_button_press ) ) ; }
public void refresh ( ) { if ( isAdded ( ) ) { showProgress ( true ) ; ObaArrivalInfoResponse lastGood = getArrivalsLoader ( ) . getLastGoodResponse ( ) ; if ( lastGood != null ) { mLastResponseLength = lastGood . getArrivalInfo ( ) . length ; } getArrivalsLoader ( ) . onContentChanged ( ) ; } }
public void refreshLocal ( ) { ArrivalsListLoader loader = getArrivalsLoader ( ) ; if ( loader != null ) { ObaArrivalInfoResponse response = loader . getLastGoodResponse ( ) ; if ( response == null ) { return; } mAdapter . setData ( response . getArrivalInfo ( ) , mRoutesFilter , System . currentTimeMillis ( ) ) ; } if ( mHeader != null ) { mHeader . refresh ( ) ; } }
public void run ( ) { refresh ( ) ; }
private void setStopId ( ) { Uri uri = ( Uri ) getArguments ( ) . getParcelable ( FragmentUtils . URI ) ; if ( uri == null ) { Log . e ( TAG , "No URI in arguments" ) ; return; } mStopId = uri . getLastPathSegment ( ) ; mStopUri = uri ; }
private void setUserInfo ( ) { ContentResolver cr = getActivity ( ) . getContentResolver ( ) ; Cursor c = cr . query ( mStopUri , USER_PROJECTION , null , null , null ) ; if ( c != null ) { try { if ( c . moveToNext ( ) ) { mFavorite = ( c . getInt ( 0 ) == 1 ) ; mStopUserName = c . getString ( 1 ) ; } } finally { c . close ( ) ; } } }
private void addToDB ( ObaStop stop ) { String name = UIUtils . formatDisplayText ( stop . getName ( ) ) ; ContentValues values = new ContentValues ( ) ; values . put ( ObaContract . Stops . CODE , stop . getStopCode ( ) ) ; values . put ( ObaContract . Stops . NAME , name ) ; values . put ( ObaContract . Stops . DIRECTION , stop . getDirection ( ) ) ; values . put ( ObaContract . Stops . LATITUDE , stop . getLatitude ( ) ) ; values . put ( ObaContract . Stops . LONGITUDE , stop . getLongitude ( ) ) ; if ( Application . get ( ) . getCurrentRegion ( ) != null ) { values . put ( ObaContract . Stops . REGION_ID , Application . get ( ) . getCurrentRegion ( ) . getId ( ) ) ; } ObaContract . Stops . insertOrUpdate ( stop . getId ( ) , values , true ) ; }
@ Override public Loader < Cursor > onCreateLoader ( int id , Bundle args ) { return new CursorLoader ( getActivity ( ) , ObaContract . Trips . CONTENT_URI , TRIPS_PROJECTION , ObaContract . Trips . STOP_ID + "=?" , new String [] { mStopId } , null ) ; }
@ Override public void onLoadFinished ( Loader < Cursor > loader , Cursor c ) { ContentQueryMap map = new ContentQueryMap ( c , ObaContract . Trips . _ID , true , null ) ; mAdapter . setTripsForStop ( map ) ; if ( mHeader != null ) { mHeader . setTripsForStop ( map ) ; } }
@ Override public void onLoaderReset ( Loader < Cursor > loader ) {        }
SituationAlert ( ObaSituation situation ) { mSituation = situation ; }
@ Override public String getId ( ) { return mSituation . getId ( ) ; }
@ Override public int getType ( ) { if ( ObaSituation . SEVERITY_NO_IMPACT . equals ( mSituation . getSeverity ( ) ) ) { return TYPE_INFO ; } else if ( ObaSituation . SEVERITY_SEVERE . equals ( mSituation . getSeverity ( ) ) || ObaSituation . SEVERITY_VERY_SEVERE . equals ( mSituation . getSeverity ( ) ) ) { return TYPE_ERROR ; } else { return TYPE_WARNING ; } }
@ Override public int getFlags ( ) { return FLAG_HASMORE ; }
@ Override public CharSequence getString ( ) { return mSituation . getSummary ( ) ; }
@ Override public void onClick ( ) { SituationDialogFragment dialog = SituationDialogFragment . newInstance ( mSituation ) ; dialog . setListener ( new SituationDialogFragment . Listener ( ) { @ Override public void onDismiss ( boolean isAlertHidden ) { if ( isAlertHidden ) { refresh ( ) ; } } @ Override public void onUndo ( ) { refresh ( ) ; } } ) ; dialog . show ( getFragmentManager ( ) , SituationDialogFragment . TAG ) ; reportAnalytics ( mSituation ) ; }
@ Override public void onDismiss ( boolean isAlertHidden ) { if ( isAlertHidden ) { refresh ( ) ; } }
@ Override public void onUndo ( ) { refresh ( ) ; }
@ Override public int hashCode ( ) { return getId ( ) . hashCode ( ) ; }
@ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } SituationAlert other = ( SituationAlert ) obj ; if ( ! getId ( ) . equals ( other . getId ( ) ) ) { return false ; } return true ; }
private void reportAnalytics ( ObaSituation situation ) { ObaSituation . AllAffects [] allAffects = situation . getAllAffects ( ) ; Set < String > agencyIds = new HashSet <> ( ) ; for ( int i = 0 ; i < allAffects . length ; i ++ ) { agencyIds . add ( allAffects [ i ] . getAgencyId ( ) ) ; } for ( String agencyId : agencyIds ) { ObaAnalytics . reportEventWithCategory ( ObaAnalytics . ObaEventCategory . UI_ACTION . toString ( ) , getString ( R . string . analytics_action_service_alerts ) , getString ( R . string . analytics_label_service_alerts ) + agencyId ) ; } }
private void refreshSituations ( List < ObaSituation > situations ) { if ( mSituationAlerts != null ) { for ( SituationAlert alert : mSituationAlerts ) { mAlertList . remove ( alert ) ; } } mAlertList . setAlertHidden ( false ) ; mSituationAlerts = null ; if ( situations . isEmpty ( ) ) { return; } mSituationAlerts = new ArrayList <> ( ) ; ContentValues values = new ContentValues ( ) ; int hiddenCount = 0 ; for ( ObaSituation situation : situations ) { values . clear ( ) ; ObaContract . ServiceAlerts . insertOrUpdate ( situation . getId ( ) , values , false , null ) ; boolean isActive = UIUtils . isActiveWindowForSituation ( situation , System . currentTimeMillis ( ) ) ; boolean isHidden = ObaContract . ServiceAlerts . isHidden ( situation . getId ( ) ) ; if ( isActive && ! isHidden ) { SituationAlert alert = new SituationAlert ( situation ) ; mSituationAlerts . add ( alert ) ; } if ( isHidden ) { mAlertList . setAlertHidden ( true ) ; hiddenCount ++ ; } } mAlertList . setHiddenAlertCount ( hiddenCount ) ; mAlertList . addAll ( mSituationAlerts ) ; }
static void displayError ( final Activity activity , final String title , final String err ) { new AlertDialog . Builder ( activity ) . setTitle ( title ) . setMessage ( err ) . setPositiveButton ( android . R . string . ok , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialogInterface , int i ) { activity . finish ( ) ; } } ) . show ( ) ; }
@ Override public void onClick ( DialogInterface dialogInterface , int i ) { activity . finish ( ) ; }
void call ( String path );
public static void show ( final InputStreamWithSource ins , final Activity activity , final PassStore passStore , final FinishCallback callAfterFinishOnUIThread ) { if ( activity . isFinishing ( ) ) { return; } final ProgressDialog dialog = ProgressDialog . show ( activity , activity . getString ( R . string . unzip_pass_dialog_title ) , activity . getString ( R . string . unzip_pass_dialog_message ) , true ) ; dialog . setCancelable ( false ) ; class AlertDialogUpdater implements Runnable { private final FinishCallback call_after_finish ; AlertDialogUpdater ( FinishCallback call_after_finish ) { this . call_after_finish = call_after_finish ; } public void run ( ) { final InputStreamUnzipControllerSpec spec = new InputStreamUnzipControllerSpec ( ins , activity , passStore , new SuccessCallback ( ) { @ Override public void call ( final String uuid ) { activity . runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { if ( ! prepareResult ( activity , dialog ) ) { return; } call_after_finish . call ( uuid ) ; } } ) ; } } , new FailCallback ( ) { @ Override public void fail ( final String reason ) { activity . runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { if ( ! prepareResult ( activity , dialog ) ) { return; } displayError ( activity , activity . getString ( R . string . invalid_passbook_title ) , reason ) ; } } ) ; } } ) ; UnzipPassController . INSTANCE . processInputStream ( spec ) ; } } final AlertDialogUpdater alertDialogUpdater = new AlertDialogUpdater ( callAfterFinishOnUIThread ) ; new Thread ( alertDialogUpdater ) . start ( ) ; }
AlertDialogUpdater ( FinishCallback call_after_finish ) { this . call_after_finish = call_after_finish ; }
public void run ( ) { final InputStreamUnzipControllerSpec spec = new InputStreamUnzipControllerSpec ( ins , activity , passStore , new SuccessCallback ( ) { @ Override public void call ( final String uuid ) { activity . runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { if ( ! prepareResult ( activity , dialog ) ) { return; } call_after_finish . call ( uuid ) ; } } ) ; } } , new FailCallback ( ) { @ Override public void fail ( final String reason ) { activity . runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { if ( ! prepareResult ( activity , dialog ) ) { return; } displayError ( activity , activity . getString ( R . string . invalid_passbook_title ) , reason ) ; } } ) ; } } ) ; UnzipPassController . INSTANCE . processInputStream ( spec ) ; }
@ Override public void call ( final String uuid ) { activity . runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { if ( ! prepareResult ( activity , dialog ) ) { return; } call_after_finish . call ( uuid ) ; } } ) ; }
@ Override public void run ( ) { if ( ! prepareResult ( activity , dialog ) ) { return; } call_after_finish . call ( uuid ) ; }
@ Override public void fail ( final String reason ) { activity . runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { if ( ! prepareResult ( activity , dialog ) ) { return; } displayError ( activity , activity . getString ( R . string . invalid_passbook_title ) , reason ) ; } } ) ; }
@ Override public void run ( ) { if ( ! prepareResult ( activity , dialog ) ) { return; } displayError ( activity , activity . getString ( R . string . invalid_passbook_title ) , reason ) ; }
private static boolean prepareResult ( final Activity activity , final ProgressDialog dialog ) { if ( activity . isFinishing ( ) ) { return false ; } if ( dialog . isShowing ( ) ) { try { dialog . dismiss ( ) ; return true ; } catch ( IllegalArgumentException ignored ) { } } return false ; }
@ Override public String getPluginGoalName ( ) { return "internal-integration-test" ; }
@ Test public void testTestProject ( ) Exception { PowerMock . suppress ( MemberMatcher . methodsDeclaredIn ( RemoteAndroidTestRunner .class ) ) ; PowerMock . replace ( AbstractAndroidMojo .class . getDeclaredMethod ( "doWithDevices" , DeviceCallback .class ) ) . with ( new InvocationHandler ( ) { @ Override public Object invoke ( Object proxy , Method method , Object [] args ) throws Throwable { DeviceCallback callback = ( DeviceCallback ) args [ 0 ] ; callback . doWithDevice ( new IDevice ( ) { @ Override public String getSerialNumber ( ) { return null ; } @ Override public String getAvdName ( ) { return null ; } @ Override public DeviceState getState ( ) { return null ; } @ Override public Map < String , String > getProperties ( ) { return null ; } @ Override public int getPropertyCount ( ) { return 0 ; } @ Override public String getProperty ( String name ) { return null ; } @ Override public String getMountPoint ( String name ) { return null ; } @ Override public boolean isOnline ( ) { return false ; } @ Override public boolean isEmulator ( ) { return false ; } @ Override public boolean isOffline ( ) { return false ; } @ Override public boolean isBootLoader ( ) { return false ; } @ Override public boolean hasClients ( ) { return false ; } @ Override public Client [] getClients ( ) { return null ; } @ Override public Client getClient ( String applicationName ) { return null ; } @ Override public SyncService getSyncService ( ) TimeoutException , AdbCommandRejectedException , IOException { return null ; } @ Override public FileListingService getFileListingService ( ) { return null ; } @ Override public RawImage getScreenshot ( ) TimeoutException , AdbCommandRejectedException , IOException { return null ; } @ Override public RawImage getScreenshot ( long l , TimeUnit timeUnit ) throws TimeoutException , AdbCommandRejectedException , IOException { return null ; } @ Override public void executeShellCommand ( String command , IShellOutputReceiver receiver ) throws TimeoutException , AdbCommandRejectedException , ShellCommandUnresponsiveException , IOException {                    } @ Override public void executeShellCommand ( String command , IShellOutputReceiver receiver , int maxTimeToOutputResponse ) throws TimeoutException , AdbCommandRejectedException , ShellCommandUnresponsiveException , IOException {                    } @ Override public void runEventLogService ( LogReceiver receiver ) throws TimeoutException , AdbCommandRejectedException , IOException {                    } @ Override public void runLogService ( String logname , LogReceiver receiver ) throws TimeoutException , AdbCommandRejectedException , IOException {                    } @ Override public void createForward ( int localPort , int remotePort ) throws TimeoutException , AdbCommandRejectedException , IOException {                    } @ Override public void removeForward ( int localPort , int remotePort ) throws TimeoutException , AdbCommandRejectedException , IOException {                    } @ Override public String getClientName ( int pid ) { return null ; } @ Override public String syncPackageToDevice ( String localFilePath ) throws TimeoutException , AdbCommandRejectedException , IOException , SyncException { return null ; } @ Override public void removeRemotePackage ( String remoteFilePath ) throws InstallException {                    } @ Override public String uninstallPackage ( String packageName ) throws InstallException { return null ; } @ Override public void reboot ( String into ) throws TimeoutException , AdbCommandRejectedException , IOException {                    } @ Override public boolean arePropertiesSet ( ) { return false ; } @ Override public String getPropertySync ( String s ) throws TimeoutException , AdbCommandRejectedException , ShellCommandUnresponsiveException , IOException { return null ; } @ Override public String getPropertyCacheOrSync ( String s ) throws TimeoutException , AdbCommandRejectedException , ShellCommandUnresponsiveException , IOException { return null ; } @ Override public void pushFile ( String s , String s1 ) throws IOException , AdbCommandRejectedException , TimeoutException , SyncException {                    } @ Override public void pullFile ( String s , String s1 ) throws IOException , AdbCommandRejectedException , TimeoutException , SyncException {                    } @ Override public void installPackage ( String s , boolean b , String ... strings ) throws InstallException {                    } @ Override public void installPackages ( List < File > list , boolean b , List < String > list1 , long l , TimeUnit timeUnit ) throws InstallException {                    } @ Override public void installRemotePackage ( String s , boolean b , String ... strings ) throws InstallException {                    } @ Override public Integer getBatteryLevel ( ) TimeoutException , AdbCommandRejectedException , IOException , ShellCommandUnresponsiveException { return null ; } @ Override public Integer getBatteryLevel ( long l ) throws TimeoutException , AdbCommandRejectedException , IOException , ShellCommandUnresponsiveException { return null ; } @ Override public Future < Integer > getBattery ( ) { return null ; } @ Override public Future < Integer > getBattery ( long l , TimeUnit timeUnit ) { return null ; } @ Override public void createForward ( int arg0 , String arg1 , DeviceUnixSocketNamespace arg2 )                            throws TimeoutException , AdbCommandRejectedException , IOException {                    } @ Override public String getName ( ) { return null ; } @ Override public void executeShellCommand ( String s , IShellOutputReceiver iShellOutputReceiver , long l , TimeUnit timeUnit )                        throws TimeoutException , AdbCommandRejectedException , ShellCommandUnresponsiveException , IOException {                    } @ Override public Future < String > getSystemProperty ( String s ) { return null ; } @ Override public void removeForward ( int arg0 , String arg1 , DeviceUnixSocketNamespace arg2 )                            throws TimeoutException , AdbCommandRejectedException , IOException {                    } @ Override public boolean supportsFeature ( Feature feature ) { return false ; } @ Override public void startScreenRecorder ( String remoteFilePath , ScreenRecorderOptions options , IShellOutputReceiver receiver )                            throws TimeoutException , AdbCommandRejectedException , IOException , ShellCommandUnresponsiveException {                    } @ Override public boolean supportsFeature ( HardwareFeature arg0 ) { return false ; } @ Override public List < String > getAbis ( ) { return null ; } @ Override public int getDensity ( ) { return 0 ; } @ Override public String getLanguage ( ) { return null ; } @ Override public String getRegion ( ) { return null ; } @ Override public AndroidVersion getVersion ( ) { return null ; } @ Override public boolean root ( ) TimeoutException , AdbCommandRejectedException , IOException , ShellCommandUnresponsiveException { return false ; } @ Override public boolean isRoot ( ) TimeoutException , AdbCommandRejectedException , IOException , ShellCommandUnresponsiveException { return false ; } } ) ; return null ; } } ) ; InternalIntegrationTestMojo mojo = createMojo ( "manifest-tests/test-project" ) ; mojo . execute ( ) ; List < String > classes = Whitebox . getInternalState ( mojo , "parsedClasses" ) ; assertNotNull ( classes ) ; assertEquals ( 1 , classes . size ( ) ) ; }
@ Override public Object invoke ( Object proxy , Method method , Object [] args ) throws Throwable { DeviceCallback callback = ( DeviceCallback ) args [ 0 ] ; callback . doWithDevice ( new IDevice ( ) { @ Override public String getSerialNumber ( ) { return null ; } @ Override public String getAvdName ( ) { return null ; } @ Override public DeviceState getState ( ) { return null ; } @ Override public Map < String , String > getProperties ( ) { return null ; } @ Override public int getPropertyCount ( ) { return 0 ; } @ Override public String getProperty ( String name ) { return null ; } @ Override public String getMountPoint ( String name ) { return null ; } @ Override public boolean isOnline ( ) { return false ; } @ Override public boolean isEmulator ( ) { return false ; } @ Override public boolean isOffline ( ) { return false ; } @ Override public boolean isBootLoader ( ) { return false ; } @ Override public boolean hasClients ( ) { return false ; } @ Override public Client [] getClients ( ) { return null ; } @ Override public Client getClient ( String applicationName ) { return null ; } @ Override public SyncService getSyncService ( ) TimeoutException , AdbCommandRejectedException , IOException { return null ; } @ Override public FileListingService getFileListingService ( ) { return null ; } @ Override public RawImage getScreenshot ( ) TimeoutException , AdbCommandRejectedException , IOException { return null ; } @ Override public RawImage getScreenshot ( long l , TimeUnit timeUnit ) throws TimeoutException , AdbCommandRejectedException , IOException { return null ; } @ Override public void executeShellCommand ( String command , IShellOutputReceiver receiver ) throws TimeoutException , AdbCommandRejectedException , ShellCommandUnresponsiveException , IOException {                    } @ Override public void executeShellCommand ( String command , IShellOutputReceiver receiver , int maxTimeToOutputResponse ) throws TimeoutException , AdbCommandRejectedException , ShellCommandUnresponsiveException , IOException {                    } @ Override public void runEventLogService ( LogReceiver receiver ) throws TimeoutException , AdbCommandRejectedException , IOException {                    } @ Override public void runLogService ( String logname , LogReceiver receiver ) throws TimeoutException , AdbCommandRejectedException , IOException {                    } @ Override public void createForward ( int localPort , int remotePort ) throws TimeoutException , AdbCommandRejectedException , IOException {                    } @ Override public void removeForward ( int localPort , int remotePort ) throws TimeoutException , AdbCommandRejectedException , IOException {                    } @ Override public String getClientName ( int pid ) { return null ; } @ Override public String syncPackageToDevice ( String localFilePath ) throws TimeoutException , AdbCommandRejectedException , IOException , SyncException { return null ; } @ Override public void removeRemotePackage ( String remoteFilePath ) throws InstallException {                    } @ Override public String uninstallPackage ( String packageName ) throws InstallException { return null ; } @ Override public void reboot ( String into ) throws TimeoutException , AdbCommandRejectedException , IOException {                    } @ Override public boolean arePropertiesSet ( ) { return false ; } @ Override public String getPropertySync ( String s ) throws TimeoutException , AdbCommandRejectedException , ShellCommandUnresponsiveException , IOException { return null ; } @ Override public String getPropertyCacheOrSync ( String s ) throws TimeoutException , AdbCommandRejectedException , ShellCommandUnresponsiveException , IOException { return null ; } @ Override public void pushFile ( String s , String s1 ) throws IOException , AdbCommandRejectedException , TimeoutException , SyncException {                    } @ Override public void pullFile ( String s , String s1 ) throws IOException , AdbCommandRejectedException , TimeoutException , SyncException {                    } @ Override public void installPackage ( String s , boolean b , String ... strings ) throws InstallException {                    } @ Override public void installPackages ( List < File > list , boolean b , List < String > list1 , long l , TimeUnit timeUnit ) throws InstallException {                    } @ Override public void installRemotePackage ( String s , boolean b , String ... strings ) throws InstallException {                    } @ Override public Integer getBatteryLevel ( ) TimeoutException , AdbCommandRejectedException , IOException , ShellCommandUnresponsiveException { return null ; } @ Override public Integer getBatteryLevel ( long l ) throws TimeoutException , AdbCommandRejectedException , IOException , ShellCommandUnresponsiveException { return null ; } @ Override public Future < Integer > getBattery ( ) { return null ; } @ Override public Future < Integer > getBattery ( long l , TimeUnit timeUnit ) { return null ; } @ Override public void createForward ( int arg0 , String arg1 , DeviceUnixSocketNamespace arg2 )                            throws TimeoutException , AdbCommandRejectedException , IOException {                    } @ Override public String getName ( ) { return null ; } @ Override public void executeShellCommand ( String s , IShellOutputReceiver iShellOutputReceiver , long l , TimeUnit timeUnit )                        throws TimeoutException , AdbCommandRejectedException , ShellCommandUnresponsiveException , IOException {                    } @ Override public Future < String > getSystemProperty ( String s ) { return null ; } @ Override public void removeForward ( int arg0 , String arg1 , DeviceUnixSocketNamespace arg2 )                            throws TimeoutException , AdbCommandRejectedException , IOException {                    } @ Override public boolean supportsFeature ( Feature feature ) { return false ; } @ Override public void startScreenRecorder ( String remoteFilePath , ScreenRecorderOptions options , IShellOutputReceiver receiver )                            throws TimeoutException , AdbCommandRejectedException , IOException , ShellCommandUnresponsiveException {                    } @ Override public boolean supportsFeature ( HardwareFeature arg0 ) { return false ; } @ Override public List < String > getAbis ( ) { return null ; } @ Override public int getDensity ( ) { return 0 ; } @ Override public String getLanguage ( ) { return null ; } @ Override public String getRegion ( ) { return null ; } @ Override public AndroidVersion getVersion ( ) { return null ; } @ Override public boolean root ( ) TimeoutException , AdbCommandRejectedException , IOException , ShellCommandUnresponsiveException { return false ; } @ Override public boolean isRoot ( ) TimeoutException , AdbCommandRejectedException , IOException , ShellCommandUnresponsiveException { return false ; } } ) ; return null ; }
@ Override public String getSerialNumber ( ) { return null ; }
@ Override public String getAvdName ( ) { return null ; }
@ Override public DeviceState getState ( ) { return null ; }
@ Override public Map < String , String > getProperties ( ) { return null ; }
@ Override public int getPropertyCount ( ) { return 0 ; }
@ Override public String getProperty ( String name ) { return null ; }
@ Override public String getMountPoint ( String name ) { return null ; }
@ Override public boolean isOnline ( ) { return false ; }
@ Override public boolean isEmulator ( ) { return false ; }
@ Override public boolean isOffline ( ) { return false ; }
@ Override public boolean isBootLoader ( ) { return false ; }
@ Override public boolean hasClients ( ) { return false ; }
@ Override public Client [] getClients ( ) { return null ; }
@ Override public Client getClient ( String applicationName ) { return null ; }
@ Override public SyncService getSyncService ( ) TimeoutException , AdbCommandRejectedException , IOException { return null ; }
@ Override public FileListingService getFileListingService ( ) { return null ; }
@ Override public RawImage getScreenshot ( ) TimeoutException , AdbCommandRejectedException , IOException { return null ; }
@ Override public RawImage getScreenshot ( long l , TimeUnit timeUnit ) throws TimeoutException , AdbCommandRejectedException , IOException { return null ; }
@ Override public void executeShellCommand ( String command , IShellOutputReceiver receiver ) throws TimeoutException , AdbCommandRejectedException , ShellCommandUnresponsiveException , IOException {                    }
@ Override public void executeShellCommand ( String command , IShellOutputReceiver receiver , int maxTimeToOutputResponse ) throws TimeoutException , AdbCommandRejectedException , ShellCommandUnresponsiveException , IOException {                    }
@ Override public void runEventLogService ( LogReceiver receiver ) throws TimeoutException , AdbCommandRejectedException , IOException {                    }
@ Override public void runLogService ( String logname , LogReceiver receiver ) throws TimeoutException , AdbCommandRejectedException , IOException {                    }
@ Override public void createForward ( int localPort , int remotePort ) throws TimeoutException , AdbCommandRejectedException , IOException {                    }
@ Override public void removeForward ( int localPort , int remotePort ) throws TimeoutException , AdbCommandRejectedException , IOException {                    }
@ Override public String getClientName ( int pid ) { return null ; }
@ Override public String syncPackageToDevice ( String localFilePath ) throws TimeoutException , AdbCommandRejectedException , IOException , SyncException { return null ; }
@ Override public void removeRemotePackage ( String remoteFilePath ) throws InstallException {                    }
@ Override public String uninstallPackage ( String packageName ) throws InstallException { return null ; }
@ Override public void reboot ( String into ) throws TimeoutException , AdbCommandRejectedException , IOException {                    }
@ Override public boolean arePropertiesSet ( ) { return false ; }
@ Override public String getPropertySync ( String s ) throws TimeoutException , AdbCommandRejectedException , ShellCommandUnresponsiveException , IOException { return null ; }
@ Override public String getPropertyCacheOrSync ( String s ) throws TimeoutException , AdbCommandRejectedException , ShellCommandUnresponsiveException , IOException { return null ; }
@ Override public void pushFile ( String s , String s1 ) throws IOException , AdbCommandRejectedException , TimeoutException , SyncException {                    }
@ Override public void pullFile ( String s , String s1 ) throws IOException , AdbCommandRejectedException , TimeoutException , SyncException {                    }
@ Override public void installPackage ( String s , boolean b , String ... strings ) throws InstallException {                    }
@ Override public void installPackages ( List < File > list , boolean b , List < String > list1 , long l , TimeUnit timeUnit ) throws InstallException {                    }
@ Override public void installRemotePackage ( String s , boolean b , String ... strings ) throws InstallException {                    }
@ Override public Integer getBatteryLevel ( ) TimeoutException , AdbCommandRejectedException , IOException , ShellCommandUnresponsiveException { return null ; }
@ Override public Integer getBatteryLevel ( long l ) throws TimeoutException , AdbCommandRejectedException , IOException , ShellCommandUnresponsiveException { return null ; }
@ Override public Future < Integer > getBattery ( ) { return null ; }
@ Override public Future < Integer > getBattery ( long l , TimeUnit timeUnit ) { return null ; }
@ Override public void createForward ( int arg0 , String arg1 , DeviceUnixSocketNamespace arg2 )                            throws TimeoutException , AdbCommandRejectedException , IOException {                    }
@ Override public String getName ( ) { return null ; }
@ Override public void executeShellCommand ( String s , IShellOutputReceiver iShellOutputReceiver , long l , TimeUnit timeUnit )                        throws TimeoutException , AdbCommandRejectedException , ShellCommandUnresponsiveException , IOException {                    }
@ Override public Future < String > getSystemProperty ( String s ) { return null ; }
@ Override public void removeForward ( int arg0 , String arg1 , DeviceUnixSocketNamespace arg2 )                            throws TimeoutException , AdbCommandRejectedException , IOException {                    }
@ Override public boolean supportsFeature ( Feature feature ) { return false ; }
@ Override public void startScreenRecorder ( String remoteFilePath , ScreenRecorderOptions options , IShellOutputReceiver receiver )                            throws TimeoutException , AdbCommandRejectedException , IOException , ShellCommandUnresponsiveException {                    }
@ Override public boolean supportsFeature ( HardwareFeature arg0 ) { return false ; }
@ Override public List < String > getAbis ( ) { return null ; }
@ Override public int getDensity ( ) { return 0 ; }
@ Override public String getLanguage ( ) { return null ; }
@ Override public String getRegion ( ) { return null ; }
@ Override public AndroidVersion getVersion ( ) { return null ; }
@ Override public boolean root ( ) TimeoutException , AdbCommandRejectedException , IOException , ShellCommandUnresponsiveException { return false ; }
@ Override public boolean isRoot ( ) TimeoutException , AdbCommandRejectedException , IOException , ShellCommandUnresponsiveException { return false ; }
@ Test public void shouldHaveApplicationName ( ) Exception { HelloAndroidActivity activityUnderTest = Robolectric . buildActivity ( HelloAndroidActivity .class ) . create ( ) . get ( ) ; String appName = activityUnderTest . getResources ( ) . getString ( R . string . app_name ) ; assertThat ( appName , equalTo ( "sonar-android-sample" ) ) ; }
@ Test public void shouldNotUseNullComputer ( ) Exception { HelloAndroidActivity activityUnderTest = Robolectric . buildActivity ( HelloAndroidActivity .class ) . create ( ) . get ( ) ; activityUnderTest . setComputer ( null ) ; Button button = ( Button ) activityUnderTest . findViewById ( R . id . button_main ) ; button . performClick ( ) ; TextView textViewHello = ( TextView ) activityUnderTest . findViewById ( R . id . textview_hello ) ; String textViewHelloString = textViewHello . getText ( ) . toString ( ) ; assertThat ( textViewHelloString , equalTo ( "-" ) ) ; }
@ Test public void shouldUseDummyComputer ( ) Exception { final int EXPECTED_RESULT = 42 ; HelloAndroidActivity activityUnderTest = Robolectric . buildActivity ( HelloAndroidActivity .class ) . create ( ) . get ( ) ; Button button = ( Button ) activityUnderTest . findViewById ( R . id . button_main ) ; button . performClick ( ) ; TextView textViewHello = ( TextView ) activityUnderTest . findViewById ( R . id . textview_hello ) ; String textViewHelloString = textViewHello . getText ( ) . toString ( ) ; assertThat ( textViewHelloString , equalTo ( String . valueOf ( EXPECTED_RESULT ) ) ) ; }
@ Test public void shouldUseCustomComputerUsingEasyMock ( ) Exception { final int EXPECTED_RESULT = 1 ; HelloAndroidActivity activityUnderTest = Robolectric . buildActivity ( HelloAndroidActivity .class ) . create ( ) . get ( ) ; Computer mockComputer = EasyMock . createMock ( Computer .class ) ; EasyMock . expect ( mockComputer . getResult ( ) ) . andReturn ( EXPECTED_RESULT ) ; activityUnderTest . setComputer ( mockComputer ) ; EasyMock . replay ( mockComputer ) ; Button button = ( Button ) activityUnderTest . findViewById ( R . id . button_main ) ; button . performClick ( ) ; EasyMock . verify ( mockComputer ) ; TextView textViewHello = ( TextView ) activityUnderTest . findViewById ( R . id . textview_hello ) ; String textViewHelloString = textViewHello . getText ( ) . toString ( ) ; assertThat ( textViewHelloString , equalTo ( String . valueOf ( EXPECTED_RESULT ) ) ) ; }
@ Test public void shouldUseCustomComputerUsingMockito ( ) Exception { final int EXPECTED_RESULT = 1 ; HelloAndroidActivity activityUnderTest = Robolectric . buildActivity ( HelloAndroidActivity .class ) . create ( ) . get ( ) ; Computer mockComputer = Mockito . mock ( Computer .class ) ; Mockito . when ( mockComputer . getResult ( ) ) . thenReturn ( EXPECTED_RESULT ) ; activityUnderTest . setComputer ( mockComputer ) ; Button button = ( Button ) activityUnderTest . findViewById ( R . id . button_main ) ; button . performClick ( ) ; Mockito . verify ( mockComputer , Mockito . times ( 1 ) ) . getResult ( ) ; TextView textViewHello = ( TextView ) activityUnderTest . findViewById ( R . id . textview_hello ) ; String textViewHelloString = textViewHello . getText ( ) . toString ( ) ; assertThat ( textViewHelloString , equalTo ( String . valueOf ( EXPECTED_RESULT ) ) ) ; }
public void test1 ( ) { final Location pt = LocationUtils . makeLocation ( 47.653 , - 122.307 ) ; ObaTripsForLocationRequest . Builder builder = new ObaTripsForLocationRequest . Builder ( getContext ( ) , pt ) ; ObaTripsForLocationRequest request = builder . build ( ) ; ObaTripsForLocationResponse response = request . call ( ) ; assertOK ( response ) ; final ObaTripDetails [] list = response . getTrips ( ) ; assertNotNull ( list ) ; }
public void testOutOfRange ( ) { final Location pt = LocationUtils . makeLocation ( 48.85808 , 2.29498 ) ; ObaTripsForLocationRequest request = new ObaTripsForLocationRequest . Builder ( getContext ( ) , pt ) . build ( ) ; ObaTripsForLocationResponse response = request . call ( ) ; assertOK ( response ) ; assertTrue ( response . getOutOfRange ( ) ) ; }
protected PasswordRepository ( ) {    }
public static Repository getRepository ( File localDir ) { if ( repository == null && localDir != null ) { FileRepositoryBuilder builder = new FileRepositoryBuilder ( ) ; try { repository = builder . setGitDir ( localDir ) . readEnvironment ( ) . build ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } } return repository ; }
public static boolean isInitialized ( ) { return repository != null ; }
public static void createRepository ( File localDir ) throws Exception { localDir . delete ( ) ; Git . init ( ) . setDirectory ( localDir ) . call ( ) ; getRepository ( localDir ) ; }
public static void addRemote ( String name , String url , Boolean replace ) { StoredConfig storedConfig = repository . getConfig ( ) ; Set < String > remotes = storedConfig . getSubsections ( "remote" ) ; if ( ! remotes . contains ( name ) ) { try { URIish uri = new URIish ( url ) ; RefSpec refSpec = new RefSpec ( "+refs/head + name + " ) ; RemoteConfig remoteConfig = new RemoteConfig ( storedConfig , name ) ; remoteConfig . addFetchRefSpec ( refSpec ) ; remoteConfig . addPushRefSpec ( refSpec ) ; remoteConfig . addURI ( uri ) ; remoteConfig . addPushURI ( uri ) ; remoteConfig . update ( storedConfig ) ; storedConfig . save ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } else if ( replace ) { try { URIish uri = new URIish ( url ) ; RemoteConfig remoteConfig = new RemoteConfig ( storedConfig , name ) ; if ( remoteConfig . getURIs ( ) . size ( ) > 0 ) { remoteConfig . removeURI ( remoteConfig . getURIs ( ) . get ( 0 ) ) ; } if ( remoteConfig . getPushURIs ( ) . size ( ) > 0 ) { remoteConfig . removePushURI ( remoteConfig . getPushURIs ( ) . get ( 0 ) ) ; } remoteConfig . addURI ( uri ) ; remoteConfig . addPushURI ( uri ) ; remoteConfig . update ( storedConfig ) ; storedConfig . save ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
public static void closeRepository ( ) { if ( repository != null ) repository . close ( ) ; repository = null ; }
public static File getRepositoryDirectory ( Context context ) { File dir = null ; SharedPreferences settings = PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ; if ( settings . getBoolean ( "git_external" , false ) ) { String external_repo = settings . getString ( "git_external_repo" , null ) ; if ( external_repo != null ) { dir = new File ( external_repo ) ; } } else { dir = new File ( context . getFilesDir ( ) + "/store" ) ; } return dir ; }
public static Repository initialize ( Context context ) { File dir = getRepositoryDirectory ( context ) ; SharedPreferences settings = PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ; if ( dir == null ) { return null ; } if ( ! dir . exists ( ) || ! dir . isDirectory ( ) || FileUtils . listFiles ( dir , null , false ) . isEmpty ( ) ) { settings . edit ( ) . putBoolean ( "repository_initialized" , false ) . apply ( ) ; } if ( ! PasswordRepository . getPasswords ( dir ) . isEmpty ( ) ) { settings . edit ( ) . putBoolean ( "repository_initialized" , true ) . apply ( ) ; } return PasswordRepository . getRepository ( new File ( dir . getAbsolutePath ( ) + "/.git" ) ) ; }
public static ArrayList < PasswordItem > getPasswords ( File rootDir ) { return getPasswords ( rootDir , rootDir ) ; }
public static ArrayList < File > getFilesList ( File path ) { if ( ! path . exists ( ) ) return new ArrayList < File > ( ) ; Log . d ( "REPO" , "current path: " + path . getPath ( ) ) ; ArrayList < File > files = new ArrayList < File > ( Arrays . asList ( path . listFiles ( ( FileFilter ) FileFilterUtils . directoryFileFilter ( ) ) ) ) ; files . addAll ( new ArrayList < File > ( ( List < File > ) FileUtils . listFiles ( path , new String [] { "gpg" } , false ) ) ) ; return new ArrayList < File > ( files ) ; }
public static ArrayList < PasswordItem > getPasswords ( File path , File rootDir ) { ArrayList < File > passList = getFilesList ( path ) ; if ( passList . size ( ) == 0 ) return new ArrayList < PasswordItem > ( ) ; ArrayList < PasswordItem > passwordList = new ArrayList < PasswordItem > ( ) ; for ( File file : passList ) { if ( file . isFile ( ) ) { passwordList . add ( PasswordItem . newPassword ( file . getName ( ) , file , rootDir ) ) ; } else { if ( file . getName ( ) . equals ( ".git" ) ) continue; passwordList . add ( PasswordItem . newCategory ( file . getName ( ) , file , rootDir ) ) ; } } sort ( passwordList ) ; return passwordList ; }
public static Bundle getIntentArgs ( Intent intent ) { Bundle args = intent . getExtras ( ) ; if ( args != null ) { args = ( Bundle ) args . clone ( ) ; } else { args = new Bundle ( ) ; } args . putParcelable ( URI , intent . getData ( ) ) ; return args ; }
@ Override public String toString ( ) { return "" ; }
public static String toTitleCase ( String str ) { if ( str == null ) { return null ; } boolean isSeparator = true ; StringBuilder builder = new StringBuilder ( str ) ; final int len = builder . length ( ) ; for ( int i = 0 ; i < len ; ++ i ) { char c = builder . charAt ( i ) ; if ( isSeparator ) { if ( Character . isLetterOrDigit ( c ) ) { builder . setCharAt ( i , Character . toTitleCase ( c ) ) ; isSeparator = false ; } } else if ( ! Character . isLetterOrDigit ( c ) ) { isSeparator = true ; } else { builder . setCharAt ( i , Character . toLowerCase ( c ) ) ; } } return builder . toString ( ) ; }
public static boolean isAllCaps ( String str ) { return str . equals ( str . toUpperCase ( ) ) ; }
public static String toSentenceCase ( String inputVal ) { if ( inputVal == null ) return null ; if ( inputVal . length ( ) == 0 ) return "" ; if ( inputVal . length ( ) == 1 ) return inputVal . toUpperCase ( ) ; return inputVal . substring ( 0 , 1 ) . toUpperCase ( ) + inputVal . substring ( 1 ) . toLowerCase ( ) ; }
